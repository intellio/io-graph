# generated by datamodel-codegen:
#   filename:  https://github.com/microsoftgraph/msgraph-metadata/raw/refs/heads/master/openapi/v1.0/openapi.yaml
#   timestamp: 2025-02-01T01:07:47+00:00

from __future__ import annotations

from datetime import date, datetime, time, timedelta
from enum import Enum
from typing import Any, Dict, List, Optional, Union, Annotated
from uuid import UUID

from pydantic import BaseModel, Field, RootModel
# from typing_extensions import Annotated

from ... import ReferenceNumeric
from ... import (
    BaseCollectionPaginationCountResponse,
)



class AuthenticationConditionApplication(BaseModel):
    app_id: Annotated[
        Optional[str],
        Field(
            description='The identifier for an application corresponding to a condition which will trigger an authenticationEventListener.'
        ),
    ] = None
    field_odata_type: str


class Compliance(BaseModel):
    field_odata_type: str


class Entity(BaseModel):
    id: Annotated[
        Optional[str],
        Field(description='The unique identifier for an entity. Read-only.'),
    ] = None
    field_odata_type: str


class Extension(Entity):
    field_odata_type: str


class ExternalDomainName(Entity):
    field_odata_type: str


class FederatedIdentityCredential(Entity):
    audiences: Annotated[
        Optional[List[str]],
        Field(
            description='The audience that can appear in the external token. This field is mandatory and should be set to api://AzureADTokenExchange for Microsoft Entra ID. It says what Microsoft identity platform should accept in the aud claim in the incoming token. This value represents Microsoft Entra ID in your external identity provider and has no fixed value across identity providers - you might need to create a new application registration in your identity provider to serve as the audience of this token. This field can only accept a single value and has a limit of 600 characters. Required.'
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='The unvalidated description of the federated identity credential, provided by the user. It has a limit of 600 characters. Optional.'
        ),
    ] = None
    issuer: Annotated[
        Optional[str],
        Field(
            description='The URL of the external identity provider, which must match the issuer claim of the external token being exchanged. The combination of the values of issuer and subject must be unique within the app. It has a limit of 600 characters. Required.'
        ),
    ] = None
    name: Annotated[
        Optional[str],
        Field(
            description="The unique identifier for the federated identity credential, which has a limit of 120 characters and must be URL friendly. The string is immutable after it's created. Alternate key. Required. Not nullable. Supports $filter (eq)."
        ),
    ] = None
    subject: Annotated[
        Optional[str],
        Field(
            description='Required. The identifier of the external software workload within the external identity provider. Like the audience value, it has no fixed format; each identity provider uses their own - sometimes a GUID, sometimes a colon delimited identifier, sometimes arbitrary strings. The value here must match the sub claim within the token presented to Microsoft Entra ID. The combination of issuer and subject must be unique within the app. It has a limit of 600 characters. Supports $filter (eq).'
        ),
    ] = None
    field_odata_type: str


class FieldValueSet(Entity):
    field_odata_type: str


class GovernanceInsight(Entity):
    insight_created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Indicates when the insight was created.',
        ),
    ] = None
    field_odata_type: str


class GroupLifecyclePolicy(Entity):
    alternate_notification_emails: Annotated[
        Optional[str],
        Field(
            description='List of email address to send notifications for groups without owners. Multiple email address can be defined by separating email address with a semicolon.'
        ),
    ] = None
    group_lifetime_in_days: Annotated[
        Optional[float],
        Field(
            description='Number of days before a group expires and needs to be renewed. Once renewed, the group expiration is extended by the number of days defined.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    managed_group_types: Annotated[
        Optional[str],
        Field(
            description='The group type for which the expiration policy applies. Possible values are All, Selected or None.'
        ),
    ] = None
    field_odata_type: str


class IdentityProvider(Entity):
    client_id: Annotated[
        Optional[str],
        Field(
            description='The client ID for the application. This is the client ID obtained when registering the application with the identity provider. Required. Not nullable.'
        ),
    ] = None
    client_secret: Annotated[
        Optional[str],
        Field(
            description='The client secret for the application. This is the client secret obtained when registering the application with the identity provider. This is write-only. A read operation will return .  Required. Not nullable.'
        ),
    ] = None
    name: Annotated[
        Optional[str],
        Field(description='The display name of the identity provider. Not nullable.'),
    ] = None
    type: Annotated[
        Optional[str],
        Field(
            description='The identity provider type is a required field. For B2B scenario: Google, Facebook. For B2C scenario: Microsoft, Google, Amazon, LinkedIn, Facebook, GitHub, Twitter, Weibo, QQ, WeChat, OpenIDConnect. Not nullable.'
        ),
    ] = None
    field_odata_type: str


class IdentityProviderBase(Entity):
    display_name: Annotated[
        Optional[str], Field(description='The display name of the identity provider.')
    ] = None
    field_odata_type: str


class InsightsSettings(Entity):
    disabled_for_group: Annotated[
        Optional[str],
        Field(
            description='The ID of a Microsoft Entra group, of which the specified type of insights are disabled for its members. The default value is null. Optional.'
        ),
    ] = None
    is_enabled_in_organization: Annotated[
        Optional[bool],
        Field(
            description='true if insights of the specified type are enabled for the organization; false if insights of the specified type are disabled for all users without exceptions. The default value is true. Optional.'
        ),
    ] = None
    field_odata_type: str


class LandingPageDetail(Entity):
    content: Annotated[
        Optional[str], Field(description='Landing page detail content.')
    ] = None
    is_default_langauge: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether this language detail is default for the landing page.'
        ),
    ] = None
    language: Annotated[
        Optional[str], Field(description='The content language for the landing page.')
    ] = None
    field_odata_type: str


class LinkedResource(Entity):
    application_name: Annotated[
        Optional[str],
        Field(description='The app name of the source that sends the linkedResource.'),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The title of the linkedResource.')
    ] = None
    external_id: Annotated[
        Optional[str],
        Field(
            description='ID of the object that is associated with this task on the third-party/partner system.'
        ),
    ] = None
    web_url: Annotated[
        Optional[str], Field(description='Deep link to the linkedResource.')
    ] = None
    field_odata_type: str


class LocalizedNotificationMessage(Entity):
    is_default: Annotated[
        Optional[bool],
        Field(
            description='Flag to indicate whether or not this is the default locale for language fallback. This flag can only be set. To unset, set this property to true on another Localized Notification Message.'
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='DateTime the object was last modified.',
        ),
    ] = None
    locale: Annotated[
        Optional[str],
        Field(description='The Locale for which this message is destined.'),
    ] = None
    message_template: Annotated[
        Optional[str], Field(description='The Message Template content.')
    ] = None
    subject: Annotated[
        Optional[str], Field(description='The Message Template Subject.')
    ] = None
    field_odata_type: str


class ManagedAppOperation(Entity):
    display_name: Annotated[Optional[str], Field(description='The operation name.')] = (
        None
    )
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The last time the app operation was modified.',
        ),
    ] = None
    state: Annotated[
        Optional[str], Field(description='The current state of the operation')
    ] = None
    version: Annotated[Optional[str], Field(description='Version of the entity.')] = (
        None
    )
    field_odata_type: str


class ManagedAppPolicy(Entity):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time the policy was created.',
        ),
    ] = None
    description: Annotated[
        Optional[str], Field(description="The policy's description.")
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='Policy display name.')
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Last time the policy was modified.',
        ),
    ] = None
    version: Annotated[Optional[str], Field(description='Version of the entity.')] = (
        None
    )
    field_odata_type: str


class ManagedAppStatus(Entity):
    display_name: Annotated[
        Optional[str], Field(description='Friendly name of the status report.')
    ] = None
    version: Annotated[Optional[str], Field(description='Version of the entity.')] = (
        None
    )
    field_odata_type: str


class ManagedAppStatusRaw(ManagedAppStatus):
    content: Annotated[Optional[Any], Field(description='Status report content.')] = (
        None
    )
    field_odata_type: str


class ManagedDeviceMobileAppConfigurationDeviceSummary(Entity):
    configuration_version: Annotated[
        Optional[float],
        Field(
            description='Version of the policy for that overview',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    error_count: Annotated[
        Optional[float],
        Field(description='Number of error devices', ge=-2147483648.0, le=2147483647.0),
    ] = None
    failed_count: Annotated[
        Optional[float],
        Field(
            description='Number of failed devices', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    last_update_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Last update time',
        ),
    ] = None
    not_applicable_count: Annotated[
        Optional[float],
        Field(
            description='Number of not applicable devices',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    pending_count: Annotated[
        Optional[float],
        Field(
            description='Number of pending devices', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    success_count: Annotated[
        Optional[float],
        Field(
            description='Number of succeeded devices', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    field_odata_type: str


class ManagedDeviceMobileAppConfigurationUserSummary(Entity):
    configuration_version: Annotated[
        Optional[float],
        Field(
            description='Version of the policy for that overview',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    error_count: Annotated[
        Optional[float],
        Field(description='Number of error Users', ge=-2147483648.0, le=2147483647.0),
    ] = None
    failed_count: Annotated[
        Optional[float],
        Field(description='Number of failed Users', ge=-2147483648.0, le=2147483647.0),
    ] = None
    last_update_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Last update time',
        ),
    ] = None
    not_applicable_count: Annotated[
        Optional[float],
        Field(
            description='Number of not applicable users',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    pending_count: Annotated[
        Optional[float],
        Field(description='Number of pending Users', ge=-2147483648.0, le=2147483647.0),
    ] = None
    success_count: Annotated[
        Optional[float],
        Field(
            description='Number of succeeded Users', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    field_odata_type: str


class MobileAppCategory(Entity):
    display_name: Annotated[
        Optional[str], Field(description='The name of the app category.')
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time the mobileAppCategory was last modified.',
        ),
    ] = None
    field_odata_type: str


class MobileContainedApp(Entity):
    field_odata_type: str


class MultiValueLegacyExtendedProperty(Entity):
    value: Annotated[
        Optional[List[str]], Field(description='A collection of property values.')
    ] = None
    field_odata_type: str


class NamedLocation(Entity):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents creation date and time of the location using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.',
        ),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='Human-readable name of the location.')
    ] = None
    modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents last modified date and time of the location using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.',
        ),
    ] = None
    field_odata_type: str


class OAuth2PermissionGrant(Entity):
    client_id: Annotated[
        Optional[str],
        Field(
            description="The object id (not appId) of the client service principal for the application that's authorized to act on behalf of a signed-in user when accessing an API. Required. Supports $filter (eq only)."
        ),
    ] = None
    consent_type: Annotated[
        Optional[str],
        Field(
            description='Indicates if authorization is granted for the client application to impersonate all users or only a specific user. AllPrincipals indicates authorization to impersonate all users. Principal indicates authorization to impersonate a specific user. Consent on behalf of all users can be granted by an administrator. Nonadmin users might be authorized to consent on behalf of themselves in some cases, for some delegated permissions. Required. Supports $filter (eq only).'
        ),
    ] = None
    principal_id: Annotated[
        Optional[str],
        Field(
            description='The id of the user on behalf of whom the client is authorized to access the resource, when consentType is Principal. If consentType is AllPrincipals this value is null. Required when consentType is Principal. Supports $filter (eq only).'
        ),
    ] = None
    resource_id: Annotated[
        Optional[str],
        Field(
            description='The id of the resource service principal to which access is authorized. This identifies the API that the client is authorized to attempt to call on behalf of a signed-in user. Supports $filter (eq only).'
        ),
    ] = None
    scope: Annotated[
        Optional[str],
        Field(
            description='A space-separated list of the claim values for delegated permissions that should be included in access tokens for the resource application (the API). For example, openid User.Read GroupMember.Read.All. Each claim value should match the value field of one of the delegated permissions defined by the API, listed in the oauth2PermissionScopes property of the resource service principal. Must not exceed 3,850 characters in length.'
        ),
    ] = None
    field_odata_type: str


class OnenoteEntityBaseModel(Entity):
    self: Annotated[
        Optional[str],
        Field(
            description='The endpoint where you can get details about the page. Read-only.'
        ),
    ] = None
    field_odata_type: str


class OnenoteEntitySchemaObjectModel(OnenoteEntityBaseModel):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the page was created. The timestamp represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.',
        ),
    ] = None
    field_odata_type: str


class OnenoteResource(OnenoteEntityBaseModel):
    content: Annotated[Optional[str], Field(description='The content stream')] = None
    content_url: Annotated[
        Optional[str], Field(description='The URL for downloading the content')
    ] = None
    field_odata_type: str


class ExcludedGroup(RootModel[UUID]):
    root: Annotated[
        UUID,
        Field(
        ),
    ]


class IncludedGroup(RootModel[UUID]):
    root: Annotated[
        UUID,
        Field(
        ),
    ]


class OnPremisesConditionalAccessSettings(Entity):
    enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates if on premises conditional access is enabled for this organization'
        ),
    ] = None
    excluded_groups: Annotated[
        Optional[List[ExcludedGroup]],
        Field(
            description='User groups that will be exempt by on premises conditional access. All users in these groups will be exempt from the conditional access policy.'
        ),
    ] = None
    included_groups: Annotated[
        Optional[List[IncludedGroup]],
        Field(
            description='User groups that will be targeted by on premises conditional access. All users in these groups will be required to have mobile device managed and compliant for mail access.'
        ),
    ] = None
    override_default_rule: Annotated[
        Optional[bool],
        Field(
            description='Override the default access rule when allowing a device to ensure access is granted.'
        ),
    ] = None
    field_odata_type: str


class OpenTypeExtension(Extension):
    extension_name: Annotated[
        Optional[str],
        Field(
            description='A unique text identifier for an open type data extension. Optional.'
        ),
    ] = None
    field_odata_type: str


class OutlookItem(Entity):
    categories: Annotated[
        Optional[List[str]],
        Field(description='The categories associated with the item'),
    ] = None
    change_key: Annotated[
        Optional[str],
        Field(
            description='Identifies the version of the item. Every time the item is changed, changeKey changes as well. This allows Exchange to apply changes to the correct version of the object. Read-only.'
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z',
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z',
        ),
    ] = None
    field_odata_type: str


class PlannerBucketTaskBoardTaskFormat(Entity):
    order_hint: Annotated[
        Optional[str],
        Field(
            description='Hint used to order tasks in the bucket view of the task board. For details about the supported format, see Using order hints in Planner.'
        ),
    ] = None
    field_odata_type: str


class PlannerProgressTaskBoardTaskFormat(Entity):
    order_hint: Annotated[
        Optional[str],
        Field(
            description='Hint value used to order the task on the progress view of the task board. For details about the supported format, see Using order hints in Planner.'
        ),
    ] = None
    field_odata_type: str


class PrintDocument(Entity):
    content_type: Annotated[
        Optional[str],
        Field(description="The document's content (MIME) type. Read-only."),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description="The document's name. Read-only.")
    ] = None
    size: Annotated[
        Optional[float], Field(description="The document's size in bytes. Read-only.")
    ] = None
    field_odata_type: str


class PrintServiceEndpoint(Entity):
    display_name: Annotated[
        Optional[str],
        Field(description='A human-readable display name for the endpoint.'),
    ] = None
    uri: Annotated[
        Optional[str],
        Field(description='The URI that can be used to access the service.'),
    ] = None
    field_odata_type: str


class PrintUsage(Entity):
    black_and_white_page_count: Optional[float] = None
    color_page_count: Optional[float] = None
    completed_black_and_white_job_count: Optional[float] = None
    completed_color_job_count: Optional[float] = None
    completed_job_count: Optional[float] = None
    double_sided_sheet_count: Optional[float] = None
    incomplete_job_count: Optional[float] = None
    media_sheet_count: Optional[float] = None
    page_count: Optional[float] = None
    single_sided_sheet_count: Optional[float] = None
    usage_date: Annotated[
        Optional[date],
        Field(),
    ] = None
    field_odata_type: str


class PrintUsageByPrinter(PrintUsage):
    printer_id: Annotated[
        Optional[str],
        Field(description='The ID of the printer represented by these statistics.'),
    ] = None
    printer_name: Annotated[
        Optional[str],
        Field(description='The name of the printer represented by these statistics.'),
    ] = None
    field_odata_type: str


class PrintUsageByUser(PrintUsage):
    user_principal_name: Annotated[
        Optional[str],
        Field(description='The UPN of the user represented by these statistics.'),
    ] = None
    field_odata_type: str


class PrivilegedAccessScheduleInstance(Entity):
    end_date_time: Annotated[
        Optional[datetime],
        Field(
            description='When the schedule instance ends. Required.',
        ),
    ] = None
    start_date_time: Annotated[
        Optional[datetime],
        Field(
            description='When this instance starts. Required.',
        ),
    ] = None
    field_odata_type: str


class ProfilePhoto(Entity):
    height: Annotated[
        Optional[float],
        Field(
            description='The height of the photo. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    width: Annotated[
        Optional[float],
        Field(
            description='The width of the photo. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class PronounsSettings(Entity):
    is_enabled_in_organization: Annotated[
        Optional[bool],
        Field(
            description='true to enable pronouns in the organization; otherwise, false. The default value is false, and pronouns are disabled.'
        ),
    ] = None
    field_odata_type: str


class ResourceOperation(Entity):
    action_name: Annotated[
        Optional[str],
        Field(
            description='Type of action this operation is going to perform. The actionName should be concise and limited to as few words as possible.'
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='Description of the resource operation. The description is used in mouse-over text for the operation when shown in the Azure Portal.'
        ),
    ] = None
    resource_name: Annotated[
        Optional[str],
        Field(description='Name of the Resource this operation is performed on.'),
    ] = None
    field_odata_type: str


class SecurityReportsRoot(Entity):
    field_odata_type: str


class ServiceAnnouncementAttachment(Entity):
    content: Annotated[Optional[str], Field(description='The attachment content.')] = (
        None
    )
    content_type: Optional[str] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
        ),
    ] = None
    name: Optional[str] = None
    size: Annotated[Optional[float], Field(ge=-2147483648.0, le=2147483647.0)] = None
    field_odata_type: str


class SettingStateDeviceSummary(Entity):
    compliant_device_count: Annotated[
        Optional[float],
        Field(
            description='Device Compliant count for the setting',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    conflict_device_count: Annotated[
        Optional[float],
        Field(
            description='Device conflict error count for the setting',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    error_device_count: Annotated[
        Optional[float],
        Field(
            description='Device error count for the setting',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    instance_path: Annotated[
        Optional[str], Field(description='Name of the InstancePath for the setting')
    ] = None
    non_compliant_device_count: Annotated[
        Optional[float],
        Field(
            description='Device NonCompliant count for the setting',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    not_applicable_device_count: Annotated[
        Optional[float],
        Field(
            description='Device Not Applicable count for the setting',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    remediated_device_count: Annotated[
        Optional[float],
        Field(
            description='Device Compliant count for the setting',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    setting_name: Annotated[Optional[str], Field(description='Name of the setting')] = (
        None
    )
    unknown_device_count: Annotated[
        Optional[float],
        Field(
            description='Device Unkown count for the setting',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class AllowedDomainGuidsForSyncAppItem(RootModel[Optional[UUID]]):
    root: Annotated[
        Optional[UUID],
        Field(
        ),
    ] = None


class SingleValueLegacyExtendedProperty(Entity):
    value: Annotated[Optional[str], Field(description='A property value.')] = None
    field_odata_type: str


class SocialIdentityProvider(IdentityProviderBase):
    client_id: Annotated[
        Optional[str],
        Field(
            description='The identifier for the client application obtained when registering the application with the identity provider. Required.'
        ),
    ] = None
    client_secret: Annotated[
        Optional[str],
        Field(
            description='The client secret for the application that is obtained when the application is registered with the identity provider. This is write-only. A read operation returns . Required.'
        ),
    ] = None
    identity_provider_type: Annotated[
        Optional[str],
        Field(
            description='For a B2B scenario, possible values: Google, Facebook. For a B2C scenario, possible values: Microsoft, Google, Amazon, LinkedIn, Facebook, GitHub, Twitter, Weibo, QQ, WeChat. Required.'
        ),
    ] = None
    field_odata_type: str


class SoftwareUpdateStatusSummary(Entity):
    compliant_device_count: Annotated[
        Optional[float],
        Field(
            description='Number of compliant devices.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    compliant_user_count: Annotated[
        Optional[float],
        Field(
            description='Number of compliant users.', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    conflict_device_count: Annotated[
        Optional[float],
        Field(
            description='Number of conflict devices.', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    conflict_user_count: Annotated[
        Optional[float],
        Field(
            description='Number of conflict users.', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The name of the policy.')
    ] = None
    error_device_count: Annotated[
        Optional[float],
        Field(
            description='Number of devices had error.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    error_user_count: Annotated[
        Optional[float],
        Field(
            description='Number of users had error.', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    non_compliant_device_count: Annotated[
        Optional[float],
        Field(
            description='Number of non compliant devices.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    non_compliant_user_count: Annotated[
        Optional[float],
        Field(
            description='Number of non compliant users.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    not_applicable_device_count: Annotated[
        Optional[float],
        Field(
            description='Number of not applicable devices.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    not_applicable_user_count: Annotated[
        Optional[float],
        Field(
            description='Number of not applicable users.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    remediated_device_count: Annotated[
        Optional[float],
        Field(
            description='Number of remediated devices.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    remediated_user_count: Annotated[
        Optional[float],
        Field(
            description='Number of remediated users.', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    unknown_device_count: Annotated[
        Optional[float],
        Field(
            description='Number of unknown devices.', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    unknown_user_count: Annotated[
        Optional[float],
        Field(
            description='Number of unknown users.', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    field_odata_type: str


class StorageQuotaBreakdown(Entity):
    display_name: Optional[str] = None
    manage_web_url: Optional[str] = None
    used: Optional[float] = None
    field_odata_type: str


class Subscription(Entity):
    application_id: Annotated[
        Optional[str],
        Field(
            description='Optional. Identifier of the application used to create the subscription. Read-only.'
        ),
    ] = None
    change_type: Annotated[
        Optional[str],
        Field(
            description='Required. Indicates the type of change in the subscribed resource that raises a change notification. The supported values are: created, updated, deleted. Multiple values can be combined using a comma-separated list. Note:  Drive root item and list change notifications support only the updated changeType. User and group change notifications support updated and deleted changeType. Use updated to receive notifications when user or group is created, updated, or soft deleted. Use deleted to receive notifications when user or group is permanently deleted.'
        ),
    ] = None
    client_state: Annotated[
        Optional[str],
        Field(
            description='Optional. Specifies the value of the clientState property sent by the service in each change notification. The maximum length is 128 characters. The client can check that the change notification came from the service by comparing the value of the clientState property sent with the subscription with the value of the clientState property received with each change notification.'
        ),
    ] = None
    creator_id: Annotated[
        Optional[str],
        Field(
            description='Optional. Identifier of the user or service principal that created the subscription. If the app used delegated permissions to create the subscription, this field contains the ID of the signed-in user the app called on behalf of. If the app used application permissions, this field contains the ID of the service principal corresponding to the app. Read-only.'
        ),
    ] = None
    encryption_certificate: Annotated[
        Optional[str],
        Field(
            description='Optional. A base64-encoded representation of a certificate with a public key used to encrypt resource data in change notifications. Optional but required when includeResourceData is true.'
        ),
    ] = None
    encryption_certificate_id: Annotated[
        Optional[str],
        Field(
            description='Optional. A custom app-provided identifier to help identify the certificate needed to decrypt resource data.'
        ),
    ] = None
    expiration_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Required. Specifies the date and time when the webhook subscription expires. The time is in UTC, and can be an amount of time from subscription creation that varies for the resource subscribed to. For the maximum supported subscription length of time, see Subscription lifetime.',
        ),
    ] = None
    include_resource_data: Annotated[
        Optional[bool],
        Field(
            description='Optional. When set to true, change notifications include resource data (such as content of a chat message).'
        ),
    ] = None
    latest_supported_tls_version: Annotated[
        Optional[str],
        Field(
            description='Optional. Specifies the latest version of Transport Layer Security (TLS) that the notification endpoint, specified by notificationUrl, supports. The possible values are: v10, v11, v12, v13. For subscribers whose notification endpoint supports a version lower than the currently recommended version (TLS 1.2), specifying this property by a set timeline allows them to temporarily use their deprecated version of TLS before completing their upgrade to TLS 1.2. For these subscribers, not setting this property per the timeline would result in subscription operations failing. For subscribers whose notification endpoint already supports TLS 1.2, setting this property is optional. In such cases, Microsoft Graph defaults the property to v1_2.'
        ),
    ] = None
    lifecycle_notification_url: Annotated[
        Optional[str],
        Field(
            description='Required for Teams resources if  the expirationDateTime value is more than 1 hour from now; optional otherwise. The URL of the endpoint that receives lifecycle notifications, including subscriptionRemoved, reauthorizationRequired, and missed notifications. This URL must make use of the HTTPS protocol. For more information, see Reduce missing subscriptions and change notifications.'
        ),
    ] = None
    notification_query_options: Annotated[
        Optional[str],
        Field(
            description='Optional. OData query options for specifying value for the targeting resource. Clients receive notifications when resource reaches the state matching the query options provided here. With this new property in the subscription creation payload along with all existing properties, Webhooks deliver notifications whenever a resource reaches the desired state mentioned in the notificationQueryOptions property. For example, when the print job is completed or when a print job resource isFetchable property value becomes true etc.  Supported only for Universal Print Service. For more information, see Subscribe to change notifications from cloud printing APIs using Microsoft Graph.'
        ),
    ] = None
    notification_url: Annotated[
        Optional[str],
        Field(
            description='Required. The URL of the endpoint that receives the change notifications. This URL must make use of the HTTPS protocol. Any query string parameter included in the notificationUrl property is included in the HTTP POST request when Microsoft Graph sends the change notifications.'
        ),
    ] = None
    notification_url_app_id: Annotated[
        Optional[str],
        Field(
            description='Optional. The app ID that the subscription service can use to generate the validation token. The value allows the client to validate the authenticity of the notification received.'
        ),
    ] = None
    resource: Annotated[
        Optional[str],
        Field(
            description="Required. Specifies the resource that is monitored for changes. Don't include the base URL (https://graph.microsoft.com/v1.0/). See the possible resource path values for each supported resource."
        ),
    ] = None
    field_odata_type: str


class TargetDeviceGroup(Entity):
    display_name: Annotated[
        Optional[str], Field(description='Display name for the target device group.')
    ] = None
    field_odata_type: str


class TeamsAppSettings(Entity):
    allow_user_requests_for_app_access: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether users are allowed to request access to the unavailable Teams apps.'
        ),
    ] = None
    is_user_personal_scope_resource_specific_consent_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether resource-specific consent for personal scope in Teams apps is enabled for the tenant. True indicates that Teams apps that are allowed in the tenant and require resource-specific permissions can be installed in the personal scope. False blocks the installation of any Teams app that requires resource-specific permissions in the personal scope.'
        ),
    ] = None
    field_odata_type: str


class TeamsTemplate(Entity):
    field_odata_type: str


class TeamworkBot(Entity):
    field_odata_type: str


class TeamworkHostedContent(Entity):
    content_bytes: Annotated[
        Optional[str],
        Field(description='Write only. Bytes for the hosted content (such as images).'),
    ] = None
    content_type: Annotated[
        Optional[str],
        Field(description='Write only. Content type. such as image/png, image/jpg.'),
    ] = None
    field_odata_type: str


class TeamworkTagMember(Entity):
    display_name: Annotated[
        Optional[str], Field(description="The member's display name.")
    ] = None
    tenant_id: Annotated[
        Optional[str],
        Field(description='The ID of the tenant that the tag member is a part of.'),
    ] = None
    user_id: Annotated[
        Optional[str], Field(description='The user ID of the member.')
    ] = None
    field_odata_type: str


class TelecomExpenseManagementPartner(Entity):
    app_authorized: Annotated[
        Optional[bool],
        Field(
            description="Whether the partner's AAD app has been authorized to access Intune."
        ),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='Display name of the TEM partner.')
    ] = None
    enabled: Annotated[
        Optional[bool],
        Field(
            description="Whether Intune's connection to the TEM service is currently enabled or disabled."
        ),
    ] = None
    last_connection_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Timestamp of the last request sent to Intune by the TEM partner.',
        ),
    ] = None
    url: Annotated[
        Optional[str],
        Field(
            description="URL of the TEM partner's administrative control panel, where an administrator can configure their TEM service."
        ),
    ] = None
    field_odata_type: str


class UnifiedRbacResourceAction(Entity):
    action_verb: Optional[str] = None
    authentication_context_id: Optional[str] = None
    description: Optional[str] = None
    is_authentication_context_settable: Optional[bool] = None
    name: Optional[str] = None
    resource_scope_id: Optional[str] = None
    field_odata_type: str


class UnifiedRbacResourceNamespace(Entity):
    name: Optional[str] = None
    resource_actions: Optional[List[UnifiedRbacResourceAction]] = None
    field_odata_type: str


class UserExperienceAnalyticsAppHealthAppPerformanceByAppVersionDetails(Entity):
    app_crash_count: Annotated[
        Optional[float],
        Field(
            description='The number of crashes for the app. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    app_display_name: Annotated[
        Optional[str], Field(description='The friendly name of the application.')
    ] = None
    app_name: Annotated[
        Optional[str], Field(description='The name of the application.')
    ] = None
    app_publisher: Annotated[
        Optional[str], Field(description='The publisher of the application.')
    ] = None
    app_version: Annotated[
        Optional[str], Field(description='The version of the application.')
    ] = None
    device_count_with_crashes: Annotated[
        Optional[float],
        Field(
            description='The total number of devices that have reported one or more application crashes for this application and version. Valid values 0 to 2147483647. Supports: $select, $OrderBy. Read-only. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    is_latest_used_version: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates the version of application is the latest version for that application that is in use. When FALSE, indicates the version is not the latest version. FALSE by default. Supports: $select, $OrderBy.'
        ),
    ] = None
    is_most_used_version: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates the version of application is the most used version for that application. When FALSE, indicates the version is not the most used version. FALSE by default. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    field_odata_type: str


class UserExperienceAnalyticsAppHealthAppPerformanceByAppVersionDeviceId(Entity):
    app_crash_count: Annotated[
        Optional[float],
        Field(
            description='The number of crashes for the app. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    app_display_name: Annotated[
        Optional[str], Field(description='The friendly name of the application.')
    ] = None
    app_name: Annotated[
        Optional[str], Field(description='The name of the application.')
    ] = None
    app_publisher: Annotated[
        Optional[str], Field(description='The publisher of the application.')
    ] = None
    app_version: Annotated[
        Optional[str], Field(description='The version of the application.')
    ] = None
    device_display_name: Annotated[
        Optional[str],
        Field(
            description='The name of the device. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    device_id: Annotated[
        Optional[str],
        Field(
            description='The Intune device id of the device. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    processed_date_time: Annotated[
        Optional[datetime],
        Field(
            description="The date and time when the statistics were last computed. The value cannot be modified and is automatically populated when the statistics are computed. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2022 would look like this: '2022-01-01T00:00:00Z'. Returned by default. Read-only.",
        ),
    ] = None
    field_odata_type: str


class UserExperienceAnalyticsAppHealthAppPerformanceByOSVersion(Entity):
    active_device_count: Annotated[
        Optional[float],
        Field(
            description='The number of devices where the application has been active. Valid values 0 to 2147483647. Supports: $select, $OrderBy. Read-only. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    app_crash_count: Annotated[
        Optional[float],
        Field(
            description='The number of crashes for the application. Valid values 0 to 2147483647. Supports: $select, $OrderBy. Read-only. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    app_display_name: Annotated[
        Optional[str],
        Field(
            description='The friendly name of the application. Possible values are: Outlook, Excel. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    app_name: Annotated[
        Optional[str],
        Field(
            description='The name of the application. Possible values are: outlook.exe, excel.exe. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    app_publisher: Annotated[
        Optional[str],
        Field(
            description='The publisher of the application. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    app_usage_duration: Annotated[
        Optional[float],
        Field(
            description='The total usage time of the application in minutes. Valid values 0 to 2147483647. Supports: $select, $OrderBy. Read-only. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    mean_time_to_failure_in_minutes: Annotated[
        Optional[float],
        Field(
            description='The mean time to failure for the application in minutes. Valid values 0 to 2147483647. Supports: $select, $OrderBy. Read-only. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    os_build_number: Annotated[
        Optional[str],
        Field(
            description='The OS build number of the application. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    os_version: Annotated[
        Optional[str],
        Field(
            description='The OS version of the application. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    field_odata_type: str


class UserExperienceAnalyticsAppHealthDevicePerformanceDetails(Entity):
    app_display_name: Annotated[
        Optional[str],
        Field(
            description='The friendly name of the application for which the event occurred. Possible values are: outlook.exe, excel.exe. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    app_publisher: Annotated[
        Optional[str],
        Field(
            description='The publisher of the application. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    app_version: Annotated[
        Optional[str],
        Field(
            description='The version of the application. Possible values are: 1.0.0.1, 75.65.23.9. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    device_display_name: Annotated[
        Optional[str],
        Field(
            description='The name of the device. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    device_id: Annotated[
        Optional[str],
        Field(
            description='The Intune device id of the device. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    event_date_time: Annotated[
        Optional[datetime],
        Field(
            description="The time the event occurred. The value cannot be modified and is automatically populated when the statistics are computed. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2022 would look like this: '2022-01-01T00:00:00Z'. Returned by default. Read-only.",
        ),
    ] = None
    event_type: Annotated[
        Optional[str],
        Field(
            description='The type of the event. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    field_odata_type: str


class UserExperienceAnalyticsDeviceStartupProcess(Entity):
    managed_device_id: Annotated[
        Optional[str],
        Field(
            description='The Intune device id of the device. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    process_name: Annotated[
        Optional[str],
        Field(
            description='The name of the process. Examples: outlook, excel. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    product_name: Annotated[
        Optional[str],
        Field(
            description='The product name of the process. Examples: Microsoft Outlook, Microsoft Excel. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    publisher: Annotated[
        Optional[str],
        Field(
            description='The publisher of the process. Examples: Microsoft Corporation, Contoso Corp. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    startup_impact_in_ms: Annotated[
        Optional[float],
        Field(
            description='The impact of startup process on device boot time in milliseconds. Supports: $select, $OrderBy. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class UserExperienceAnalyticsDeviceStartupProcessPerformance(Entity):
    device_count: Annotated[
        Optional[float],
        Field(
            description='The count of devices which initiated this process on startup. Supports: $filter, $select, $OrderBy. Read-only.'
        ),
    ] = None
    median_impact_in_ms: Annotated[
        Optional[float],
        Field(
            description='The median impact of startup process on device boot time in milliseconds. Supports: $filter, $select, $OrderBy. Read-only.'
        ),
    ] = None
    process_name: Annotated[
        Optional[str],
        Field(
            description='The name of the startup process. Examples: outlook, excel. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    product_name: Annotated[
        Optional[str],
        Field(
            description='The product name of the startup process. Examples: Microsoft Outlook, Microsoft Excel. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    publisher: Annotated[
        Optional[str],
        Field(
            description='The publisher of the startup process. Examples: Microsoft Corporation, Contoso Corp. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    total_impact_in_ms: Annotated[
        Optional[float],
        Field(
            description='The total impact of startup process on device boot time in milliseconds. Supports: $filter, $select, $OrderBy. Read-only.'
        ),
    ] = None
    field_odata_type: str


class UserExperienceAnalyticsMetricHistory(Entity):
    device_id: Annotated[
        Optional[str], Field(description='The Intune device id of the device.')
    ] = None
    metric_date_time: Annotated[
        Optional[datetime],
        Field(
            description="The metric date time. The value cannot be modified and is automatically populated when the metric is created. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look like this: '2014-01-01T00:00:00Z'. Returned by default.",
        ),
    ] = None
    metric_type: Annotated[
        Optional[str], Field(description='The user experience analytics metric type.')
    ] = None
    field_odata_type: str


class UserExperienceAnalyticsScoreHistory(Entity):
    startup_date_time: Annotated[
        Optional[datetime],
        Field(
            description="The device startup date time. The value cannot be modified and is automatically populated. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look like this: '2014-01-01T00:00:00Z'. Returned by default.",
        ),
    ] = None
    field_odata_type: str


class UserFlowLanguagePage(Entity):
    field_odata_type: str


class UserInsightsSettings(Entity):
    is_enabled: Annotated[
        Optional[bool],
        Field(
            description="True if the user's itemInsights and meeting hours insights are enabled; false if the user's itemInsights and meeting hours insights are disabled. The default value is true. Optional."
        ),
    ] = None
    field_odata_type: str


class UserSignInInsight(GovernanceInsight):
    last_sign_in_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Indicates when the user last signed in.',
        ),
    ] = None
    field_odata_type: str


class VirtualEventRegistrationQuestionBase(Entity):
    display_name: Annotated[
        Optional[str], Field(description='Display name of the registration question.')
    ] = None
    is_required: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether an answer to the question is required. The default value is false.'
        ),
    ] = None
    field_odata_type: str


class WebPart(Entity):
    field_odata_type: str


class WindowsAutopilotDeploymentProfileAssignment(Entity):
    field_odata_type: str


class WindowsInformationProtectionAppLockerFile(Entity):
    display_name: Annotated[Optional[str], Field(description='The friendly name')] = (
        None
    )
    file: Annotated[Optional[str], Field(description='File as a byte array')] = None
    file_hash: Annotated[
        Optional[str], Field(description='SHA256 hash of the file')
    ] = None
    version: Annotated[Optional[str], Field(description='Version of the entity.')] = (
        None
    )
    field_odata_type: str


class WindowsInformationProtectionNetworkLearningSummary(Entity):
    device_count: Annotated[
        Optional[float],
        Field(description='Device Count', ge=-2147483648.0, le=2147483647.0),
    ] = None
    url: Annotated[Optional[str], Field(description='Website url')] = None
    field_odata_type: str


class WindowsSettingInstance(Entity):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Set by the server. Represents the dateTime in UTC when the object was created on the server.',
        ),
    ] = None
    expiration_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Set by the server. The object expires at the specified dateTime in UTC, making it unavailable after that time.',
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description="Set by the server if not provided in the request from the Windows client device. Refers to the user's Windows device that modified the object at the specified dateTime in UTC.",
        ),
    ] = None
    payload: Annotated[
        Optional[str], Field(description='Base64-encoded JSON setting value.')
    ] = None
    field_odata_type: str


class WindowsUniversalAppXContainedApp(MobileContainedApp):
    app_user_model_id: Annotated[
        Optional[str],
        Field(
            description='The app user model ID of the contained app of a WindowsUniversalAppX app.'
        ),
    ] = None
    field_odata_type: str


class WorkbookApplication(Entity):
    calculation_mode: Annotated[
        Optional[str],
        Field(
            description='Returns the calculation mode used in the workbook. Possible values are: Automatic, AutomaticExceptTables, Manual.'
        ),
    ] = None
    field_odata_type: str


class WorkbookChartFill(Entity):
    field_odata_type: str


class WorkbookChartLineFormat(Entity):
    color: Annotated[
        Optional[str],
        Field(
            description='The HTML color code that represents the color of lines in the chart.'
        ),
    ] = None
    field_odata_type: str


class WorkbookChartPointFormat(Entity):
    fill: Annotated[
        Optional[Union[WorkbookChartFill, Dict[str, Any]]],
        Field(
            description='Represents the fill format of a chart, which includes background formatting information. Read-only.'
        ),
    ] = None
    field_odata_type: str


class WorkbookChartSeriesFormat(Entity):
    fill: Annotated[
        Optional[Union[WorkbookChartFill, Dict[str, Any]]],
        Field(
            description='Represents the fill format of a chart series, which includes background formatting information. Read-only.'
        ),
    ] = None
    line: Annotated[
        Optional[Union[WorkbookChartLineFormat, Dict[str, Any]]],
        Field(description='Represents line formatting. Read-only.'),
    ] = None
    field_odata_type: str


class WorkbookCommentReply(Entity):
    content: Annotated[
        Optional[str], Field(description='The content of the reply.')
    ] = None
    content_type: Annotated[
        Optional[str], Field(description='The content type for the reply.')
    ] = None
    field_odata_type: str


class WorkbookFormatProtection(Entity):
    formula_hidden: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether Excel hides the formula for the cells in the range. A null value indicates that the entire range doesn't have uniform formula hidden setting."
        ),
    ] = None
    locked: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether Excel locks the cells in the object. A null value indicates that the entire range doesn't have uniform lock setting."
        ),
    ] = None
    field_odata_type: str


class WorkbookFunctionResult(Entity):
    error: Optional[str] = None
    value: Optional[Any] = None
    field_odata_type: str


class WorkbookFunctions(Entity):
    field_odata_type: str


class WorkbookRangeBorder(Entity):
    color: Annotated[
        Optional[str],
        Field(
            description="The HTML color code that represents the color of the border line. Can either be of the form #RRGGBB, for example 'FFA500', or a named HTML color, for example 'orange'."
        ),
    ] = None
    side_index: Annotated[
        Optional[str],
        Field(
            description='Indicates the specific side of the border. The possible values are: EdgeTop, EdgeBottom, EdgeLeft, EdgeRight, InsideVertical, InsideHorizontal, DiagonalDown, DiagonalUp. Read-only.'
        ),
    ] = None
    style: Annotated[
        Optional[str],
        Field(
            description='Indicates the line style for the border. The possible values are: None, Continuous, Dash, DashDot, DashDotDot, Dot, Double, SlantDashDot.'
        ),
    ] = None
    weight: Annotated[
        Optional[str],
        Field(
            description='The weight of the border around a range. The possible values are: Hairline, Thin, Medium, Thick.'
        ),
    ] = None
    field_odata_type: str


class WorkbookRangeFill(Entity):
    color: Annotated[
        Optional[str],
        Field(
            description="HTML color code representing the color of the border line. Can either be of the form #RRGGBB, for example 'FFA500', or be a named HTML color, for example 'orange'."
        ),
    ] = None
    field_odata_type: str


class WorkbookRangeSort(Entity):
    field_odata_type: str


class WorkbookRangeView(Entity):
    cell_addresses: Annotated[
        Optional[Any], Field(description='The cell addresses.')
    ] = None
    column_count: Annotated[
        Optional[float],
        Field(
            description='The number of visible columns. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    formulas: Annotated[
        Optional[Any], Field(description='The formula in A1-style notation.')
    ] = None
    formulas_local: Annotated[
        Optional[Any],
        Field(
            description="The formula in A1-style notation, in the user's language and number-formatting locale. For example, the English '=SUM(A1, 1.5)' formula would become '=SUMME(A1; 1,5)' in German."
        ),
    ] = None
    formulas_r1_c1: Annotated[
        Optional[Any],
        Field(description='Represents the formula in R1C1-style notation.'),
    ] = None
    index: Annotated[
        Optional[float],
        Field(description='The index of the range.', ge=-2147483648.0, le=2147483647.0),
    ] = None
    number_format: Annotated[
        Optional[Any],
        Field(description="Excel's number format code for the given cell. Read-only."),
    ] = None
    row_count: Annotated[
        Optional[float],
        Field(
            description='The number of visible rows. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    text: Annotated[
        Optional[Any],
        Field(
            description="The text values of the specified range. The Text value won't depend on the cell width. The # sign substitution that happens in Excel UI won't affect the text value returned by the API. Read-only."
        ),
    ] = None
    values: Annotated[
        Optional[Any],
        Field(
            description='The raw values of the specified range view. The data returned could be of type string, number, or a Boolean. Cell that contains an error returns the error string.'
        ),
    ] = None
    value_types: Annotated[
        Optional[Any],
        Field(
            description='The type of data of each cell. Read-only. The possible values are: Unknown, Empty, String, Integer, Double, Boolean, Error.'
        ),
    ] = None
    rows: Annotated[
        Optional[List[WorkbookRangeView]],
        Field(
            description='The collection of range views associated with the range. Read-only. Read-only.'
        ),
    ] = None
    field_odata_type: str


class WorkbookTableRow(Entity):
    index: Annotated[
        Optional[float],
        Field(
            description='The index of the row within the rows collection of the table. Zero-based. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    values: Annotated[
        Optional[Any],
        Field(
            description='The raw values of the specified range. The data returned could be of type string, number, or a Boolean. Any cell that contain an error will return the error string.'
        ),
    ] = None
    field_odata_type: str


class WorkingTimeSchedule(Entity):
    field_odata_type: str


class AccessAction(BaseModel):
    field_odata_type: str


class AccessPackageAutomaticRequestSettings(BaseModel):
    grace_period_before_access_removal: Annotated[
        Optional[timedelta],
        Field(
            description="The duration for which access must be retained before the target's access is revoked once they leave the allowed target scope.",
        ),
    ] = None
    remove_access_when_target_leaves_allowed_targets: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether automatic assignment must be removed for targets who move out of the allowed target scope.'
        ),
    ] = None
    request_access_for_allowed_targets: Annotated[
        Optional[bool],
        Field(
            description='If set to true, automatic assignments will be created for targets in the allowed target scope.'
        ),
    ] = None
    field_odata_type: str


class AccessPackageLocalizedText(BaseModel):
    language_code: Annotated[
        Optional[str],
        Field(
            description="The language code that text is in. For example, 'en-us'. The language component follows 2-letter codes as defined in ISO 639-1, and the country component follows 2-letter codes as defined in ISO 3166-1 alpha-2. Required."
        ),
    ] = None
    text: Annotated[
        Optional[str],
        Field(description='The question in the specific language. Required.'),
    ] = None
    field_odata_type: str


class AccessPackageResourceAttributeDestination(BaseModel):
    field_odata_type: str


class AccessPackageResourceAttributeSource(BaseModel):
    field_odata_type: str


class AccessPackageUserDirectoryAttributeStore(
    AccessPackageResourceAttributeDestination
):
    field_odata_type: str


class AccessReviewApplyAction(BaseModel):
    field_odata_type: str


class AccessReviewInstanceDecisionItemResource(BaseModel):
    display_name: Annotated[
        Optional[str], Field(description='Display name of the resource')
    ] = None
    id: Annotated[Optional[str], Field(description='Identifier of the resource')] = None
    type: Annotated[
        Optional[str],
        Field(
            description='Type of resource. Types include: Group, ServicePrincipal, DirectoryRole, AzureRole, AccessPackageAssignmentPolicy.'
        ),
    ] = None
    field_odata_type: str


class AccessReviewInstanceDecisionItemServicePrincipalResource(
    AccessReviewInstanceDecisionItemResource
):
    app_id: Annotated[
        Optional[str],
        Field(
            description='The globally unique identifier of the application to which access has been granted.'
        ),
    ] = None
    field_odata_type: str


class AccessReviewNotificationRecipientScope(BaseModel):
    field_odata_type: str


class AccessReviewRecommendationInsightSetting(BaseModel):
    field_odata_type: str


class AccessReviewReviewerScope(BaseModel):
    query: Annotated[
        Optional[str],
        Field(description='The query specifying who will be the reviewer.'),
    ] = None
    query_root: Annotated[
        Optional[str],
        Field(
            description='In the scenario where reviewers need to be specified dynamically, this property is used to indicate the relative source of the query. This property is only required if a relative query, for example, ./manager, is specified. Possible value: decisions.'
        ),
    ] = None
    query_type: Annotated[
        Optional[str],
        Field(
            description='The type of query. Examples include MicrosoftGraph and ARM.'
        ),
    ] = None
    field_odata_type: str


class AccessReviewScope(BaseModel):
    field_odata_type: str


class AccessReviewStageSettings(BaseModel):
    decisions_that_will_move_to_next_stage: Annotated[
        Optional[List[str]],
        Field(
            description='Indicate which decisions will go to the next stage. Can be a subset of Approve, Deny, Recommendation, or NotReviewed. If not provided, all decisions will go to the next stage. Optional.'
        ),
    ] = None
    depends_on: Annotated[
        Optional[List[str]],
        Field(
            description="Defines the sequential or parallel order of the stages and depends on the stageId. Only sequential stages are currently supported. For example, if stageId is 2, then dependsOn must be 1. If stageId is 1, don't specify dependsOn. Required if stageId isn't 1."
        ),
    ] = None
    duration_in_days: Annotated[
        Optional[float],
        Field(
            description="The duration of the stage. Required.  NOTE: The cumulative value of this property across all stages  1. Will override the instanceDurationInDays setting on the accessReviewScheduleDefinition object. 2. Can't exceed the length of one recurrence. That is, if the review recurs weekly, the cumulative durationInDays can't exceed 7.",
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    fallback_reviewers: Annotated[
        Optional[List[AccessReviewReviewerScope]],
        Field(
            description="If provided, the fallback reviewers are asked to complete a review if the primary reviewers don't exist. For example, if managers are selected as reviewers and a principal under review doesn't have a manager in Microsoft Entra ID, the fallback reviewers are asked to review that principal. NOTE: The value of this property overrides the corresponding setting on the accessReviewScheduleDefinition object."
        ),
    ] = None
    recommendation_insight_settings: Optional[
        List[AccessReviewRecommendationInsightSetting]
    ] = None
    recommendations_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether showing recommendations to reviewers is enabled. Required. NOTE: The value of this property overrides override the corresponding setting on the accessReviewScheduleDefinition object.'
        ),
    ] = None
    reviewers: Annotated[
        Optional[List[AccessReviewReviewerScope]],
        Field(
            description='Defines who the reviewers are. If none is specified, the review is a self-review (users review their own access).  For examples of options for assigning reviewers, see Assign reviewers to your access review definition using the Microsoft Graph API. NOTE: The value of this property overrides the corresponding setting on the accessReviewScheduleDefinition.'
        ),
    ] = None
    stage_id: Annotated[
        Optional[str],
        Field(
            description='Unique identifier of the accessReviewStageSettings object. The stageId is used by the dependsOn property to indicate the order of the stages. Required.'
        ),
    ] = None
    field_odata_type: str


class AgreementFileData(BaseModel):
    data: Annotated[
        Optional[str],
        Field(
            description='Data that represents the terms of use PDF document. Read-only.'
        ),
    ] = None
    field_odata_type: str


class Album(BaseModel):
    cover_image_item_id: Annotated[
        Optional[str],
        Field(
            description='Unique identifier of the driveItem that is the cover of the album.'
        ),
    ] = None
    field_odata_type: str


class AlertDetection(BaseModel):
    detection_type: Optional[str] = None
    method: Optional[str] = None
    name: Optional[str] = None
    field_odata_type: str


class AlertTrigger(BaseModel):
    name: Annotated[
        Optional[str],
        Field(description='Name of the property serving as a detection trigger.'),
    ] = None
    type: Annotated[
        Optional[str],
        Field(
            description='Type of the property in the key:value pair for interpretation. For example, String, Boolean etc.'
        ),
    ] = None
    value: Annotated[
        Optional[str],
        Field(description='Value of the property serving as a detection trigger.'),
    ] = None
    field_odata_type: str


class AlteredQueryToken(BaseModel):
    length: Annotated[
        Optional[float],
        Field(
            description='Defines the length of a changed segment.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    offset: Annotated[
        Optional[float],
        Field(
            description='Defines the offset of a changed segment.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    suggestion: Annotated[
        Optional[str], Field(description='Represents the corrected segment string.')
    ] = None
    field_odata_type: str


class AlternativeSecurityId(BaseModel):
    identity_provider: Annotated[
        Optional[str], Field(description='For internal use only.')
    ] = None
    key: Annotated[Optional[str], Field(description='For internal use only.')] = None
    type: Annotated[
        Optional[float],
        Field(description='For internal use only.', ge=-2147483648.0, le=2147483647.0),
    ] = None
    field_odata_type: str


class AndroidMinimumOperatingSystem(BaseModel):
    v10_0: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, only Version 10.0 or later is supported. Default value is FALSE. Exactly one of the minimum operating system boolean values will be TRUE.'
        ),
    ] = None
    v11_0: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, only Version 11.0 or later is supported. Default value is FALSE. Exactly one of the minimum operating system boolean values will be TRUE.'
        ),
    ] = None
    v4_0: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, only Version 4.0 or later is supported. Default value is FALSE. Exactly one of the minimum operating system boolean values will be TRUE.'
        ),
    ] = None
    v4_0_3: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, only Version 4.0.3 or later is supported. Default value is FALSE. Exactly one of the minimum operating system boolean values will be TRUE.'
        ),
    ] = None
    v4_1: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, only Version 4.1 or later is supported. Default value is FALSE. Exactly one of the minimum operating system boolean values will be TRUE.'
        ),
    ] = None
    v4_2: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, only Version 4.2 or later is supported. Default value is FALSE. Exactly one of the minimum operating system boolean values will be TRUE.'
        ),
    ] = None
    v4_3: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, only Version 4.3 or later is supported. Default value is FALSE. Exactly one of the minimum operating system boolean values will be TRUE.'
        ),
    ] = None
    v4_4: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, only Version 4.4 or later is supported. Default value is FALSE. Exactly one of the minimum operating system boolean values will be TRUE.'
        ),
    ] = None
    v5_0: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, only Version 5.0 or later is supported. Default value is FALSE. Exactly one of the minimum operating system boolean values will be TRUE.'
        ),
    ] = None
    v5_1: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, only Version 5.1 or later is supported. Default value is FALSE. Exactly one of the minimum operating system boolean values will be TRUE.'
        ),
    ] = None
    v6_0: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, only Version 6.0 or later is supported. Default value is FALSE. Exactly one of the minimum operating system boolean values will be TRUE.'
        ),
    ] = None
    v7_0: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, only Version 7.0 or later is supported. Default value is FALSE. Exactly one of the minimum operating system boolean values will be TRUE.'
        ),
    ] = None
    v7_1: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, only Version 7.1 or later is supported. Default value is FALSE. Exactly one of the minimum operating system boolean values will be TRUE.'
        ),
    ] = None
    v8_0: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, only Version 8.0 or later is supported. Default value is FALSE. Exactly one of the minimum operating system boolean values will be TRUE.'
        ),
    ] = None
    v8_1: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, only Version 8.1 or later is supported. Default value is FALSE. Exactly one of the minimum operating system boolean values will be TRUE.'
        ),
    ] = None
    v9_0: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, only Version 9.0 or later is supported. Default value is FALSE. Exactly one of the minimum operating system boolean values will be TRUE.'
        ),
    ] = None
    field_odata_type: str


class KnownClientApplication(RootModel[Optional[UUID]]):
    root: Annotated[
        Optional[UUID],
        Field(
        ),
    ] = None


class ApiAuthenticationConfigurationBase(BaseModel):
    field_odata_type: str


class AppConsentRequestScope(BaseModel):
    display_name: Annotated[
        Optional[str], Field(description='The name of the scope.')
    ] = None
    field_odata_type: str


class AppIdentity(BaseModel):
    app_id: Annotated[
        Optional[str],
        Field(
            description='Refers to the unique ID representing application in Microsoft Entra ID.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='Refers to the application name displayed in the Microsoft Entra admin center.'
        ),
    ] = None
    service_principal_id: Annotated[
        Optional[str],
        Field(
            description='Refers to the unique ID for the service principal in Microsoft Entra ID.'
        ),
    ] = None
    service_principal_name: Annotated[
        Optional[str],
        Field(
            description='Refers to the Service Principal Name is the Application name in the tenant.'
        ),
    ] = None
    field_odata_type: str


class AppListItem(BaseModel):
    app_id: Annotated[
        Optional[str],
        Field(description='The application or bundle identifier of the application'),
    ] = None
    app_store_url: Annotated[
        Optional[str], Field(description='The Store URL of the application')
    ] = None
    name: Annotated[Optional[str], Field(description='The application name')] = None
    publisher: Annotated[
        Optional[str], Field(description='The publisher of the application')
    ] = None
    field_odata_type: str


class AppRole(BaseModel):
    allowed_member_types: Annotated[
        Optional[List[str]],
        Field(
            description="Specifies whether this app role can be assigned to users and groups (by setting to ['User']), to other application's (by setting to ['Application'], or both (by setting to ['User', 'Application']). App roles supporting assignment to other applications' service principals are also known as application permissions. The 'Application' value is only supported for app roles defined on application entities."
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='The description for the app role. This is displayed when the app role is being assigned and, if the app role functions as an application permission, during  consent experiences.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='Display name for the permission that appears in the app role assignment and consent experiences.'
        ),
    ] = None
    id: Annotated[
        Optional[UUID],
        Field(
            description='Unique role identifier inside the appRoles collection. When creating a new app role, a new GUID identifier must be provided.',
        ),
    ] = None
    is_enabled: Annotated[
        Optional[bool],
        Field(
            description='When creating or updating an app role, this must be set to true (which is the default). To delete a role, this must first be set to false.  At that point, in a subsequent call, this role may be removed.'
        ),
    ] = None
    origin: Annotated[
        Optional[str],
        Field(
            description='Specifies if the app role is defined on the application object or on the servicePrincipal entity. Must not be included in any POST or PATCH requests. Read-only.'
        ),
    ] = None
    value: Annotated[
        Optional[str],
        Field(
            description="Specifies the value to include in the roles claim in ID tokens and access tokens authenticating an assigned user or service principal. Must not exceed 120 characters in length. Allowed characters are : ! # $ % & ' ( ) * + , - . / : ;  =  ? @ [ ] ^ + _  {  } ~, and characters in the ranges 0-9, A-Z and a-z. Any other character, including the space character, aren't allowed. May not begin with .."
        ),
    ] = None
    field_odata_type: str


class AppsInstallationOptionsForMac(BaseModel):
    is_microsoft365_apps_enabled: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether users can install Microsoft 365 apps on their MAC devices. The default value is true.'
        ),
    ] = None
    is_skype_for_business_enabled: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether users can install Skype for Business on their MAC devices running OS X El Capitan 10.11 or later. The default value is true.'
        ),
    ] = None
    field_odata_type: str


class AppsInstallationOptionsForWindows(BaseModel):
    is_microsoft365_apps_enabled: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether users can install Microsoft 365 apps, including Skype for Business, on their Windows devices. The default value is true.'
        ),
    ] = None
    is_project_enabled: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether users can install Microsoft Project on their Windows devices. The default value is true.'
        ),
    ] = None
    is_skype_for_business_enabled: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether users can install Skype for Business (standalone) on their Windows devices. The default value is true.'
        ),
    ] = None
    is_visio_enabled: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether users can install Visio on their Windows devices. The default value is true.'
        ),
    ] = None
    field_odata_type: str


class AssignedLabel(BaseModel):
    display_name: Annotated[
        Optional[str], Field(description='The display name of the label. Read-only.')
    ] = None
    label_id: Annotated[
        Optional[str], Field(description='The unique identifier of the label.')
    ] = None
    field_odata_type: str


class DisabledPlan(RootModel[UUID]):
    root: Annotated[
        UUID,
        Field(
        ),
    ]


class AssignedLicense(BaseModel):
    disabled_plans: Annotated[
        Optional[List[DisabledPlan]],
        Field(
            description="A collection of the unique identifiers for plans that have been disabled. IDs are available in servicePlans > servicePlanId in the tenant's subscribedSkus or serviceStatus > servicePlanId in the tenant's companySubscription."
        ),
    ] = None
    sku_id: Annotated[
        Optional[UUID],
        Field(
            description='The unique identifier for the SKU. Corresponds to the skuId from subscribedSkus or companySubscription.',
        ),
    ] = None
    field_odata_type: str


class AssignedPlan(BaseModel):
    assigned_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time at which the plan was assigned. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    capability_status: Annotated[
        Optional[str],
        Field(
            description='Condition of the capability assignment. The possible values are Enabled, Warning, Suspended, Deleted, LockedOut. See a detailed description of each value.'
        ),
    ] = None
    service: Annotated[
        Optional[str],
        Field(description='The name of the service; for example, exchange.'),
    ] = None
    service_plan_id: Annotated[
        Optional[UUID],
        Field(
            description='A GUID that identifies the service plan. For a complete list of GUIDs and their equivalent friendly service names, see Product names and service plan identifiers for licensing.',
        ),
    ] = None
    field_odata_type: str


class AssignedTrainingInfo(BaseModel):
    assigned_user_count: Annotated[
        Optional[float],
        Field(
            description='Number of users who were assigned the training in an attack simulation and training campaign.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    completed_user_count: Annotated[
        Optional[float],
        Field(
            description='Number of users who completed the training in an attack simulation and training campaign.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='Display name of the training in an attack simulation and training campaign.'
        ),
    ] = None
    field_odata_type: str


class AssignmentOrder(BaseModel):
    order: Annotated[
        Optional[List[str]],
        Field(
            description='A list of identityUserFlowAttribute object identifiers that determine the order in which attributes should be collected within a user flow.'
        ),
    ] = None
    field_odata_type: str


class AttackSimulationUser(BaseModel):
    display_name: Annotated[
        Optional[str], Field(description='Display name of the user.')
    ] = None
    email: Annotated[Optional[str], Field(description='Email address of the user.')] = (
        None
    )
    user_id: Annotated[
        Optional[str],
        Field(
            description='This is the id property value of the user resource that represents the user in the Microsoft Entra tenant.'
        ),
    ] = None
    field_odata_type: str


class AttendanceInterval(BaseModel):
    duration_in_seconds: Annotated[
        Optional[float],
        Field(
            description='Duration of the meeting interval in seconds; that is, the difference between joinDateTime and leaveDateTime.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    join_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The time the attendee joined in UTC.',
        ),
    ] = None
    leave_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The time the attendee left in UTC.',
        ),
    ] = None
    field_odata_type: str


class AttendeeNotificationInfo(BaseModel):
    phone_number: Annotated[
        Optional[str],
        Field(description='The phone number of the external attendee. Required.'),
    ] = None
    time_zone: Annotated[
        Optional[str],
        Field(
            description='The time zone of the external attendee. The timeZone property can be set to any of the time zones currently supported by Windows. Required.'
        ),
    ] = None
    field_odata_type: str


class Audio(BaseModel):
    album: Annotated[
        Optional[str], Field(description='The title of the album for this audio file.')
    ] = None
    album_artist: Annotated[
        Optional[str],
        Field(description='The artist named on the album for the audio file.'),
    ] = None
    artist: Annotated[
        Optional[str], Field(description='The performing artist for the audio file.')
    ] = None
    bitrate: Annotated[
        Optional[float], Field(description='Bitrate expressed in kbps.')
    ] = None
    composers: Annotated[
        Optional[str], Field(description='The name of the composer of the audio file.')
    ] = None
    copyright: Annotated[
        Optional[str], Field(description='Copyright information for the audio file.')
    ] = None
    disc: Annotated[
        Optional[float],
        Field(
            description='The number of the disc this audio file came from.',
            ge=-32768.0,
            le=32767.0,
        ),
    ] = None
    disc_count: Annotated[
        Optional[float],
        Field(
            description='The total number of discs in this album.',
            ge=-32768.0,
            le=32767.0,
        ),
    ] = None
    duration: Annotated[
        Optional[float],
        Field(description='Duration of the audio file, expressed in milliseconds'),
    ] = None
    genre: Annotated[
        Optional[str], Field(description='The genre of this audio file.')
    ] = None
    has_drm: Annotated[
        Optional[bool],
        Field(
            description='Indicates if the file is protected with digital rights management.'
        ),
    ] = None
    is_variable_bitrate: Annotated[
        Optional[bool],
        Field(description='Indicates if the file is encoded with a variable bitrate.'),
    ] = None
    title: Annotated[
        Optional[str], Field(description='The title of the audio file.')
    ] = None
    track: Annotated[
        Optional[float],
        Field(
            description='The number of the track on the original disc for this audio file.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    track_count: Annotated[
        Optional[float],
        Field(
            description='The total number of tracks on the original disc for this audio file.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    year: Annotated[
        Optional[float],
        Field(
            description='The year the audio file was recorded.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class AudioConferencing(BaseModel):
    conference_id: Annotated[
        Optional[str], Field(description='The conference id of the online meeting.')
    ] = None
    dialin_url: Annotated[
        Optional[str],
        Field(
            description='A URL to the externally-accessible web page that contains dial-in information.'
        ),
    ] = None
    toll_free_number: Annotated[
        Optional[str],
        Field(
            description='The toll-free number that connects to the Audio Conference Provider.'
        ),
    ] = None
    toll_free_numbers: Annotated[
        Optional[List[str]],
        Field(
            description='List of toll-free numbers that are displayed in the meeting invite.'
        ),
    ] = None
    toll_number: Annotated[
        Optional[str],
        Field(
            description='The toll number that connects to the Audio Conference Provider.'
        ),
    ] = None
    toll_numbers: Annotated[
        Optional[List[str]],
        Field(
            description='List of toll numbers that are displayed in the meeting invite.'
        ),
    ] = None
    field_odata_type: str


class AuditActor(BaseModel):
    application_display_name: Annotated[
        Optional[str], Field(description='Name of the Application.')
    ] = None
    application_id: Annotated[
        Optional[str], Field(description='AAD Application Id.')
    ] = None
    audit_actor_type: Annotated[Optional[str], Field(description='Actor Type.')] = None
    ip_address: Annotated[Optional[str], Field(description='IPAddress.')] = None
    service_principal_name: Annotated[
        Optional[str], Field(description='Service Principal Name (SPN).')
    ] = None
    user_id: Annotated[Optional[str], Field(description='User Id.')] = None
    user_permissions: Annotated[
        Optional[List[str]],
        Field(description='List of user permissions when the audit was performed.'),
    ] = None
    user_principal_name: Annotated[
        Optional[str], Field(description='User Principal Name (UPN).')
    ] = None
    field_odata_type: str


class AuditProperty(BaseModel):
    display_name: Annotated[Optional[str], Field(description='Display name.')] = None
    new_value: Annotated[Optional[str], Field(description='New value.')] = None
    old_value: Annotated[Optional[str], Field(description='Old value.')] = None
    field_odata_type: str


class AuditResource(BaseModel):
    audit_resource_type: Annotated[
        Optional[str], Field(description="Audit resource's type.")
    ] = None
    display_name: Annotated[Optional[str], Field(description='Display name.')] = None
    modified_properties: Annotated[
        Optional[List[AuditProperty]], Field(description='List of modified properties.')
    ] = None
    resource_id: Annotated[Optional[str], Field(description="Audit resource's Id.")] = (
        None
    )
    field_odata_type: str


class AuthenticationAttributeCollectionOptionConfiguration(BaseModel):
    label: Annotated[
        Optional[str],
        Field(
            description='The label of the option that will be displayed to user, unless overridden.'
        ),
    ] = None
    value: Annotated[
        Optional[str], Field(description='The value of the option that will be stored.')
    ] = None
    field_odata_type: str


class AuthenticationConditionsApplications(BaseModel):
    include_applications: Optional[List[AuthenticationConditionApplication]] = None
    field_odata_type: str


class AuthorizationInfo(BaseModel):
    certificate_user_ids: Optional[List[str]] = None
    field_odata_type: str


class BasicAuthentication(ApiAuthenticationConfigurationBase):
    password: Annotated[
        Optional[str],
        Field(description="The password. It isn't returned in the responses."),
    ] = None
    username: Annotated[Optional[str], Field(description='The username.')] = None
    field_odata_type: str


class BookingCustomerInformationBase(BaseModel):
    field_odata_type: str


class BookingQuestionAssignment(BaseModel):
    is_required: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether it's mandatory to answer the custom question."
        ),
    ] = None
    question_id: Annotated[
        Optional[str], Field(description='The ID of the custom question.')
    ] = None
    field_odata_type: str


class BookingWorkTimeSlot(BaseModel):
    end_time: Annotated[
        Optional[time],
        Field(
            description='The time of the day when work stops. For example, 17:00:00.0000000.',
        ),
    ] = None
    start_time: Annotated[
        Optional[time],
        Field(
            description='The time of the day when work starts. For example, 08:00:00.0000000.',
        ),
    ] = None
    field_odata_type: str


class BooleanColumn(BaseModel):
    field_odata_type: str


class BroadcastMeetingCaptionSettings(BaseModel):
    is_caption_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether captions are enabled for this Teams live event.'
        ),
    ] = None
    spoken_language: Annotated[
        Optional[str], Field(description='The spoken language.')
    ] = None
    translation_languages: Annotated[
        Optional[List[str]],
        Field(description='The translation languages (choose up to 6).'),
    ] = None
    field_odata_type: str


class BucketAggregationRange(BaseModel):
    from_: Annotated[
        Optional[str],
        Field(
            description='Defines the lower bound from which to compute the aggregation. This can be a numeric value or a string representation of a date using the YYYY-MM-DDTHH:mm:ss.sssZ format. Required.'
        ),
    ] = None
    to: Annotated[
        Optional[str],
        Field(
            description='Defines the upper bound up to which to compute the aggregation. This can be a numeric value or a string representation of a date using the YYYY-MM-DDTHH:mm:ss.sssZ format. Required.'
        ),
    ] = None
    field_odata_type: str


class Bundle(BaseModel):
    album: Annotated[
        Optional[Union[Album, Dict[str, Any]]],
        Field(
            description='If the bundle is an album, then the album property is included'
        ),
    ] = None
    child_count: Annotated[
        Optional[float],
        Field(
            description='Number of children contained immediately within this container.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class CalculatedColumn(BaseModel):
    format: Annotated[
        Optional[str],
        Field(
            description='For dateTime output types, the format of the value. Possible values are: dateOnly or dateTime.'
        ),
    ] = None
    formula: Annotated[
        Optional[str],
        Field(description='The formula used to compute the value for this column.'),
    ] = None
    output_type: Annotated[
        Optional[str],
        Field(
            description='The output type used to format values in this column. Possible values are: boolean, currency, dateTime, number, or text.'
        ),
    ] = None
    field_odata_type: str


class CallOptions(BaseModel):
    hide_bot_after_escalation: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether to hide the app after the call is escalated.'
        ),
    ] = None
    is_content_sharing_notification_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether content sharing notifications should be enabled for the call.'
        ),
    ] = None
    is_delta_roster_enabled: Annotated[
        Optional[bool],
        Field(description='Indicates whether delta roster is enabled for the call.'),
    ] = None
    field_odata_type: str


class CertificateAuthority(BaseModel):
    certificate: Annotated[
        Optional[str],
        Field(
            description='Required. The base64 encoded string representing the public certificate.'
        ),
    ] = None
    certificate_revocation_list_url: Annotated[
        Optional[str], Field(description='The URL of the certificate revocation list.')
    ] = None
    delta_certificate_revocation_list_url: Annotated[
        Optional[str],
        Field(
            description='The URL contains the list of all revoked certificates since the last time a full certificate revocaton list was created.'
        ),
    ] = None
    is_root_authority: Annotated[
        Optional[bool],
        Field(
            description='Required. true if the trusted certificate is a root authority, false if the trusted certificate is an intermediate authority.'
        ),
    ] = None
    issuer: Annotated[
        Optional[str],
        Field(
            description='The issuer of the certificate, calculated from the certificate value. Read-only.'
        ),
    ] = None
    issuer_ski: Annotated[
        Optional[str],
        Field(
            description='The subject key identifier of the certificate, calculated from the certificate value. Read-only.'
        ),
    ] = None
    field_odata_type: str


class Certification(BaseModel):
    certification_details_url: Annotated[
        Optional[str],
        Field(description='URL that shows certification details for the application.'),
    ] = None
    certification_expiration_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The timestamp when the current certification for the application expires.',
        ),
    ] = None
    is_certified_by_microsoft: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the application is certified by Microsoft.'
        ),
    ] = None
    is_publisher_attested: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the application has been self-attested by the application developer or the publisher.'
        ),
    ] = None
    last_certification_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The timestamp when the certification for the application was most recently added or updated.',
        ),
    ] = None
    field_odata_type: str


class CertificationControl(BaseModel):
    name: Annotated[Optional[str], Field(description='Certification control name')] = (
        None
    )
    url: Annotated[
        Optional[str], Field(description='URL for the Microsoft Service Trust Portal')
    ] = None
    field_odata_type: str


class ChangeNotificationEncryptedContent(BaseModel):
    data: Annotated[
        Optional[str],
        Field(
            description='Base64-encoded encrypted data that produces a full resource respresented as JSON. The data has been encrypted with the provided dataKey using an AES/CBC/PKCS5PADDING cipher suite.'
        ),
    ] = None
    data_key: Annotated[
        Optional[str],
        Field(
            description='Base64-encoded symmetric key generated by Microsoft Graph to encrypt the data value and to generate the data signature. This key is encrypted with the certificate public key that was provided during the subscription. It must be decrypted with the certificate private key before it can be used to decrypt the data or verify the signature. This key has been encrypted with the following cipher suite: RSA/ECB/OAEPWithSHA1AndMGF1Padding.'
        ),
    ] = None
    data_signature: Annotated[
        Optional[str],
        Field(
            description='Base64-encoded HMAC-SHA256 hash of the data for validation purposes.'
        ),
    ] = None
    encryption_certificate_id: Annotated[
        Optional[str],
        Field(description='ID of the certificate used to encrypt the dataKey.'),
    ] = None
    encryption_certificate_thumbprint: Annotated[
        Optional[str],
        Field(
            description='Hexadecimal representation of the thumbprint of the certificate used to encrypt the dataKey.'
        ),
    ] = None
    field_odata_type: str


class ChannelIdentity(BaseModel):
    channel_id: Annotated[
        Optional[str],
        Field(
            description='The identity of the channel in which the message was posted.'
        ),
    ] = None
    team_id: Annotated[
        Optional[str],
        Field(description='The identity of the team in which the message was posted.'),
    ] = None
    field_odata_type: str


class ChannelSummary(BaseModel):
    guests_count: Annotated[
        Optional[float],
        Field(
            description='Count of guests in a channel.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    has_members_from_other_tenants: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether external members are included on the channel.'
        ),
    ] = None
    members_count: Annotated[
        Optional[float],
        Field(
            description='Count of members in a channel.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    owners_count: Annotated[
        Optional[float],
        Field(
            description='Count of owners in a channel.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class ChatInfo(BaseModel):
    message_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier of a message in a Microsoft Teams channel.'
        ),
    ] = None
    reply_chain_message_id: Annotated[
        Optional[str], Field(description='The ID of the reply message.')
    ] = None
    thread_id: Annotated[
        Optional[str],
        Field(description='The unique identifier for a thread in Microsoft Teams.'),
    ] = None
    field_odata_type: str


class ChatMessageAttachment(BaseModel):
    content: Annotated[
        Optional[str],
        Field(
            description='The content of the attachment. If the attachment is a rich card, set the property to the rich card object. This property and contentUrl are mutually exclusive.'
        ),
    ] = None
    content_type: Annotated[
        Optional[str],
        Field(
            description="The media type of the content attachment. The possible values are: reference: The attachment is a link to another file. Populate the contentURL with the link to the object.forwardedMessageReference: The attachment is a reference to a forwarded message. Populate the content with the original message context.Any contentType that is supported by the Bot Framework's Attachment object.application/vnd.microsoft.card.codesnippet: A code snippet. application/vnd.microsoft.card.announcement: An announcement header."
        ),
    ] = None
    content_url: Annotated[
        Optional[str], Field(description='The URL for the content of the attachment.')
    ] = None
    id: Annotated[
        Optional[str], Field(description='Read-only. The unique ID of the attachment.')
    ] = None
    name: Annotated[Optional[str], Field(description='The name of the attachment.')] = (
        None
    )
    teams_app_id: Annotated[
        Optional[str],
        Field(
            description='The ID of the Teams app that is associated with the attachment. The property is used to attribute a Teams message card to the specified app.'
        ),
    ] = None
    thumbnail_url: Annotated[
        Optional[str],
        Field(
            description='The URL to a thumbnail image that the channel can use if it supports using an alternative, smaller form of content or contentUrl. For example, if you set contentType to application/word and set contentUrl to the location of the Word document, you might include a thumbnail image that represents the document. The channel could display the thumbnail image instead of the document. When the user selects the image, the channel would open the document.'
        ),
    ] = None
    field_odata_type: str


class ChatMessagePolicyViolationPolicyTip(BaseModel):
    compliance_url: Annotated[
        Optional[str],
        Field(
            description="The URL a user can visit to read about the data loss prevention policies for the organization. (ie, policies about what users shouldn't say in chats)"
        ),
    ] = None
    general_text: Annotated[
        Optional[str],
        Field(description='Explanatory text shown to the sender of the message.'),
    ] = None
    matched_condition_descriptions: Annotated[
        Optional[List[str]],
        Field(
            description="The list of improper data in the message that was detected by the data loss prevention app. Each DLP app defines its own conditions, examples include 'Credit Card Number' and 'Social Security Number'."
        ),
    ] = None
    field_odata_type: str


class ChatRestrictions(BaseModel):
    allow_text_only: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether only text is allowed in the meeting chat. Optional.'
        ),
    ] = None
    field_odata_type: str


class ChatViewpoint(BaseModel):
    is_hidden: Annotated[
        Optional[bool],
        Field(description='Indicates whether the chat is hidden for the current user.'),
    ] = None
    last_message_read_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Represents the dateTime up until which the current user has read chatMessages in a specific chat.',
        ),
    ] = None
    field_odata_type: str


class ChoiceColumn(BaseModel):
    allow_text_entry: Annotated[
        Optional[bool],
        Field(
            description="If true, allows custom values that aren't in the configured choices."
        ),
    ] = None
    choices: Annotated[
        Optional[List[str]],
        Field(description='The list of values available for this column.'),
    ] = None
    display_as: Annotated[
        Optional[str],
        Field(
            description='How the choices are to be presented in the UX. Must be one of checkBoxes, dropDownMenu, or radioButtons'
        ),
    ] = None
    field_odata_type: str


class CloudAppSecurityState(BaseModel):
    destination_service_ip: Annotated[
        Optional[str],
        Field(
            description='Destination IP Address of the connection to the cloud application/service.'
        ),
    ] = None
    destination_service_name: Annotated[
        Optional[str],
        Field(
            description="Cloud application/service name (for example 'Salesforce', 'DropBox', etc.)."
        ),
    ] = None
    risk_score: Annotated[
        Optional[str],
        Field(
            description='Provider-generated/calculated risk score of the Cloud Application/Service. Recommended value range of 0-1, which equates to a percentage.'
        ),
    ] = None
    field_odata_type: str


class CloudClipboardItemPayload(BaseModel):
    content: Annotated[
        Optional[str],
        Field(
            description='The formatName version of the value of a cloud clipboard encoded in base64.'
        ),
    ] = None
    format_name: Annotated[
        Optional[str],
        Field(description='For a list of possible values see formatName values.'),
    ] = None
    field_odata_type: str


class CloudPcAuditProperty(BaseModel):
    display_name: Annotated[
        Optional[str], Field(description='The display name for this property.')
    ] = None
    new_value: Annotated[
        Optional[str], Field(description='The new value for this property.')
    ] = None
    old_value: Annotated[
        Optional[str], Field(description='The old value for this property.')
    ] = None
    field_odata_type: str


class CloudPcAuditResource(BaseModel):
    display_name: Annotated[
        Optional[str],
        Field(description='The display name of the modified resource entity.'),
    ] = None
    modified_properties: Annotated[
        Optional[List[CloudPcAuditProperty]],
        Field(description='The list of modified properties.'),
    ] = None
    resource_id: Annotated[
        Optional[str],
        Field(description='The unique identifier of the modified resource entity.'),
    ] = None
    field_odata_type: str


class CloudPcManagementAssignmentTarget(BaseModel):
    field_odata_type: str


class CloudPcManagementGroupAssignmentTarget(CloudPcManagementAssignmentTarget):
    group_id: Annotated[
        Optional[str],
        Field(description='The ID of the target group for the assignment.'),
    ] = None
    service_plan_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier for the service plan that indicates which size of the Cloud PC to provision for the user. Use a null value, when the provisioningType is dedicated.'
        ),
    ] = None
    field_odata_type: str


class CloudPcProvisioningPolicyAutopatch(BaseModel):
    autopatch_group_id: Optional[str] = None
    field_odata_type: str


class CloudPcSourceDeviceImage(BaseModel):
    display_name: Annotated[
        Optional[str],
        Field(description='The display name for the source image. Read-only.'),
    ] = None
    resource_id: Annotated[
        Optional[str],
        Field(
            description="The fully qualified unique identifier (ID) of the source image resource in Azure. The ID format is: '/subscriptions/{subscription-id}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/images/{imageName}'. Read-only."
        ),
    ] = None
    subscription_display_name: Annotated[
        Optional[str],
        Field(
            description='The display name of the subscription that hosts the source image. Read-only.'
        ),
    ] = None
    subscription_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier (ID) of the subscription that hosts the source image. Read-only.'
        ),
    ] = None
    field_odata_type: str


class CloudPcUserRoleScopeTagInfo(BaseModel):
    display_name: Annotated[
        Optional[str], Field(description='Scope tag display name.')
    ] = None
    role_scope_tag_id: Annotated[
        Optional[str], Field(description='Scope tag identity.')
    ] = None
    field_odata_type: str


class CloudPcWindowsSetting(BaseModel):
    locale: Annotated[
        Optional[str],
        Field(
            description='The Windows language or region tag to use for language pack configuration and localization of the Cloud PC. The default value is en-US, which corresponds to English (United States).'
        ),
    ] = None
    field_odata_type: str


class CollapseProperty(BaseModel):
    fields: Annotated[
        Optional[List[str]],
        Field(
            description='Defines the collapse group to trim results. The properties in this collection must be sortable/refinable properties. Required.'
        ),
    ] = None
    limit: Annotated[
        Optional[float],
        Field(
            description='Defines a maximum limit count for this field. This numeric value must be a positive integer. Required.',
            ge=-32768.0,
            le=32767.0,
        ),
    ] = None
    field_odata_type: str


class ComplexExtensionValue(BaseModel):
    field_odata_type: str


class ComplianceInformation(BaseModel):
    certification_controls: Annotated[
        Optional[List[CertificationControl]],
        Field(
            description='Collection of the certification controls associated with the certification.'
        ),
    ] = None
    certification_name: Annotated[
        Optional[str],
        Field(
            description='The name of the compliance certification, for example, ISO 27018:2014, GDPR, FedRAMP, and NIST 800-171.'
        ),
    ] = None
    field_odata_type: str


class ConditionalAccessLocations(BaseModel):
    exclude_locations: Annotated[
        Optional[List[str]],
        Field(description='Location IDs excluded from scope of policy.'),
    ] = None
    include_locations: Annotated[
        Optional[List[str]],
        Field(
            description='Location IDs in scope of policy unless explicitly excluded, All, or AllTrusted.'
        ),
    ] = None
    field_odata_type: str


class ConditionalAccessSessionControl(BaseModel):
    is_enabled: Annotated[
        Optional[bool],
        Field(description='Specifies whether the session control is enabled.'),
    ] = None
    field_odata_type: str


class ConfigurationManagerClientEnabledFeatures(BaseModel):
    compliance_policy: Annotated[
        Optional[bool],
        Field(description='Whether compliance policy is managed by Intune'),
    ] = None
    device_configuration: Annotated[
        Optional[bool],
        Field(description='Whether device configuration is managed by Intune'),
    ] = None
    inventory: Annotated[
        Optional[bool], Field(description='Whether inventory is managed by Intune')
    ] = None
    modern_apps: Annotated[
        Optional[bool],
        Field(description='Whether modern application is managed by Intune'),
    ] = None
    resource_access: Annotated[
        Optional[bool],
        Field(description='Whether resource access is managed by Intune'),
    ] = None
    windows_update_for_business: Annotated[
        Optional[bool],
        Field(description='Whether Windows Update for Business is managed by Intune'),
    ] = None
    field_odata_type: str


class ConnectionInfo(BaseModel):
    url: Annotated[
        Optional[str],
        Field(
            description='The endpoint that is used by Entitlement Management to communicate with the access package resource.'
        ),
    ] = None
    field_odata_type: str


class ContainerFilter(BaseModel):
    included_containers: Optional[List[str]] = None
    field_odata_type: str


class ContentApprovalStatusColumn(BaseModel):
    field_odata_type: str


class ContentTypeInfo(BaseModel):
    id: Annotated[Optional[str], Field(description='The ID of the content type.')] = (
        None
    )
    name: Annotated[
        Optional[str], Field(description='The name of the content type.')
    ] = None
    field_odata_type: str


class ContentTypeOrder(BaseModel):
    default: Annotated[
        Optional[bool],
        Field(description='Indicates whether this is the default content type'),
    ] = None
    position: Annotated[
        Optional[float],
        Field(
            description='Specifies the position in which the content type appears in the selection UI.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class CreateAction(BaseModel):
    field_odata_type: str


class CrossTenantAccessPolicyInboundTrust(BaseModel):
    is_compliant_device_accepted: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether compliant devices from external Microsoft Entra organizations are trusted.'
        ),
    ] = None
    is_hybrid_azure_ad_joined_device_accepted: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether Microsoft Entra hybrid joined devices from external Microsoft Entra organizations are trusted.'
        ),
    ] = None
    is_mfa_accepted: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether MFA from external Microsoft Entra organizations is trusted.'
        ),
    ] = None
    field_odata_type: str


class CrossTenantUserSyncInbound(BaseModel):
    is_sync_allowed: Annotated[
        Optional[bool],
        Field(
            description='Defines whether user objects should be synchronized from the partner tenant. false causes any current user synchronization from the source tenant to the target tenant to stop. This property has no impact on existing users who have already been synchronized.'
        ),
    ] = None
    field_odata_type: str


class CurrencyColumn(BaseModel):
    locale: Annotated[
        Optional[str],
        Field(
            description='Specifies the locale from which to infer the currency symbol.'
        ),
    ] = None
    field_odata_type: str


class CustomExtensionAuthenticationConfiguration(BaseModel):
    field_odata_type: str


class CustomExtensionCallbackConfiguration(BaseModel):
    timeout_duration: Annotated[
        Optional[timedelta],
        Field(
            description='The maximum duration in ISO 8601 format that Microsoft Entra ID will wait for a resume action for the callout it sent to the logic app. The valid range for custom extensions in lifecycle workflows is five minutes to three hours. The valid range for custom extensions in entitlement management is between 5 minutes and 14 days. For example, PT3H refers to three hours, P3D refers to three days, PT10M refers to ten minutes.',
        ),
    ] = None
    field_odata_type: str


class CustomExtensionClientConfiguration(BaseModel):
    maximum_retries: Annotated[
        Optional[float],
        Field(
            description='The max number of retries that Microsoft Entra ID makes to the external API. Values of 0 or 1 are supported. If null, the default for the service applies.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    timeout_in_milliseconds: Annotated[
        Optional[float],
        Field(
            description='The max duration in milliseconds that Microsoft Entra ID waits for a response from the external app before it shuts down the connection. The valid range is between 200 and 2000 milliseconds. Default duration is 1000.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class CustomExtensionData(BaseModel):
    field_odata_type: str


class CustomExtensionEndpointConfiguration(BaseModel):
    field_odata_type: str


class CustomExtensionOverwriteConfiguration(BaseModel):
    client_configuration: Annotated[
        Optional[Union[CustomExtensionClientConfiguration, Dict[str, Any]]],
        Field(
            description='Configuration regarding properties of the custom extension which can be overwritten per event listener. If no values are provided, the properties on the custom extension are used.'
        ),
    ] = None
    field_odata_type: str


class CustomSecurityAttributeValue(BaseModel):
    field_odata_type: str


class DataSubject(BaseModel):
    email: Annotated[Optional[str], Field(description='Email of the data subject.')] = (
        None
    )
    first_name: Annotated[
        Optional[str], Field(description='First name of the data subject.')
    ] = None
    last_name: Annotated[
        Optional[str], Field(description='Last Name of the data subject.')
    ] = None
    residency: Annotated[
        Optional[str],
        Field(
            description='The country/region of residency. The residency information is uesed only for internal reporting but not for the content search.'
        ),
    ] = None
    field_odata_type: str


class DateTimeColumn(BaseModel):
    display_as: Annotated[
        Optional[str],
        Field(
            description='How the value should be presented in the UX. Must be one of default, friendly, or standard. See below for more details. If unspecified, treated as default.'
        ),
    ] = None
    format: Annotated[
        Optional[str],
        Field(
            description='Indicates whether the value should be presented as a date only or a date and time. Must be one of dateOnly or dateTime'
        ),
    ] = None
    field_odata_type: str


class DateTimeTimeZone(BaseModel):
    date_time: Annotated[
        Optional[str],
        Field(
            description='A single point of time in a combined date and time representation ({date}T{time}; for example, 2017-08-29T04:00:00.0000000).'
        ),
    ] = None
    time_zone: Annotated[
        Optional[str],
        Field(
            description="Represents a time zone, for example, 'Pacific Standard Time'. See below for more possible values."
        ),
    ] = None
    field_odata_type: str


class DefaultColumnValue(BaseModel):
    formula: Annotated[
        Optional[str],
        Field(
            description='The formula used to compute the default value for the column.'
        ),
    ] = None
    value: Annotated[
        Optional[str],
        Field(
            description='The direct value to use as the default value for the column.'
        ),
    ] = None
    field_odata_type: str


class DefaultUserRolePermissions(BaseModel):
    allowed_to_create_apps: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the default user role can create applications. This setting corresponds to the Users can register applications setting in the User settings menu in the Microsoft Entra admin center.'
        ),
    ] = None
    allowed_to_create_security_groups: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the default user role can create security groups. This setting corresponds to the following menus in the Microsoft Entra admin center:  The Users can create security groups in Microsoft Entra admin centers, API or PowerShell setting in the Group settings menu.  Users can create security groups setting in the User settings menu.'
        ),
    ] = None
    allowed_to_create_tenants: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the default user role can create tenants. This setting corresponds to the Restrict non-admin users from creating tenants setting in the User settings menu in the Microsoft Entra admin center.  When this setting is false, users assigned the Tenant Creator role can still create tenants.'
        ),
    ] = None
    allowed_to_read_bitlocker_keys_for_owned_device: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the registered owners of a device can read their own BitLocker recovery keys with default user role.'
        ),
    ] = None
    allowed_to_read_other_users: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the default user role can read other users. DO NOT SET THIS VALUE TO false.'
        ),
    ] = None
    permission_grant_policies_assigned: Annotated[
        Optional[List[str]],
        Field(
            description='Indicates if user consent to apps is allowed, and if it is, which permission to grant consent and which app consent policy (permissionGrantPolicy) govern the permission for users to grant consent. Value should be in the format managePermissionGrantsForSelf.{id}, where {id} is the id of a built-in or custom app consent policy. An empty list indicates user consent to apps is disabled.'
        ),
    ] = None
    field_odata_type: str


class DelegatedAdminRelationshipCustomerParticipant(BaseModel):
    display_name: Annotated[
        Optional[str],
        Field(
            description='The display name of the customer tenant as set by Microsoft Entra ID. Read-only'
        ),
    ] = None
    tenant_id: Annotated[
        Optional[str],
        Field(
            description='The Microsoft Entra ID-assigned tenant ID of the customer tenant.'
        ),
    ] = None
    field_odata_type: str


class DeleteAction(BaseModel):
    name: Annotated[
        Optional[str], Field(description='The name of the item that was deleted.')
    ] = None
    object_type: Annotated[
        Optional[str],
        Field(description='File or Folder, depending on the type of the deleted item.'),
    ] = None
    field_odata_type: str


class Deleted(BaseModel):
    state: Annotated[
        Optional[str], Field(description='Represents the state of the deleted item.')
    ] = None
    field_odata_type: str


class DetailsInfo(BaseModel):
    field_odata_type: str


class DeviceAndAppManagementAssignmentTarget(BaseModel):
    field_odata_type: str


class DeviceAndAppManagementData(BaseModel):
    content: Annotated[Optional[str], Field(description='Not yet documented')] = None
    field_odata_type: str


class DeviceDetail(BaseModel):
    browser: Annotated[
        Optional[str],
        Field(
            description='Indicates the browser information of the used in the sign-in. Populated for devices registered in Microsoft Entra.'
        ),
    ] = None
    device_id: Annotated[
        Optional[str],
        Field(
            description='Refers to the unique ID of the device used in the sign-in. Populated for devices registered in Microsoft Entra.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='Refers to the name of the device used in the sign-in. Populated for devices registered in Microsoft Entra.'
        ),
    ] = None
    is_compliant: Annotated[
        Optional[bool],
        Field(description='Indicates whether the device is compliant or not.'),
    ] = None
    is_managed: Annotated[
        Optional[bool], Field(description='Indicates if the device is managed or not.')
    ] = None
    operating_system: Annotated[
        Optional[str],
        Field(description='Indicates the OS name and version used in the sign-in.'),
    ] = None
    trust_type: Annotated[
        Optional[str],
        Field(
            description='Indicates information on whether the device used in the sign-in is workplace-joined, Microsoft Entra-joined, domain-joined.'
        ),
    ] = None
    field_odata_type: str


class DeviceEnrollmentPlatformRestriction(BaseModel):
    os_maximum_version: Annotated[
        Optional[str], Field(description='Max OS version supported')
    ] = None
    os_minimum_version: Annotated[
        Optional[str], Field(description='Min OS version supported')
    ] = None
    personal_device_enrollment_blocked: Annotated[
        Optional[bool],
        Field(description='Block personally owned devices from enrolling'),
    ] = None
    platform_blocked: Annotated[
        Optional[bool], Field(description='Block the platform from enrolling')
    ] = None
    field_odata_type: str


class DeviceExchangeAccessStateSummary(BaseModel):
    allowed_device_count: Annotated[
        Optional[float],
        Field(
            description='Total count of devices with Exchange Access State: Allowed.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    blocked_device_count: Annotated[
        Optional[float],
        Field(
            description='Total count of devices with Exchange Access State: Blocked.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    quarantined_device_count: Annotated[
        Optional[float],
        Field(
            description='Total count of devices with Exchange Access State: Quarantined.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    unavailable_device_count: Annotated[
        Optional[float],
        Field(
            description='Total count of devices for which no Exchange Access State could be found.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    unknown_device_count: Annotated[
        Optional[float],
        Field(
            description='Total count of devices with Exchange Access State: Unknown.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class DeviceHealthAttestationState(BaseModel):
    attestation_identity_key: Annotated[
        Optional[str],
        Field(
            description='TWhen an Attestation Identity Key (AIK) is present on a device, it indicates that the device has an endorsement key (EK) certificate.'
        ),
    ] = None
    bit_locker_status: Annotated[
        Optional[str], Field(description='On or Off of BitLocker Drive Encryption')
    ] = None
    boot_app_security_version: Annotated[
        Optional[str],
        Field(description='The security version number of the Boot Application'),
    ] = None
    boot_debugging: Annotated[
        Optional[str],
        Field(
            description='When bootDebugging is enabled, the device is used in development and testing'
        ),
    ] = None
    boot_manager_security_version: Annotated[
        Optional[str],
        Field(description='The security version number of the Boot Application'),
    ] = None
    boot_manager_version: Annotated[
        Optional[str], Field(description='The version of the Boot Manager')
    ] = None
    boot_revision_list_info: Annotated[
        Optional[str],
        Field(
            description='The Boot Revision List that was loaded during initial boot on the attested device'
        ),
    ] = None
    code_integrity: Annotated[
        Optional[str],
        Field(
            description='When code integrity is enabled, code execution is restricted to integrity verified code'
        ),
    ] = None
    code_integrity_check_version: Annotated[
        Optional[str], Field(description='The version of the Boot Manager')
    ] = None
    code_integrity_policy: Annotated[
        Optional[str],
        Field(
            description='The Code Integrity policy that is controlling the security of the boot environment'
        ),
    ] = None
    content_namespace_url: Annotated[
        Optional[str], Field(description='The DHA report version. (Namespace version)')
    ] = None
    content_version: Annotated[
        Optional[str], Field(description='The HealthAttestation state schema version')
    ] = None
    data_excution_policy: Annotated[
        Optional[str],
        Field(
            description='DEP Policy defines a set of hardware and software technologies that perform additional checks on memory'
        ),
    ] = None
    device_health_attestation_status: Annotated[
        Optional[str], Field(description='The DHA report version. (Namespace version)')
    ] = None
    early_launch_anti_malware_driver_protection: Annotated[
        Optional[str],
        Field(
            description='ELAM provides protection for the computers in your network when they start up'
        ),
    ] = None
    health_attestation_supported_status: Annotated[
        Optional[str],
        Field(
            description='This attribute indicates if DHA is supported for the device'
        ),
    ] = None
    health_status_mismatch_info: Annotated[
        Optional[str],
        Field(
            description='This attribute appears if DHA-Service detects an integrity issue'
        ),
    ] = None
    issued_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The DateTime when device was evaluated or issued to MDM',
        ),
    ] = None
    last_update_date_time: Annotated[
        Optional[str], Field(description='The Timestamp of the last update.')
    ] = None
    operating_system_kernel_debugging: Annotated[
        Optional[str],
        Field(
            description='When operatingSystemKernelDebugging is enabled, the device is used in development and testing'
        ),
    ] = None
    operating_system_rev_list_info: Annotated[
        Optional[str],
        Field(
            description='The Operating System Revision List that was loaded during initial boot on the attested device'
        ),
    ] = None
    pcr0: Annotated[
        Optional[str], Field(description='The measurement that is captured in PCR[0]')
    ] = None
    pcr_hash_algorithm: Annotated[
        Optional[str],
        Field(
            description='Informational attribute that identifies the HASH algorithm that was used by TPM'
        ),
    ] = None
    reset_count: Annotated[
        Optional[float],
        Field(description='The number of times a PC device has hibernated or resumed'),
    ] = None
    restart_count: Annotated[
        Optional[float],
        Field(description='The number of times a PC device has rebooted'),
    ] = None
    safe_mode: Annotated[
        Optional[str],
        Field(
            description='Safe mode is a troubleshooting option for Windows that starts your computer in a limited state'
        ),
    ] = None
    secure_boot: Annotated[
        Optional[str],
        Field(
            description='When Secure Boot is enabled, the core components must have the correct cryptographic signatures'
        ),
    ] = None
    secure_boot_configuration_policy_finger_print: Annotated[
        Optional[str],
        Field(description='Fingerprint of the Custom Secure Boot Configuration Policy'),
    ] = None
    test_signing: Annotated[
        Optional[str],
        Field(
            description='When test signing is allowed, the device does not enforce signature validation during boot'
        ),
    ] = None
    tpm_version: Annotated[
        Optional[str],
        Field(description='The security version number of the Boot Application'),
    ] = None
    virtual_secure_mode: Annotated[
        Optional[str],
        Field(
            description='VSM is a container that protects high value assets from a compromised kernel'
        ),
    ] = None
    windows_pe: Annotated[
        Optional[str],
        Field(
            description='Operating system running with limited services that is used to prepare a computer for Windows'
        ),
    ] = None
    field_odata_type: str


class DeviceLocalCredential(Entity):
    account_name: Annotated[
        Optional[str],
        Field(
            description='The name of the local admin account for which LAPS is enabled.'
        ),
    ] = None
    account_sid: Annotated[
        Optional[str],
        Field(
            description='The SID of the local admin account for which LAPS is enabled.'
        ),
    ] = None
    backup_date_time: Annotated[
        Optional[datetime],
        Field(
            description='When the local administrator account credential for the device object was backed up to Azure Active Directory.',
        ),
    ] = None
    password_base64: Annotated[
        Optional[str],
        Field(
            description='The password for the local administrator account that is backed up to Azure Active Directory and returned as a Base64 encoded value.'
        ),
    ] = None
    field_odata_type: str


class DeviceManagementPartnerAssignment(BaseModel):
    target: Annotated[
        Optional[Union[DeviceAndAppManagementAssignmentTarget, Dict[str, Any]]],
        Field(
            description='User groups targeting for devices to be enrolled through partner.'
        ),
    ] = None
    field_odata_type: str


class DeviceManagementSettings(BaseModel):
    device_compliance_checkin_threshold_days: Annotated[
        Optional[float],
        Field(
            description='The number of days a device is allowed to go without checking in to remain compliant.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    is_scheduled_action_enabled: Annotated[
        Optional[bool],
        Field(description='Is feature enabled or not for scheduled action for rule.'),
    ] = None
    secure_by_default: Annotated[
        Optional[bool],
        Field(
            description='Device should be noncompliant when there is no compliance policy targeted when this is true'
        ),
    ] = None
    field_odata_type: str


class DeviceOperatingSystemSummary(BaseModel):
    android_corporate_work_profile_count: Annotated[
        Optional[float],
        Field(
            description='The count of Corporate work profile Android devices. Also known as Corporate Owned Personally Enabled (COPE). Valid values -1 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    android_count: Annotated[
        Optional[float],
        Field(
            description='Number of android device count.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    android_dedicated_count: Annotated[
        Optional[float],
        Field(
            description='Number of dedicated Android devices.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    android_device_admin_count: Annotated[
        Optional[float],
        Field(
            description='Number of device admin Android devices.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    android_fully_managed_count: Annotated[
        Optional[float],
        Field(
            description='Number of fully managed Android devices.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    android_work_profile_count: Annotated[
        Optional[float],
        Field(
            description='Number of work profile Android devices.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    config_mgr_device_count: Annotated[
        Optional[float],
        Field(
            description='Number of ConfigMgr managed devices.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    ios_count: Annotated[
        Optional[float],
        Field(
            description='Number of iOS device count.', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    mac_os_count: Annotated[
        Optional[float],
        Field(
            description='Number of Mac OS X device count.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    unknown_count: Annotated[
        Optional[float],
        Field(
            description='Number of unknown device count.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    windows_count: Annotated[
        Optional[float],
        Field(
            description='Number of Windows device count.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    windows_mobile_count: Annotated[
        Optional[float],
        Field(
            description='Number of Windows mobile device count.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class DeviceProtectionOverview(BaseModel):
    clean_device_count: Annotated[
        Optional[float],
        Field(
            description='Indicates number of devices reporting as clean',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    critical_failures_device_count: Annotated[
        Optional[float],
        Field(
            description='Indicates number of devices with critical failures',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    inactive_threat_agent_device_count: Annotated[
        Optional[float],
        Field(
            description='Indicates number of devices with inactive threat agent',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    pending_full_scan_device_count: Annotated[
        Optional[float],
        Field(
            description='Indicates number of devices pending full scan',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    pending_manual_steps_device_count: Annotated[
        Optional[float],
        Field(
            description='Indicates number of devices with pending manual steps',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    pending_offline_scan_device_count: Annotated[
        Optional[float],
        Field(
            description='Indicates number of pending offline scan devices',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    pending_quick_scan_device_count: Annotated[
        Optional[float],
        Field(
            description='Indicates the number of devices that have a pending full scan. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    pending_restart_device_count: Annotated[
        Optional[float],
        Field(
            description='Indicates number of devices pending restart',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    pending_signature_update_device_count: Annotated[
        Optional[float],
        Field(
            description='Indicates number of devices with an old signature',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    total_reported_device_count: Annotated[
        Optional[float],
        Field(description='Total device count.', ge=-2147483648.0, le=2147483647.0),
    ] = None
    unknown_state_threat_agent_device_count: Annotated[
        Optional[float],
        Field(
            description='Indicates number of devices with threat agent state as unknown',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class DeviceRegistrationMembership(BaseModel):
    field_odata_type: str


class Diagnostic(BaseModel):
    message: Optional[str] = None
    url: Optional[str] = None
    field_odata_type: str


class Dictionary(BaseModel):
    field_odata_type: str


class DisableAndDeleteUserApplyAction(AccessReviewApplyAction):
    field_odata_type: str


class DisplayNameLocalization(BaseModel):
    display_name: Annotated[
        Optional[str],
        Field(
            description='If present, the value of this field contains the displayName string that has been set for the language present in the languageTag field.'
        ),
    ] = None
    language_tag: Annotated[
        Optional[str],
        Field(
            description='Provides the language culture-code and friendly name of the language that the displayName field has been provided in.'
        ),
    ] = None
    field_odata_type: str


class DocumentSetContent(BaseModel):
    content_type: Annotated[
        Optional[Union[ContentTypeInfo, Dict[str, Any]]],
        Field(description='Content type information of the file.'),
    ] = None
    file_name: Annotated[
        Optional[str],
        Field(
            description='Name of the file in resource folder that should be added as a default content or a template in the document set.'
        ),
    ] = None
    folder_name: Annotated[
        Optional[str],
        Field(
            description='Folder name in which the file will be placed when a new document set is created in the library.'
        ),
    ] = None
    field_odata_type: str


class DocumentSetVersionItem(BaseModel):
    item_id: Annotated[
        Optional[str], Field(description='The unique identifier for the item.')
    ] = None
    title: Annotated[Optional[str], Field(description='The title of the item.')] = None
    version_id: Annotated[
        Optional[str], Field(description='The version ID of the item.')
    ] = None
    field_odata_type: str


class DomainState(BaseModel):
    last_action_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Timestamp for when the last activity occurred. The value is updated when an operation is scheduled, the asynchronous task starts, and when the operation completes.',
        ),
    ] = None
    operation: Annotated[
        Optional[str],
        Field(
            description='Type of asynchronous operation. The values can be ForceDelete or Verification.'
        ),
    ] = None
    status: Annotated[
        Optional[str],
        Field(
            description="Current status of the operation.  Scheduled - Operation is scheduled but hasn't started.  InProgress - Task is in progress.  Failed - The operation failed."
        ),
    ] = None
    field_odata_type: str


class DriveRecipient(BaseModel):
    alias: Annotated[
        Optional[str],
        Field(
            description='The alias of the domain object, for cases where an email address is unavailable (e.g. security groups).'
        ),
    ] = None
    email: Annotated[
        Optional[str],
        Field(
            description='The email address for the recipient, if the recipient has an associated email address.'
        ),
    ] = None
    object_id: Annotated[
        Optional[str],
        Field(description='The unique identifier for the recipient in the directory.'),
    ] = None
    field_odata_type: str


class EdgeSearchEngineBase(BaseModel):
    field_odata_type: str


class EdgeSearchEngineCustom(EdgeSearchEngineBase):
    edge_search_engine_open_search_xml_url: Annotated[
        Optional[str],
        Field(
            description='Points to a https link containing the OpenSearch xml file that contains, at minimum, the short name and the URL to the search Engine.'
        ),
    ] = None
    field_odata_type: str


class EditAction(BaseModel):
    field_odata_type: str


class EducationAssignmentGradeType(BaseModel):
    field_odata_type: str


class EducationAssignmentRecipient(BaseModel):
    field_odata_type: str


class EducationCourse(BaseModel):
    course_number: Annotated[
        Optional[str], Field(description='Unique identifier for the course.')
    ] = None
    description: Annotated[
        Optional[str], Field(description='Description of the course.')
    ] = None
    display_name: Annotated[Optional[str], Field(description='Name of the course.')] = (
        None
    )
    external_id: Annotated[
        Optional[str], Field(description='ID of the course from the syncing system.')
    ] = None
    subject: Annotated[Optional[str], Field(description='Subject of the course.')] = (
        None
    )
    field_odata_type: str


class EducationOnPremisesInfo(BaseModel):
    immutable_id: Annotated[
        Optional[str],
        Field(description='Unique identifier for the user object in Active Directory.'),
    ] = None
    field_odata_type: str


class EducationSubmissionRecipient(BaseModel):
    field_odata_type: str


class EducationTeacher(BaseModel):
    external_id: Annotated[
        Optional[str], Field(description='ID of the teacher in the source system.')
    ] = None
    teacher_number: Annotated[Optional[str], Field(description='Teacher number.')] = (
        None
    )
    field_odata_type: str


class EducationTerm(BaseModel):
    display_name: Annotated[
        Optional[str], Field(description='Display name of the term.')
    ] = None
    end_date: Annotated[
        Optional[date],
        Field(
            description='End of the term.',
        ),
    ] = None
    external_id: Annotated[
        Optional[str], Field(description='ID of term in the syncing system.')
    ] = None
    start_date: Annotated[
        Optional[date],
        Field(
            description='Start of the term.',
        ),
    ] = None
    field_odata_type: str


class EmailAddress(BaseModel):
    address: Annotated[
        Optional[str], Field(description='The email address of the person or entity.')
    ] = None
    name: Annotated[
        Optional[str], Field(description='The display name of the person or entity.')
    ] = None
    field_odata_type: str


class EmailSettings(BaseModel):
    sender_domain: Annotated[
        Optional[str],
        Field(
            description='Specifies the domain that should be used when sending email notifications. This domain must be verified in order to be used. We recommend that you use a domain that has the appropriate DNS records to facilitate email validation, like SPF, DKIM, DMARC, and MX, because this then complies with the RFC compliance for sending and receiving email. For details, see Learn more about Exchange Online Email Routing.'
        ),
    ] = None
    use_company_branding: Annotated[
        Optional[bool],
        Field(
            description='Specifies if the organizations banner logo should be included in email notifications. The banner logo will replace the Microsoft logo at the top of the email notification. If true the banner logo will be taken from the tenants branding settings. This value can only be set to true if the organizationalBranding bannerLogo property is set.'
        ),
    ] = None
    field_odata_type: str


class EmployeeOrgData(BaseModel):
    cost_center: Annotated[
        Optional[str],
        Field(
            description='The cost center associated with the user. Returned only on $select. Supports $filter.'
        ),
    ] = None
    division: Annotated[
        Optional[str],
        Field(
            description='The name of the division in which the user works. Returned only on $select. Supports $filter.'
        ),
    ] = None
    field_odata_type: str


class EnumeratedDeviceRegistrationMembership(DeviceRegistrationMembership):
    groups: Optional[List[str]] = None
    users: Optional[List[str]] = None
    field_odata_type: str


class EventMessageDetail(BaseModel):
    field_odata_type: str


class ExtensionSchemaProperty(BaseModel):
    name: Annotated[
        Optional[str],
        Field(
            description='The name of the strongly typed property defined as part of a schema extension.'
        ),
    ] = None
    type: Annotated[
        Optional[str],
        Field(
            description='The type of the property that is defined as part of a schema extension.  Allowed values are Binary, Boolean, DateTime, Integer, or String. For more information, see Supported property data types.'
        ),
    ] = None
    field_odata_type: str


class ExternalLink(BaseModel):
    href: Annotated[Optional[str], Field(description='The URL of the link.')] = None
    field_odata_type: str


class FileEncryptionInfo(BaseModel):
    encryption_key: Annotated[
        Optional[str], Field(description='The key used to encrypt the file content.')
    ] = None
    file_digest: Annotated[
        Optional[str],
        Field(
            description='The file digest prior to encryption. ProfileVersion1 requires a non-null FileDigest.'
        ),
    ] = None
    file_digest_algorithm: Annotated[
        Optional[str],
        Field(
            description='The file digest algorithm. ProfileVersion1 currently only supports SHA256 for the FileDigestAlgorithm.'
        ),
    ] = None
    initialization_vector: Annotated[
        Optional[str],
        Field(
            description='The initialization vector (IV) used for the encryption algorithm. Must be 16 bytes.'
        ),
    ] = None
    mac: Annotated[
        Optional[str],
        Field(
            description='The hash of the concatenation of the IV and encrypted file content. Must be 32 bytes.'
        ),
    ] = None
    mac_key: Annotated[
        Optional[str],
        Field(
            description='The key used to compute the message authentication code of the concatenation of the IV and encrypted file content. Must be 32 bytes.'
        ),
    ] = None
    profile_identifier: Annotated[
        Optional[str],
        Field(
            description='The profile identifier. Maps to the strategy used to encrypt the file. Currently, only ProfileVersion1 is supported.'
        ),
    ] = None
    field_odata_type: str


class FileStorageContainerCustomPropertyDictionary(Dictionary):
    field_odata_type: str


class FileStorageContainerCustomPropertyValue(BaseModel):
    is_searchable: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the custom property is searchable. Optional. The default value is false.'
        ),
    ] = None
    value: Annotated[
        Optional[str], Field(description='Value of the custom property. Required.')
    ] = None
    field_odata_type: str


class FileStorageContainerSettings(BaseModel):
    is_item_versioning_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether versioning is enabled for items in the container. Optional. Read-write.'
        ),
    ] = None
    is_ocr_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether Optical Character Recognition (OCR) is enabled for the container. The default value is false. When set to true, OCR extraction is performed for new and updated documents of supported document types, and the extracted fields in the metadata of the document enable end-user search and search-driven solutions. When set to false, existing OCR metadata is not impacted. Optional. Read-write.'
        ),
    ] = None
    item_major_version_limit: Annotated[
        Optional[float],
        Field(
            description='The maximum major versions allowed for items in the container. Optional. Read-write.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class FileStorageContainerViewpoint(BaseModel):
    effective_role: Annotated[
        Optional[str],
        Field(description="The current user's effective role. Read-only."),
    ] = None
    field_odata_type: str


class FileSystemInfo(BaseModel):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The UTC date and time the file was created on a client.',
        ),
    ] = None
    last_accessed_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The UTC date and time the file was last accessed. Available for the recent file list only.',
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The UTC date and time the file was last modified on a client.',
        ),
    ] = None
    field_odata_type: str


class FilterOperand(BaseModel):
    values: Annotated[
        Optional[List[str]], Field(description='Collection of values.')
    ] = None
    field_odata_type: str


class FolderView(BaseModel):
    sort_by: Annotated[
        Optional[str],
        Field(description='The method by which the folder should be sorted.'),
    ] = None
    sort_order: Annotated[
        Optional[str],
        Field(
            description='If true, indicates that items should be sorted in descending order. Otherwise, items should be sorted ascending.'
        ),
    ] = None
    view_type: Annotated[
        Optional[str],
        Field(
            description='The type of view that should be used to represent the folder.'
        ),
    ] = None
    field_odata_type: str


class FreeBusyError(BaseModel):
    message: Annotated[Optional[str], Field(description='Describes the error.')] = None
    response_code: Annotated[
        Optional[str],
        Field(
            description='The response code from querying for the availability of the user, distribution list, or resource.'
        ),
    ] = None
    field_odata_type: str


class GenericError(BaseModel):
    code: Annotated[Optional[str], Field(description='The error code.')] = None
    message: Annotated[Optional[str], Field(description='The error message.')] = None
    field_odata_type: str


class GeolocationColumn(BaseModel):
    field_odata_type: str


class GroupAssignmentTarget(DeviceAndAppManagementAssignmentTarget):
    group_id: Annotated[
        Optional[str],
        Field(description='The group Id that is the target of the assignment.'),
    ] = None
    field_odata_type: str


class GroupFilter(BaseModel):
    included_groups: Optional[List[str]] = None
    field_odata_type: str


class GroupPeerOutlierRecommendationInsightSettings(
    AccessReviewRecommendationInsightSetting
):
    field_odata_type: str


class Hashes(BaseModel):
    crc32_hash: Annotated[
        Optional[str],
        Field(
            description='The CRC32 value of the file in little endian (if available). Read-only.'
        ),
    ] = None
    quick_xor_hash: Annotated[
        Optional[str],
        Field(
            description='A proprietary hash of the file that can be used to determine if the contents of the file have changed (if available). Read-only.'
        ),
    ] = None
    sha1_hash: Annotated[
        Optional[str],
        Field(
            description='SHA1 hash for the contents of the file (if available). Read-only.'
        ),
    ] = None
    sha256_hash: Annotated[
        Optional[str],
        Field(
            description='SHA256 hash for the contents of the file (if available). Read-only.'
        ),
    ] = None
    field_odata_type: str


class HostSecurityState(BaseModel):
    fqdn: Annotated[
        Optional[str],
        Field(
            description='Host FQDN (Fully Qualified Domain Name) (for example, machine.company.com).'
        ),
    ] = None
    is_azure_ad_joined: Optional[bool] = None
    is_azure_ad_registered: Optional[bool] = None
    is_hybrid_azure_domain_joined: Annotated[
        Optional[bool],
        Field(
            description='True if the host is domain joined to an on-premises Active Directory domain.'
        ),
    ] = None
    net_bios_name: Annotated[
        Optional[str],
        Field(description='The local host name, without the DNS domain name.'),
    ] = None
    os: Annotated[
        Optional[str],
        Field(
            description='Host Operating System. (For example, Windows 10, macOS, RHEL, etc.).'
        ),
    ] = None
    private_ip_address: Annotated[
        Optional[str],
        Field(
            description='Private (not routable) IPv4 or IPv6 address (see RFC 1918) at the time of the alert.'
        ),
    ] = None
    public_ip_address: Annotated[
        Optional[str],
        Field(
            description='Publicly routable IPv4 or IPv6 address (see RFC 1918) at time of the alert.'
        ),
    ] = None
    risk_score: Annotated[
        Optional[str],
        Field(
            description='Provider-generated/calculated risk score of the host.  Recommended value range of 0-1, which equates to a percentage.'
        ),
    ] = None
    field_odata_type: str


class HttpRequestEndpoint(CustomExtensionEndpointConfiguration):
    target_url: Annotated[
        Optional[str],
        Field(description='The HTTP endpoint that a custom extension calls.'),
    ] = None
    field_odata_type: str


class HyperlinkOrPictureColumn(BaseModel):
    is_picture: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether the display format used for URL columns is an image or a hyperlink.'
        ),
    ] = None
    field_odata_type: str


class Identity(BaseModel):
    display_name: Annotated[
        Optional[str],
        Field(
            description="The display name of the identity.For drive items, the display name might not always be available or up to date. For example, if a user changes their display name the API might show the new value in a future response, but the items associated with the user don't show up as changed when using delta."
        ),
    ] = None
    id: Annotated[
        Optional[str],
        Field(
            description="Unique identifier for the identity or actor. For example, in the access reviews decisions API, this property might record the id of the principal, that is, the group, user, or application that's subject to review."
        ),
    ] = None
    field_odata_type: str


class IdentitySet(BaseModel):
    application: Annotated[
        Optional[Union[Identity, Dict[str, Any]]],
        Field(description='Optional. The application associated with this action.'),
    ] = None
    device: Annotated[
        Optional[Union[Identity, Dict[str, Any]]],
        Field(description='Optional. The device associated with this action.'),
    ] = None
    user: Annotated[
        Optional[Union[Identity, Dict[str, Any]]],
        Field(description='Optional. The user associated with this action.'),
    ] = None
    field_odata_type: str


class IdentitySource(BaseModel):
    field_odata_type: str


class IdleSessionSignOut(BaseModel):
    is_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the idle session sign-out policy is enabled.'
        ),
    ] = None
    sign_out_after_in_seconds: Annotated[
        Optional[float],
        Field(
            description='Number of seconds of inactivity after which a user is signed out.'
        ),
    ] = None
    warn_after_in_seconds: Annotated[
        Optional[float],
        Field(
            description="Number of seconds of inactivity after which a user is notified that they'll be signed out."
        ),
    ] = None
    field_odata_type: str


class Image(BaseModel):
    height: Annotated[
        Optional[float],
        Field(
            description='Optional. Height of the image, in pixels. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    width: Annotated[
        Optional[float],
        Field(
            description='Optional. Width of the image, in pixels. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class ImageInfo(BaseModel):
    add_image_query: Annotated[
        Optional[bool],
        Field(
            description='Optional; parameter used to indicate the server is able to render image dynamically in response to parameterization. For example  a high contrast image'
        ),
    ] = None
    alternate_text: Annotated[
        Optional[str],
        Field(description='Optional; alt-text accessible content for the image'),
    ] = None
    alternative_text: Optional[str] = None
    icon_url: Annotated[
        Optional[str],
        Field(
            description='Optional; URI that points to an icon which represents the application used to generate the activity'
        ),
    ] = None
    field_odata_type: str


class ImplicitGrantSettings(BaseModel):
    enable_access_token_issuance: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether this web application can request an access token using the OAuth 2.0 implicit flow.'
        ),
    ] = None
    enable_id_token_issuance: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether this web application can request an ID token using the OAuth 2.0 implicit flow.'
        ),
    ] = None
    field_odata_type: str


class InboundOutboundPolicyConfiguration(BaseModel):
    inbound_allowed: Annotated[
        Optional[bool],
        Field(description='Defines whether external users coming inbound are allowed.'),
    ] = None
    outbound_allowed: Annotated[
        Optional[bool],
        Field(description='Defines whether internal users are allowed to go outbound.'),
    ] = None
    field_odata_type: str


class IncomingCallOptions(CallOptions):
    field_odata_type: str


class IncomingContext(BaseModel):
    observed_participant_id: Annotated[
        Optional[str],
        Field(
            description='The ID of the participant that is under observation. Read-only.'
        ),
    ] = None
    on_behalf_of: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='The identity that the call is happening on behalf of.'),
    ] = None
    source_participant_id: Annotated[
        Optional[str],
        Field(
            description='The ID of the participant that triggered the incoming call. Read-only.'
        ),
    ] = None
    transferor: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='The identity that transferred the call.'),
    ] = None
    field_odata_type: str


class IncompleteData(BaseModel):
    missing_data_before_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The service does not have source data before the specified time.',
        ),
    ] = None
    was_throttled: Annotated[
        Optional[bool],
        Field(description='Some data was not recorded due to excessive activity.'),
    ] = None
    field_odata_type: str


class InformationalUrl(BaseModel):
    logo_url: Annotated[
        Optional[str],
        Field(description="CDN URL to the application's logo, Read-only."),
    ] = None
    marketing_url: Annotated[
        Optional[str],
        Field(
            description="Link to the application's marketing page. For example, https://www.contoso.com/app/marketing"
        ),
    ] = None
    privacy_statement_url: Annotated[
        Optional[str],
        Field(
            description="Link to the application's privacy statement. For example, https://www.contoso.com/app/privacy"
        ),
    ] = None
    support_url: Annotated[
        Optional[str],
        Field(
            description="Link to the application's support page. For example, https://www.contoso.com/app/support"
        ),
    ] = None
    terms_of_service_url: Annotated[
        Optional[str],
        Field(
            description="Link to the application's terms of service statement. For example, https://www.contoso.com/app/termsofservice"
        ),
    ] = None
    field_odata_type: str


class InsightIdentity(BaseModel):
    address: Annotated[
        Optional[str],
        Field(description='The email address of the user who shared the item.'),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(description='The display name of the user who shared the item.'),
    ] = None
    id: Annotated[
        Optional[str], Field(description='The ID of the user who shared the item.')
    ] = None
    field_odata_type: str


class IntegerRange(BaseModel):
    end: Annotated[
        Optional[float],
        Field(description='The inclusive upper bound of the integer range.'),
    ] = None
    start: Annotated[
        Optional[float],
        Field(description='The inclusive lower bound of the integer range.'),
    ] = None
    field_odata_type: str


class InternetMessageHeader(BaseModel):
    name: Annotated[
        Optional[str], Field(description='Represents the key in a key-value pair.')
    ] = None
    value: Annotated[
        Optional[str], Field(description='The value in a key-value pair.')
    ] = None
    field_odata_type: str


class InvestigationSecurityState(BaseModel):
    name: Optional[str] = None
    status: Optional[str] = None
    field_odata_type: str


class InvitationParticipantInfo(BaseModel):
    hidden: Annotated[
        Optional[bool],
        Field(description='Optional. Whether to hide the participant from the roster.'),
    ] = None
    identity: Optional[IdentitySet] = None
    participant_id: Annotated[
        Optional[str], Field(description='Optional. The ID of the target participant.')
    ] = None
    remove_from_default_audio_routing_group: Annotated[
        Optional[bool],
        Field(description='Optional. Whether to remove them from the main mixer.'),
    ] = None
    replaces_call_id: Annotated[
        Optional[str],
        Field(
            description='Optional. The call which the target identity is currently a part of. For peer-to-peer case, the call will be dropped once the participant is added successfully.'
        ),
    ] = None
    field_odata_type: str


class IosDeviceType(BaseModel):
    i_pad: Annotated[
        Optional[bool], Field(description='Whether the app should run on iPads.')
    ] = None
    i_phone_and_i_pod: Annotated[
        Optional[bool],
        Field(description='Whether the app should run on iPhones and iPods.'),
    ] = None
    field_odata_type: str


class IosHomeScreenItem(BaseModel):
    display_name: Annotated[Optional[str], Field(description='Name of the app')] = None
    field_odata_type: str


class IosHomeScreenPage(BaseModel):
    display_name: Annotated[Optional[str], Field(description='Name of the page')] = None
    icons: Annotated[
        Optional[List[IosHomeScreenItem]],
        Field(
            description='A list of apps, folders, and web clips to appear on a page. This collection can contain a maximum of 500 elements.'
        ),
    ] = None
    field_odata_type: str


class IosMinimumOperatingSystem(BaseModel):
    v10_0: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, only Version 10.0 or later is supported. Default value is FALSE. Exactly one of the minimum operating system boolean values will be TRUE.'
        ),
    ] = None
    v11_0: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, only Version 11.0 or later is supported. Default value is FALSE. Exactly one of the minimum operating system boolean values will be TRUE.'
        ),
    ] = None
    v12_0: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, only Version 12.0 or later is supported. Default value is FALSE. Exactly one of the minimum operating system boolean values will be TRUE.'
        ),
    ] = None
    v13_0: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, only Version 13.0 or later is supported. Default value is FALSE. Exactly one of the minimum operating system boolean values will be TRUE.'
        ),
    ] = None
    v14_0: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, only Version 14.0 or later is supported. Default value is FALSE. Exactly one of the minimum operating system boolean values will be TRUE.'
        ),
    ] = None
    v15_0: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, only Version 15.0 or later is supported. Default value is FALSE. Exactly one of the minimum operating system boolean values will be TRUE.'
        ),
    ] = None
    v8_0: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, only Version 8.0 or later is supported. Default value is FALSE. Exactly one of the minimum operating system boolean values will be TRUE.'
        ),
    ] = None
    v9_0: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, only Version 9.0 or later is supported. Default value is FALSE. Exactly one of the minimum operating system boolean values will be TRUE.'
        ),
    ] = None
    field_odata_type: str


class IosNetworkUsageRule(BaseModel):
    cellular_data_blocked: Annotated[
        Optional[bool],
        Field(
            description='If set to true, corresponding managed apps will not be allowed to use cellular data at any time.'
        ),
    ] = None
    cellular_data_block_when_roaming: Annotated[
        Optional[bool],
        Field(
            description='If set to true, corresponding managed apps will not be allowed to use cellular data when roaming.'
        ),
    ] = None
    managed_apps: Annotated[
        Optional[List[AppListItem]],
        Field(
            description='Information about the managed apps that this rule is going to apply to. This collection can contain a maximum of 500 elements.'
        ),
    ] = None
    field_odata_type: str


class IpRange(BaseModel):
    field_odata_type: str


class IPv4CidrRange(IpRange):
    cidr_address: Annotated[
        Optional[str], Field(description='IPv4 address in CIDR notation. Not nullable.')
    ] = None
    field_odata_type: str


class IPv4Range(IpRange):
    lower_address: Annotated[Optional[str], Field(description='Lower address.')] = None
    upper_address: Annotated[Optional[str], Field(description='Upper address.')] = None
    field_odata_type: str


class IPv6CidrRange(IpRange):
    cidr_address: Annotated[
        Optional[str], Field(description='IPv6 address in CIDR notation. Not nullable.')
    ] = None
    field_odata_type: str


class IPv6Range(IpRange):
    lower_address: Annotated[Optional[str], Field(description='Lower address.')] = None
    upper_address: Annotated[Optional[str], Field(description='Upper address.')] = None
    field_odata_type: str


class ItemActionStat(BaseModel):
    action_count: Annotated[
        Optional[float],
        Field(
            description='The number of times the action took place. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    actor_count: Annotated[
        Optional[float],
        Field(
            description='The number of distinct actors that performed the action. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class ItemPreviewInfo(BaseModel):
    get_url: Optional[str] = None
    post_parameters: Optional[str] = None
    post_url: Optional[str] = None
    field_odata_type: str


class JoinMeetingIdSettings(BaseModel):
    is_passcode_required: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether a passcode is required to join a meeting when using joinMeetingId. Optional.'
        ),
    ] = None
    join_meeting_id: Annotated[
        Optional[str],
        Field(
            description='The meeting ID to be used to join a meeting. Optional. Read-only.'
        ),
    ] = None
    passcode: Annotated[
        Optional[str],
        Field(description='The passcode to join a meeting.  Optional. Read-only.'),
    ] = None
    field_odata_type: str


class Json(BaseModel):
    field_odata_type: str


class KeyCredential(BaseModel):
    custom_key_identifier: Annotated[
        Optional[str],
        Field(
            description='A 40-character binary type that can be used to identify the credential. Optional. When not provided in the payload, defaults to the thumbprint of the certificate.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='The friendly name for the key, with a maximum length of 90 characters. Longer values are accepted but shortened. Optional.'
        ),
    ] = None
    end_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time at which the credential expires. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    key: Annotated[
        Optional[str],
        Field(
            description="The certificate's raw data in byte array converted to Base64 string. Returned only on $select for a single object, that is, GET applications/{applicationId}?$select=keyCredentials or GET servicePrincipals/{servicePrincipalId}?$select=keyCredentials; otherwise, it's always null.  From a .cer certificate, you can read the key using the Convert.ToBase64String() method. For more information, see Get the certificate key."
        ),
    ] = None
    key_id: Annotated[
        Optional[UUID],
        Field(
            description='The unique identifier (GUID) for the key.',
        ),
    ] = None
    start_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time at which the credential becomes valid.The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    type: Annotated[
        Optional[str],
        Field(
            description='The type of key credential; for example, Symmetric, AsymmetricX509Cert.'
        ),
    ] = None
    usage: Annotated[
        Optional[str],
        Field(
            description='A string that describes the purpose for which the key can be used; for example, Verify.'
        ),
    ] = None
    field_odata_type: str


class KeyValue(BaseModel):
    key: Annotated[Optional[str], Field(description='Key for the key-value pair.')] = (
        None
    )
    value: Annotated[
        Optional[str], Field(description='Value for the key-value pair.')
    ] = None
    field_odata_type: str


class KeyValuePair(BaseModel):
    name: Annotated[
        Optional[str], Field(description='Name for this key-value pair')
    ] = None
    value: Annotated[
        Optional[str], Field(description='Value for this key-value pair')
    ] = None
    field_odata_type: str


class DisabledPlanModel(RootModel[Optional[UUID]]):
    root: Annotated[
        Optional[UUID],
        Field(
        ),
    ] = None


class LicenseAssignmentState(BaseModel):
    assigned_by_group: Optional[str] = None
    disabled_plans: Optional[List[DisabledPlanModel]] = None
    error: Optional[str] = None
    last_updated_date_time: Annotated[
        Optional[datetime],
        Field(
        ),
    ] = None
    sku_id: Annotated[
        Optional[UUID],
        Field(
        ),
    ] = None
    state: Optional[str] = None
    field_odata_type: str


class LicenseProcessingState(BaseModel):
    state: Optional[str] = None
    field_odata_type: str


class LicenseUnitsDetail(BaseModel):
    enabled: Annotated[
        Optional[float],
        Field(
            description='The number of units that are enabled for the active subscription of the service SKU.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    locked_out: Annotated[
        Optional[float],
        Field(
            description='The number of units that are locked out because the customer canceled their subscription of the service SKU.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    suspended: Annotated[
        Optional[float],
        Field(
            description="The number of units that are suspended because the subscription of the service SKU has been canceled. The units can't be assigned but can still be reactivated before they're deleted.",
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    warning: Annotated[
        Optional[float],
        Field(
            description="The number of units that are in warning status. When the subscription of the service SKU has expired, the customer has a grace period to renew their subscription before it's canceled (moved to a suspended state).",
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class ListInfo(BaseModel):
    content_types_enabled: Annotated[
        Optional[bool],
        Field(
            description='If true, indicates that content types are enabled for this list.'
        ),
    ] = None
    hidden: Annotated[
        Optional[bool],
        Field(
            description="If true, indicates that the list isn't normally visible in the SharePoint user experience."
        ),
    ] = None
    template: Annotated[
        Optional[str],
        Field(
            description='An enumerated value that represents the base list template used in creating the list. Possible values include documentLibrary, genericList, task, survey, announcements, contacts, and more.'
        ),
    ] = None
    field_odata_type: str


class LocalAdminPasswordSettings(BaseModel):
    is_enabled: Optional[bool] = None
    field_odata_type: str


class LocaleInfo(BaseModel):
    display_name: Annotated[
        Optional[str],
        Field(
            description="A name representing the user's locale in natural language, for example, 'English (United States)'."
        ),
    ] = None
    locale: Annotated[
        Optional[str],
        Field(
            description="A locale representation for the user, which includes the user's preferred language and country/region. For example, 'en-us'. The language component follows 2-letter codes as defined in ISO 639-1, and the country component follows 2-letter codes as defined in ISO 3166-1 alpha-2."
        ),
    ] = None
    field_odata_type: str


class LogicAppTriggerEndpointConfiguration(CustomExtensionEndpointConfiguration):
    logic_app_workflow_name: Annotated[
        Optional[str], Field(description='The name of the logic app.')
    ] = None
    resource_group_name: Annotated[
        Optional[str],
        Field(description='The Azure resource group name for the logic app.'),
    ] = None
    subscription_id: Annotated[
        Optional[str],
        Field(description='Identifier of the Azure subscription for the logic app.'),
    ] = None
    url: Annotated[
        Optional[str],
        Field(
            description='The URL to the logic app endpoint that will be triggered. Only required for app-only token scenarios where app is creating a customCalloutExtension without a signed-in user.'
        ),
    ] = None
    field_odata_type: str


class LoginPageTextVisibilitySettings(BaseModel):
    hide_account_reset_credentials: Annotated[
        Optional[bool],
        Field(
            description="Option to hide the self-service password reset (SSPR) hyperlinks such as 'Can't access your account?', 'Forgot my password' and 'Reset it now' on the sign-in form."
        ),
    ] = None
    hide_cannot_access_your_account: Annotated[
        Optional[bool],
        Field(
            description="Option to hide the self-service password reset (SSPR) 'Can't access your account?' hyperlink on the sign-in form."
        ),
    ] = None
    hide_forgot_my_password: Annotated[
        Optional[bool],
        Field(
            description="Option to hide the self-service password reset (SSPR) 'Forgot my password' hyperlink on the sign-in form."
        ),
    ] = None
    hide_privacy_and_cookies: Annotated[
        Optional[bool],
        Field(
            description="Option to hide the 'Privacy & Cookies' hyperlink in the footer."
        ),
    ] = None
    hide_reset_it_now: Annotated[
        Optional[bool],
        Field(
            description="Option to hide the self-service password reset (SSPR) 'reset it now' hyperlink on the sign-in form."
        ),
    ] = None
    hide_terms_of_use: Annotated[
        Optional[bool],
        Field(description="Option to hide the 'Terms of Use' hyperlink in the footer."),
    ] = None
    field_odata_type: str


class LookupColumn(BaseModel):
    allow_multiple_values: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether multiple values can be selected from the source.'
        ),
    ] = None
    allow_unlimited_length: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether values in the column should be able to exceed the standard limit of 255 characters.'
        ),
    ] = None
    column_name: Annotated[
        Optional[str], Field(description='The name of the lookup source column.')
    ] = None
    list_id: Annotated[
        Optional[str],
        Field(description='The unique identifier of the lookup source list.'),
    ] = None
    primary_lookup_column_id: Annotated[
        Optional[str],
        Field(
            description='If specified, this column is a secondary lookup, pulling an additional field from the list item looked up by the primary lookup. Use the list item looked up by the primary as the source for the column named here.'
        ),
    ] = None
    field_odata_type: str


class MacOSIncludedApp(BaseModel):
    bundle_id: Annotated[
        Optional[str],
        Field(
            description="The bundleId of the app. This maps to the CFBundleIdentifier in the app's bundle configuration."
        ),
    ] = None
    bundle_version: Annotated[
        Optional[str],
        Field(
            description="The version of the app. This maps to the CFBundleShortVersion in the app's bundle configuration."
        ),
    ] = None
    field_odata_type: str


class MacOSLobChildApp(BaseModel):
    build_number: Annotated[
        Optional[str], Field(description='The build number of the app.')
    ] = None
    bundle_id: Annotated[
        Optional[str], Field(description='The bundleId of the app.')
    ] = None
    version_number: Annotated[
        Optional[str], Field(description='The version number of the app.')
    ] = None
    field_odata_type: str


class MacOSMinimumOperatingSystem(BaseModel):
    v10_10: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates OS X 10.10 or later is required to install the app. When FALSE, indicates some other OS version is the minimum OS to install the app. Default value is FALSE.'
        ),
    ] = None
    v10_11: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates OS X 10.11 or later is required to install the app. When FALSE, indicates some other OS version is the minimum OS to install the app. Default value is FALSE.'
        ),
    ] = None
    v10_12: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates macOS 10.12 or later is required to install the app. When FALSE, indicates some other OS version is the minimum OS to install the app. Default value is FALSE.'
        ),
    ] = None
    v10_13: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates macOS 10.13 or later is required to install the app. When FALSE, indicates some other OS version is the minimum OS to install the app. Default value is FALSE.'
        ),
    ] = None
    v10_14: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates macOS 10.14 or later is required to install the app. When FALSE, indicates some other OS version is the minimum OS to install the app. Default value is FALSE.'
        ),
    ] = None
    v10_15: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates macOS 10.15 or later is required to install the app. When FALSE, indicates some other OS version is the minimum OS to install the app. Default value is FALSE.'
        ),
    ] = None
    v10_7: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates Mac OS X 10.7 or later is required to install the app. When FALSE, indicates some other OS version is the minimum OS to install the app. Default value is FALSE.'
        ),
    ] = None
    v10_8: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates OS X 10.8 or later is required to install the app. When FALSE, indicates some other OS version is the minimum OS to install the app. Default value is FALSE.'
        ),
    ] = None
    v10_9: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates OS X 10.9 or later is required to install the app. When FALSE, indicates some other OS version is the minimum OS to install the app. Default value is FALSE.'
        ),
    ] = None
    v11_0: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates macOS 11.0 or later is required to install the app. When FALSE, indicates some other OS version is the minimum OS to install the app. Default value is FALSE.'
        ),
    ] = None
    v12_0: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates macOS 12.0 or later is required to install the app. When FALSE, indicates some other OS version is the minimum OS to install the app. Default value is FALSE.'
        ),
    ] = None
    v13_0: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates macOS 13.0 or later is required to install the app. When FALSE, indicates some other OS version is the minimum OS to install the app. Default value is FALSE.'
        ),
    ] = None
    field_odata_type: str


class MailTipsError(BaseModel):
    code: Annotated[Optional[str], Field(description='The error code.')] = None
    message: Annotated[Optional[str], Field(description='The error message.')] = None
    field_odata_type: str


class Malware(BaseModel):
    description: Annotated[
        Optional[str],
        Field(description='Contains the virus details for the malware facet.'),
    ] = None
    field_odata_type: str


class MalwareState(BaseModel):
    category: Annotated[
        Optional[str],
        Field(
            description='Provider-generated malware category (for example, trojan, ransomware, etc.).'
        ),
    ] = None
    family: Annotated[
        Optional[str],
        Field(
            description="Provider-generated malware family (for example, 'wannacry,' 'notpetya,' etc.)."
        ),
    ] = None
    name: Annotated[
        Optional[str],
        Field(
            description='Provider-generated malware variant name (for example, Trojan:Win32/Powessere.H).'
        ),
    ] = None
    severity: Annotated[
        Optional[str],
        Field(description='Provider-determined severity of this malware.'),
    ] = None
    was_running: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the detected file (malware/vulnerability) was running at the time of detection or was detected at rest on the disk.'
        ),
    ] = None
    field_odata_type: str


class ManagedAppDiagnosticStatus(BaseModel):
    mitigation_instruction: Annotated[
        Optional[str],
        Field(description='Instruction on how to mitigate a failed validation'),
    ] = None
    state: Annotated[Optional[str], Field(description='The state of the operation')] = (
        None
    )
    validation_name: Annotated[
        Optional[str], Field(description='The validation friendly name')
    ] = None
    field_odata_type: str


class MediaConfig(BaseModel):
    field_odata_type: str


class MediaInfo(BaseModel):
    resource_id: Annotated[
        Optional[str],
        Field(
            description='Optional. Used to uniquely identity the resource. If passed in, the prompt uri is against this resourceId as a key.'
        ),
    ] = None
    uri: Annotated[
        Optional[str],
        Field(
            description='Path to the prompt that will be played. Currently supports only Wave file (.wav) format, single-channel, 16-bit samples with a 16,000 (16 KHz) sampling rate.'
        ),
    ] = None
    field_odata_type: str


class MeetingInfo(BaseModel):
    field_odata_type: str


class MeetingPolicyUpdatedEventMessageDetail(EventMessageDetail):
    initiator: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Initiator of the event.'),
    ] = None
    meeting_chat_enabled: Annotated[
        Optional[bool],
        Field(description='Represents whether the meeting chat is enabled or not.'),
    ] = None
    meeting_chat_id: Annotated[
        Optional[str], Field(description='Unique identifier of the meeting chat.')
    ] = None
    field_odata_type: str


class MentionAction(BaseModel):
    mentionees: Annotated[
        Optional[List[IdentitySet]],
        Field(description='The identities of the users mentioned in this action.'),
    ] = None
    field_odata_type: str


class MessagePinnedEventMessageDetail(EventMessageDetail):
    event_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when the event occurred.',
        ),
    ] = None
    initiator: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Initiator of the event.'),
    ] = None
    field_odata_type: str


class MessageSecurityState(BaseModel):
    connecting_ip: Optional[str] = None
    delivery_action: Optional[str] = None
    delivery_location: Optional[str] = None
    directionality: Optional[str] = None
    internet_message_id: Optional[str] = None
    message_fingerprint: Optional[str] = None
    message_received_date_time: Annotated[
        Optional[datetime],
        Field(
        ),
    ] = None
    message_subject: Optional[str] = None
    network_message_id: Optional[str] = None
    field_odata_type: str


class MessageUnpinnedEventMessageDetail(EventMessageDetail):
    event_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when the event occurred.',
        ),
    ] = None
    initiator: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Initiator of the event.'),
    ] = None
    field_odata_type: str


class MetaDataKeyStringPair(BaseModel):
    key: Annotated[Optional[str], Field(description='Key of the meta data.')] = None
    value: Annotated[Optional[str], Field(description='Value of the meta data.')] = None
    field_odata_type: str


class MetaDataKeyValuePair(BaseModel):
    key: Annotated[Optional[str], Field(description='Key of the metadata.')] = None
    value: Annotated[
        Optional[Any], Field(description='Value of the metadata. Should be an object.')
    ] = None
    field_odata_type: str


class MimeContent(BaseModel):
    type: Annotated[
        Optional[str], Field(description='Indicates the content mime type.')
    ] = None
    value: Annotated[
        Optional[str],
        Field(description='The byte array that contains the actual content.'),
    ] = None
    field_odata_type: str


class MobileAppAssignmentSettings(BaseModel):
    field_odata_type: str


class MobileAppIdentifier(BaseModel):
    field_odata_type: str


class MobileAppInstallTimeSettings(BaseModel):
    deadline_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The time at which the app should be installed.',
        ),
    ] = None
    start_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The time at which the app should be available for installation.',
        ),
    ] = None
    use_local_time: Annotated[
        Optional[bool],
        Field(
            description='Whether the local device time or UTC time should be used when determining the available and deadline times.'
        ),
    ] = None
    field_odata_type: str


class ModifiedProperty(BaseModel):
    display_name: Annotated[
        Optional[str],
        Field(
            description='Indicates the property name of the target attribute that was changed.'
        ),
    ] = None
    new_value: Annotated[
        Optional[str], Field(description='Indicates the updated value for the propery.')
    ] = None
    old_value: Annotated[
        Optional[str],
        Field(
            description='Indicates the previous value (before the update) for the property.'
        ),
    ] = None
    field_odata_type: str


class MoveAction(BaseModel):
    from_: Annotated[
        Optional[str],
        Field(description='The name of the location the item was moved from.'),
    ] = None
    to: Annotated[
        Optional[str],
        Field(description='The name of the location the item was moved to.'),
    ] = None
    field_odata_type: str


class NoDeviceRegistrationMembership(DeviceRegistrationMembership):
    field_odata_type: str


class NotebookLinks(BaseModel):
    one_note_client_url: Annotated[
        Optional[Union[ExternalLink, Dict[str, Any]]],
        Field(
            description="Opens the notebook in the OneNote native client if it's installed."
        ),
    ] = None
    one_note_web_url: Annotated[
        Optional[Union[ExternalLink, Dict[str, Any]]],
        Field(description='Opens the notebook in OneNote on the web.'),
    ] = None
    field_odata_type: str


class ObjectIdentity(BaseModel):
    issuer: Annotated[
        Optional[str],
        Field(
            description="Specifies the issuer of the identity, for example facebook.com. 512 character limit. For local accounts (where signInType isn't federated), this property is the local default domain name for the tenant, for example contoso.com.  For guests from other Microsoft Entra organizations, this is the domain of the federated organization, for example contoso.com. For more information about filtering behavior for this property, see Filtering on the identities property of a user."
        ),
    ] = None
    issuer_assigned_id: Annotated[
        Optional[str],
        Field(
            description='Specifies the unique identifier assigned to the user by the issuer. 64 character limit. The combination of issuer and issuerAssignedId must be unique within the organization. Represents the sign-in name for the user, when signInType is set to emailAddress or userName (also known as local accounts).When signInType is set to: emailAddress (or a custom string that starts with emailAddress like emailAddress1), issuerAssignedId must be a valid email addressuserName, issuerAssignedId must begin with an alphabetical character or number, and can only contain alphanumeric characters and the following symbols: - or _  For more information about filtering behavior for this property, see Filtering on the identities property of a user.'
        ),
    ] = None
    sign_in_type: Annotated[
        Optional[str],
        Field(
            description='Specifies the user sign-in types in your directory, such as emailAddress, userName, federated, or userPrincipalName. federated represents a unique identifier for a user from an issuer that can be in any format chosen by the issuer. Setting or updating a userPrincipalName identity updates the value of the userPrincipalName property on the user object. The validations performed on the userPrincipalName property on the user object, for example, verified domains and acceptable characters, are performed when setting or updating a userPrincipalName identity. Extra validation is enforced on issuerAssignedId when the sign-in type is set to emailAddress or userName. This property can also be set to any custom string.  For more information about filtering behavior for this property, see Filtering on the identities property of a user.'
        ),
    ] = None
    field_odata_type: str


class OmaSetting(BaseModel):
    description: Annotated[Optional[str], Field(description='Description.')] = None
    display_name: Annotated[Optional[str], Field(description='Display Name.')] = None
    oma_uri: Annotated[Optional[str], Field(description='OMA.')] = None
    field_odata_type: str


class OmaSettingBase64(OmaSetting):
    file_name: Annotated[
        Optional[str],
        Field(description='File name associated with the Value property (.cer'),
    ] = None
    value: Annotated[
        Optional[str], Field(description='Value. (Base64 encoded string)')
    ] = None
    field_odata_type: str


class OmaSettingBoolean(OmaSetting):
    value: Annotated[Optional[bool], Field(description='Value.')] = None
    field_odata_type: str


class OmaSettingDateTime(OmaSetting):
    value: Annotated[
        Optional[datetime],
        Field(
            description='Value.',
        ),
    ] = None
    field_odata_type: str


class OmaSettingInteger(OmaSetting):
    value: Annotated[
        Optional[float], Field(description='Value.', ge=-2147483648.0, le=2147483647.0)
    ] = None
    field_odata_type: str


class OmaSettingString(OmaSetting):
    value: Annotated[Optional[str], Field(description='Value.')] = None
    field_odata_type: str


class OmaSettingStringXml(OmaSetting):
    file_name: Annotated[
        Optional[str],
        Field(description='File name associated with the Value property (.xml).'),
    ] = None
    value: Annotated[
        Optional[str], Field(description='Value. (UTF8 encoded byte array)')
    ] = None
    field_odata_type: str


class OnAttributeCollectionHandler(BaseModel):
    field_odata_type: str


class OnAuthenticationMethodLoadStartHandler(BaseModel):
    field_odata_type: str


class OnenoteOperationError(BaseModel):
    code: Annotated[Optional[str], Field(description='The error code.')] = None
    message: Annotated[Optional[str], Field(description='The error message.')] = None
    field_odata_type: str


class OnenotePagePreviewLinks(BaseModel):
    preview_image_url: Optional[Union[ExternalLink, Dict[str, Any]]] = None
    field_odata_type: str


class OnInteractiveAuthFlowStartHandler(BaseModel):
    field_odata_type: str


class OnPremisesDirectorySynchronizationFeature(BaseModel):
    block_cloud_object_takeover_through_hard_match_enabled: Annotated[
        Optional[bool],
        Field(
            description='Used to block cloud object takeover via source anchor hard match if enabled.'
        ),
    ] = None
    block_soft_match_enabled: Annotated[
        Optional[bool],
        Field(
            description='Use to block soft match for all objects if enabled for the  tenant. Customers are encouraged to enable this feature and keep it enabled until soft matching is required again for their tenancy. This flag should be enabled again after any soft matching has been completed and is no longer needed.'
        ),
    ] = None
    bypass_dir_sync_overrides_enabled: Annotated[
        Optional[bool],
        Field(
            description='When true, persists the values of Mobile and OtherMobile in on-premises AD during sync cycles instead of values of MobilePhone or AlternateMobilePhones in Microsoft Entra ID.'
        ),
    ] = None
    cloud_password_policy_for_password_synced_users_enabled: Annotated[
        Optional[bool],
        Field(
            description='Used to indicate that cloud password policy applies to users whose passwords are synchronized from on-premises.'
        ),
    ] = None
    concurrent_credential_update_enabled: Annotated[
        Optional[bool],
        Field(
            description='Used to enable concurrent user credentials update in OrgId.'
        ),
    ] = None
    concurrent_org_id_provisioning_enabled: Annotated[
        Optional[bool],
        Field(description='Used to enable concurrent user creation in OrgId.'),
    ] = None
    device_writeback_enabled: Annotated[
        Optional[bool],
        Field(description='Used to indicate that device write-back is enabled.'),
    ] = None
    directory_extensions_enabled: Annotated[
        Optional[bool],
        Field(
            description='Used to indicate that directory extensions are being synced from on-premises AD to Microsoft Entra ID.'
        ),
    ] = None
    fope_conflict_resolution_enabled: Annotated[
        Optional[bool],
        Field(
            description='Used to indicate that for a Microsoft Forefront Online Protection for Exchange (FOPE) migrated tenant, the conflicting proxy address should be migrated over.'
        ),
    ] = None
    group_write_back_enabled: Annotated[
        Optional[bool],
        Field(
            description='Used to enable object-level group writeback feature for additional group types.'
        ),
    ] = None
    password_sync_enabled: Annotated[
        Optional[bool],
        Field(
            description='Used to indicate on-premise password synchronization is enabled.'
        ),
    ] = None
    password_writeback_enabled: Annotated[
        Optional[bool],
        Field(
            description="Used to indicate that writeback of password resets from Microsoft Entra ID to on-premises AD is enabled. This property isn't in use and updating it isn't supported."
        ),
    ] = None
    quarantine_upon_proxy_addresses_conflict_enabled: Annotated[
        Optional[bool],
        Field(
            description='Used to indicate that we should quarantine objects with conflicting proxy address.'
        ),
    ] = None
    quarantine_upon_upn_conflict_enabled: Annotated[
        Optional[bool],
        Field(
            description='Used to indicate that we should quarantine objects conflicting with duplicate userPrincipalName.'
        ),
    ] = None
    soft_match_on_upn_enabled: Annotated[
        Optional[bool],
        Field(
            description='Used to indicate that we should soft match objects based on userPrincipalName.'
        ),
    ] = None
    synchronize_upn_for_managed_users_enabled: Annotated[
        Optional[bool],
        Field(
            description='Used to indicate that we should synchronize userPrincipalName objects for managed users with licenses.'
        ),
    ] = None
    unified_group_writeback_enabled: Annotated[
        Optional[bool],
        Field(
            description='Used to indicate that Microsoft 365 Group write-back is enabled.'
        ),
    ] = None
    user_force_password_change_on_logon_enabled: Annotated[
        Optional[bool],
        Field(
            description='Used to indicate that feature to force password change for a user on logon is enabled while synchronizing on-premise credentials.'
        ),
    ] = None
    user_writeback_enabled: Annotated[
        Optional[bool],
        Field(description='Used to indicate that user writeback is enabled.'),
    ] = None
    field_odata_type: str


class OnPremisesExtensionAttributes(BaseModel):
    extension_attribute1: Annotated[
        Optional[str], Field(description='First customizable extension attribute.')
    ] = None
    extension_attribute10: Annotated[
        Optional[str], Field(description='Tenth customizable extension attribute.')
    ] = None
    extension_attribute11: Annotated[
        Optional[str], Field(description='Eleventh customizable extension attribute.')
    ] = None
    extension_attribute12: Annotated[
        Optional[str], Field(description='Twelfth customizable extension attribute.')
    ] = None
    extension_attribute13: Annotated[
        Optional[str], Field(description='Thirteenth customizable extension attribute.')
    ] = None
    extension_attribute14: Annotated[
        Optional[str], Field(description='Fourteenth customizable extension attribute.')
    ] = None
    extension_attribute15: Annotated[
        Optional[str], Field(description='Fifteenth customizable extension attribute.')
    ] = None
    extension_attribute2: Annotated[
        Optional[str], Field(description='Second customizable extension attribute.')
    ] = None
    extension_attribute3: Annotated[
        Optional[str], Field(description='Third customizable extension attribute.')
    ] = None
    extension_attribute4: Annotated[
        Optional[str], Field(description='Fourth customizable extension attribute.')
    ] = None
    extension_attribute5: Annotated[
        Optional[str], Field(description='Fifth customizable extension attribute.')
    ] = None
    extension_attribute6: Annotated[
        Optional[str], Field(description='Sixth customizable extension attribute.')
    ] = None
    extension_attribute7: Annotated[
        Optional[str], Field(description='Seventh customizable extension attribute.')
    ] = None
    extension_attribute8: Annotated[
        Optional[str], Field(description='Eighth customizable extension attribute.')
    ] = None
    extension_attribute9: Annotated[
        Optional[str], Field(description='Ninth customizable extension attribute.')
    ] = None
    field_odata_type: str


class OnPremisesProvisioningError(BaseModel):
    category: Annotated[
        Optional[str],
        Field(
            description='Category of the provisioning error. Note: Currently, there is only one possible value. Possible value: PropertyConflict - indicates a property value is not unique. Other objects contain the same value for the property.'
        ),
    ] = None
    occurred_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time at which the error occurred.',
        ),
    ] = None
    property_causing_error: Annotated[
        Optional[str],
        Field(
            description='Name of the directory property causing the error. Current possible values: UserPrincipalName or ProxyAddress'
        ),
    ] = None
    value: Annotated[
        Optional[str], Field(description='Value of the property causing the error.')
    ] = None
    field_odata_type: str


class OnTokenIssuanceStartHandler(BaseModel):
    field_odata_type: str


class OnTokenIssuanceStartReturnClaim(BaseModel):
    claim_id_in_api_response: Annotated[
        Optional[str],
        Field(
            description='The identifier of the claim returned by an API that is to be add to a token being issued.'
        ),
    ] = None
    field_odata_type: str


class OnUserCreateStartHandler(BaseModel):
    field_odata_type: str


class OperationError(BaseModel):
    code: Annotated[Optional[str], Field(description='Operation error code.')] = None
    message: Annotated[Optional[str], Field(description='Operation error message.')] = (
        None
    )
    field_odata_type: str


class OptionalClaim(BaseModel):
    additional_properties: Annotated[
        Optional[List[str]],
        Field(
            description='Additional properties of the claim. If a property exists in this collection, it modifies the behavior of the optional claim specified in the name property.'
        ),
    ] = None
    essential: Annotated[
        Optional[bool],
        Field(
            description='If the value is true, the claim specified by the client is necessary to ensure a smooth authorization experience for the specific task requested by the end user. The default value is false.'
        ),
    ] = None
    name: Annotated[
        Optional[str], Field(description='The name of the optional claim.')
    ] = None
    source: Annotated[
        Optional[str],
        Field(
            description='The source (directory object) of the claim. There are predefined claims and user-defined claims from extension properties. If the source value is null, the claim is a predefined optional claim. If the source value is user, the value in the name property is the extension property from the user object.'
        ),
    ] = None
    field_odata_type: str


class OptionalClaims(BaseModel):
    access_token: Annotated[
        Optional[List[OptionalClaim]],
        Field(description='The optional claims returned in the JWT access token.'),
    ] = None
    id_token: Annotated[
        Optional[List[OptionalClaim]],
        Field(description='The optional claims returned in the JWT ID token.'),
    ] = None
    saml2_token: Annotated[
        Optional[List[OptionalClaim]],
        Field(description='The optional claims returned in the SAML token.'),
    ] = None
    field_odata_type: str


class OrganizerMeetingInfo(MeetingInfo):
    organizer: Optional[IdentitySet] = None
    field_odata_type: str


class OsVersionCount(BaseModel):
    device_count: Annotated[
        Optional[float],
        Field(
            description='Count of devices with malware for the OS version',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    last_update_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp of the last update for the device count in UTC',
        ),
    ] = None
    os_version: Annotated[Optional[str], Field(description='OS version')] = None
    field_odata_type: str


class OutgoingCallOptions(CallOptions):
    field_odata_type: str


class Package(BaseModel):
    type: Annotated[
        Optional[str],
        Field(
            description='A string indicating the type of package. While oneNote is the only currently defined value, you should expect other package types to be returned and handle them accordingly.'
        ),
    ] = None
    field_odata_type: str


class PageLinks(BaseModel):
    one_note_client_url: Annotated[
        Optional[Union[ExternalLink, Dict[str, Any]]],
        Field(
            description="Opens the page in the OneNote native client if it's installed."
        ),
    ] = None
    one_note_web_url: Annotated[
        Optional[Union[ExternalLink, Dict[str, Any]]],
        Field(description='Opens the page in OneNote on the web.'),
    ] = None
    field_odata_type: str


class ParentalControlSettings(BaseModel):
    countries_blocked_for_minors: Annotated[
        Optional[List[str]],
        Field(
            description='Specifies the two-letter ISO country codes. Access to the application will be blocked for minors from the countries specified in this list.'
        ),
    ] = None
    legal_age_group_rule: Annotated[
        Optional[str],
        Field(
            description='Specifies the legal age group rule that applies to users of the app. Can be set to one of the following values: ValueDescriptionAllowDefault. Enforces the legal minimum. This means parental consent is required for minors in the European Union and Korea.RequireConsentForPrivacyServicesEnforces the user to specify date of birth to comply with COPPA rules. RequireConsentForMinorsRequires parental consent for ages below 18, regardless of country minor rules.RequireConsentForKidsRequires parental consent for ages below 14, regardless of country minor rules.BlockMinorsBlocks minors from using the app.'
        ),
    ] = None
    field_odata_type: str


class ParticipantJoiningResponse(BaseModel):
    field_odata_type: str


class PasswordCredential(BaseModel):
    custom_key_identifier: Annotated[
        Optional[str], Field(description='Do not use.')
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='Friendly name for the password. Optional.')
    ] = None
    end_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time at which the password expires represented using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Optional.',
        ),
    ] = None
    hint: Annotated[
        Optional[str],
        Field(
            description='Contains the first three characters of the password. Read-only.'
        ),
    ] = None
    key_id: Annotated[
        Optional[UUID],
        Field(
            description='The unique identifier for the password.',
        ),
    ] = None
    secret_text: Annotated[
        Optional[str],
        Field(
            description='Read-only; Contains the strong passwords generated by Microsoft Entra ID that are 16-64 characters in length. The generated password value is only returned during the initial POST request to addPassword. There is no way to retrieve this password in the future.'
        ),
    ] = None
    start_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time at which the password becomes valid. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Optional.',
        ),
    ] = None
    field_odata_type: str


class PasswordProfile(BaseModel):
    force_change_password_next_sign_in: Annotated[
        Optional[bool],
        Field(
            description='true if the user must change their password on the next sign-in; otherwise false.'
        ),
    ] = None
    force_change_password_next_sign_in_with_mfa: Annotated[
        Optional[bool],
        Field(
            description='If true, at next sign-in, the user must perform a multifactor authentication (MFA) before being forced to change their password. The behavior is identical to forceChangePasswordNextSignIn except that the user is required to first perform a multifactor authentication before password change. After a password change, this property will be automatically reset to false. If not set, default is false.'
        ),
    ] = None
    password: Annotated[
        Optional[str],
        Field(
            description="The password for the user. This property is required when a user is created. It can be updated, but the user will be required to change the password on the next sign-in. The password must satisfy minimum requirements as specified by the user's passwordPolicies property. By default, a strong password is required."
        ),
    ] = None
    field_odata_type: str


class PasswordResetResponse(BaseModel):
    new_password: Annotated[
        Optional[str], Field(description='The Microsoft Entra ID-generated password.')
    ] = None
    field_odata_type: str


class PendingContentUpdate(BaseModel):
    queued_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time the pending binary operation was queued in UTC time. Read-only.',
        ),
    ] = None
    field_odata_type: str


class PendingOperations(BaseModel):
    pending_content_update: Annotated[
        Optional[Union[PendingContentUpdate, Dict[str, Any]]],
        Field(
            description='A property that indicates that an operation that might update the binary content of a file is pending completion.'
        ),
    ] = None
    field_odata_type: str


class PermissionScope(BaseModel):
    admin_consent_description: Annotated[
        Optional[str],
        Field(
            description='A description of the delegated permissions, intended to be read by an administrator granting the permission on behalf of all users. This text appears in tenant-wide admin consent experiences.'
        ),
    ] = None
    admin_consent_display_name: Annotated[
        Optional[str],
        Field(
            description="The permission's title, intended to be read by an administrator granting the permission on behalf of all users."
        ),
    ] = None
    id: Annotated[
        Optional[UUID],
        Field(
            description='Unique delegated permission identifier inside the collection of delegated permissions defined for a resource application.',
        ),
    ] = None
    is_enabled: Annotated[
        Optional[bool],
        Field(
            description='When you create or update a permission, this property must be set to true (which is the default). To delete a permission, this property must first be set to false.  At that point, in a subsequent call, the permission may be removed.'
        ),
    ] = None
    origin: Optional[str] = None
    type: Annotated[
        Optional[str],
        Field(
            description='The possible values are: User and Admin. Specifies whether this delegated permission should be considered safe for non-admin users to consent to on behalf of themselves, or whether an administrator consent should always be required. While Microsoft Graph defines the default consent requirement for each permission, the tenant administrator may override the behavior in their organization (by allowing, restricting, or limiting user consent to this delegated permission). For more information, see Configure how users consent to applications.'
        ),
    ] = None
    user_consent_description: Annotated[
        Optional[str],
        Field(
            description='A description of the delegated permissions, intended to be read by a user granting the permission on their own behalf. This text appears in consent experiences where the user is consenting only on behalf of themselves.'
        ),
    ] = None
    user_consent_display_name: Annotated[
        Optional[str],
        Field(
            description='A title for the permission, intended to be read by a user granting the permission on their own behalf. This text appears in consent experiences where the user is consenting only on behalf of themselves.'
        ),
    ] = None
    value: Annotated[
        Optional[str],
        Field(
            description="Specifies the value to include in the scp (scope) claim in access tokens. Must not exceed 120 characters in length. Allowed characters are : ! # $ % & ' ( ) * + , - . / : ;  =  ? @ [ ] ^ + _  {  } ~, and characters in the ranges 0-9, A-Z and a-z. Any other character, including the space character, aren't allowed. May not begin with .."
        ),
    ] = None
    field_odata_type: str


class PersonOrGroupColumn(BaseModel):
    allow_multiple_selection: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether multiple values can be selected from the source.'
        ),
    ] = None
    choose_from_type: Annotated[
        Optional[str],
        Field(
            description='Whether to allow selection of people only, or people and groups. Must be one of peopleAndGroups or peopleOnly.'
        ),
    ] = None
    display_as: Annotated[
        Optional[str],
        Field(
            description='How to display the information about the person or group chosen. See below.'
        ),
    ] = None
    field_odata_type: str


class PersonType(BaseModel):
    class_: Annotated[
        Optional[str], Field(description='The type of data source, such as Person.')
    ] = None
    subclass: Annotated[
        Optional[str],
        Field(
            description='The secondary type of data source, such as OrganizationUser.'
        ),
    ] = None
    field_odata_type: str


class PhysicalAddress(BaseModel):
    city: Annotated[Optional[str], Field(description='The city.')] = None
    country_or_region: Annotated[
        Optional[str],
        Field(
            description="The country or region. It's a free-format string value, for example, 'United States'."
        ),
    ] = None
    postal_code: Annotated[Optional[str], Field(description='The postal code.')] = None
    state: Annotated[Optional[str], Field(description='The state.')] = None
    street: Annotated[Optional[str], Field(description='The street.')] = None
    field_odata_type: str


class PhysicalOfficeAddress(BaseModel):
    city: Annotated[Optional[str], Field(description='The city.')] = None
    country_or_region: Annotated[
        Optional[str],
        Field(
            description="The country or region. It's a free-format string value, for example, 'United States'."
        ),
    ] = None
    office_location: Annotated[
        Optional[str],
        Field(
            description='Office location such as building and office number for an organizational contact.'
        ),
    ] = None
    postal_code: Annotated[Optional[str], Field(description='The postal code.')] = None
    state: Annotated[Optional[str], Field(description='The state.')] = None
    street: Annotated[Optional[str], Field(description='The street.')] = None
    field_odata_type: str


class Pkcs12Certificate(ApiAuthenticationConfigurationBase):
    password: Annotated[
        Optional[str],
        Field(
            description="The password for the pfx file. Required. If no password is used, you must still provide a value of ''."
        ),
    ] = None
    pkcs12_value: Annotated[
        Optional[str],
        Field(
            description='Represents the pfx content that is sent. The value should be a base-64 encoded version of the actual certificate content. Required.'
        ),
    ] = None
    field_odata_type: str


class Pkcs12CertificateInformation(BaseModel):
    is_active: Annotated[
        Optional[bool],
        Field(
            description="Represents whether the certificate is the active certificate to be used for calling the API connector. The active certificate is the most recently uploaded certificate that isn't yet expired but whose notBefore time is in the past."
        ),
    ] = None
    not_after: Annotated[
        Optional[float],
        Field(
            description="The certificate's expiry. This value is a NumericDate as defined in RFC 7519 (A JSON numeric value representing the number of seconds from 1970-01-01T00:00:00Z UTC until the specified UTC date/time, ignoring leap seconds.)"
        ),
    ] = None
    not_before: Annotated[
        Optional[float],
        Field(
            description="The certificate's issue time (not before). This value is a NumericDate as defined in RFC 7519 (A JSON numeric value representing the number of seconds from 1970-01-01T00:00:00Z UTC until the specified UTC date/time, ignoring leap seconds.)"
        ),
    ] = None
    thumbprint: Annotated[
        Optional[str], Field(description='The certificate thumbprint.')
    ] = None
    field_odata_type: str


class PlannerAppliedCategories(BaseModel):
    field_odata_type: str


class PlannerAssignment(BaseModel):
    assigned_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(
            description='The identity of the user that performed the assignment of the task, that is, the assignor.'
        ),
    ] = None
    assigned_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The time when the task was assigned. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z',
        ),
    ] = None
    order_hint: Annotated[
        Optional[str],
        Field(
            description='Hint used to order assignees in a task. The format is defined as outlined here.'
        ),
    ] = None
    field_odata_type: str


class PlannerAssignments(BaseModel):
    field_odata_type: str


class PlannerCategoryDescriptions(BaseModel):
    category1: Annotated[
        Optional[str], Field(description='The label associated with Category 1')
    ] = None
    category10: Annotated[
        Optional[str], Field(description='The label associated with Category 10')
    ] = None
    category11: Annotated[
        Optional[str], Field(description='The label associated with Category 11')
    ] = None
    category12: Annotated[
        Optional[str], Field(description='The label associated with Category 12')
    ] = None
    category13: Annotated[
        Optional[str], Field(description='The label associated with Category 13')
    ] = None
    category14: Annotated[
        Optional[str], Field(description='The label associated with Category 14')
    ] = None
    category15: Annotated[
        Optional[str], Field(description='The label associated with Category 15')
    ] = None
    category16: Annotated[
        Optional[str], Field(description='The label associated with Category 16')
    ] = None
    category17: Annotated[
        Optional[str], Field(description='The label associated with Category 17')
    ] = None
    category18: Annotated[
        Optional[str], Field(description='The label associated with Category 18')
    ] = None
    category19: Annotated[
        Optional[str], Field(description='The label associated with Category 19')
    ] = None
    category2: Annotated[
        Optional[str], Field(description='The label associated with Category 2')
    ] = None
    category20: Annotated[
        Optional[str], Field(description='The label associated with Category 20')
    ] = None
    category21: Annotated[
        Optional[str], Field(description='The label associated with Category 21')
    ] = None
    category22: Annotated[
        Optional[str], Field(description='The label associated with Category 22')
    ] = None
    category23: Annotated[
        Optional[str], Field(description='The label associated with Category 23')
    ] = None
    category24: Annotated[
        Optional[str], Field(description='The label associated with Category 24')
    ] = None
    category25: Annotated[
        Optional[str], Field(description='The label associated with Category 25')
    ] = None
    category3: Annotated[
        Optional[str], Field(description='The label associated with Category 3')
    ] = None
    category4: Annotated[
        Optional[str], Field(description='The label associated with Category 4')
    ] = None
    category5: Annotated[
        Optional[str], Field(description='The label associated with Category 5')
    ] = None
    category6: Annotated[
        Optional[str], Field(description='The label associated with Category 6')
    ] = None
    category7: Annotated[
        Optional[str], Field(description='The label associated with Category 7')
    ] = None
    category8: Annotated[
        Optional[str], Field(description='The label associated with Category 8')
    ] = None
    category9: Annotated[
        Optional[str], Field(description='The label associated with Category 9')
    ] = None
    field_odata_type: str


class PlannerChecklistItem(BaseModel):
    is_checked: Annotated[
        Optional[bool],
        Field(description='Value is true if the item is checked and false otherwise.'),
    ] = None
    last_modified_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Read-only. User ID by which this is last modified.'),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Read-only. Date and time at which this is last modified. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z',
        ),
    ] = None
    order_hint: Annotated[
        Optional[str],
        Field(
            description='Used to set the relative order of items in the checklist. The format is defined as outlined here.'
        ),
    ] = None
    title: Annotated[
        Optional[str], Field(description='Title of the checklist item')
    ] = None
    field_odata_type: str


class PlannerChecklistItems(BaseModel):
    field_odata_type: str


class PlannerExternalReference(BaseModel):
    alias: Annotated[
        Optional[str], Field(description='A name alias to describe the reference.')
    ] = None
    last_modified_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Read-only. User ID by which this is last modified.'),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Read-only. Date and time at which this is last modified. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z',
        ),
    ] = None
    preview_priority: Annotated[
        Optional[str],
        Field(
            description='Used to set the relative priority order in which the reference will be shown as a preview on the task.'
        ),
    ] = None
    type: Annotated[
        Optional[str],
        Field(
            description='Used to describe the type of the reference. Types include: PowerPoint, Word, Excel, Other.'
        ),
    ] = None
    field_odata_type: str


class PlannerExternalReferences(BaseModel):
    field_odata_type: str


class PlannerOrderHintsByAssignee(BaseModel):
    field_odata_type: str


class PlannerUserIds(BaseModel):
    field_odata_type: str


class PreAuthorizedApplication(BaseModel):
    app_id: Annotated[
        Optional[str], Field(description='The unique identifier for the application.')
    ] = None
    delegated_permission_ids: Annotated[
        Optional[List[str]],
        Field(
            description='The unique identifier for the oauth2PermissionScopes the application requires.'
        ),
    ] = None
    field_odata_type: str


class PrincipalResourceMembershipsScope(AccessReviewScope):
    principal_scopes: Annotated[
        Optional[List[AccessReviewScope]],
        Field(
            description='Defines the scopes of the principals whose access to resources are reviewed in the access review.'
        ),
    ] = None
    resource_scopes: Annotated[
        Optional[List[AccessReviewScope]],
        Field(
            description='Defines the scopes of the resources for which access is reviewed.'
        ),
    ] = None
    field_odata_type: str


class PrintCertificateSigningRequest(BaseModel):
    content: Annotated[
        Optional[str],
        Field(description='A base64-encoded pkcs10 certificate request. Read-only.'),
    ] = None
    transport_key: Annotated[
        Optional[str],
        Field(
            description='The base64-encoded public portion of an asymmetric key that is generated by the client. Read-only.'
        ),
    ] = None
    field_odata_type: str


class PrintDocumentUploadProperties(BaseModel):
    content_type: Annotated[
        Optional[str], Field(description="The document's content (MIME) type.")
    ] = None
    document_name: Annotated[
        Optional[str], Field(description="The document's name.")
    ] = None
    size: Annotated[
        Optional[float], Field(description="The document's size in bytes.")
    ] = None
    field_odata_type: str


class BottomMargin(RootModel[Optional[float]]):
    root: Annotated[Optional[float], Field(ge=-2147483648.0, le=2147483647.0)] = None


class Dpi(RootModel[Optional[float]]):
    root: Annotated[Optional[float], Field(ge=-2147483648.0, le=2147483647.0)] = None


class LeftMargin(RootModel[Optional[float]]):
    root: Annotated[Optional[float], Field(ge=-2147483648.0, le=2147483647.0)] = None


class PagesPerSheetItem(RootModel[Optional[float]]):
    root: Annotated[Optional[float], Field(ge=-2147483648.0, le=2147483647.0)] = None


class RightMargin(RootModel[Optional[float]]):
    root: Annotated[Optional[float], Field(ge=-2147483648.0, le=2147483647.0)] = None


class TopMargin(RootModel[Optional[float]]):
    root: Annotated[Optional[float], Field(ge=-2147483648.0, le=2147483647.0)] = None


class PrinterShareViewpoint(BaseModel):
    last_used_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when the printer was last used by the signed-in user. The timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    field_odata_type: str


class PrintMargin(BaseModel):
    bottom: Annotated[
        Optional[float],
        Field(
            description='The margin in microns from the bottom edge.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    left: Annotated[
        Optional[float],
        Field(
            description='The margin in microns from the left edge.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    right: Annotated[
        Optional[float],
        Field(
            description='The margin in microns from the right edge.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    top: Annotated[
        Optional[float],
        Field(
            description='The margin in microns from the top edge.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class PrintSettings(BaseModel):
    document_conversion_enabled: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether document conversion is enabled for the tenant. If document conversion is enabled, Universal Print service will automatically convert documents into a format compatible with the printer (xps to pdf) when needed.'
        ),
    ] = None
    field_odata_type: str


class PrivacyProfile(BaseModel):
    contact_email: Annotated[
        Optional[str],
        Field(
            description='A valid smtp email address for the privacy statement contact. Not required.'
        ),
    ] = None
    statement_url: Annotated[
        Optional[str],
        Field(
            description="A valid URL format that begins with http:// or https://. Maximum length is 255 characters. The URL that directs to the company's privacy statement. Not required."
        ),
    ] = None
    field_odata_type: str


class ProfileCardAnnotation(BaseModel):
    display_name: Annotated[
        Optional[str],
        Field(
            description="If present, the value of this field is used by the profile card as the default property label in the experience (for example, 'Cost Center')."
        ),
    ] = None
    localizations: Annotated[
        Optional[List[DisplayNameLocalization]],
        Field(
            description="Each resource in this collection represents the localized value of the attribute name for a given language, used as the default label for that locale. For example, a user with a nb-NO client gets 'Kostnadssenter' as the attribute label, rather than 'Cost Center.'"
        ),
    ] = None
    field_odata_type: str


class Prompt(BaseModel):
    field_odata_type: str


class ProvisionChannelEmailResult(BaseModel):
    email: Annotated[
        Optional[str], Field(description='Represents the provisioned email address.')
    ] = None
    field_odata_type: str


class ProvisionedIdentity(Identity):
    details: Annotated[
        Optional[Union[DetailsInfo, Dict[str, Any]]],
        Field(description='Details of the identity.'),
    ] = None
    identity_type: Annotated[
        Optional[str],
        Field(
            description="Type of identity that has been provisioned, such as 'user' or 'group'. Supports $filter (eq, contains)."
        ),
    ] = None
    field_odata_type: str


class ProvisionedPlan(BaseModel):
    capability_status: Annotated[
        Optional[str],
        Field(
            description='Condition of the capability assignment. The possible values are Enabled, Warning, Suspended, Deleted, LockedOut. See a detailed description of each value.'
        ),
    ] = None
    provisioning_status: Annotated[
        Optional[str],
        Field(
            description="The possible values are:Success - Service is fully provisioned.Disabled - Service is disabled.Error - The service plan isn't provisioned and is in an error state.PendingInput - The service isn't provisioned and is awaiting service confirmation.PendingActivation - The service is provisioned but requires explicit activation by an administrator (for example, Intune_O365 service plan)PendingProvisioning - Microsoft has added a new service to the product SKU and it isn't activated in the tenant."
        ),
    ] = None
    service: Annotated[
        Optional[str],
        Field(description="The name of the service; for example, 'AccessControlS2S'."),
    ] = None
    field_odata_type: str


class ProvisioningServicePrincipal(Identity):
    field_odata_type: str


class ProvisioningSystem(Identity):
    details: Annotated[
        Optional[Union[DetailsInfo, Dict[str, Any]]],
        Field(description='Details of the system.'),
    ] = None
    field_odata_type: str


class ProxiedDomain(BaseModel):
    ip_address_or_fqdn: Annotated[
        Optional[str], Field(description='The IP address or FQDN')
    ] = None
    proxy: Annotated[Optional[str], Field(description='Proxy IP or FQDN')] = None
    field_odata_type: str


class PublicationFacet(BaseModel):
    checked_out_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='The user who checked out the file.'),
    ] = None
    level: Annotated[
        Optional[str],
        Field(
            description='The state of publication for this document. Either published or checkout. Read-only.'
        ),
    ] = None
    version_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier for the version that is visible to the current caller. Read-only.'
        ),
    ] = None
    field_odata_type: str


class PublicClientApplication(BaseModel):
    redirect_uris: Annotated[
        Optional[List[str]],
        Field(
            description="Specifies the URLs where user tokens are sent for sign-in, or the redirect URIs where OAuth 2.0 authorization codes and access tokens are sent. For iOS and macOS apps, specify the value following the syntax msauth.{BUNDLEID}://auth, replacing '{BUNDLEID}'. For example, if the bundle ID is com.microsoft.identitysample.MSALiOS, the URI is msauth.com.microsoft.identitysample.MSALiOS://auth."
        ),
    ] = None
    field_odata_type: str


class PublicErrorDetail(BaseModel):
    code: Annotated[Optional[str], Field(description='The error code.')] = None
    message: Annotated[Optional[str], Field(description='The error message.')] = None
    target: Annotated[Optional[str], Field(description='The target of the error.')] = (
        None
    )
    field_odata_type: str


class PublicInnerError(BaseModel):
    code: Annotated[Optional[str], Field(description='The error code.')] = None
    details: Annotated[
        Optional[List[PublicErrorDetail]],
        Field(description='A collection of error details.'),
    ] = None
    message: Annotated[Optional[str], Field(description='The error message.')] = None
    target: Annotated[Optional[str], Field(description='The target of the error.')] = (
        None
    )
    field_odata_type: str


class ReactionsFacet(BaseModel):
    comment_count: Annotated[
        Optional[float],
        Field(description='Count of comments.', ge=-2147483648.0, le=2147483647.0),
    ] = None
    like_count: Annotated[
        Optional[float],
        Field(description='Count of likes.', ge=-2147483648.0, le=2147483647.0),
    ] = None
    share_count: Annotated[
        Optional[float],
        Field(description='Count of shares.', ge=-2147483648.0, le=2147483647.0),
    ] = None
    field_odata_type: str


class RecentNotebookLinks(BaseModel):
    one_note_client_url: Annotated[
        Optional[Union[ExternalLink, Dict[str, Any]]],
        Field(
            description="Opens the notebook in the OneNote native client if it's installed."
        ),
    ] = None
    one_note_web_url: Annotated[
        Optional[Union[ExternalLink, Dict[str, Any]]],
        Field(description='Opens the notebook in OneNote on the web.'),
    ] = None
    field_odata_type: str


class Recipient(BaseModel):
    email_address: Annotated[
        Optional[Union[EmailAddress, Dict[str, Any]]],
        Field(description="The recipient's email address."),
    ] = None
    field_odata_type: str


class RecycleBinSettings(BaseModel):
    retention_period_override_days: Annotated[
        Optional[float],
        Field(
            description='Recycle bin retention period override in days for deleted content. The default value is 93; the value range is 7 to 180. The setting applies to newly deleted content only. Setting this property to null reverts to its default value. Read-write.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class RedirectUriSettings(BaseModel):
    index: Annotated[Optional[float], Field(ge=-2147483648.0, le=2147483647.0)] = None
    uri: Optional[str] = None
    field_odata_type: str


class ReferencedObject(BaseModel):
    referenced_object_name: Annotated[
        Optional[str],
        Field(
            description='Name of the referenced object. Must match one of the objects in the directory definition.'
        ),
    ] = None
    referenced_property: Annotated[
        Optional[str],
        Field(
            description='Currently not supported. Name of the property in the referenced object, the value for which is used as the reference.'
        ),
    ] = None
    field_odata_type: str


class RemoveAccessApplyAction(AccessReviewApplyAction):
    field_odata_type: str


class RemovedState(BaseModel):
    reason: Annotated[
        Optional[str],
        Field(description='The removal reason for the participant resource.'),
    ] = None
    field_odata_type: str


class RenameAction(BaseModel):
    new_name: Annotated[
        Optional[str], Field(description='The new name of the item.')
    ] = None
    old_name: Annotated[
        Optional[str], Field(description='The previous name of the item.')
    ] = None
    field_odata_type: str


class Report(BaseModel):
    content: Annotated[Optional[str], Field(description='Not yet documented')] = None
    field_odata_type: str


class ResourceAccess(BaseModel):
    id: Annotated[
        Optional[UUID],
        Field(
            description="The unique identifier of an app role or delegated permission exposed by the resource application. For delegated permissions, this should match the id property of one of the delegated permissions in the oauth2PermissionScopes collection of the resource application's service principal. For app roles (application permissions), this should match the id property of an app role in the appRoles collection of the resource application's service principal.",
        ),
    ] = None
    type: Annotated[
        Optional[str],
        Field(
            description='Specifies whether the id property references a delegated permission or an app role (application permission). The possible values are: Scope (for delegated permissions) or Role (for app roles).'
        ),
    ] = None
    field_odata_type: str


class ResourceAction(BaseModel):
    allowed_resource_actions: Annotated[
        Optional[List[str]], Field(description='Allowed Actions')
    ] = None
    not_allowed_resource_actions: Annotated[
        Optional[List[str]], Field(description='Not Allowed Actions.')
    ] = None
    field_odata_type: str


class ResourceData(BaseModel):
    field_odata_type: str


class ResourcePermission(BaseModel):
    type: Optional[str] = None
    value: Optional[str] = None
    field_odata_type: str


class ResourceReference(BaseModel):
    id: Annotated[Optional[str], Field(description="The item's unique identifier.")] = (
        None
    )
    type: Annotated[
        Optional[str],
        Field(
            description="A string value that can be used to classify the item, such as 'microsoft.graph.driveItem'"
        ),
    ] = None
    web_url: Annotated[
        Optional[str], Field(description='A URL leading to the referenced item.')
    ] = None
    field_odata_type: str


class ResourceSpecificPermission(BaseModel):
    description: Annotated[
        Optional[str],
        Field(
            description='Describes the level of access that the resource-specific permission represents.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(description='The display name for the resource-specific permission.'),
    ] = None
    id: Annotated[
        Optional[UUID],
        Field(
            description='The unique identifier for the resource-specific application permission.',
        ),
    ] = None
    is_enabled: Annotated[
        Optional[bool],
        Field(description='Indicates whether the permission is enabled.'),
    ] = None
    value: Annotated[
        Optional[str], Field(description='The value of the permission.')
    ] = None
    field_odata_type: str


class ResourceVisualization(BaseModel):
    container_display_name: Annotated[
        Optional[str],
        Field(
            description='A string describing where the item is stored. For example, the name of a SharePoint site or the user name identifying the owner of the OneDrive storing the item.'
        ),
    ] = None
    container_type: Annotated[
        Optional[str],
        Field(
            description='Can be used for filtering by the type of container in which the file is stored. Such as Site or OneDriveBusiness.'
        ),
    ] = None
    container_web_url: Annotated[
        Optional[str],
        Field(description='A path leading to the folder in which the item is stored.'),
    ] = None
    media_type: Annotated[
        Optional[str],
        Field(
            description="The item's media type. Can be used for filtering for a specific type of file based on supported IANA Media Mime Types. Not all Media Mime Types are supported."
        ),
    ] = None
    preview_image_url: Annotated[
        Optional[str],
        Field(description='A URL leading to the preview image for the item.'),
    ] = None
    preview_text: Annotated[
        Optional[str], Field(description='A preview text for the item.')
    ] = None
    title: Annotated[Optional[str], Field(description="The item's title text.")] = None
    type: Annotated[
        Optional[str],
        Field(
            description="The item's media type. Can be used for filtering for a specific file based on a specific type. See the section Type property values for supported types."
        ),
    ] = None
    field_odata_type: str


class RestoreAction(BaseModel):
    field_odata_type: str


class ResultInfo(BaseModel):
    code: Annotated[
        Optional[float],
        Field(description='The result code.', ge=-2147483648.0, le=2147483647.0),
    ] = None
    message: Annotated[Optional[str], Field(description='The message.')] = None
    subcode: Annotated[
        Optional[float],
        Field(description='The result subcode.', ge=-2147483648.0, le=2147483647.0),
    ] = None
    field_odata_type: str


class ResultTemplate(BaseModel):
    body: Annotated[
        Optional[Any], Field(description='JSON schema of the result template.')
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='Name of the result template.')
    ] = None
    field_odata_type: str


class ResultTemplateDictionary(Dictionary):
    field_odata_type: str


class ResultTemplateOption(BaseModel):
    enable_result_template: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether search display layouts are enabled. If enabled, the user will get the result template to render the search results content in the resultTemplates property of the response. The result template is based on Adaptive Cards. Optional.'
        ),
    ] = None
    field_odata_type: str


class RetentionSetting(BaseModel):
    interval: Annotated[
        Optional[str], Field(description='The frequency of the backup.')
    ] = None
    period: Annotated[
        Optional[timedelta],
        Field(
            description='The period of time to retain the protected data for a single Microsoft 365 service.',
        ),
    ] = None
    field_odata_type: str


class RgbColor(BaseModel):
    b: Annotated[Optional[float], Field(description='Blue value')] = None
    g: Annotated[Optional[float], Field(description='Green value')] = None
    r: Annotated[Optional[float], Field(description='Red value')] = None
    field_odata_type: str


class RolePermission(BaseModel):
    resource_actions: Annotated[
        Optional[List[ResourceAction]],
        Field(
            description='Resource Actions each containing a set of allowed and not allowed permissions.'
        ),
    ] = None
    field_odata_type: str


class Root(BaseModel):
    field_odata_type: str


class RubricQualitySelectedColumnModel(BaseModel):
    column_id: Annotated[
        Optional[str], Field(description='ID of the selected level for this quality.')
    ] = None
    quality_id: Annotated[
        Optional[str], Field(description='ID of the associated quality.')
    ] = None
    field_odata_type: str


class SamlSingleSignOnSettings(BaseModel):
    relay_state: Annotated[
        Optional[str],
        Field(
            description='The relative URI the service provider would redirect to after completion of the single sign-on flow.'
        ),
    ] = None
    field_odata_type: str


class SearchAlteration(BaseModel):
    altered_highlighted_query_string: Annotated[
        Optional[str],
        Field(
            description='Defines the altered highlighted query string with spelling correction. The annotation around the corrected segment is: /ue000, /ue001.'
        ),
    ] = None
    altered_query_string: Annotated[
        Optional[str],
        Field(description='Defines the altered query string with spelling correction.'),
    ] = None
    altered_query_tokens: Annotated[
        Optional[List[AlteredQueryToken]],
        Field(
            description='Represents changed segments related to an original user query.'
        ),
    ] = None
    field_odata_type: str


class SearchAlterationOptions(BaseModel):
    enable_modification: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether spelling modifications are enabled. If enabled, the user gets the search results for the corrected query if there were no results for the original query with typos. The response will also include the spelling modification information in the queryAlterationResponse property. Optional.'
        ),
    ] = None
    enable_suggestion: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether spelling suggestions are enabled. If enabled, the user gets the search results for the original search query and suggestions for spelling correction in the queryAlterationResponse property of the response for the typos in the query. Optional.'
        ),
    ] = None
    field_odata_type: str


class SearchBucket(BaseModel):
    aggregation_filter_token: Annotated[
        Optional[str],
        Field(
            description="A token containing the encoded filter to aggregate search matches by the specific key value. To use the filter, pass the token as part of the aggregationFilter property in a searchRequest object, in the format '{field}:/'{aggregationFilterToken}/''. See an example."
        ),
    ] = None
    count: Annotated[
        Optional[float],
        Field(
            description='The approximate number of search matches that share the same value specified in the key property. Note that this number is not the exact number of matches.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    key: Annotated[
        Optional[str],
        Field(
            description='The discrete value of the field that an aggregation was computed on.'
        ),
    ] = None
    field_odata_type: str


class SearchHit(BaseModel):
    content_source: Annotated[
        Optional[str],
        Field(
            description='The name of the content source that the externalItem is part of.'
        ),
    ] = None
    hit_id: Annotated[
        Optional[str],
        Field(
            description='The internal identifier for the item. The format of the identifier varies based on the entity type. For details, see hitId format.'
        ),
    ] = None
    is_collapsed: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the current result is collapsed when the collapseProperties property in the searchRequest is used.'
        ),
    ] = None
    rank: Annotated[
        Optional[float],
        Field(
            description='The rank or the order of the result.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    result_template_id: Annotated[
        Optional[str],
        Field(
            description='ID of the result template used to render the search result. This ID must map to a display layout in the resultTemplates dictionary that is also included in the searchResponse.'
        ),
    ] = None
    summary: Annotated[
        Optional[str],
        Field(description='A summary of the result, if a summary is available.'),
    ] = None
    resource: Optional[Union[Entity, Dict[str, Any]]] = None
    field_odata_type: str


class SearchQuery(BaseModel):
    query_string: Annotated[
        Optional[str],
        Field(description='The search query containing the search terms. Required.'),
    ] = None
    query_template: Annotated[
        Optional[str],
        Field(
            description='Provides a way to decorate the query string. Supports both KQL and query variables. Optional.'
        ),
    ] = None
    field_odata_type: str


class SearchResult(BaseModel):
    on_click_telemetry_url: Annotated[
        Optional[str],
        Field(
            description='A callback URL that can be used to record telemetry information. The application should issue a GET on this URL if the user interacts with this item to improve the quality of results.'
        ),
    ] = None
    field_odata_type: str


class SectionLinks(BaseModel):
    one_note_client_url: Annotated[
        Optional[Union[ExternalLink, Dict[str, Any]]],
        Field(
            description="Opens the section in the OneNote native client if it's installed."
        ),
    ] = None
    one_note_web_url: Annotated[
        Optional[Union[ExternalLink, Dict[str, Any]]],
        Field(description='Opens the section in OneNote on the web.'),
    ] = None
    field_odata_type: str


class SecureScoreControlStateUpdate(BaseModel):
    assigned_to: Annotated[
        Optional[str],
        Field(description='Assigns the control to the user who will take the action.'),
    ] = None
    comment: Annotated[
        Optional[str], Field(description='Provides optional comment about the control.')
    ] = None
    state: Annotated[
        Optional[str],
        Field(
            description='State of the control, which can be modified via a PATCH command (for example, ignored, thirdParty).'
        ),
    ] = None
    updated_by: Annotated[
        Optional[str], Field(description='ID of the user who updated tenant state.')
    ] = None
    updated_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Time at which the control state was updated.',
        ),
    ] = None
    field_odata_type: str


class SecurityVendorInformation(BaseModel):
    provider: Annotated[
        Optional[str],
        Field(
            description='Specific provider (product/service - not vendor company); for example, WindowsDefenderATP.'
        ),
    ] = None
    provider_version: Annotated[
        Optional[str],
        Field(
            description='Version of the provider or subprovider, if it exists, that generated the alert. Required'
        ),
    ] = None
    sub_provider: Annotated[
        Optional[str],
        Field(
            description='Specific subprovider (under aggregating provider); for example, WindowsDefenderATP.SmartScreen.'
        ),
    ] = None
    vendor: Annotated[
        Optional[str],
        Field(
            description='Name of the alert vendor (for example, Microsoft, Dell, FireEye). Required'
        ),
    ] = None
    field_odata_type: str


class SelfServiceSignUpAuthenticationFlowConfiguration(BaseModel):
    is_enabled: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether self-service sign-up flow is enabled or disabled. The default value is false. This property isn't a key. Required."
        ),
    ] = None
    field_odata_type: str


class SelfSignedCertificate(BaseModel):
    custom_key_identifier: Annotated[
        Optional[str], Field(description='Custom key identifier.')
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The friendly name for the key.')
    ] = None
    end_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time at which the credential expires. The timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on January 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    key: Annotated[
        Optional[str],
        Field(
            description='The value for the key credential. Should be a Base-64 encoded value.'
        ),
    ] = None
    key_id: Annotated[
        Optional[UUID],
        Field(
            description='The unique identifier (GUID) for the key.',
        ),
    ] = None
    start_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time at which the credential becomes valid. The timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on January 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    thumbprint: Annotated[
        Optional[str], Field(description='The thumbprint value for the key.')
    ] = None
    type: Annotated[
        Optional[str],
        Field(description='The type of key credential. AsymmetricX509Cert.'),
    ] = None
    usage: Annotated[
        Optional[str],
        Field(
            description='A string that describes the purpose for which the key can be used. The possible value is Verify.'
        ),
    ] = None
    field_odata_type: str


class ServerProcessedContent(BaseModel):
    html_strings: Annotated[
        Optional[List[MetaDataKeyStringPair]],
        Field(
            description='A key-value map where keys are string identifiers and values are rich text with HTML format. SharePoint servers treat the values as HTML content and run services like safety checks, search index and link fixup on them.'
        ),
    ] = None
    image_sources: Annotated[
        Optional[List[MetaDataKeyStringPair]],
        Field(
            description='A key-value map where keys are string identifiers and values are image sources. SharePoint servers treat the values as image sources and run services like search index and link fixup on them.'
        ),
    ] = None
    links: Annotated[
        Optional[List[MetaDataKeyStringPair]],
        Field(
            description='A key-value map where keys are string identifiers and values are links. SharePoint servers treat the values as links and run services like link fixup on them.'
        ),
    ] = None
    searchable_plain_texts: Annotated[
        Optional[List[MetaDataKeyStringPair]],
        Field(
            description='A key-value map where keys are string identifiers and values are strings that should be search indexed.'
        ),
    ] = None
    field_odata_type: str


class ServiceHostedMediaConfig(MediaConfig):
    pre_fetch_media: Annotated[
        Optional[List[MediaInfo]], Field(description='The list of media to pre-fetch.')
    ] = None
    field_odata_type: str


class ServicePlanInfo(BaseModel):
    applies_to: Annotated[
        Optional[str],
        Field(
            description='The object the service plan can be assigned to. The possible values are:User - service plan can be assigned to individual users.Company - service plan can be assigned to the entire tenant.'
        ),
    ] = None
    provisioning_status: Annotated[
        Optional[str],
        Field(
            description="The provisioning status of the service plan. The possible values are:Success - Service is fully provisioned.Disabled - Service is disabled.Error - The service plan isn't provisioned and is in an error state.PendingInput - The service isn't provisioned and is awaiting service confirmation.PendingActivation - The service is provisioned but requires explicit activation by an administrator (for example, Intune_O365 service plan)PendingProvisioning - Microsoft has added a new service to the product SKU and it isn't activated in the tenant."
        ),
    ] = None
    service_plan_id: Annotated[
        Optional[UUID],
        Field(
            description='The unique identifier of the service plan.',
        ),
    ] = None
    service_plan_name: Annotated[
        Optional[str], Field(description='The name of the service plan.')
    ] = None
    field_odata_type: str


class ServicePrincipalIdentity(Identity):
    app_id: Annotated[
        Optional[str],
        Field(description='The application identifier of the service principal.'),
    ] = None
    field_odata_type: str


class ServicePrincipalLockConfiguration(BaseModel):
    all_properties: Annotated[
        Optional[bool],
        Field(
            description='Enables locking all sensitive properties. The sensitive properties are keyCredentials, passwordCredentials, and tokenEncryptionKeyId.'
        ),
    ] = None
    credentials_with_usage_sign: Annotated[
        Optional[bool],
        Field(
            description='Locks the keyCredentials and passwordCredentials properties for modification where credential usage type is Sign.'
        ),
    ] = None
    credentials_with_usage_verify: Annotated[
        Optional[bool],
        Field(
            description='Locks the keyCredentials and passwordCredentials properties for modification where credential usage type is Verify. This locks OAuth service principals.'
        ),
    ] = None
    is_enabled: Annotated[
        Optional[bool],
        Field(
            description='Enables or disables service principal lock configuration. To allow the sensitive properties to be updated, update this property to false to disable the lock on the service principal.'
        ),
    ] = None
    token_encryption_key_id: Annotated[
        Optional[bool],
        Field(
            description='Locks the tokenEncryptionKeyId property for modification on the service principal.'
        ),
    ] = None
    field_odata_type: str


class ServiceProvisioningError(BaseModel):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time at which the error occurred.',
        ),
    ] = None
    is_resolved: Annotated[
        Optional[bool],
        Field(description='Indicates whether the error has been attended to.'),
    ] = None
    service_instance: Annotated[
        Optional[str],
        Field(
            description="Qualified service instance (for example, 'SharePoint/Dublin') that published the service error information."
        ),
    ] = None
    field_odata_type: str


class ServiceProvisioningXmlError(ServiceProvisioningError):
    error_detail: Annotated[
        Optional[str],
        Field(
            description='Error Information published by the Federated Service as an xml string.'
        ),
    ] = None
    field_odata_type: str


class ServiceUpdateMessageViewpoint(BaseModel):
    is_archived: Annotated[
        Optional[bool],
        Field(description='Indicates whether the user archived the message.'),
    ] = None
    is_favorited: Annotated[
        Optional[bool],
        Field(description='Indicates whether the user marked the message as favorite.'),
    ] = None
    is_read: Annotated[
        Optional[bool],
        Field(description='Indicates whether the user read the message.'),
    ] = None
    field_odata_type: str


class SettingTemplateValue(BaseModel):
    default_value: Annotated[
        Optional[str], Field(description='Default value for the setting.')
    ] = None
    description: Annotated[
        Optional[str], Field(description='Description of the setting.')
    ] = None
    name: Annotated[Optional[str], Field(description='Name of the setting.')] = None
    type: Annotated[Optional[str], Field(description='Type of the setting.')] = None
    field_odata_type: str


class SettingValue(BaseModel):
    name: Annotated[
        Optional[str],
        Field(
            description='Name of the setting (as defined by the groupSettingTemplate).'
        ),
    ] = None
    value: Annotated[Optional[str], Field(description='Value of the setting.')] = None
    field_odata_type: str


class ShareAction(BaseModel):
    recipients: Annotated[
        Optional[List[IdentitySet]],
        Field(description='The identities the item was shared with in this action.'),
    ] = None
    field_odata_type: str


class Shared(BaseModel):
    owner: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='The identity of the owner of the shared item. Read-only.'),
    ] = None
    scope: Annotated[
        Optional[str],
        Field(
            description='Indicates the scope of how the item is shared. The possible values are: anonymous, organization, or users. Read-only.'
        ),
    ] = None
    shared_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='The identity of the user who shared the item. Read-only.'),
    ] = None
    shared_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The UTC date and time when the item was shared. Read-only.',
        ),
    ] = None
    field_odata_type: str


class SharePointIdentity(Identity):
    login_name: Annotated[
        Optional[str], Field(description='The sign in name of the SharePoint identity.')
    ] = None
    field_odata_type: str


class SharePointIdentitySet(IdentitySet):
    group: Annotated[
        Optional[Union[Identity, Dict[str, Any]]],
        Field(description='The group associated with this action. Optional.'),
    ] = None
    site_group: Annotated[
        Optional[Union[SharePointIdentity, Dict[str, Any]]],
        Field(
            description='The SharePoint group associated with this action. Optional.'
        ),
    ] = None
    site_user: Annotated[
        Optional[Union[SharePointIdentity, Dict[str, Any]]],
        Field(description='The SharePoint user associated with this action. Optional.'),
    ] = None
    field_odata_type: str


class SharepointIds(BaseModel):
    list_id: Annotated[
        Optional[str],
        Field(
            description="The unique identifier (guid) for the item's list in SharePoint."
        ),
    ] = None
    list_item_id: Annotated[
        Optional[str],
        Field(
            description='An integer identifier for the item within the containing list.'
        ),
    ] = None
    list_item_unique_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier (guid) for the item within OneDrive for Business or a SharePoint site.'
        ),
    ] = None
    site_id: Annotated[
        Optional[str],
        Field(
            description="The unique identifier (guid) for the item's site collection (SPSite)."
        ),
    ] = None
    site_url: Annotated[
        Optional[str],
        Field(description='The SharePoint URL for the site that contains the item.'),
    ] = None
    tenant_id: Annotated[
        Optional[str],
        Field(description='The unique identifier (guid) for the tenancy.'),
    ] = None
    web_id: Annotated[
        Optional[str],
        Field(description="The unique identifier (guid) for the item's site (SPWeb)."),
    ] = None
    field_odata_type: str


class SharingDetail(BaseModel):
    shared_by: Annotated[
        Optional[Union[InsightIdentity, Dict[str, Any]]],
        Field(description='The user who shared the document.'),
    ] = None
    shared_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time the file was last shared. The timestamp represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.',
        ),
    ] = None
    sharing_reference: Annotated[
        Optional[Union[ResourceReference, Dict[str, Any]]],
        Field(
            description='Reference properties of the document, such as the URL and type of the document. Read-only'
        ),
    ] = None
    sharing_subject: Annotated[
        Optional[str],
        Field(description='The subject with which the document was shared.'),
    ] = None
    sharing_type: Annotated[
        Optional[str],
        Field(
            description='Determines the way the document was shared. Can be by a 1Link1, 1Attachment1, 1Group1, 1Site1.'
        ),
    ] = None
    field_odata_type: str


class SharingInvitation(BaseModel):
    email: Annotated[
        Optional[str],
        Field(
            description='The email address provided for the recipient of the sharing invitation. Read-only.'
        ),
    ] = None
    invited_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(
            description='Provides information about who sent the invitation that created this permission, if that information is available. Read-only.'
        ),
    ] = None
    redeemed_by: Optional[str] = None
    sign_in_required: Annotated[
        Optional[bool],
        Field(
            description='If true the recipient of the invitation needs to sign in in order to access the shared item. Read-only.'
        ),
    ] = None
    field_odata_type: str


class SharingLink(BaseModel):
    application: Annotated[
        Optional[Union[Identity, Dict[str, Any]]],
        Field(description='The app the link is associated with.'),
    ] = None
    prevents_download: Annotated[
        Optional[bool],
        Field(
            description='If true then the user can only use this link to view the item on the web, and cannot use it to download the contents of the item. Only for OneDrive for Business and SharePoint.'
        ),
    ] = None
    scope: Annotated[
        Optional[str],
        Field(
            description='The scope of the link represented by this permission. Value anonymous indicates the link is usable by anyone, organization indicates the link is only usable for users signed into the same tenant.'
        ),
    ] = None
    type: Annotated[
        Optional[str], Field(description='The type of the link created.')
    ] = None
    web_html: Annotated[
        Optional[str],
        Field(
            description='For embed links, this property contains the HTML code for an <iframe> element that will embed the item in a webpage.'
        ),
    ] = None
    web_url: Annotated[
        Optional[str],
        Field(
            description='A URL that opens the item in the browser on the OneDrive website.'
        ),
    ] = None
    field_odata_type: str


class SignInActivity(BaseModel):
    last_non_interactive_sign_in_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The last non-interactive sign-in date for a specific user. You can use this field to calculate the last time a client attempted (either successfully or unsuccessfully) to sign in to the directory on behalf of a user. Because some users may use clients to access tenant resources rather than signing into your tenant directly, you can use the non-interactive sign-in date to along with lastSignInDateTime to identify inactive users. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Microsoft Entra ID maintains non-interactive sign-ins going back to May 2020. For more information about using the value of this property, see Manage inactive user accounts in Microsoft Entra ID.',
        ),
    ] = None
    last_non_interactive_sign_in_request_id: Annotated[
        Optional[str],
        Field(
            description='Request identifier of the last non-interactive sign-in performed by this user.'
        ),
    ] = None
    last_sign_in_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The last interactive sign-in date and time for a specific user. You can use this field to calculate the last time a user attempted (either successfully or unsuccessfully) to sign in to the directory with an interactive authentication method. This field can be used to build reports, such as inactive users. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Microsoft Entra ID maintains interactive sign-ins going back to April 2020. For more information about using the value of this property, see Manage inactive user accounts in Microsoft Entra ID.',
        ),
    ] = None
    last_sign_in_request_id: Annotated[
        Optional[str],
        Field(
            description='Request identifier of the last interactive sign-in performed by this user.'
        ),
    ] = None
    last_successful_sign_in_date_time: Annotated[
        Optional[datetime],
        Field(
            description="The date and time of the user's most recent successful sign-in activity. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.",
        ),
    ] = None
    last_successful_sign_in_request_id: Annotated[
        Optional[str],
        Field(description='The request ID of the last successful sign-in.'),
    ] = None
    field_odata_type: str


class SigningCertificateUpdateStatus(BaseModel):
    certificate_update_result: Annotated[
        Optional[str],
        Field(
            description='Status of the last certificate update. Read-only. For a list of statuses, see certificateUpdateResult status.'
        ),
    ] = None
    last_run_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time in ISO 8601 format and in UTC time when the certificate was last updated. Read-only.',
        ),
    ] = None
    field_odata_type: str


class SignInStatus(BaseModel):
    additional_details: Annotated[
        Optional[str],
        Field(description='Provides additional details on the sign-in activity'),
    ] = None
    error_code: Annotated[
        Optional[float],
        Field(
            description="Provides the 5-6 digit error code that's generated during a sign-in failure. Check out the list of error codes and messages.",
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    failure_reason: Annotated[
        Optional[str],
        Field(
            description='Provides the error message or the reason for failure for the corresponding sign-in activity. Check out the list of error codes and messages.'
        ),
    ] = None
    field_odata_type: str


class SimulationEvent(BaseModel):
    count: Annotated[
        Optional[float],
        Field(
            description='Count of the simulation event occurrence in an attack simulation and training campaign.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    event_name: Annotated[
        Optional[str],
        Field(
            description='Name of the simulation event in an attack simulation and training campaign.'
        ),
    ] = None
    field_odata_type: str


class SizeRange(BaseModel):
    maximum_size: Annotated[
        Optional[float],
        Field(
            description='The maximum size (in kilobytes) that an incoming message must have in order for a condition or exception to apply.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    minimum_size: Annotated[
        Optional[float],
        Field(
            description='The minimum size (in kilobytes) that an incoming message must have in order for a condition or exception to apply.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class SortProperty(BaseModel):
    is_descending: Annotated[
        Optional[bool],
        Field(
            description='True if the sort order is descending. Default is false, with the sort order as ascending. Optional.'
        ),
    ] = None
    name: Annotated[
        Optional[str],
        Field(description='The name of the property to sort on. Required.'),
    ] = None
    field_odata_type: str


class SpaApplication(BaseModel):
    redirect_uris: Annotated[
        Optional[List[str]],
        Field(
            description='Specifies the URLs where user tokens are sent for sign-in, or the redirect URIs where OAuth 2.0 authorization codes and access tokens are sent.'
        ),
    ] = None
    field_odata_type: str


class SpecialFolder(BaseModel):
    name: Annotated[
        Optional[str],
        Field(
            description='The unique identifier for this item in the /drive/special collection'
        ),
    ] = None
    field_odata_type: str


class StoragePlanInformation(BaseModel):
    upgrade_available: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether there are higher storage quota plans available. Read-only.'
        ),
    ] = None
    field_odata_type: str


class StringKeyLongValuePair(BaseModel):
    key: Annotated[
        Optional[str],
        Field(
            description='The mapping of the user type from the source system to the target system. For example:User to User - For Microsoft Entra ID to Microsoft Entra ID synchronization worker to user - For Workday to Microsoft Entra synchronization.'
        ),
    ] = None
    value: Annotated[
        Optional[float], Field(description='Total number of synchronized objects.')
    ] = None
    field_odata_type: str


class StringKeyObjectValuePair(BaseModel):
    key: Annotated[Optional[str], Field(description='Key.')] = None
    field_odata_type: str


class StringKeyStringValuePair(BaseModel):
    key: Annotated[Optional[str], Field(description='Key.')] = None
    value: Annotated[Optional[str], Field(description='Value.')] = None
    field_odata_type: str


class SubjectRightsRequestDetail(BaseModel):
    excluded_item_count: Annotated[
        Optional[float],
        Field(description='Count of items that are excluded from the request.'),
    ] = None
    insight_counts: Annotated[
        Optional[List[KeyValuePair]], Field(description='Count of items per insight.')
    ] = None
    item_count: Annotated[
        Optional[float], Field(description='Count of items found.')
    ] = None
    item_need_review: Annotated[
        Optional[float], Field(description='Count of item that need review.')
    ] = None
    product_item_counts: Annotated[
        Optional[List[KeyValuePair]],
        Field(
            description='Count of items per product, such as Exchange, SharePoint, OneDrive, and Teams.'
        ),
    ] = None
    signed_off_item_count: Annotated[
        Optional[float],
        Field(description='Count of items signed off by the administrator.'),
    ] = None
    total_item_size: Annotated[
        Optional[float], Field(description='Total item size in bytes.')
    ] = None
    field_odata_type: str


class SubjectRightsRequestMailboxLocation(BaseModel):
    field_odata_type: str


class SubjectRightsRequestSiteLocation(BaseModel):
    field_odata_type: str


class SubjectSet(BaseModel):
    field_odata_type: str


class SynchronizationError(BaseModel):
    code: Annotated[
        Optional[str],
        Field(
            description='The error code. For example, AzureDirectoryB2BManagementPolicyCheckFailure.'
        ),
    ] = None
    message: Annotated[
        Optional[str],
        Field(
            description='The error message. For example, Policy permitting auto-redemption of invitations not configured.'
        ),
    ] = None
    tenant_actionable: Annotated[
        Optional[bool],
        Field(
            description='The action to take to resolve the error. For example, false.'
        ),
    ] = None
    field_odata_type: str


class SynchronizationProgress(BaseModel):
    completed_units: Annotated[
        Optional[float],
        Field(
            description='The numerator of a progress ratio; the number of units of changes already processed.'
        ),
    ] = None
    progress_observation_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The time of a progress observation as an offset in minutes from UTC.',
        ),
    ] = None
    total_units: Annotated[
        Optional[float],
        Field(
            description='The denominator of a progress ratio; a number of units of changes to be processed to accomplish synchronization.'
        ),
    ] = None
    units: Annotated[
        Optional[str], Field(description='An optional description of the units.')
    ] = None
    field_odata_type: str


class SystemFacet(BaseModel):
    field_odata_type: str


class TabUpdatedEventMessageDetail(EventMessageDetail):
    initiator: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Initiator of the event.'),
    ] = None
    tab_id: Annotated[
        Optional[str], Field(description='Unique identifier of the tab.')
    ] = None
    field_odata_type: str


class TargetApplicationOwners(SubjectSet):
    field_odata_type: str


class TargetManager(SubjectSet):
    manager_level: Annotated[
        Optional[float],
        Field(
            description='Manager level, between 1 and 4. The direct manager is 1.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class TargetUserSponsors(SubjectSet):
    field_odata_type: str


class TeamArchivedEventMessageDetail(EventMessageDetail):
    initiator: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Initiator of the event.'),
    ] = None
    team_id: Annotated[
        Optional[str], Field(description='Unique identifier of the team.')
    ] = None
    field_odata_type: str


class TeamClassSettings(BaseModel):
    notify_guardians_about_assignments: Annotated[
        Optional[bool],
        Field(
            description='If set to true, enables sending of weekly assignments digest emails to parents/guardians, provided the tenant admin has enabled the setting globally.'
        ),
    ] = None
    field_odata_type: str


class TeamCreatedEventMessageDetail(EventMessageDetail):
    initiator: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Initiator of the event.'),
    ] = None
    team_description: Annotated[
        Optional[str], Field(description='Description for the team.')
    ] = None
    team_display_name: Annotated[
        Optional[str], Field(description='Display name of the team.')
    ] = None
    team_id: Annotated[
        Optional[str], Field(description='Unique identifier of the team.')
    ] = None
    field_odata_type: str


class TeamDescriptionUpdatedEventMessageDetail(EventMessageDetail):
    initiator: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Initiator of the event.'),
    ] = None
    team_description: Annotated[
        Optional[str], Field(description='The updated description for the team.')
    ] = None
    team_id: Annotated[
        Optional[str], Field(description='Unique identifier of the team.')
    ] = None
    field_odata_type: str


class TeamGuestSettings(BaseModel):
    allow_create_update_channels: Annotated[
        Optional[bool],
        Field(description='If set to true, guests can add and update channels.'),
    ] = None
    allow_delete_channels: Annotated[
        Optional[bool], Field(description='If set to true, guests can delete channels.')
    ] = None
    field_odata_type: str


class TeamJoiningDisabledEventMessageDetail(EventMessageDetail):
    initiator: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Initiator of the event.'),
    ] = None
    team_id: Annotated[
        Optional[str], Field(description='Unique identifier of the team.')
    ] = None
    field_odata_type: str


class TeamJoiningEnabledEventMessageDetail(EventMessageDetail):
    initiator: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Initiator of the event.'),
    ] = None
    team_id: Annotated[
        Optional[str], Field(description='Unique identifier of the team.')
    ] = None
    field_odata_type: str


class TeamMemberSettings(BaseModel):
    allow_add_remove_apps: Annotated[
        Optional[bool],
        Field(description='If set to true, members can add and remove apps.'),
    ] = None
    allow_create_private_channels: Annotated[
        Optional[bool],
        Field(
            description='If set to true, members can add and update private channels.'
        ),
    ] = None
    allow_create_update_channels: Annotated[
        Optional[bool],
        Field(description='If set to true, members can add and update channels.'),
    ] = None
    allow_create_update_remove_connectors: Annotated[
        Optional[bool],
        Field(
            description='If set to true, members can add, update, and remove connectors.'
        ),
    ] = None
    allow_create_update_remove_tabs: Annotated[
        Optional[bool],
        Field(description='If set to true, members can add, update, and remove tabs.'),
    ] = None
    allow_delete_channels: Annotated[
        Optional[bool],
        Field(description='If set to true, members can delete channels.'),
    ] = None
    field_odata_type: str


class TeamMessagingSettings(BaseModel):
    allow_channel_mentions: Annotated[
        Optional[bool],
        Field(description='If set to true, @channel mentions are allowed.'),
    ] = None
    allow_owner_delete_messages: Annotated[
        Optional[bool],
        Field(description='If set to true, owners can delete any message.'),
    ] = None
    allow_team_mentions: Annotated[
        Optional[bool], Field(description='If set to true, @team mentions are allowed.')
    ] = None
    allow_user_delete_messages: Annotated[
        Optional[bool],
        Field(description='If set to true, users can delete their messages.'),
    ] = None
    allow_user_edit_messages: Annotated[
        Optional[bool],
        Field(description='If set to true, users can edit their messages.'),
    ] = None
    field_odata_type: str


class TeamRenamedEventMessageDetail(EventMessageDetail):
    initiator: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Initiator of the event.'),
    ] = None
    team_display_name: Annotated[
        Optional[str], Field(description='The updated name of the team.')
    ] = None
    team_id: Annotated[
        Optional[str], Field(description='Unique identifier of the team.')
    ] = None
    field_odata_type: str


class TeamsAppInstalledEventMessageDetail(EventMessageDetail):
    initiator: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Initiator of the event.'),
    ] = None
    teams_app_display_name: Annotated[
        Optional[str], Field(description='Display name of the teamsApp.')
    ] = None
    teams_app_id: Annotated[
        Optional[str], Field(description='Unique identifier of the teamsApp.')
    ] = None
    field_odata_type: str


class TeamsAppRemovedEventMessageDetail(EventMessageDetail):
    initiator: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Initiator of the event.'),
    ] = None
    teams_app_display_name: Annotated[
        Optional[str], Field(description='Display name of the teamsApp.')
    ] = None
    teams_app_id: Annotated[
        Optional[str], Field(description='Unique identifier of the teamsApp.')
    ] = None
    field_odata_type: str


class TeamsAppUpgradedEventMessageDetail(EventMessageDetail):
    initiator: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Initiator of the event.'),
    ] = None
    teams_app_display_name: Annotated[
        Optional[str], Field(description='Display name of the teamsApp.')
    ] = None
    teams_app_id: Annotated[
        Optional[str], Field(description='Unique identifier of the teamsApp.')
    ] = None
    field_odata_type: str


class TeamsLicensingDetails(Entity):
    has_teams_license: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the user has a valid license to use Microsoft Teams.'
        ),
    ] = None
    field_odata_type: str


class TeamsTabConfiguration(BaseModel):
    content_url: Annotated[
        Optional[str],
        Field(description='Url used for rendering tab contents in Teams. Required.'),
    ] = None
    entity_id: Annotated[
        Optional[str],
        Field(description='Identifier for the entity hosted by the tab provider.'),
    ] = None
    remove_url: Annotated[
        Optional[str],
        Field(
            description='Url called by Teams client when a Tab is removed using the Teams Client.'
        ),
    ] = None
    website_url: Annotated[
        Optional[str],
        Field(description='Url for showing tab contents outside of Teams.'),
    ] = None
    field_odata_type: str


class TeamSummary(BaseModel):
    guests_count: Annotated[
        Optional[float],
        Field(
            description='Count of guests in a team.', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    members_count: Annotated[
        Optional[float],
        Field(
            description='Count of members in a team.', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    owners_count: Annotated[
        Optional[float],
        Field(
            description='Count of owners in a team.', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    field_odata_type: str


class TeamUnarchivedEventMessageDetail(EventMessageDetail):
    initiator: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Initiator of the event.'),
    ] = None
    team_id: Annotated[
        Optional[str], Field(description='Unique identifier of the team.')
    ] = None
    field_odata_type: str


class TeamworkNotificationRecipient(BaseModel):
    field_odata_type: str


class TeamworkTagIdentity(Identity):
    field_odata_type: str


class TenantInformation(BaseModel):
    default_domain_name: Annotated[
        Optional[str],
        Field(description='Primary domain name of a Microsoft Entra tenant.'),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='Display name of a Microsoft Entra tenant.')
    ] = None
    federation_brand_name: Annotated[
        Optional[str],
        Field(
            description='Name shown to users that sign in to a Microsoft Entra tenant.'
        ),
    ] = None
    tenant_id: Annotated[
        Optional[str],
        Field(description='Unique identifier of a Microsoft Entra tenant.'),
    ] = None
    field_odata_type: str


class TermsExpiration(BaseModel):
    frequency: Annotated[
        Optional[timedelta],
        Field(
            description='Represents the frequency at which the terms will expire, after its first expiration as set in startDateTime. The value is represented in ISO 8601 format for durations. For example, PT1M represents a time period of one month.',
        ),
    ] = None
    start_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The DateTime when the agreement is set to expire for all users. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    field_odata_type: str


class TextColumn(BaseModel):
    allow_multiple_lines: Annotated[
        Optional[bool], Field(description='Whether to allow multiple lines of text.')
    ] = None
    append_changes_to_existing_text: Annotated[
        Optional[bool],
        Field(
            description='Whether updates to this column should replace existing text, or append to it.'
        ),
    ] = None
    lines_for_editing: Annotated[
        Optional[float],
        Field(
            description='The size of the text box.', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    max_length: Annotated[
        Optional[float],
        Field(
            description='The maximum number of characters for the value.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    text_type: Annotated[
        Optional[str],
        Field(
            description='The type of text being stored. Must be one of plain or richText'
        ),
    ] = None
    field_odata_type: str


class Thumbnail(BaseModel):
    content: Annotated[
        Optional[str], Field(description='The content stream for the thumbnail.')
    ] = None
    height: Annotated[
        Optional[float],
        Field(
            description='The height of the thumbnail, in pixels.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    source_item_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier of the item that provided the thumbnail. This is only available when a folder thumbnail is requested.'
        ),
    ] = None
    url: Annotated[
        Optional[str], Field(description='The URL used to fetch the thumbnail content.')
    ] = None
    width: Annotated[
        Optional[float],
        Field(
            description='The width of the thumbnail, in pixels.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class ThumbnailColumn(BaseModel):
    field_odata_type: str


class TicketInfo(BaseModel):
    ticket_number: Annotated[Optional[str], Field(description='The ticket number.')] = (
        None
    )
    ticket_system: Annotated[
        Optional[str], Field(description='The description of the ticket system.')
    ] = None
    field_odata_type: str


class TimePeriod(BaseModel):
    end_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date time of the end of the time period.',
        ),
    ] = None
    start_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date time of the start of the time period.',
        ),
    ] = None
    field_odata_type: str


class TimeRange(BaseModel):
    end_time: Annotated[
        Optional[time],
        Field(
            description='End time for the time range.',
        ),
    ] = None
    start_time: Annotated[
        Optional[time],
        Field(
            description='Start time for the time range.',
        ),
    ] = None
    field_odata_type: str


class TimeSlot(BaseModel):
    end: Optional[DateTimeTimeZone] = None
    start: Optional[DateTimeTimeZone] = None
    field_odata_type: str


class TimeZoneBase(BaseModel):
    name: Annotated[
        Optional[str],
        Field(
            description="The name of a time zone. It can be a standard time zone name such as 'Hawaii-Aleutian Standard Time', or 'Customized Time Zone' for a custom time zone."
        ),
    ] = None
    field_odata_type: str


class TimeZoneInformation(BaseModel):
    alias: Annotated[
        Optional[str], Field(description='An identifier for the time zone.')
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(description='A display string that represents the time zone.'),
    ] = None
    field_odata_type: str


class TokenMeetingInfo(MeetingInfo):
    token: Annotated[
        Optional[str], Field(description='The token used to join the call.')
    ] = None
    field_odata_type: str


class TrainingEventsContent(BaseModel):
    assigned_trainings_infos: Annotated[
        Optional[List[AssignedTrainingInfo]],
        Field(
            description='List of assigned trainings and their information in an attack simulation and training campaign.'
        ),
    ] = None
    trainings_assigned_user_count: Annotated[
        Optional[float],
        Field(
            description='Number of users who were assigned trainings in an attack simulation and training campaign.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class UnifiedApprovalStage(BaseModel):
    approval_stage_time_out_in_days: Annotated[
        Optional[float],
        Field(
            description='The number of days that a request can be pending a response before it is automatically denied.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    escalation_approvers: Annotated[
        Optional[List[SubjectSet]],
        Field(
            description="The escalation approvers for this stage when the primary approvers don't respond."
        ),
    ] = None
    escalation_time_in_minutes: Annotated[
        Optional[float],
        Field(
            description='The time a request can be pending a response from a primary approver before it can be escalated to the escalation approvers.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    is_approver_justification_required: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the approver must provide justification for their reponse.'
        ),
    ] = None
    is_escalation_enabled: Annotated[
        Optional[bool], Field(description='Indicates whether escalation if enabled.')
    ] = None
    primary_approvers: Annotated[
        Optional[List[SubjectSet]],
        Field(description='The primary approvers of this stage.'),
    ] = None
    field_odata_type: str


class UnifiedRole(BaseModel):
    role_definition_id: Annotated[
        Optional[str],
        Field(
            description='The unified role definition ID of the directory role. Refer to unifiedRoleDefinition resource.'
        ),
    ] = None
    field_odata_type: str


class UnifiedRolePermission(BaseModel):
    allowed_resource_actions: Annotated[
        Optional[List[str]],
        Field(
            description='Set of tasks that can be performed on a resource. Required.'
        ),
    ] = None
    condition: Annotated[
        Optional[str],
        Field(
            description='Optional constraints that must be met for the permission to be effective. Not supported for custom roles.'
        ),
    ] = None
    excluded_resource_actions: Annotated[
        Optional[List[str]],
        Field(
            description='Set of tasks that may not be performed on a resource. Not yet supported.'
        ),
    ] = None
    field_odata_type: str


class UploadSession(BaseModel):
    expiration_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time in UTC that the upload session will expire. The complete file must be uploaded before this expiration time is reached.',
        ),
    ] = None
    next_expected_ranges: Annotated[
        Optional[List[str]],
        Field(
            description="A collection of byte ranges that the server is missing for the file. These ranges are zero indexed and of the format 'start-end' (for example '0-26' to indicate the first 27 bytes of the file). When uploading files as Outlook attachments, instead of a collection of ranges, this property always indicates a single value '{start}', the location in the file where the next upload should begin."
        ),
    ] = None
    upload_url: Annotated[
        Optional[str],
        Field(
            description='The URL endpoint that accepts PUT requests for byte ranges of the file.'
        ),
    ] = None
    field_odata_type: str


class UriClickSecurityState(BaseModel):
    click_action: Optional[str] = None
    click_date_time: Annotated[
        Optional[datetime],
        Field(
        ),
    ] = None
    id: Optional[str] = None
    source_id: Optional[str] = None
    uri_domain: Optional[str] = None
    verdict: Optional[str] = None
    field_odata_type: str


class UsageDetails(BaseModel):
    last_accessed_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time the resource was last accessed by the user. The timestamp represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.',
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time the resource was last modified by the user. The timestamp represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.',
        ),
    ] = None
    field_odata_type: str


class UserAttributeValuesItem(BaseModel):
    is_default: Annotated[
        Optional[bool],
        Field(description='Determines whether the value is set as the default.'),
    ] = None
    name: Annotated[
        Optional[str],
        Field(
            description='The display name of the property displayed to the user in the user flow.'
        ),
    ] = None
    value: Annotated[
        Optional[str],
        Field(description='The value that is set when this item is selected.'),
    ] = None
    field_odata_type: str


class UserExperienceAnalyticsAutopilotDevicesSummary(BaseModel):
    devices_not_autopilot_registered: Annotated[
        Optional[float],
        Field(
            description='The count of intune devices that are not autopilot registerd. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    devices_without_autopilot_profile_assigned: Annotated[
        Optional[float],
        Field(
            description='The count of intune devices not autopilot profile assigned. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    total_windows10_devices_without_tenant_attached: Annotated[
        Optional[float],
        Field(
            description='The count of windows 10 devices that are Intune and co-managed. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class UserExperienceAnalyticsCloudIdentityDevicesSummary(BaseModel):
    device_without_cloud_identity_count: Annotated[
        Optional[float],
        Field(
            description='The count of devices that are not cloud identity. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class UserExperienceAnalyticsCloudManagementDevicesSummary(BaseModel):
    co_managed_device_count: Annotated[
        Optional[float],
        Field(
            description='Total number of  co-managed devices. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    intune_device_count: Annotated[
        Optional[float],
        Field(
            description='The count of intune devices that are not autopilot registerd. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    tenant_attach_device_count: Annotated[
        Optional[float],
        Field(
            description='Total count of tenant attach devices. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class UserExperienceAnalyticsInsightValue(BaseModel):
    field_odata_type: str


class UserExperienceAnalyticsSettings(BaseModel):
    configuration_manager_data_connector_configured: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates Tenant attach is configured properly and System Center Configuration Manager (SCCM) tenant attached devices will show up in endpoint analytics reporting. When FALSE, indicates Tenant attach is not configured. FALSE by default.'
        ),
    ] = None
    field_odata_type: str


class UserExperienceAnalyticsWindows10DevicesSummary(BaseModel):
    unsupported_o_sversion_device_count: Annotated[
        Optional[float],
        Field(
            description='The count of Windows 10 devices that have unsupported OS versions. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class UserExperienceAnalyticsWorkFromAnywhereDevicesSummary(BaseModel):
    autopilot_devices_summary: Annotated[
        Optional[Union[UserExperienceAnalyticsAutopilotDevicesSummary, Dict[str, Any]]],
        Field(
            description='The user experience analytics work from anywhere Autopilot devices summary. Read-only.'
        ),
    ] = None
    cloud_identity_devices_summary: Annotated[
        Optional[
            Union[UserExperienceAnalyticsCloudIdentityDevicesSummary, Dict[str, Any]]
        ],
        Field(
            description='The user experience analytics work from anywhere Cloud Identity devices summary. Read-only.'
        ),
    ] = None
    cloud_management_devices_summary: Annotated[
        Optional[
            Union[UserExperienceAnalyticsCloudManagementDevicesSummary, Dict[str, Any]]
        ],
        Field(
            description='The user experience analytics work from anywhere Cloud management devices summary. Read-only.'
        ),
    ] = None
    co_managed_devices: Annotated[
        Optional[float],
        Field(
            description='Total number of co-managed devices. Read-only. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    devices_not_autopilot_registered: Annotated[
        Optional[float],
        Field(
            description='The count of intune devices that are not autopilot registerd. Read-only. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    devices_without_autopilot_profile_assigned: Annotated[
        Optional[float],
        Field(
            description='The count of intune devices not autopilot profile assigned. Read-only. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    devices_without_cloud_identity: Annotated[
        Optional[float],
        Field(
            description='The count of devices that are not cloud identity. Read-only. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    intune_devices: Annotated[
        Optional[float],
        Field(
            description='The count of intune devices that are not autopilot registerd. Read-only. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    tenant_attach_devices: Annotated[
        Optional[float],
        Field(
            description='Total count of tenant attach devices. Read-only. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    total_devices: Annotated[
        Optional[float],
        Field(
            description='The total count of devices. Read-only. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    unsupported_o_sversion_devices: Annotated[
        Optional[float],
        Field(
            description='The count of Windows 10 devices that have unsupported OS versions. Read-only. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    windows10_devices: Annotated[
        Optional[float],
        Field(
            description='The count of windows 10 devices. Read-only. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    windows10_devices_summary: Annotated[
        Optional[Union[UserExperienceAnalyticsWindows10DevicesSummary, Dict[str, Any]]],
        Field(
            description='The user experience analytics work from anywhere Windows 10 devices summary. Read-only.'
        ),
    ] = None
    windows10_devices_without_tenant_attach: Annotated[
        Optional[float],
        Field(
            description='The count of windows 10 devices that are Intune and co-managed. Read-only. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class UserIdentity(Identity):
    ip_address: Annotated[
        Optional[str],
        Field(
            description='Indicates the client IP address associated with the user performing the activity (audit log only).'
        ),
    ] = None
    user_principal_name: Annotated[
        Optional[str], Field(description='The userPrincipalName attribute of the user.')
    ] = None
    field_odata_type: str


class UserRegistrationMethodCount(BaseModel):
    authentication_method: Annotated[
        Optional[str], Field(description='Name of the authentication method.')
    ] = None
    user_count: Annotated[
        Optional[float], Field(description='Number of users registered.')
    ] = None
    field_odata_type: str


class VerifiedDomain(BaseModel):
    capabilities: Annotated[
        Optional[str],
        Field(description='For example, Email, OfficeCommunicationsOnline.'),
    ] = None
    is_default: Annotated[
        Optional[bool],
        Field(
            description='true if this is the default domain associated with the tenant; otherwise, false.'
        ),
    ] = None
    is_initial: Annotated[
        Optional[bool],
        Field(
            description='true if this is the initial domain associated with the tenant; otherwise, false.'
        ),
    ] = None
    name: Annotated[
        Optional[str], Field(description='The domain name; for example, contoso.com.')
    ] = None
    type: Annotated[Optional[str], Field(description='For example, Managed.')] = None
    field_odata_type: str


class VerifiedPublisher(BaseModel):
    added_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The timestamp when the verified publisher was first added or most recently updated.',
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description="The verified publisher name from the app publisher's Partner Center account."
        ),
    ] = None
    verified_publisher_id: Annotated[
        Optional[str],
        Field(
            description="The ID of the verified publisher from the app publisher's Partner Center account."
        ),
    ] = None
    field_odata_type: str


class VersionAction(BaseModel):
    new_version: Annotated[
        Optional[str],
        Field(
            description='The name of the new version that was created by this action.'
        ),
    ] = None
    field_odata_type: str


class VirtualEventExternalInformation(BaseModel):
    application_id: Annotated[
        Optional[str],
        Field(
            description='Identifier of the application that hosts the externalEventId. Read-only.'
        ),
    ] = None
    external_event_id: Annotated[
        Optional[str],
        Field(
            description='The identifier for a virtualEventExternalInformation object that associates the virtual event with an event ID in an external application. This association bundles all the information (both supported and not supported in virtualEvent) into one virtual event object. Optional. If set, the maximum supported length is 256 characters.'
        ),
    ] = None
    field_odata_type: str


class VirtualEventExternalRegistrationInformation(BaseModel):
    referrer: Annotated[
        Optional[str],
        Field(
            description='A URL or string that represents the location from which the registrant registered. Optional.'
        ),
    ] = None
    registration_id: Annotated[
        Optional[str],
        Field(
            description='The identifier for a virtualEventExternalRegistrationInformation object. Optional. If set, the maximum supported length is 256 characters.'
        ),
    ] = None
    field_odata_type: str


class VirtualEventRegistrationQuestionAnswer(BaseModel):
    boolean_value: Annotated[
        Optional[bool],
        Field(
            description='Boolean answer of the virtual event registration question. Only appears when answerInputType is boolean.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='Display name of the registration question.')
    ] = None
    multi_choice_values: Annotated[
        Optional[List[str]],
        Field(
            description='Collection of text answer of the virtual event registration question. Only appears when answerInputType is multiChoice.'
        ),
    ] = None
    question_id: Annotated[
        Optional[str],
        Field(description='id of the virtual event registration question.'),
    ] = None
    value: Annotated[
        Optional[str],
        Field(
            description='Text answer of the virtual event registration question. Appears when answerInputType is text, multilineText or singleChoice.'
        ),
    ] = None
    field_odata_type: str


class VirtualEventSettings(BaseModel):
    is_attendee_email_notification_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether virtual event attendees receive email notifications.'
        ),
    ] = None
    field_odata_type: str


class VisualInfo(BaseModel):
    attribution: Annotated[
        Optional[Union[ImageInfo, Dict[str, Any]]],
        Field(
            description='Optional. JSON object used to represent an icon which represents the application used to generate the activity'
        ),
    ] = None
    background_color: Annotated[
        Optional[str],
        Field(
            description='Optional. Background color used to render the activity in the UI - brand color for the application source of the activity. Must be a valid hex color'
        ),
    ] = None
    content: Annotated[
        Optional[Any],
        Field(
            description='Optional. Custom piece of data - JSON object used to provide custom content to render the activity in the Windows Shell UI'
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description="Optional. Longer text description of the user's unique activity (example: document name, first sentence, and/or metadata)"
        ),
    ] = None
    display_text: Annotated[
        Optional[str],
        Field(
            description="Required. Short text description of the user's unique activity (for example, document name in cases where an activity refers to document creation)"
        ),
    ] = None
    field_odata_type: str


class VppLicensingType(BaseModel):
    supports_device_licensing: Annotated[
        Optional[bool],
        Field(description='Whether the program supports the device licensing type.'),
    ] = None
    supports_user_licensing: Annotated[
        Optional[bool],
        Field(description='Whether the program supports the user licensing type.'),
    ] = None
    field_odata_type: str


class VulnerabilityState(BaseModel):
    cve: Annotated[
        Optional[str],
        Field(
            description='Common Vulnerabilities and Exposures (CVE) for the vulnerability.'
        ),
    ] = None
    severity: Annotated[
        Optional[str],
        Field(
            description='Base Common Vulnerability Scoring System (CVSS) severity score for this vulnerability.'
        ),
    ] = None
    was_running: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the detected vulnerability (file) was running at the time of detection or was the file detected at rest on the disk.'
        ),
    ] = None
    field_odata_type: str


class WatermarkProtectionValues(BaseModel):
    is_enabled_for_content_sharing: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether to apply a watermark to any shared content.'
        ),
    ] = None
    is_enabled_for_video: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether to apply a watermark to everyone's video feed."
        ),
    ] = None
    field_odata_type: str


class WebApplication(BaseModel):
    home_page_url: Annotated[
        Optional[str],
        Field(description='Home page or landing page of the application.'),
    ] = None
    implicit_grant_settings: Annotated[
        Optional[Union[ImplicitGrantSettings, Dict[str, Any]]],
        Field(
            description='Specifies whether this web application can request tokens using the OAuth 2.0 implicit flow.'
        ),
    ] = None
    logout_url: Annotated[
        Optional[str],
        Field(
            description="Specifies the URL that is used by Microsoft's authorization service to log out a user using front-channel, back-channel or SAML logout protocols."
        ),
    ] = None
    redirect_uris: Annotated[
        Optional[List[str]],
        Field(
            description='Specifies the URLs where user tokens are sent for sign-in, or the redirect URIs where OAuth 2.0 authorization codes and access tokens are sent.'
        ),
    ] = None
    redirect_uri_settings: Optional[List[RedirectUriSettings]] = None
    field_odata_type: str


class WebPartData(BaseModel):
    data_version: Annotated[
        Optional[str],
        Field(
            description='Data version of the web part. The value is defined by the web part developer. Different dataVersions usually refers to a different property structure.'
        ),
    ] = None
    description: Annotated[
        Optional[str], Field(description='Description of the web part.')
    ] = None
    properties: Annotated[
        Optional[Any], Field(description='Properties bag of the web part.')
    ] = None
    server_processed_content: Annotated[
        Optional[Union[ServerProcessedContent, Dict[str, Any]]],
        Field(
            description='Contains collections of data that can be processed by server side services like search index and link fixup.'
        ),
    ] = None
    title: Annotated[Optional[str], Field(description='Title of the web part.')] = None
    field_odata_type: str


class Win32LobAppRestartSettings(BaseModel):
    countdown_display_before_restart_in_minutes: Annotated[
        Optional[float],
        Field(
            description='The number of minutes before the restart time to display the countdown dialog for pending restarts.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    grace_period_in_minutes: Annotated[
        Optional[float],
        Field(
            description='The number of minutes to wait before restarting the device after an app installation.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    restart_notification_snooze_duration_in_minutes: Annotated[
        Optional[float],
        Field(
            description='The number of minutes to snooze the restart notification dialog when the snooze button is selected.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class Windows10NetworkProxyServer(BaseModel):
    address: Annotated[
        Optional[str],
        Field(
            description="Address to the proxy server. Specify an address in the format [':']"
        ),
    ] = None
    exceptions: Annotated[
        Optional[List[str]],
        Field(
            description='Addresses that should not use the proxy server. The system will not use the proxy server for addresses beginning with what is specified in this node.'
        ),
    ] = None
    use_for_local_addresses: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether the proxy server should be used for local (intranet) addresses.'
        ),
    ] = None
    field_odata_type: str


class WindowsAppXAppAssignmentSettings(MobileAppAssignmentSettings):
    use_device_context: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates that device execution context will be used for the AppX mobile app. When FALSE, indicates that user context will be used for the AppX mobile app. By default, this property is set to FALSE. Once this property has been set to TRUE it cannot be changed.'
        ),
    ] = None
    field_odata_type: str


class WindowsDeviceAccount(BaseModel):
    password: Annotated[Optional[str], Field(description='Not yet documented')] = None
    field_odata_type: str


class WindowsDeviceADAccount(WindowsDeviceAccount):
    domain_name: Annotated[Optional[str], Field(description='Not yet documented')] = (
        None
    )
    user_name: Annotated[Optional[str], Field(description='Not yet documented')] = None
    field_odata_type: str


class WindowsDeviceAzureADAccount(WindowsDeviceAccount):
    user_principal_name: Annotated[
        Optional[str], Field(description='Not yet documented')
    ] = None
    field_odata_type: str


class WindowsInformationProtectionApp(BaseModel):
    denied: Annotated[
        Optional[bool],
        Field(description='If true, app is denied protection or exemption.'),
    ] = None
    description: Annotated[
        Optional[str], Field(description="The app's description.")
    ] = None
    display_name: Annotated[Optional[str], Field(description='App display name.')] = (
        None
    )
    product_name: Annotated[Optional[str], Field(description='The product name.')] = (
        None
    )
    publisher_name: Annotated[
        Optional[str], Field(description='The publisher name')
    ] = None
    field_odata_type: str


class WindowsInformationProtectionDataRecoveryCertificate(BaseModel):
    certificate: Annotated[
        Optional[str], Field(description='Data recovery Certificate')
    ] = None
    description: Annotated[
        Optional[str], Field(description='Data recovery Certificate description')
    ] = None
    expiration_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Data recovery Certificate expiration datetime',
        ),
    ] = None
    subject_name: Annotated[
        Optional[str], Field(description='Data recovery Certificate subject name')
    ] = None
    field_odata_type: str


class WindowsInformationProtectionDesktopApp(WindowsInformationProtectionApp):
    binary_name: Annotated[Optional[str], Field(description='The binary name.')] = None
    binary_version_high: Annotated[
        Optional[str], Field(description='The high binary version.')
    ] = None
    binary_version_low: Annotated[
        Optional[str], Field(description='The lower binary version.')
    ] = None
    field_odata_type: str


class WindowsInformationProtectionIPRangeCollection(BaseModel):
    display_name: Annotated[Optional[str], Field(description='Display name')] = None
    ranges: Annotated[
        Optional[List[IpRange]], Field(description='Collection of ip ranges')
    ] = None
    field_odata_type: str


class WindowsInformationProtectionProxiedDomainCollection(BaseModel):
    display_name: Annotated[Optional[str], Field(description='Display name')] = None
    proxied_domains: Annotated[
        Optional[List[ProxiedDomain]],
        Field(description='Collection of proxied domains'),
    ] = None
    field_odata_type: str


class WindowsInformationProtectionResourceCollection(BaseModel):
    display_name: Annotated[Optional[str], Field(description='Display name')] = None
    resources: Annotated[
        Optional[List[str]], Field(description='Collection of resources')
    ] = None
    field_odata_type: str


class WindowsInformationProtectionStoreApp(WindowsInformationProtectionApp):
    field_odata_type: str


class WindowsMalwareNameCount(BaseModel):
    device_count: Annotated[
        Optional[float],
        Field(
            description='Count of devices with malware dectected for this malware',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    last_update_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp of the last update for the device count in UTC',
        ),
    ] = None
    malware_identifier: Annotated[
        Optional[str],
        Field(description='The unique identifier. This is malware identifier'),
    ] = None
    name: Annotated[Optional[str], Field(description='Malware name')] = None
    field_odata_type: str


class WindowsMinimumOperatingSystem(BaseModel):
    v10_0: Annotated[
        Optional[bool], Field(description='Windows version 10.0 or later.')
    ] = None
    v8_0: Annotated[
        Optional[bool], Field(description='Windows version 8.0 or later.')
    ] = None
    v8_1: Annotated[
        Optional[bool], Field(description='Windows version 8.1 or later.')
    ] = None
    field_odata_type: str


class WindowsUniversalAppXAppAssignmentSettings(MobileAppAssignmentSettings):
    use_device_context: Annotated[
        Optional[bool],
        Field(
            description='If true, uses device execution context for Windows Universal AppX mobile app. Device-context install is not allowed when this type of app is targeted with Available intent. Defaults to false.'
        ),
    ] = None
    field_odata_type: str


class WindowsUpdateInstallScheduleType(BaseModel):
    field_odata_type: str


class WorkbookFilterDatetime(BaseModel):
    date: Annotated[
        Optional[str],
        Field(description='The date in ISO 8601 format used to filter data.'),
    ] = None
    specificity: Annotated[
        Optional[str],
        Field(
            description='Defines how specific you should use the date to keep data. For example, if the date is 2005-04-02 and the specificity property is set to month, the filter operation keeps all rows with a date in the month of April 2009. The possible values are: Year, Month, Day, Hour, Minute, Second.'
        ),
    ] = None
    field_odata_type: str


class WorkbookIcon(BaseModel):
    index: Annotated[
        Optional[float],
        Field(
            description='The index of the icon in the given set.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    set: Annotated[
        Optional[str],
        Field(
            description='The set that the icon is part of. The possible values are: Invalid, ThreeArrows, ThreeArrowsGray, ThreeFlags, ThreeTrafficLights1, ThreeTrafficLights2, ThreeSigns, ThreeSymbols, ThreeSymbols2, FourArrows, FourArrowsGray, FourRedToBlack, FourRating, FourTrafficLights, FiveArrows, FiveArrowsGray, FiveRating, FiveQuarters, ThreeStars, ThreeTriangles, FiveBoxes.'
        ),
    ] = None
    field_odata_type: str


class WorkbookOperationError(BaseModel):
    code: Annotated[Optional[str], Field(description='The error code.')] = None
    inner_error: Optional[Union[WorkbookOperationError, Dict[str, Any]]] = None
    message: Annotated[Optional[str], Field(description='The error message.')] = None
    field_odata_type: str


class WorkbookRangeReference(BaseModel):
    address: Optional[str] = None
    field_odata_type: str


class WorkbookSessionInfo(BaseModel):
    id: Annotated[Optional[str], Field(description='ID of the workbook session.')] = (
        None
    )
    persist_changes: Annotated[
        Optional[bool],
        Field(
            description='true for persistent session. false for non-persistent session (view mode)'
        ),
    ] = None
    field_odata_type: str


class WorkbookSortField(BaseModel):
    ascending: Annotated[
        Optional[bool],
        Field(
            description='Represents whether the sorting is done in an ascending fashion.'
        ),
    ] = None
    color: Annotated[
        Optional[str],
        Field(
            description='Represents the color that is the target of the condition if the sorting is on font or cell color.'
        ),
    ] = None
    data_option: Annotated[
        Optional[str],
        Field(
            description='Represents additional sorting options for this field. The possible values are: Normal, TextAsNumber.'
        ),
    ] = None
    icon: Annotated[
        Optional[Union[WorkbookIcon, Dict[str, Any]]],
        Field(
            description="Represents the icon that is the target of the condition if the sorting is on the cell's icon."
        ),
    ] = None
    key: Annotated[
        Optional[float],
        Field(
            description='Represents the column (or row, depending on the sort orientation) that the condition is on. Represented as an offset from the first column (or row).',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    sort_on: Annotated[
        Optional[str],
        Field(
            description='Represents the type of sorting of this condition. The possible values are: Value, CellColor, FontColor, Icon.'
        ),
    ] = None
    field_odata_type: str


class WorkbookWorksheetProtectionOptions(BaseModel):
    allow_auto_filter: Annotated[
        Optional[bool],
        Field(
            description='Represents the worksheet protection option of allowing using auto filter feature.'
        ),
    ] = None
    allow_delete_columns: Annotated[
        Optional[bool],
        Field(
            description='Represents the worksheet protection option of allowing deleting columns.'
        ),
    ] = None
    allow_delete_rows: Annotated[
        Optional[bool],
        Field(
            description='Represents the worksheet protection option of allowing deleting rows.'
        ),
    ] = None
    allow_format_cells: Annotated[
        Optional[bool],
        Field(
            description='Represents the worksheet protection option of allowing formatting cells.'
        ),
    ] = None
    allow_format_columns: Annotated[
        Optional[bool],
        Field(
            description='Represents the worksheet protection option of allowing formatting columns.'
        ),
    ] = None
    allow_format_rows: Annotated[
        Optional[bool],
        Field(
            description='Represents the worksheet protection option of allowing formatting rows.'
        ),
    ] = None
    allow_insert_columns: Annotated[
        Optional[bool],
        Field(
            description='Represents the worksheet protection option of allowing inserting columns.'
        ),
    ] = None
    allow_insert_hyperlinks: Annotated[
        Optional[bool],
        Field(
            description='Represents the worksheet protection option of allowing inserting hyperlinks.'
        ),
    ] = None
    allow_insert_rows: Annotated[
        Optional[bool],
        Field(
            description='Represents the worksheet protection option of allowing inserting rows.'
        ),
    ] = None
    allow_pivot_tables: Annotated[
        Optional[bool],
        Field(
            description='Represents the worksheet protection option of allowing using pivot table feature.'
        ),
    ] = None
    allow_sort: Annotated[
        Optional[bool],
        Field(
            description='Represents the worksheet protection option of allowing using sort feature.'
        ),
    ] = None
    field_odata_type: str


class AccessPackageAssignmentFilterByCurrentUserOptions(Enum):
    target = 'target'
    created_by = 'createdBy'
    unknown_future_value = 'unknownFutureValue'


class AccessPackageAssignmentRequestFilterByCurrentUserOptions(Enum):
    target = 'target'
    created_by = 'createdBy'
    approver = 'approver'
    unknown_future_value = 'unknownFutureValue'


class AccessPackageAssignmentState(Enum):
    delivering = 'delivering'
    partially_delivered = 'partiallyDelivered'
    delivered = 'delivered'
    expired = 'expired'
    delivery_failed = 'deliveryFailed'
    unknown_future_value = 'unknownFutureValue'


class AccessPackageCatalogState(Enum):
    unpublished = 'unpublished'
    published = 'published'
    unknown_future_value = 'unknownFutureValue'


class AccessPackageCatalogType(Enum):
    user_managed = 'userManaged'
    service_default = 'serviceDefault'
    service_managed = 'serviceManaged'
    unknown_future_value = 'unknownFutureValue'


class AccessPackageCustomExtensionStage(Enum):
    assignment_request_created = 'assignmentRequestCreated'
    assignment_request_approved = 'assignmentRequestApproved'
    assignment_request_granted = 'assignmentRequestGranted'
    assignment_request_removed = 'assignmentRequestRemoved'
    assignment_fourteen_days_before_expiration = (
        'assignmentFourteenDaysBeforeExpiration'
    )
    assignment_one_day_before_expiration = 'assignmentOneDayBeforeExpiration'
    unknown_future_value = 'unknownFutureValue'


class AccessPackageExternalUserLifecycleAction(Enum):
    none = 'none'
    block_sign_in = 'blockSignIn'
    block_sign_in_and_delete = 'blockSignInAndDelete'
    unknown_future_value = 'unknownFutureValue'


class AccessPackageFilterByCurrentUserOptions(Enum):
    allowed_requestor = 'allowedRequestor'
    unknown_future_value = 'unknownFutureValue'


class AccessPackageRequestState(Enum):
    submitted = 'submitted'
    pending_approval = 'pendingApproval'
    delivering = 'delivering'
    delivered = 'delivered'
    delivery_failed = 'deliveryFailed'
    denied = 'denied'
    scheduled = 'scheduled'
    canceled = 'canceled'
    partially_delivered = 'partiallyDelivered'
    unknown_future_value = 'unknownFutureValue'


class AccessPackageRequestType(Enum):
    not_specified = 'notSpecified'
    user_add = 'userAdd'
    user_update = 'userUpdate'
    user_remove = 'userRemove'
    admin_add = 'adminAdd'
    admin_update = 'adminUpdate'
    admin_remove = 'adminRemove'
    system_add = 'systemAdd'
    system_update = 'systemUpdate'
    system_remove = 'systemRemove'
    on_behalf_add = 'onBehalfAdd'
    unknown_future_value = 'unknownFutureValue'


class AccessPackageSubjectType(Enum):
    not_specified = 'notSpecified'
    user = 'user'
    service_principal = 'servicePrincipal'
    unknown_future_value = 'unknownFutureValue'


class AccessReviewExpirationBehavior(Enum):
    keep_access = 'keepAccess'
    remove_access = 'removeAccess'
    accept_access_recommendation = 'acceptAccessRecommendation'
    unknown_future_value = 'unknownFutureValue'


class AccessReviewHistoryDecisionFilter(Enum):
    approve = 'approve'
    deny = 'deny'
    not_reviewed = 'notReviewed'
    dont_know = 'dontKnow'
    not_notified = 'notNotified'
    unknown_future_value = 'unknownFutureValue'


class AccessReviewHistoryStatus(Enum):
    done = 'done'
    inprogress = 'inprogress'
    error = 'error'
    requested = 'requested'
    unknown_future_value = 'unknownFutureValue'


class AccessReviewInstanceDecisionItemFilterByCurrentUserOptions(Enum):
    reviewer = 'reviewer'
    unknown_future_value = 'unknownFutureValue'


class AccessReviewInstanceFilterByCurrentUserOptions(Enum):
    reviewer = 'reviewer'
    unknown_future_value = 'unknownFutureValue'


class AccessReviewScheduleDefinitionFilterByCurrentUserOptions(Enum):
    reviewer = 'reviewer'
    unknown_future_value = 'unknownFutureValue'


class AccessReviewStageFilterByCurrentUserOptions(Enum):
    reviewer = 'reviewer'
    unknown_future_value = 'unknownFutureValue'


class AccountTargetContentType(Enum):
    unknown = 'unknown'
    include_all = 'includeAll'
    address_book = 'addressBook'
    unknown_future_value = 'unknownFutureValue'


class ActionState(Enum):
    none = 'none'
    pending = 'pending'
    canceled = 'canceled'
    active = 'active'
    done = 'done'
    failed = 'failed'
    not_supported = 'notSupported'


class ActivityDomain(Enum):
    unknown = 'unknown'
    work = 'work'
    personal = 'personal'
    unrestricted = 'unrestricted'


class ActivityType(Enum):
    signin = 'signin'
    user = 'user'
    unknown_future_value = 'unknownFutureValue'
    service_principal = 'servicePrincipal'


class AdvancedConfigState(Enum):
    default = 'default'
    enabled = 'enabled'
    disabled = 'disabled'
    unknown_future_value = 'unknownFutureValue'


class AgreementAcceptanceState(Enum):
    accepted = 'accepted'
    declined = 'declined'
    unknown_future_value = 'unknownFutureValue'


class AlertFeedback(Enum):
    unknown = 'unknown'
    true_positive = 'truePositive'
    false_positive = 'falsePositive'
    benign_positive = 'benignPositive'
    unknown_future_value = 'unknownFutureValue'


class AlertSeverity(Enum):
    unknown = 'unknown'
    informational = 'informational'
    low = 'low'
    medium = 'medium'
    high = 'high'
    unknown_future_value = 'unknownFutureValue'


class AlertStatus(Enum):
    unknown = 'unknown'
    new_alert = 'newAlert'
    in_progress = 'inProgress'
    resolved = 'resolved'
    dismissed = 'dismissed'
    unknown_future_value = 'unknownFutureValue'


class AllowedTargetScope(Enum):
    not_specified = 'notSpecified'
    specific_directory_users = 'specificDirectoryUsers'
    specific_connected_organization_users = 'specificConnectedOrganizationUsers'
    specific_directory_service_principals = 'specificDirectoryServicePrincipals'
    all_member_users = 'allMemberUsers'
    all_directory_users = 'allDirectoryUsers'
    all_directory_service_principals = 'allDirectoryServicePrincipals'
    all_configured_connected_organization_users = (
        'allConfiguredConnectedOrganizationUsers'
    )
    all_external_users = 'allExternalUsers'
    unknown_future_value = 'unknownFutureValue'


class AllowInvitesFrom(Enum):
    none = 'none'
    admins_and_guest_inviters = 'adminsAndGuestInviters'
    admins_guest_inviters_and_all_members = 'adminsGuestInvitersAndAllMembers'
    everyone = 'everyone'
    unknown_future_value = 'unknownFutureValue'


class AndroidRequiredPasswordType(Enum):
    device_default = 'deviceDefault'
    alphabetic = 'alphabetic'
    alphanumeric = 'alphanumeric'
    alphanumeric_with_symbols = 'alphanumericWithSymbols'
    low_security_biometric = 'lowSecurityBiometric'
    numeric = 'numeric'
    numeric_complex = 'numericComplex'
    any = 'any'


class AndroidWorkProfileCrossProfileDataSharingType(Enum):
    device_default = 'deviceDefault'
    prevent_any = 'preventAny'
    allow_personal_to_work = 'allowPersonalToWork'
    no_restrictions = 'noRestrictions'


class AndroidWorkProfileDefaultAppPermissionPolicyType(Enum):
    device_default = 'deviceDefault'
    prompt = 'prompt'
    auto_grant = 'autoGrant'
    auto_deny = 'autoDeny'


class AndroidWorkProfileRequiredPasswordType(Enum):
    device_default = 'deviceDefault'
    low_security_biometric = 'lowSecurityBiometric'
    required = 'required'
    at_least_numeric = 'atLeastNumeric'
    numeric_complex = 'numericComplex'
    at_least_alphabetic = 'atLeastAlphabetic'
    at_least_alphanumeric = 'atLeastAlphanumeric'
    alphanumeric_with_symbols = 'alphanumericWithSymbols'


class AnswerInputType(Enum):
    text = 'text'
    radio_button = 'radioButton'
    unknown_future_value = 'unknownFutureValue'


class AppCredentialRestrictionType(Enum):
    password_addition = 'passwordAddition'
    password_lifetime = 'passwordLifetime'
    symmetric_key_addition = 'symmetricKeyAddition'
    symmetric_key_lifetime = 'symmetricKeyLifetime'
    custom_password_addition = 'customPasswordAddition'
    unknown_future_value = 'unknownFutureValue'


class AppKeyCredentialRestrictionType(Enum):
    asymmetric_key_lifetime = 'asymmetricKeyLifetime'
    unknown_future_value = 'unknownFutureValue'


class ApplicationGuardBlockClipboardSharingType(Enum):
    not_configured = 'notConfigured'
    block_both = 'blockBoth'
    block_host_to_container = 'blockHostToContainer'
    block_container_to_host = 'blockContainerToHost'
    block_none = 'blockNone'


class ApplicationGuardBlockFileTransferType(Enum):
    not_configured = 'notConfigured'
    block_image_and_text_file = 'blockImageAndTextFile'
    block_image_file = 'blockImageFile'
    block_none = 'blockNone'
    block_text_file = 'blockTextFile'


class ApplicationType(Enum):
    universal = 'universal'
    desktop = 'desktop'


class AppliedConditionalAccessPolicyResult(Enum):
    success = 'success'
    failure = 'failure'
    not_applied = 'notApplied'
    not_enabled = 'notEnabled'
    unknown = 'unknown'
    unknown_future_value = 'unknownFutureValue'
    report_only_success = 'reportOnlySuccess'
    report_only_failure = 'reportOnlyFailure'
    report_only_not_applied = 'reportOnlyNotApplied'
    report_only_interrupted = 'reportOnlyInterrupted'


class AppListType(Enum):
    none = 'none'
    apps_in_list_compliant = 'appsInListCompliant'
    apps_not_in_list_compliant = 'appsNotInListCompliant'


class AppLockerApplicationControlType(Enum):
    not_configured = 'notConfigured'
    enforce_components_and_store_apps = 'enforceComponentsAndStoreApps'
    audit_components_and_store_apps = 'auditComponentsAndStoreApps'
    enforce_components_store_apps_and_smartlocker = (
        'enforceComponentsStoreAppsAndSmartlocker'
    )
    audit_components_store_apps_and_smartlocker = (
        'auditComponentsStoreAppsAndSmartlocker'
    )


class AppLogDecryptionAlgorithm(Enum):
    aes256 = 'aes256'
    unknown_future_value = 'unknownFutureValue'


class AppLogUploadState(Enum):
    pending = 'pending'
    completed = 'completed'
    failed = 'failed'
    unknown_future_value = 'unknownFutureValue'


class AppManagementRestrictionState(Enum):
    enabled = 'enabled'
    disabled = 'disabled'
    unknown_future_value = 'unknownFutureValue'


class ApprovalFilterByCurrentUserOptions(Enum):
    target = 'target'
    created_by = 'createdBy'
    approver = 'approver'
    unknown_future_value = 'unknownFutureValue'


class AppsUpdateChannelType(Enum):
    current = 'current'
    monthly_enterprise = 'monthlyEnterprise'
    semi_annual = 'semiAnnual'
    unknown_future_value = 'unknownFutureValue'


class ArtifactRestoreStatus(Enum):
    added = 'added'
    scheduling = 'scheduling'
    scheduled = 'scheduled'
    in_progress = 'inProgress'
    succeeded = 'succeeded'
    failed = 'failed'
    unknown_future_value = 'unknownFutureValue'


class AssignmentScheduleFilterByCurrentUserOptions(Enum):
    principal = 'principal'
    unknown_future_value = 'unknownFutureValue'


class AssignmentScheduleInstanceFilterByCurrentUserOptions(Enum):
    principal = 'principal'
    unknown_future_value = 'unknownFutureValue'


class AssignmentScheduleRequestFilterByCurrentUserOptions(Enum):
    principal = 'principal'
    created_by = 'createdBy'
    approver = 'approver'
    unknown_future_value = 'unknownFutureValue'


class AssignmentType(Enum):
    required = 'required'
    recommended = 'recommended'
    unknown_future_value = 'unknownFutureValue'
    peer_recommended = 'peerRecommended'


class AttachmentType(Enum):
    file = 'file'
    item = 'item'
    reference = 'reference'


class AttackSimulationOperationType(Enum):
    create_simualation = 'createSimualation'
    update_simulation = 'updateSimulation'
    unknown_future_value = 'unknownFutureValue'


class AttendeeType(Enum):
    required = 'required'
    optional = 'optional'
    resource = 'resource'


class AttestationLevel(Enum):
    attested = 'attested'
    not_attested = 'notAttested'
    unknown_future_value = 'unknownFutureValue'


class AttributeDefinitionMetadata(Enum):
    base_attribute_name = 'BaseAttributeName'
    complex_object_definition = 'ComplexObjectDefinition'
    is_container = 'IsContainer'
    is_customer_defined = 'IsCustomerDefined'
    is_domain_qualified = 'IsDomainQualified'
    link_property_names = 'LinkPropertyNames'
    link_type_name = 'LinkTypeName'
    maximum_length = 'MaximumLength'
    referenced_property = 'ReferencedProperty'


class AttributeFlowBehavior(Enum):
    flow_when_changed = 'FlowWhenChanged'
    flow_always = 'FlowAlways'


class AttributeFlowType(Enum):
    always = 'Always'
    object_add_only = 'ObjectAddOnly'
    multi_value_add_only = 'MultiValueAddOnly'
    value_add_only = 'ValueAddOnly'
    attribute_add_only = 'AttributeAddOnly'


class AttributeMappingSourceType(Enum):
    attribute = 'Attribute'
    constant = 'Constant'
    function = 'Function'


class AttributeType(Enum):
    string = 'String'
    integer = 'Integer'
    reference = 'Reference'
    binary = 'Binary'
    boolean = 'Boolean'
    date_time = 'DateTime'


class AuthenticationAttributeCollectionInputType(Enum):
    text = 'text'
    radio_single_select = 'radioSingleSelect'
    checkbox_multi_select = 'checkboxMultiSelect'
    boolean = 'boolean'
    unknown_future_value = 'unknownFutureValue'


class AuthenticationMethodFeature(Enum):
    sspr_registered = 'ssprRegistered'
    sspr_enabled = 'ssprEnabled'
    sspr_capable = 'ssprCapable'
    passwordless_capable = 'passwordlessCapable'
    mfa_capable = 'mfaCapable'
    unknown_future_value = 'unknownFutureValue'


class AuthenticationMethodKeyStrength(Enum):
    normal = 'normal'
    weak = 'weak'
    unknown = 'unknown'


class AuthenticationMethodModes(Enum):
    password = 'password'
    voice = 'voice'
    hardware_oath = 'hardwareOath'
    software_oath = 'softwareOath'
    sms = 'sms'
    fido2 = 'fido2'
    windows_hello_for_business = 'windowsHelloForBusiness'
    microsoft_authenticator_push = 'microsoftAuthenticatorPush'
    device_based_push = 'deviceBasedPush'
    temporary_access_pass_one_time = 'temporaryAccessPassOneTime'
    temporary_access_pass_multi_use = 'temporaryAccessPassMultiUse'
    email = 'email'
    x509_certificate_single_factor = 'x509CertificateSingleFactor'
    x509_certificate_multi_factor = 'x509CertificateMultiFactor'
    federated_single_factor = 'federatedSingleFactor'
    federated_multi_factor = 'federatedMultiFactor'
    unknown_future_value = 'unknownFutureValue'


class AuthenticationMethodSignInState(Enum):
    not_supported = 'notSupported'
    not_allowed_by_policy = 'notAllowedByPolicy'
    not_enabled = 'notEnabled'
    phone_number_not_unique = 'phoneNumberNotUnique'
    ready = 'ready'
    not_configured = 'notConfigured'
    unknown_future_value = 'unknownFutureValue'


class AuthenticationMethodsPolicyMigrationState(Enum):
    pre_migration = 'preMigration'
    migration_in_progress = 'migrationInProgress'
    migration_complete = 'migrationComplete'
    unknown_future_value = 'unknownFutureValue'


class AuthenticationMethodState(Enum):
    enabled = 'enabled'
    disabled = 'disabled'


class AuthenticationMethodTargetType(Enum):
    user = 'user'
    group = 'group'
    unknown_future_value = 'unknownFutureValue'


class AuthenticationPhoneType(Enum):
    mobile = 'mobile'
    alternate_mobile = 'alternateMobile'
    office = 'office'
    unknown_future_value = 'unknownFutureValue'


class AuthenticationProtocol(Enum):
    ws_fed = 'wsFed'
    saml = 'saml'
    unknown_future_value = 'unknownFutureValue'


class AuthenticationStrengthPolicyType(Enum):
    built_in = 'builtIn'
    custom = 'custom'
    unknown_future_value = 'unknownFutureValue'


class AuthenticationStrengthRequirements(Enum):
    none = 'none'
    mfa = 'mfa'
    unknown_future_value = 'unknownFutureValue'


class AutomaticRepliesStatus(Enum):
    disabled = 'disabled'
    always_enabled = 'alwaysEnabled'
    scheduled = 'scheduled'


class AutomaticUpdateMode(Enum):
    user_defined = 'userDefined'
    notify_download = 'notifyDownload'
    auto_install_at_maintenance_time = 'autoInstallAtMaintenanceTime'
    auto_install_and_reboot_at_maintenance_time = (
        'autoInstallAndRebootAtMaintenanceTime'
    )
    auto_install_and_reboot_at_scheduled_time = 'autoInstallAndRebootAtScheduledTime'
    auto_install_and_reboot_without_end_user_control = (
        'autoInstallAndRebootWithoutEndUserControl'
    )


class AutoRestartNotificationDismissalMethod(Enum):
    not_configured = 'notConfigured'
    automatic = 'automatic'
    user = 'user'
    unknown_future_value = 'unknownFutureValue'


class B2bIdentityProvidersType(Enum):
    azure_active_directory = 'azureActiveDirectory'
    external_federation = 'externalFederation'
    social_identity_providers = 'socialIdentityProviders'
    email_one_time_passcode = 'emailOneTimePasscode'
    microsoft_account = 'microsoftAccount'
    default_configured_idp = 'defaultConfiguredIdp'
    unknown_future_value = 'unknownFutureValue'


class BackupServiceConsumer(Enum):
    unknown = 'unknown'
    firstparty = 'firstparty'
    thirdparty = 'thirdparty'
    unknown_future_value = 'unknownFutureValue'


class BackupServiceStatus(Enum):
    disabled = 'disabled'
    enabled = 'enabled'
    protection_change_locked = 'protectionChangeLocked'
    restore_locked = 'restoreLocked'
    unknown_future_value = 'unknownFutureValue'


class BaseAuthenticationMethod(Enum):
    password = 'password'
    voice = 'voice'
    hardware_oath = 'hardwareOath'
    software_oath = 'softwareOath'
    sms = 'sms'
    fido2 = 'fido2'
    windows_hello_for_business = 'windowsHelloForBusiness'
    microsoft_authenticator = 'microsoftAuthenticator'
    temporary_access_pass = 'temporaryAccessPass'
    email = 'email'
    x509_certificate = 'x509Certificate'
    federation = 'federation'
    unknown_future_value = 'unknownFutureValue'


class BinaryOperator(Enum):
    or_ = 'or'
    and_ = 'and'


class BitLockerEncryptionMethod(Enum):
    aes_cbc128 = 'aesCbc128'
    aes_cbc256 = 'aesCbc256'
    xts_aes128 = 'xtsAes128'
    xts_aes256 = 'xtsAes256'


class BodyType(Enum):
    text = 'text'
    html = 'html'


class BookingPageAccessControl(Enum):
    unrestricted = 'unrestricted'
    restricted_to_organization = 'restrictedToOrganization'
    unknown_future_value = 'unknownFutureValue'


class BookingPriceType(Enum):
    undefined = 'undefined'
    fixed_price = 'fixedPrice'
    starting_at = 'startingAt'
    hourly = 'hourly'
    free = 'free'
    price_varies = 'priceVaries'
    call_us = 'callUs'
    not_set = 'notSet'
    unknown_future_value = 'unknownFutureValue'


class BookingReminderRecipients(Enum):
    all_attendees = 'allAttendees'
    staff = 'staff'
    customer = 'customer'
    unknown_future_value = 'unknownFutureValue'


class BookingsAvailabilityStatus(Enum):
    available = 'available'
    busy = 'busy'
    slots_available = 'slotsAvailable'
    out_of_office = 'outOfOffice'
    unknown_future_value = 'unknownFutureValue'


class BookingsServiceAvailabilityType(Enum):
    book_when_staff_are_free = 'bookWhenStaffAreFree'
    not_bookable = 'notBookable'
    custom_weekly_hours = 'customWeeklyHours'
    unknown_future_value = 'unknownFutureValue'


class BookingStaffMembershipStatus(Enum):
    active = 'active'
    pending_acceptance = 'pendingAcceptance'
    rejected_by_staff = 'rejectedByStaff'
    unknown_future_value = 'unknownFutureValue'


class BookingStaffRole(Enum):
    guest = 'guest'
    administrator = 'administrator'
    viewer = 'viewer'
    external_guest = 'externalGuest'
    unknown_future_value = 'unknownFutureValue'
    scheduler = 'scheduler'
    team_member = 'teamMember'


class BookingType(Enum):
    unknown = 'unknown'
    standard = 'standard'
    reserved = 'reserved'


class BroadcastMeetingAudience(Enum):
    role_is_attendee = 'roleIsAttendee'
    organization = 'organization'
    everyone = 'everyone'
    unknown_future_value = 'unknownFutureValue'


class BrowserSharedCookieSourceEnvironment(Enum):
    microsoft_edge = 'microsoftEdge'
    internet_explorer11 = 'internetExplorer11'
    both = 'both'
    unknown_future_value = 'unknownFutureValue'


class BrowserSharedCookieStatus(Enum):
    published = 'published'
    pending_add = 'pendingAdd'
    pending_edit = 'pendingEdit'
    pending_delete = 'pendingDelete'
    unknown_future_value = 'unknownFutureValue'


class BrowserSiteCompatibilityMode(Enum):
    default = 'default'
    internet_explorer8_enterprise = 'internetExplorer8Enterprise'
    internet_explorer7_enterprise = 'internetExplorer7Enterprise'
    internet_explorer11 = 'internetExplorer11'
    internet_explorer10 = 'internetExplorer10'
    internet_explorer9 = 'internetExplorer9'
    internet_explorer8 = 'internetExplorer8'
    internet_explorer7 = 'internetExplorer7'
    internet_explorer5 = 'internetExplorer5'
    unknown_future_value = 'unknownFutureValue'


class BrowserSiteListStatus(Enum):
    draft = 'draft'
    published = 'published'
    pending = 'pending'
    unknown_future_value = 'unknownFutureValue'


class BrowserSiteMergeType(Enum):
    no_merge = 'noMerge'
    default = 'default'
    unknown_future_value = 'unknownFutureValue'


class BrowserSiteStatus(Enum):
    published = 'published'
    pending_add = 'pendingAdd'
    pending_edit = 'pendingEdit'
    pending_delete = 'pendingDelete'
    unknown_future_value = 'unknownFutureValue'


class BrowserSiteTargetEnvironment(Enum):
    internet_explorer_mode = 'internetExplorerMode'
    internet_explorer11 = 'internetExplorer11'
    microsoft_edge = 'microsoftEdge'
    configurable = 'configurable'
    none = 'none'
    unknown_future_value = 'unknownFutureValue'


class BucketAggregationSortProperty(Enum):
    count = 'count'
    key_as_string = 'keyAsString'
    key_as_number = 'keyAsNumber'
    unknown_future_value = 'unknownFutureValue'


class CalendarColor(Enum):
    auto = 'auto'
    light_blue = 'lightBlue'
    light_green = 'lightGreen'
    light_orange = 'lightOrange'
    light_gray = 'lightGray'
    light_yellow = 'lightYellow'
    light_teal = 'lightTeal'
    light_pink = 'lightPink'
    light_brown = 'lightBrown'
    light_red = 'lightRed'
    max_color = 'maxColor'


class CalendarRoleType(Enum):
    none = 'none'
    free_busy_read = 'freeBusyRead'
    limited_read = 'limitedRead'
    read = 'read'
    write = 'write'
    delegate_without_private_event_access = 'delegateWithoutPrivateEventAccess'
    delegate_with_private_event_access = 'delegateWithPrivateEventAccess'
    custom = 'custom'


class CalendarSharingAction(Enum):
    accept = 'accept'
    accept_and_view_calendar = 'acceptAndViewCalendar'
    view_calendar = 'viewCalendar'
    add_this_calendar = 'addThisCalendar'


class CalendarSharingActionImportance(Enum):
    primary = 'primary'
    secondary = 'secondary'


class CalendarSharingActionType(Enum):
    accept = 'accept'


class CallDirection(Enum):
    incoming = 'incoming'
    outgoing = 'outgoing'


class CallRecordingStatus(Enum):
    success = 'success'
    failure = 'failure'
    initial = 'initial'
    chunk_finished = 'chunkFinished'
    unknown_future_value = 'unknownFutureValue'


class CallState(Enum):
    incoming = 'incoming'
    establishing = 'establishing'
    established = 'established'
    hold = 'hold'
    transferring = 'transferring'
    transfer_accepted = 'transferAccepted'
    redirecting = 'redirecting'
    terminating = 'terminating'
    terminated = 'terminated'
    unknown_future_value = 'unknownFutureValue'


class CallTranscriptionState(Enum):
    not_started = 'notStarted'
    active = 'active'
    inactive = 'inactive'
    unknown_future_value = 'unknownFutureValue'


class CategoryColor(Enum):
    none = 'none'
    preset0 = 'preset0'
    preset1 = 'preset1'
    preset2 = 'preset2'
    preset3 = 'preset3'
    preset4 = 'preset4'
    preset5 = 'preset5'
    preset6 = 'preset6'
    preset7 = 'preset7'
    preset8 = 'preset8'
    preset9 = 'preset9'
    preset10 = 'preset10'
    preset11 = 'preset11'
    preset12 = 'preset12'
    preset13 = 'preset13'
    preset14 = 'preset14'
    preset15 = 'preset15'
    preset16 = 'preset16'
    preset17 = 'preset17'
    preset18 = 'preset18'
    preset19 = 'preset19'
    preset20 = 'preset20'
    preset21 = 'preset21'
    preset22 = 'preset22'
    preset23 = 'preset23'
    preset24 = 'preset24'


class CertificateStatus(Enum):
    not_provisioned = 'notProvisioned'
    provisioned = 'provisioned'


class ChangeType(Enum):
    created = 'created'
    updated = 'updated'
    deleted = 'deleted'


class ChannelMembershipType(Enum):
    standard = 'standard'
    private = 'private'
    unknown_future_value = 'unknownFutureValue'
    shared = 'shared'


class ChatMessageActions(Enum):
    reaction_added = 'reactionAdded'
    reaction_removed = 'reactionRemoved'
    action_undefined = 'actionUndefined'
    unknown_future_value = 'unknownFutureValue'


class ChatMessageImportance(Enum):
    normal = 'normal'
    high = 'high'
    urgent = 'urgent'
    unknown_future_value = 'unknownFutureValue'


class ChatMessagePolicyViolationDlpActionTypes(Enum):
    none = 'none'
    notify_sender = 'notifySender'
    block_access = 'blockAccess'
    block_access_external = 'blockAccessExternal'


class ChatMessagePolicyViolationUserActionTypes(Enum):
    none = 'none'
    override = 'override'
    report_false_positive = 'reportFalsePositive'


class ChatMessagePolicyViolationVerdictDetailsTypes(Enum):
    none = 'none'
    allow_false_positive_override = 'allowFalsePositiveOverride'
    allow_override_without_justification = 'allowOverrideWithoutJustification'
    allow_override_with_justification = 'allowOverrideWithJustification'


class ChatMessageType(Enum):
    message = 'message'
    chat_event = 'chatEvent'
    typing = 'typing'
    unknown_future_value = 'unknownFutureValue'
    system_event_message = 'systemEventMessage'


class ChatType(Enum):
    one_on_one = 'oneOnOne'
    group = 'group'
    meeting = 'meeting'
    unknown_future_value = 'unknownFutureValue'


class ClickSource(Enum):
    unknown = 'unknown'
    qr_code = 'qrCode'
    phishing_url = 'phishingUrl'
    unknown_future_value = 'unknownFutureValue'


class ClonableTeamParts(Enum):
    apps = 'apps'
    tabs = 'tabs'
    settings = 'settings'
    channels = 'channels'
    members = 'members'


class CloudAppSecuritySessionControlType(Enum):
    mcas_configured = 'mcasConfigured'
    monitor_only = 'monitorOnly'
    block_downloads = 'blockDownloads'
    unknown_future_value = 'unknownFutureValue'


class CloudPcAuditActivityOperationType(Enum):
    create = 'create'
    delete = 'delete'
    patch = 'patch'
    unknown_future_value = 'unknownFutureValue'


class CloudPcAuditActivityResult(Enum):
    success = 'success'
    client_error = 'clientError'
    failure = 'failure'
    timeout = 'timeout'
    unknown_future_value = 'unknownFutureValue'


class CloudPcAuditCategory(Enum):
    cloud_pc = 'cloudPC'
    unknown_future_value = 'unknownFutureValue'


class CloudPcDeviceImageErrorCode(Enum):
    internal_server_error = 'internalServerError'
    source_image_not_found = 'sourceImageNotFound'
    os_version_not_supported = 'osVersionNotSupported'
    source_image_invalid = 'sourceImageInvalid'
    source_image_not_generalized = 'sourceImageNotGeneralized'
    unknown_future_value = 'unknownFutureValue'
    vm_already_azure_adjoined = 'vmAlreadyAzureAdjoined'
    paid_source_image_not_support = 'paidSourceImageNotSupport'
    source_image_not_support_customize_vm_name = 'sourceImageNotSupportCustomizeVMName'
    source_image_size_exceeds_limitation = 'sourceImageSizeExceedsLimitation'


class CloudPcDeviceImageOsStatus(Enum):
    supported = 'supported'
    supported_with_warning = 'supportedWithWarning'
    unknown = 'unknown'
    unknown_future_value = 'unknownFutureValue'


class CloudPcDeviceImageStatus(Enum):
    pending = 'pending'
    ready = 'ready'
    failed = 'failed'
    unknown_future_value = 'unknownFutureValue'


class CloudPcDomainJoinType(Enum):
    azure_ad_join = 'azureADJoin'
    hybrid_azure_ad_join = 'hybridAzureADJoin'
    unknown_future_value = 'unknownFutureValue'


class CloudPcGalleryImageStatus(Enum):
    supported = 'supported'
    supported_with_warning = 'supportedWithWarning'
    not_supported = 'notSupported'
    unknown_future_value = 'unknownFutureValue'


class CloudPcOnPremisesConnectionHealthCheckErrorType(Enum):
    dns_check_fqdn_not_found = 'dnsCheckFqdnNotFound'
    dns_check_name_with_invalid_character = 'dnsCheckNameWithInvalidCharacter'
    dns_check_unknown_error = 'dnsCheckUnknownError'
    ad_join_check_fqdn_not_found = 'adJoinCheckFqdnNotFound'
    ad_join_check_incorrect_credentials = 'adJoinCheckIncorrectCredentials'
    ad_join_check_organizational_unit_not_found = (
        'adJoinCheckOrganizationalUnitNotFound'
    )
    ad_join_check_organizational_unit_incorrect_format = (
        'adJoinCheckOrganizationalUnitIncorrectFormat'
    )
    ad_join_check_computer_object_already_exists = (
        'adJoinCheckComputerObjectAlreadyExists'
    )
    ad_join_check_access_denied = 'adJoinCheckAccessDenied'
    ad_join_check_credentials_expired = 'adJoinCheckCredentialsExpired'
    ad_join_check_account_locked_or_disabled = 'adJoinCheckAccountLockedOrDisabled'
    ad_join_check_account_quota_exceeded = 'adJoinCheckAccountQuotaExceeded'
    ad_join_check_server_not_operational = 'adJoinCheckServerNotOperational'
    ad_join_check_unknown_error = 'adJoinCheckUnknownError'
    endpoint_connectivity_check_cloud_pc_url_not_allow_listed = (
        'endpointConnectivityCheckCloudPcUrlNotAllowListed'
    )
    endpoint_connectivity_check_wvd_url_not_allow_listed = (
        'endpointConnectivityCheckWVDUrlNotAllowListed'
    )
    endpoint_connectivity_check_intune_url_not_allow_listed = (
        'endpointConnectivityCheckIntuneUrlNotAllowListed'
    )
    endpoint_connectivity_check_azure_ad_url_not_allow_listed = (
        'endpointConnectivityCheckAzureADUrlNotAllowListed'
    )
    endpoint_connectivity_check_locale_url_not_allow_listed = (
        'endpointConnectivityCheckLocaleUrlNotAllowListed'
    )
    endpoint_connectivity_check_unknown_error = 'endpointConnectivityCheckUnknownError'
    azure_ad_device_sync_check_device_not_found = 'azureAdDeviceSyncCheckDeviceNotFound'
    azure_ad_device_sync_check_long_sync_circle = 'azureAdDeviceSyncCheckLongSyncCircle'
    azure_ad_device_sync_check_connect_disabled = (
        'azureAdDeviceSyncCheckConnectDisabled'
    )
    azure_ad_device_sync_check_duration_exceeded = (
        'azureAdDeviceSyncCheckDurationExceeded'
    )
    azure_ad_device_sync_check_scp_not_configured = (
        'azureAdDeviceSyncCheckScpNotConfigured'
    )
    azure_ad_device_sync_check_transient_service_error = (
        'azureAdDeviceSyncCheckTransientServiceError'
    )
    azure_ad_device_sync_check_unknown_error = 'azureAdDeviceSyncCheckUnknownError'
    resource_availability_check_no_subnet_ip = 'resourceAvailabilityCheckNoSubnetIP'
    resource_availability_check_subscription_disabled = (
        'resourceAvailabilityCheckSubscriptionDisabled'
    )
    resource_availability_check_azure_policy_violation = (
        'resourceAvailabilityCheckAzurePolicyViolation'
    )
    resource_availability_check_subscription_not_found = (
        'resourceAvailabilityCheckSubscriptionNotFound'
    )
    resource_availability_check_subscription_transferred = (
        'resourceAvailabilityCheckSubscriptionTransferred'
    )
    resource_availability_check_general_subscription_error = (
        'resourceAvailabilityCheckGeneralSubscriptionError'
    )
    resource_availability_check_unsupported_v_net_region = (
        'resourceAvailabilityCheckUnsupportedVNetRegion'
    )
    resource_availability_check_resource_group_invalid = (
        'resourceAvailabilityCheckResourceGroupInvalid'
    )
    resource_availability_check_v_net_invalid = 'resourceAvailabilityCheckVNetInvalid'
    resource_availability_check_subnet_invalid = (
        'resourceAvailabilityCheckSubnetInvalid'
    )
    resource_availability_check_resource_group_being_deleted = (
        'resourceAvailabilityCheckResourceGroupBeingDeleted'
    )
    resource_availability_check_v_net_being_moved = (
        'resourceAvailabilityCheckVNetBeingMoved'
    )
    resource_availability_check_subnet_delegation_failed = (
        'resourceAvailabilityCheckSubnetDelegationFailed'
    )
    resource_availability_check_subnet_with_external_resources = (
        'resourceAvailabilityCheckSubnetWithExternalResources'
    )
    resource_availability_check_resource_group_locked_for_readonly = (
        'resourceAvailabilityCheckResourceGroupLockedForReadonly'
    )
    resource_availability_check_resource_group_locked_for_delete = (
        'resourceAvailabilityCheckResourceGroupLockedForDelete'
    )
    resource_availability_check_no_intune_reader_role_error = (
        'resourceAvailabilityCheckNoIntuneReaderRoleError'
    )
    resource_availability_check_intune_default_windows_restriction_violation = (
        'resourceAvailabilityCheckIntuneDefaultWindowsRestrictionViolation'
    )
    resource_availability_check_intune_custom_windows_restriction_violation = (
        'resourceAvailabilityCheckIntuneCustomWindowsRestrictionViolation'
    )
    resource_availability_check_deployment_quota_limit_reached = (
        'resourceAvailabilityCheckDeploymentQuotaLimitReached'
    )
    resource_availability_check_transient_service_error = (
        'resourceAvailabilityCheckTransientServiceError'
    )
    resource_availability_check_unknown_error = 'resourceAvailabilityCheckUnknownError'
    permission_check_no_subscription_reader_role = (
        'permissionCheckNoSubscriptionReaderRole'
    )
    permission_check_no_resource_group_owner_role = (
        'permissionCheckNoResourceGroupOwnerRole'
    )
    permission_check_no_v_net_contributor_role = 'permissionCheckNoVNetContributorRole'
    permission_check_no_resource_group_network_contributor_role = (
        'permissionCheckNoResourceGroupNetworkContributorRole'
    )
    permission_check_no_windows365_network_user_role = (
        'permissionCheckNoWindows365NetworkUserRole'
    )
    permission_check_no_windows365_network_interface_contributor_role = (
        'permissionCheckNoWindows365NetworkInterfaceContributorRole'
    )
    permission_check_transient_service_error = 'permissionCheckTransientServiceError'
    permission_check_unknown_error = 'permissionCheckUnknownError'
    udp_connectivity_check_stun_url_not_allow_listed = (
        'udpConnectivityCheckStunUrlNotAllowListed'
    )
    udp_connectivity_check_turn_url_not_allow_listed = (
        'udpConnectivityCheckTurnUrlNotAllowListed'
    )
    udp_connectivity_check_urls_not_allow_listed = (
        'udpConnectivityCheckUrlsNotAllowListed'
    )
    udp_connectivity_check_unknown_error = 'udpConnectivityCheckUnknownError'
    internal_server_error_deployment_canceled = 'internalServerErrorDeploymentCanceled'
    internal_server_error_allocate_resource_failed = (
        'internalServerErrorAllocateResourceFailed'
    )
    internal_server_error_vm_deployment_timeout = (
        'internalServerErrorVMDeploymentTimeout'
    )
    internal_server_error_unable_to_run_dsc_script = (
        'internalServerErrorUnableToRunDscScript'
    )
    sso_check_kerberos_configuration_error = 'ssoCheckKerberosConfigurationError'
    internal_server_unknown_error = 'internalServerUnknownError'
    unknown_future_value = 'unknownFutureValue'


class CloudPcOnPremisesConnectionStatus(Enum):
    pending = 'pending'
    running = 'running'
    passed = 'passed'
    failed = 'failed'
    warning = 'warning'
    informational = 'informational'
    unknown_future_value = 'unknownFutureValue'


class CloudPcOnPremisesConnectionType(Enum):
    hybrid_azure_ad_join = 'hybridAzureADJoin'
    azure_ad_join = 'azureADJoin'
    unknown_future_value = 'unknownFutureValue'


class CloudPcProvisioningPolicyImageType(Enum):
    gallery = 'gallery'
    custom = 'custom'
    unknown_future_value = 'unknownFutureValue'


class CloudPcProvisioningType(Enum):
    dedicated = 'dedicated'
    shared = 'shared'
    unknown_future_value = 'unknownFutureValue'


class CloudPcRegionGroup(Enum):
    default = 'default'
    australia = 'australia'
    canada = 'canada'
    us_central = 'usCentral'
    us_east = 'usEast'
    us_west = 'usWest'
    france = 'france'
    germany = 'germany'
    europe_union = 'europeUnion'
    united_kingdom = 'unitedKingdom'
    japan = 'japan'
    asia = 'asia'
    india = 'india'
    south_america = 'southAmerica'
    euap = 'euap'
    us_government = 'usGovernment'
    us_government_dod = 'usGovernmentDOD'
    norway = 'norway'
    switzerland = 'switzerland'
    south_korea = 'southKorea'
    unknown_future_value = 'unknownFutureValue'


class CloudPcRestorePointFrequencyType(Enum):
    default = 'default'
    four_hours = 'fourHours'
    six_hours = 'sixHours'
    twelve_hours = 'twelveHours'
    sixteen_hours = 'sixteenHours'
    twenty_four_hours = 'twentyFourHours'
    unknown_future_value = 'unknownFutureValue'


class CoachmarkLocationType(Enum):
    unknown = 'unknown'
    from_email = 'fromEmail'
    subject = 'subject'
    external_tag = 'externalTag'
    display_name = 'displayName'
    message_body = 'messageBody'
    unknown_future_value = 'unknownFutureValue'


class ColumnTypes(Enum):
    note = 'note'
    text = 'text'
    choice = 'choice'
    multichoice = 'multichoice'
    number = 'number'
    currency = 'currency'
    date_time = 'dateTime'
    lookup = 'lookup'
    boolean = 'boolean'
    user = 'user'
    url = 'url'
    calculated = 'calculated'
    location = 'location'
    geolocation = 'geolocation'
    term = 'term'
    multiterm = 'multiterm'
    thumbnail = 'thumbnail'
    approval_status = 'approvalStatus'
    unknown_future_value = 'unknownFutureValue'


class CommunityPrivacy(Enum):
    public = 'public'
    private = 'private'
    unknown_future_value = 'unknownFutureValue'


class ComplianceState(Enum):
    unknown = 'unknown'
    compliant = 'compliant'
    noncompliant = 'noncompliant'
    conflict = 'conflict'
    error = 'error'
    in_grace_period = 'inGracePeriod'
    config_manager = 'configManager'


class ComplianceStatus(Enum):
    unknown = 'unknown'
    not_applicable = 'notApplicable'
    compliant = 'compliant'
    remediated = 'remediated'
    non_compliant = 'nonCompliant'
    error = 'error'
    conflict = 'conflict'
    not_assigned = 'notAssigned'


class ConditionalAccessClientApp(Enum):
    all = 'all'
    browser = 'browser'
    mobile_apps_and_desktop_clients = 'mobileAppsAndDesktopClients'
    exchange_active_sync = 'exchangeActiveSync'
    eas_supported = 'easSupported'
    other = 'other'
    unknown_future_value = 'unknownFutureValue'


class ConditionalAccessDevicePlatform(Enum):
    android = 'android'
    i_os = 'iOS'
    windows = 'windows'
    windows_phone = 'windowsPhone'
    mac_os = 'macOS'
    all = 'all'
    unknown_future_value = 'unknownFutureValue'
    linux = 'linux'


class ConditionalAccessExternalTenantsMembershipKind(Enum):
    all = 'all'
    enumerated = 'enumerated'
    unknown_future_value = 'unknownFutureValue'


class ConditionalAccessGrantControl(Enum):
    block = 'block'
    mfa = 'mfa'
    compliant_device = 'compliantDevice'
    domain_joined_device = 'domainJoinedDevice'
    approved_application = 'approvedApplication'
    compliant_application = 'compliantApplication'
    password_change = 'passwordChange'
    unknown_future_value = 'unknownFutureValue'


class ConditionalAccessGuestOrExternalUserTypes(Enum):
    none = 'none'
    internal_guest = 'internalGuest'
    b2b_collaboration_guest = 'b2bCollaborationGuest'
    b2b_collaboration_member = 'b2bCollaborationMember'
    b2b_direct_connect_user = 'b2bDirectConnectUser'
    other_external_user = 'otherExternalUser'
    service_provider = 'serviceProvider'
    unknown_future_value = 'unknownFutureValue'


class ConditionalAccessInsiderRiskLevels(Enum):
    minor = 'minor'
    moderate = 'moderate'
    elevated = 'elevated'
    unknown_future_value = 'unknownFutureValue'


class ConditionalAccessPolicyState(Enum):
    enabled = 'enabled'
    disabled = 'disabled'
    enabled_for_reporting_but_not_enforced = 'enabledForReportingButNotEnforced'


class ConditionalAccessStatus(Enum):
    success = 'success'
    failure = 'failure'
    not_applied = 'notApplied'
    unknown_future_value = 'unknownFutureValue'


class ConditionalAccessTransferMethods(Enum):
    none = 'none'
    device_code_flow = 'deviceCodeFlow'
    authentication_transfer = 'authenticationTransfer'
    unknown_future_value = 'unknownFutureValue'


class ConnectedOrganizationState(Enum):
    configured = 'configured'
    proposed = 'proposed'
    unknown_future_value = 'unknownFutureValue'


class ConnectionDirection(Enum):
    unknown = 'unknown'
    inbound = 'inbound'
    outbound = 'outbound'
    unknown_future_value = 'unknownFutureValue'


class ConnectionStatus(Enum):
    unknown = 'unknown'
    attempted = 'attempted'
    succeeded = 'succeeded'
    blocked = 'blocked'
    failed = 'failed'
    unknown_future_value = 'unknownFutureValue'


class ConsentRequestFilterByCurrentUserOptions(Enum):
    reviewer = 'reviewer'
    unknown_future_value = 'unknownFutureValue'


class ContactRelationship(Enum):
    parent = 'parent'
    relative = 'relative'
    aide = 'aide'
    doctor = 'doctor'
    guardian = 'guardian'
    child = 'child'
    other = 'other'
    unknown_future_value = 'unknownFutureValue'


class CountryLookupMethodType(Enum):
    client_ip_address = 'clientIpAddress'
    authenticator_app_gps = 'authenticatorAppGps'
    unknown_future_value = 'unknownFutureValue'


class CourseStatus(Enum):
    not_started = 'notStarted'
    in_progress = 'inProgress'
    completed = 'completed'
    unknown_future_value = 'unknownFutureValue'


class CrossTenantAccessPolicyTargetConfigurationAccessType(Enum):
    allowed = 'allowed'
    blocked = 'blocked'
    unknown_future_value = 'unknownFutureValue'


class CrossTenantAccessPolicyTargetType(Enum):
    user = 'user'
    group = 'group'
    application = 'application'
    unknown_future_value = 'unknownFutureValue'


class CustomExtensionCalloutInstanceStatus(Enum):
    callout_sent = 'calloutSent'
    callback_received = 'callbackReceived'
    callout_failed = 'calloutFailed'
    callback_timed_out = 'callbackTimedOut'
    waiting_for_callback = 'waitingForCallback'
    unknown_future_value = 'unknownFutureValue'


class DataPolicyOperationStatus(Enum):
    not_started = 'notStarted'
    running = 'running'
    complete = 'complete'
    failed = 'failed'
    unknown_future_value = 'unknownFutureValue'


class DataSubjectType(Enum):
    customer = 'customer'
    current_employee = 'currentEmployee'
    former_employee = 'formerEmployee'
    prospective_employee = 'prospectiveEmployee'
    student = 'student'
    teacher = 'teacher'
    faculty = 'faculty'
    other = 'other'
    unknown_future_value = 'unknownFutureValue'


class DayOfWeek(Enum):
    sunday = 'sunday'
    monday = 'monday'
    tuesday = 'tuesday'
    wednesday = 'wednesday'
    thursday = 'thursday'
    friday = 'friday'
    saturday = 'saturday'


class DefenderCloudBlockLevelType(Enum):
    not_configured = 'notConfigured'
    high = 'high'
    high_plus = 'highPlus'
    zero_tolerance = 'zeroTolerance'


class DefenderMonitorFileActivity(Enum):
    user_defined = 'userDefined'
    disable = 'disable'
    monitor_all_files = 'monitorAllFiles'
    monitor_incoming_files_only = 'monitorIncomingFilesOnly'
    monitor_outgoing_files_only = 'monitorOutgoingFilesOnly'


class DefenderPromptForSampleSubmission(Enum):
    user_defined = 'userDefined'
    always_prompt = 'alwaysPrompt'
    prompt_before_sending_personal_data = 'promptBeforeSendingPersonalData'
    never_send_data = 'neverSendData'
    send_all_data_without_prompting = 'sendAllDataWithoutPrompting'


class DefenderScanType(Enum):
    user_defined = 'userDefined'
    disabled = 'disabled'
    quick = 'quick'
    full = 'full'


class DefenderThreatAction(Enum):
    device_default = 'deviceDefault'
    clean = 'clean'
    quarantine = 'quarantine'
    remove = 'remove'
    allow = 'allow'
    user_defined = 'userDefined'
    block = 'block'


class DelegatedAdminAccessAssignmentStatus(Enum):
    pending = 'pending'
    active = 'active'
    deleting = 'deleting'
    deleted = 'deleted'
    error = 'error'
    unknown_future_value = 'unknownFutureValue'


class DelegatedAdminAccessContainerType(Enum):
    security_group = 'securityGroup'
    unknown_future_value = 'unknownFutureValue'


class DelegatedAdminRelationshipOperationType(Enum):
    delegated_admin_access_assignment_update = 'delegatedAdminAccessAssignmentUpdate'
    unknown_future_value = 'unknownFutureValue'
    delegated_admin_relationship_update = 'delegatedAdminRelationshipUpdate'


class DelegatedAdminRelationshipRequestAction(Enum):
    lock_for_approval = 'lockForApproval'
    approve = 'approve'
    terminate = 'terminate'
    unknown_future_value = 'unknownFutureValue'
    reject = 'reject'


class DelegatedAdminRelationshipRequestStatus(Enum):
    created = 'created'
    pending = 'pending'
    succeeded = 'succeeded'
    failed = 'failed'
    unknown_future_value = 'unknownFutureValue'


class DelegatedAdminRelationshipStatus(Enum):
    activating = 'activating'
    active = 'active'
    approval_pending = 'approvalPending'
    approved = 'approved'
    created = 'created'
    expired = 'expired'
    expiring = 'expiring'
    terminated = 'terminated'
    terminating = 'terminating'
    termination_requested = 'terminationRequested'
    unknown_future_value = 'unknownFutureValue'


class DelegateMeetingMessageDeliveryOptions(Enum):
    send_to_delegate_and_information_to_principal = (
        'sendToDelegateAndInformationToPrincipal'
    )
    send_to_delegate_and_principal = 'sendToDelegateAndPrincipal'
    send_to_delegate_only = 'sendToDelegateOnly'


class DestinationType(Enum):
    new = 'new'
    in_place = 'inPlace'
    unknown_future_value = 'unknownFutureValue'


class DetectedAppPlatformType(Enum):
    unknown = 'unknown'
    windows = 'windows'
    windows_mobile = 'windowsMobile'
    windows_holographic = 'windowsHolographic'
    ios = 'ios'
    mac_os = 'macOS'
    chrome_os = 'chromeOS'
    android_osp = 'androidOSP'
    android_device_administrator = 'androidDeviceAdministrator'
    android_work_profile = 'androidWorkProfile'
    android_dedicated_and_fully_managed = 'androidDedicatedAndFullyManaged'
    unknown_future_value = 'unknownFutureValue'


class DeviceComplianceActionType(Enum):
    no_action = 'noAction'
    notification = 'notification'
    block = 'block'
    retire = 'retire'
    wipe = 'wipe'
    remove_resource_access_profiles = 'removeResourceAccessProfiles'
    push_notification = 'pushNotification'


class DeviceEnrollmentFailureReason(Enum):
    unknown = 'unknown'
    authentication = 'authentication'
    authorization = 'authorization'
    account_validation = 'accountValidation'
    user_validation = 'userValidation'
    device_not_supported = 'deviceNotSupported'
    in_maintenance = 'inMaintenance'
    bad_request = 'badRequest'
    feature_not_supported = 'featureNotSupported'
    enrollment_restrictions_enforced = 'enrollmentRestrictionsEnforced'
    client_disconnected = 'clientDisconnected'
    user_abandonment = 'userAbandonment'


class DeviceEnrollmentType(Enum):
    unknown = 'unknown'
    user_enrollment = 'userEnrollment'
    device_enrollment_manager = 'deviceEnrollmentManager'
    apple_bulk_with_user = 'appleBulkWithUser'
    apple_bulk_without_user = 'appleBulkWithoutUser'
    windows_azure_ad_join = 'windowsAzureADJoin'
    windows_bulk_userless = 'windowsBulkUserless'
    windows_auto_enrollment = 'windowsAutoEnrollment'
    windows_bulk_azure_domain_join = 'windowsBulkAzureDomainJoin'
    windows_co_management = 'windowsCoManagement'
    windows_azure_ad_join_using_device_auth = 'windowsAzureADJoinUsingDeviceAuth'
    apple_user_enrollment = 'appleUserEnrollment'
    apple_user_enrollment_with_service_account = 'appleUserEnrollmentWithServiceAccount'


class DeviceLogCollectionTemplateType(Enum):
    predefined = 'predefined'
    unknown_future_value = 'unknownFutureValue'


class DeviceManagementExchangeAccessState(Enum):
    none = 'none'
    unknown = 'unknown'
    allowed = 'allowed'
    blocked = 'blocked'
    quarantined = 'quarantined'


class DeviceManagementExchangeAccessStateReason(Enum):
    none = 'none'
    unknown = 'unknown'
    exchange_global_rule = 'exchangeGlobalRule'
    exchange_individual_rule = 'exchangeIndividualRule'
    exchange_device_rule = 'exchangeDeviceRule'
    exchange_upgrade = 'exchangeUpgrade'
    exchange_mailbox_policy = 'exchangeMailboxPolicy'
    other = 'other'
    compliant = 'compliant'
    not_compliant = 'notCompliant'
    not_enrolled = 'notEnrolled'
    unknown_location = 'unknownLocation'
    mfa_required = 'mfaRequired'
    azure_ad_block_due_to_access_policy = 'azureADBlockDueToAccessPolicy'
    compromised_password = 'compromisedPassword'
    device_not_known_with_managed_app = 'deviceNotKnownWithManagedApp'


class DeviceManagementExchangeConnectorStatus(Enum):
    none = 'none'
    connection_pending = 'connectionPending'
    connected = 'connected'
    disconnected = 'disconnected'
    unknown_future_value = 'unknownFutureValue'


class DeviceManagementExchangeConnectorSyncType(Enum):
    full_sync = 'fullSync'
    delta_sync = 'deltaSync'


class DeviceManagementExchangeConnectorType(Enum):
    on_premises = 'onPremises'
    hosted = 'hosted'
    service_to_service = 'serviceToService'
    dedicated = 'dedicated'
    unknown_future_value = 'unknownFutureValue'


class DeviceManagementExportJobLocalizationType(Enum):
    localized_values_as_additional_column = 'localizedValuesAsAdditionalColumn'
    replace_localizable_values = 'replaceLocalizableValues'


class DeviceManagementPartnerAppType(Enum):
    unknown = 'unknown'
    single_tenant_app = 'singleTenantApp'
    multi_tenant_app = 'multiTenantApp'


class DeviceManagementPartnerTenantState(Enum):
    unknown = 'unknown'
    unavailable = 'unavailable'
    enabled = 'enabled'
    terminated = 'terminated'
    rejected = 'rejected'
    unresponsive = 'unresponsive'


class DeviceManagementReportFileFormat(Enum):
    csv = 'csv'
    pdf = 'pdf'
    json = 'json'
    unknown_future_value = 'unknownFutureValue'


class DeviceManagementReportStatus(Enum):
    unknown = 'unknown'
    not_started = 'notStarted'
    in_progress = 'inProgress'
    completed = 'completed'
    failed = 'failed'


class DeviceManagementSubscriptionState(Enum):
    pending = 'pending'
    active = 'active'
    warning = 'warning'
    disabled = 'disabled'
    deleted = 'deleted'
    blocked = 'blocked'
    locked_out = 'lockedOut'


class DevicePlatformType(Enum):
    android = 'android'
    android_for_work = 'androidForWork'
    i_os = 'iOS'
    mac_os = 'macOS'
    windows_phone81 = 'windowsPhone81'
    windows81_and_later = 'windows81AndLater'
    windows10_and_later = 'windows10AndLater'
    android_work_profile = 'androidWorkProfile'
    unknown = 'unknown'
    android_aosp = 'androidAOSP'
    android_mobile_application_management = 'androidMobileApplicationManagement'
    i_os_mobile_application_management = 'iOSMobileApplicationManagement'
    unknown_future_value = 'unknownFutureValue'


class DeviceRegistrationState(Enum):
    not_registered = 'notRegistered'
    registered = 'registered'
    revoked = 'revoked'
    key_conflict = 'keyConflict'
    approval_pending = 'approvalPending'
    certificate_reset = 'certificateReset'
    not_registered_pending_enrollment = 'notRegisteredPendingEnrollment'
    unknown = 'unknown'


class DeviceThreatProtectionLevel(Enum):
    unavailable = 'unavailable'
    secured = 'secured'
    low = 'low'
    medium = 'medium'
    high = 'high'
    not_set = 'notSet'


class DiagnosticDataSubmissionMode(Enum):
    user_defined = 'userDefined'
    none = 'none'
    basic = 'basic'
    enhanced = 'enhanced'
    full = 'full'


class DirectoryDefinitionDiscoverabilities(Enum):
    none = 'None'
    attribute_names = 'AttributeNames'
    attribute_data_types = 'AttributeDataTypes'
    attribute_read_only = 'AttributeReadOnly'
    reference_attributes = 'ReferenceAttributes'
    unknown_future_value = 'UnknownFutureValue'


class DisableReason(Enum):
    none = 'none'
    invalid_billing_profile = 'invalidBillingProfile'
    user_requested = 'userRequested'
    unknown_future_value = 'unknownFutureValue'


class DiskType(Enum):
    unknown = 'unknown'
    hdd = 'hdd'
    ssd = 'ssd'
    unknown_future_value = 'unknownFutureValue'


class DriveItemSourceApplication(Enum):
    teams = 'teams'
    yammer = 'yammer'
    share_point = 'sharePoint'
    one_drive = 'oneDrive'
    stream = 'stream'
    power_point = 'powerPoint'
    office = 'office'
    loki = 'loki'
    loop = 'loop'
    other = 'other'
    unknown_future_value = 'unknownFutureValue'


class EdgeCookiePolicy(Enum):
    user_defined = 'userDefined'
    allow = 'allow'
    block_third_party = 'blockThirdParty'
    block_all = 'blockAll'


class EdgeSearchEngineType(Enum):
    default = 'default'
    bing = 'bing'


class EditionUpgradeLicenseType(Enum):
    product_key = 'productKey'
    license_file = 'licenseFile'


class EducationAddedStudentAction(Enum):
    none = 'none'
    assign_if_open = 'assignIfOpen'
    unknown_future_value = 'unknownFutureValue'


class EducationAddToCalendarOptions(Enum):
    none = 'none'
    students_and_publisher = 'studentsAndPublisher'
    students_and_team_owners = 'studentsAndTeamOwners'
    unknown_future_value = 'unknownFutureValue'
    students_only = 'studentsOnly'


class EducationAssignmentStatus(Enum):
    draft = 'draft'
    published = 'published'
    assigned = 'assigned'
    unknown_future_value = 'unknownFutureValue'
    inactive = 'inactive'


class EducationExternalSource(Enum):
    sis = 'sis'
    manual = 'manual'
    unknown_future_value = 'unknownFutureValue'


class EducationFeedbackResourceOutcomeStatus(Enum):
    not_published = 'notPublished'
    pending_publish = 'pendingPublish'
    published = 'published'
    failed_publish = 'failedPublish'
    unknown_future_value = 'unknownFutureValue'


class EducationGender(Enum):
    female = 'female'
    male = 'male'
    other = 'other'
    unknown_future_value = 'unknownFutureValue'


class EducationModuleStatus(Enum):
    draft = 'draft'
    published = 'published'
    unknown_future_value = 'unknownFutureValue'


class EducationSubmissionStatus(Enum):
    working = 'working'
    submitted = 'submitted'
    released = 'released'
    returned = 'returned'
    unknown_future_value = 'unknownFutureValue'
    reassigned = 'reassigned'
    excused = 'excused'


class EducationUserRole(Enum):
    student = 'student'
    teacher = 'teacher'
    none = 'none'
    unknown_future_value = 'unknownFutureValue'


class EligibilityFilteringEnabledEntities(Enum):
    none = 'none'
    swap_request = 'swapRequest'
    offer_shift_request = 'offerShiftRequest'
    unknown_future_value = 'unknownFutureValue'
    time_off_reason = 'timeOffReason'


class EligibilityScheduleFilterByCurrentUserOptions(Enum):
    principal = 'principal'
    unknown_future_value = 'unknownFutureValue'


class EligibilityScheduleInstanceFilterByCurrentUserOptions(Enum):
    principal = 'principal'
    unknown_future_value = 'unknownFutureValue'


class EligibilityScheduleRequestFilterByCurrentUserOptions(Enum):
    principal = 'principal'
    created_by = 'createdBy'
    approver = 'approver'
    unknown_future_value = 'unknownFutureValue'


class EmailRole(Enum):
    unknown = 'unknown'
    sender = 'sender'
    recipient = 'recipient'
    unknown_future_value = 'unknownFutureValue'


class Enablement(Enum):
    not_configured = 'notConfigured'
    enabled = 'enabled'
    disabled = 'disabled'


class EndpointType(Enum):
    default = 'default'
    voicemail = 'voicemail'
    skype_for_business = 'skypeForBusiness'
    skype_for_business_voip_phone = 'skypeForBusinessVoipPhone'
    unknown_future_value = 'unknownFutureValue'


class EndUserNotificationPreference(Enum):
    unknown = 'unknown'
    microsoft = 'microsoft'
    custom = 'custom'
    unknown_future_value = 'unknownFutureValue'


class EndUserNotificationSettingType(Enum):
    unknown = 'unknown'
    no_training = 'noTraining'
    training_selected = 'trainingSelected'
    no_notification = 'noNotification'
    unknown_future_value = 'unknownFutureValue'


class EndUserNotificationType(Enum):
    unknown = 'unknown'
    positive_reinforcement = 'positiveReinforcement'
    no_training = 'noTraining'
    training_assignment = 'trainingAssignment'
    training_reminder = 'trainingReminder'
    unknown_future_value = 'unknownFutureValue'


class EngagementAsyncOperationType(Enum):
    create_community = 'createCommunity'
    unknown_future_value = 'unknownFutureValue'


class EnrollmentState(Enum):
    unknown = 'unknown'
    enrolled = 'enrolled'
    pending_reset = 'pendingReset'
    failed = 'failed'
    not_contacted = 'notContacted'


class EntityType(Enum):
    event = 'event'
    message = 'message'
    drive_item = 'driveItem'
    external_item = 'externalItem'
    site = 'site'
    list = 'list'
    list_item = 'listItem'
    drive = 'drive'
    unknown_future_value = 'unknownFutureValue'
    chat_message = 'chatMessage'
    person = 'person'
    acronym = 'acronym'
    bookmark = 'bookmark'


class EntryExportStatus(Enum):
    noop = 'Noop'
    success = 'Success'
    retryable_error = 'RetryableError'
    permanent_error = 'PermanentError'
    error = 'Error'


class EntrySyncOperation(Enum):
    none = 'None'
    add = 'Add'
    delete = 'Delete'
    update = 'Update'


class EscrowBehavior(Enum):
    default = 'Default'
    ignore_lookup_reference_resolution_failure = (
        'IgnoreLookupReferenceResolutionFailure'
    )


class EventType(Enum):
    single_instance = 'singleInstance'
    occurrence = 'occurrence'
    exception = 'exception'
    series_master = 'seriesMaster'


class ExchangeIdFormat(Enum):
    entry_id = 'entryId'
    ews_id = 'ewsId'
    immutable_entry_id = 'immutableEntryId'
    rest_id = 'restId'
    rest_immutable_entry_id = 'restImmutableEntryId'


class ExpirationPatternType(Enum):
    not_specified = 'notSpecified'
    no_expiration = 'noExpiration'
    after_date_time = 'afterDateTime'
    after_duration = 'afterDuration'


class ExternalAudienceScope(Enum):
    none = 'none'
    contacts_only = 'contactsOnly'
    all = 'all'


class ExternalEmailOtpState(Enum):
    default = 'default'
    enabled = 'enabled'
    disabled = 'disabled'
    unknown_future_value = 'unknownFutureValue'


class FeatureTargetType(Enum):
    group = 'group'
    administrative_unit = 'administrativeUnit'
    role = 'role'
    unknown_future_value = 'unknownFutureValue'


class FeatureType(Enum):
    registration = 'registration'
    reset = 'reset'
    unknown_future_value = 'unknownFutureValue'


class FederatedIdpMfaBehavior(Enum):
    accept_if_mfa_done_by_federated_idp = 'acceptIfMfaDoneByFederatedIdp'
    enforce_mfa_by_federated_idp = 'enforceMfaByFederatedIdp'
    reject_mfa_by_federated_idp = 'rejectMfaByFederatedIdp'
    unknown_future_value = 'unknownFutureValue'


class Fido2RestrictionEnforcementType(Enum):
    allow = 'allow'
    block = 'block'
    unknown_future_value = 'unknownFutureValue'


class FileHashType(Enum):
    unknown = 'unknown'
    sha1 = 'sha1'
    sha256 = 'sha256'
    md5 = 'md5'
    authenticode_hash256 = 'authenticodeHash256'
    ls_hash = 'lsHash'
    ctph = 'ctph'
    unknown_future_value = 'unknownFutureValue'


class FileStorageContainerStatus(Enum):
    inactive = 'inactive'
    active = 'active'
    unknown_future_value = 'unknownFutureValue'


class FilterMode(Enum):
    include = 'include'
    exclude = 'exclude'


class FirewallCertificateRevocationListCheckMethodType(Enum):
    device_default = 'deviceDefault'
    none = 'none'
    attempt = 'attempt'
    require = 'require'


class FirewallPacketQueueingMethodType(Enum):
    device_default = 'deviceDefault'
    disabled = 'disabled'
    queue_inbound = 'queueInbound'
    queue_outbound = 'queueOutbound'
    queue_both = 'queueBoth'


class FirewallPreSharedKeyEncodingMethodType(Enum):
    device_default = 'deviceDefault'
    none = 'none'
    ut_f8 = 'utF8'


class FollowupFlagStatus(Enum):
    not_flagged = 'notFlagged'
    complete = 'complete'
    flagged = 'flagged'


class FreeBusyStatus(Enum):
    unknown = 'unknown'
    free = 'free'
    tentative = 'tentative'
    busy = 'busy'
    oof = 'oof'
    working_elsewhere = 'workingElsewhere'


class GiphyRatingType(Enum):
    strict = 'strict'
    moderate = 'moderate'
    unknown_future_value = 'unknownFutureValue'


class GroupType(Enum):
    unified_groups = 'unifiedGroups'
    azure_ad = 'azureAD'
    unknown_future_value = 'unknownFutureValue'


class HorizontalSectionLayoutType(Enum):
    none = 'none'
    one_column = 'oneColumn'
    two_columns = 'twoColumns'
    three_columns = 'threeColumns'
    one_third_left_column = 'oneThirdLeftColumn'
    one_third_right_column = 'oneThirdRightColumn'
    full_width = 'fullWidth'
    unknown_future_value = 'unknownFutureValue'


class IdentityUserFlowAttributeDataType(Enum):
    string = 'string'
    boolean = 'boolean'
    int64 = 'int64'
    string_collection = 'stringCollection'
    date_time = 'dateTime'
    unknown_future_value = 'unknownFutureValue'


class IdentityUserFlowAttributeInputType(Enum):
    text_box = 'textBox'
    date_time_dropdown = 'dateTimeDropdown'
    radio_single_select = 'radioSingleSelect'
    dropdown_single_select = 'dropdownSingleSelect'
    email_box = 'emailBox'
    checkbox_multi_select = 'checkboxMultiSelect'


class IdentityUserFlowAttributeType(Enum):
    built_in = 'builtIn'
    custom = 'custom'
    required = 'required'
    unknown_future_value = 'unknownFutureValue'


class ImageTaggingChoice(Enum):
    disabled = 'disabled'
    basic = 'basic'
    enhanced = 'enhanced'
    unknown_future_value = 'unknownFutureValue'


class Importance(Enum):
    low = 'low'
    normal = 'normal'
    high = 'high'


class ImportedWindowsAutopilotDeviceIdentityImportStatus(Enum):
    unknown = 'unknown'
    pending = 'pending'
    partial = 'partial'
    complete = 'complete'
    error = 'error'


class ImportedWindowsAutopilotDeviceIdentityUploadStatus(Enum):
    no_upload = 'noUpload'
    pending = 'pending'
    complete = 'complete'
    error = 'error'


class IncludedUserRoles(Enum):
    all = 'all'
    privileged_admin = 'privilegedAdmin'
    admin = 'admin'
    user = 'user'
    unknown_future_value = 'unknownFutureValue'


class IncludedUserTypes(Enum):
    all = 'all'
    member = 'member'
    guest = 'guest'
    unknown_future_value = 'unknownFutureValue'


class InferenceClassificationType(Enum):
    focused = 'focused'
    other = 'other'


class InitiatorType(Enum):
    user = 'user'
    application = 'application'
    system = 'system'
    unknown_future_value = 'unknownFutureValue'


class InstallIntent(Enum):
    available = 'available'
    required = 'required'
    uninstall = 'uninstall'
    available_without_enrollment = 'availableWithoutEnrollment'


class InstallState(Enum):
    not_applicable = 'notApplicable'
    installed = 'installed'
    failed = 'failed'
    not_installed = 'notInstalled'
    uninstall_failed = 'uninstallFailed'
    unknown = 'unknown'


class InternetSiteSecurityLevel(Enum):
    user_defined = 'userDefined'
    medium = 'medium'
    medium_high = 'mediumHigh'
    high = 'high'


class IosNotificationAlertType(Enum):
    device_default = 'deviceDefault'
    banner = 'banner'
    modal = 'modal'
    none = 'none'


class IosUpdatesInstallStatus(Enum):
    device_os_higher_than_desired_os_version = 'deviceOsHigherThanDesiredOsVersion'
    shared_device_user_logged_in_error = 'sharedDeviceUserLoggedInError'
    not_supported_operation = 'notSupportedOperation'
    install_failed = 'installFailed'
    install_phone_call_in_progress = 'installPhoneCallInProgress'
    install_insufficient_power = 'installInsufficientPower'
    install_insufficient_space = 'installInsufficientSpace'
    installing = 'installing'
    download_insufficient_network = 'downloadInsufficientNetwork'
    download_insufficient_power = 'downloadInsufficientPower'
    download_insufficient_space = 'downloadInsufficientSpace'
    download_requires_computer = 'downloadRequiresComputer'
    download_failed = 'downloadFailed'
    downloading = 'downloading'
    success = 'success'
    available = 'available'
    idle = 'idle'
    unknown = 'unknown'


class LayoutTemplateType(Enum):
    default = 'default'
    vertical_split = 'verticalSplit'
    unknown_future_value = 'unknownFutureValue'


class Level(Enum):
    beginner = 'beginner'
    intermediate = 'intermediate'
    advanced = 'advanced'
    unknown_future_value = 'unknownFutureValue'


class LifecycleEventType(Enum):
    missed = 'missed'
    subscription_removed = 'subscriptionRemoved'
    reauthorization_required = 'reauthorizationRequired'


class LobbyBypassScope(Enum):
    organizer = 'organizer'
    organization = 'organization'
    organization_and_federated = 'organizationAndFederated'
    everyone = 'everyone'
    unknown_future_value = 'unknownFutureValue'
    invited = 'invited'
    organization_excluding_guests = 'organizationExcludingGuests'


class LocationType(Enum):
    default = 'default'
    conference_room = 'conferenceRoom'
    home_address = 'homeAddress'
    business_address = 'businessAddress'
    geo_coordinates = 'geoCoordinates'
    street_address = 'streetAddress'
    hotel = 'hotel'
    restaurant = 'restaurant'
    local_business = 'localBusiness'
    postal_address = 'postalAddress'


class LocationUniqueIdType(Enum):
    unknown = 'unknown'
    location_store = 'locationStore'
    directory = 'directory'
    private = 'private'
    bing = 'bing'


class LogonType(Enum):
    unknown = 'unknown'
    interactive = 'interactive'
    remote_interactive = 'remoteInteractive'
    network = 'network'
    batch = 'batch'
    service = 'service'
    unknown_future_value = 'unknownFutureValue'


class LongRunningOperationStatus(Enum):
    not_started = 'notStarted'
    running = 'running'
    succeeded = 'succeeded'
    failed = 'failed'
    unknown_future_value = 'unknownFutureValue'


class MailDestinationRoutingReason(Enum):
    none = 'none'
    mail_flow_rule = 'mailFlowRule'
    safe_sender = 'safeSender'
    blocked_sender = 'blockedSender'
    advanced_spam_filtering = 'advancedSpamFiltering'
    domain_allow_list = 'domainAllowList'
    domain_block_list = 'domainBlockList'
    not_in_address_book = 'notInAddressBook'
    first_time_sender = 'firstTimeSender'
    auto_purge_to_inbox = 'autoPurgeToInbox'
    auto_purge_to_junk = 'autoPurgeToJunk'
    auto_purge_to_deleted = 'autoPurgeToDeleted'
    outbound = 'outbound'
    not_junk = 'notJunk'
    junk = 'junk'
    unknown_future_value = 'unknownFutureValue'


class MailTipsType(Enum):
    automatic_replies = 'automaticReplies'
    mailbox_full_status = 'mailboxFullStatus'
    custom_mail_tip = 'customMailTip'
    external_member_count = 'externalMemberCount'
    total_member_count = 'totalMemberCount'
    max_message_size = 'maxMessageSize'
    delivery_restriction = 'deliveryRestriction'
    moderation_status = 'moderationStatus'
    recipient_scope = 'recipientScope'
    recipient_suggestions = 'recipientSuggestions'


class ManagedAppAvailability(Enum):
    global_ = 'global'
    line_of_business = 'lineOfBusiness'


class ManagedAppClipboardSharingLevel(Enum):
    all_apps = 'allApps'
    managed_apps_with_paste_in = 'managedAppsWithPasteIn'
    managed_apps = 'managedApps'
    blocked = 'blocked'


class ManagedAppDataEncryptionType(Enum):
    use_device_settings = 'useDeviceSettings'
    after_device_restart = 'afterDeviceRestart'
    when_device_locked_except_open_files = 'whenDeviceLockedExceptOpenFiles'
    when_device_locked = 'whenDeviceLocked'


class ManagedAppDataStorageLocation(Enum):
    one_drive_for_business = 'oneDriveForBusiness'
    share_point = 'sharePoint'
    box = 'box'
    local_storage = 'localStorage'


class ManagedAppDataTransferLevel(Enum):
    all_apps = 'allApps'
    managed_apps = 'managedApps'
    none = 'none'


class ManagedAppFlaggedReason(Enum):
    none = 'none'
    rooted_device = 'rootedDevice'


class ManagedAppPinCharacterSet(Enum):
    numeric = 'numeric'
    alphanumeric_and_symbol = 'alphanumericAndSymbol'


class ManagedBrowserType(Enum):
    not_configured = 'notConfigured'
    microsoft_edge = 'microsoftEdge'


class ManagedDeviceOwnerType(Enum):
    unknown = 'unknown'
    company = 'company'
    personal = 'personal'
    unknown_future_value = 'unknownFutureValue'


class ManagedDevicePartnerReportedHealthState(Enum):
    unknown = 'unknown'
    activated = 'activated'
    deactivated = 'deactivated'
    secured = 'secured'
    low_severity = 'lowSeverity'
    medium_severity = 'mediumSeverity'
    high_severity = 'highSeverity'
    unresponsive = 'unresponsive'
    compromised = 'compromised'
    misconfigured = 'misconfigured'


class ManagementAgentType(Enum):
    eas = 'eas'
    mdm = 'mdm'
    eas_mdm = 'easMdm'
    intune_client = 'intuneClient'
    eas_intune_client = 'easIntuneClient'
    configuration_manager_client = 'configurationManagerClient'
    configuration_manager_client_mdm = 'configurationManagerClientMdm'
    configuration_manager_client_mdm_eas = 'configurationManagerClientMdmEas'
    unknown = 'unknown'
    jamf = 'jamf'
    google_cloud_device_policy_controller = 'googleCloudDevicePolicyController'
    microsoft365_managed_mdm = 'microsoft365ManagedMdm'
    ms_sense = 'msSense'


class MdmAppConfigKeyType(Enum):
    string_type = 'stringType'
    integer_type = 'integerType'
    real_type = 'realType'
    boolean_type = 'booleanType'
    token_type = 'tokenType'


class MdmAuthority(Enum):
    unknown = 'unknown'
    intune = 'intune'
    sccm = 'sccm'
    office365 = 'office365'


class MediaDirection(Enum):
    inactive = 'inactive'
    send_only = 'sendOnly'
    receive_only = 'receiveOnly'
    send_receive = 'sendReceive'


class MediaSourceContentCategory(Enum):
    meeting = 'meeting'
    live_stream = 'liveStream'
    presentation = 'presentation'
    screen_recording = 'screenRecording'
    story = 'story'
    profile = 'profile'
    chat = 'chat'
    note = 'note'
    comment = 'comment'
    unknown_future_value = 'unknownFutureValue'


class MediaState(Enum):
    active = 'active'
    inactive = 'inactive'
    unknown_future_value = 'unknownFutureValue'


class MeetingAudience(Enum):
    everyone = 'everyone'
    organization = 'organization'
    unknown_future_value = 'unknownFutureValue'


class MeetingChatHistoryDefaultMode(Enum):
    none = 'none'
    all = 'all'
    unknown_future_value = 'unknownFutureValue'


class MeetingChatMode(Enum):
    enabled = 'enabled'
    disabled = 'disabled'
    limited = 'limited'
    unknown_future_value = 'unknownFutureValue'


class MeetingMessageType(Enum):
    none = 'none'
    meeting_request = 'meetingRequest'
    meeting_cancelled = 'meetingCancelled'
    meeting_accepted = 'meetingAccepted'
    meeting_tenatively_accepted = 'meetingTenativelyAccepted'
    meeting_declined = 'meetingDeclined'


class MeetingRequestType(Enum):
    none = 'none'
    new_meeting_request = 'newMeetingRequest'
    full_update = 'fullUpdate'
    informational_update = 'informationalUpdate'
    silent_update = 'silentUpdate'
    outdated = 'outdated'
    principal_wants_copy = 'principalWantsCopy'


class MessageActionFlag(Enum):
    any = 'any'
    call = 'call'
    do_not_forward = 'doNotForward'
    follow_up = 'followUp'
    fyi = 'fyi'
    forward = 'forward'
    no_response_necessary = 'noResponseNecessary'
    read = 'read'
    reply = 'reply'
    reply_to_all = 'replyToAll'
    review = 'review'


class MicrosoftAuthenticatorAuthenticationMode(Enum):
    device_based_push = 'deviceBasedPush'
    push = 'push'
    any = 'any'


class MicrosoftEdgeChannel(Enum):
    dev = 'dev'
    beta = 'beta'
    stable = 'stable'
    unknown_future_value = 'unknownFutureValue'


class MicrosoftManagedDesktopType(Enum):
    not_managed = 'notManaged'
    premium_managed = 'premiumManaged'
    standard_managed = 'standardManaged'
    starter_managed = 'starterManaged'
    unknown_future_value = 'unknownFutureValue'


class MicrosoftStoreForBusinessLicenseType(Enum):
    offline = 'offline'
    online = 'online'


class MigrationStatus(Enum):
    ready = 'ready'
    needs_review = 'needsReview'
    additional_steps_required = 'additionalStepsRequired'
    unknown_future_value = 'unknownFutureValue'


class MiracastChannel(Enum):
    user_defined = 'userDefined'
    one = 'one'
    two = 'two'
    three = 'three'
    four = 'four'
    five = 'five'
    six = 'six'
    seven = 'seven'
    eight = 'eight'
    nine = 'nine'
    ten = 'ten'
    eleven = 'eleven'
    thirty_six = 'thirtySix'
    forty = 'forty'
    forty_four = 'fortyFour'
    forty_eight = 'fortyEight'
    one_hundred_forty_nine = 'oneHundredFortyNine'
    one_hundred_fifty_three = 'oneHundredFiftyThree'
    one_hundred_fifty_seven = 'oneHundredFiftySeven'
    one_hundred_sixty_one = 'oneHundredSixtyOne'
    one_hundred_sixty_five = 'oneHundredSixtyFive'


class MobileAppContentFileUploadState(Enum):
    success = 'success'
    transient_error = 'transientError'
    error = 'error'
    unknown = 'unknown'
    azure_storage_uri_request_success = 'azureStorageUriRequestSuccess'
    azure_storage_uri_request_pending = 'azureStorageUriRequestPending'
    azure_storage_uri_request_failed = 'azureStorageUriRequestFailed'
    azure_storage_uri_request_timed_out = 'azureStorageUriRequestTimedOut'
    azure_storage_uri_renewal_success = 'azureStorageUriRenewalSuccess'
    azure_storage_uri_renewal_pending = 'azureStorageUriRenewalPending'
    azure_storage_uri_renewal_failed = 'azureStorageUriRenewalFailed'
    azure_storage_uri_renewal_timed_out = 'azureStorageUriRenewalTimedOut'
    commit_file_success = 'commitFileSuccess'
    commit_file_pending = 'commitFilePending'
    commit_file_failed = 'commitFileFailed'
    commit_file_timed_out = 'commitFileTimedOut'


class MobileAppPublishingState(Enum):
    not_published = 'notPublished'
    processing = 'processing'
    published = 'published'


class MobileThreatPartnerTenantState(Enum):
    unavailable = 'unavailable'
    available = 'available'
    enabled = 'enabled'
    unresponsive = 'unresponsive'
    unknown_future_value = 'unknownFutureValue'


class Modality(Enum):
    audio = 'audio'
    video = 'video'
    video_based_screen_sharing = 'videoBasedScreenSharing'
    data = 'data'
    unknown_future_value = 'unknownFutureValue'


class MultiFactorAuthConfiguration(Enum):
    not_required = 'notRequired'
    required = 'required'
    unknown_future_value = 'unknownFutureValue'


class MultiTenantOrganizationMemberProcessingStatus(Enum):
    not_started = 'notStarted'
    running = 'running'
    succeeded = 'succeeded'
    failed = 'failed'
    unknown_future_value = 'unknownFutureValue'


class MultiTenantOrganizationMemberRole(Enum):
    owner = 'owner'
    member = 'member'
    unknown_future_value = 'unknownFutureValue'


class MultiTenantOrganizationMemberState(Enum):
    pending = 'pending'
    active = 'active'
    removed = 'removed'
    unknown_future_value = 'unknownFutureValue'


class MultiTenantOrganizationState(Enum):
    active = 'active'
    inactive = 'inactive'
    unknown_future_value = 'unknownFutureValue'


class Mutability(Enum):
    read_write = 'ReadWrite'
    read_only = 'ReadOnly'
    immutable = 'Immutable'
    write_only = 'WriteOnly'


class NativeAuthenticationApisEnabled(Enum):
    none = 'none'
    all = 'all'
    unknown_future_value = 'unknownFutureValue'


class NotificationDeliveryFrequency(Enum):
    unknown = 'unknown'
    weekly = 'weekly'
    bi_weekly = 'biWeekly'
    unknown_future_value = 'unknownFutureValue'


class NotificationDeliveryPreference(Enum):
    unknown = 'unknown'
    deliver_immedietly = 'deliverImmedietly'
    deliver_after_campaign_end = 'deliverAfterCampaignEnd'
    unknown_future_value = 'unknownFutureValue'


class NotificationTemplateBrandingOptions(Enum):
    none = 'none'
    include_company_logo = 'includeCompanyLogo'
    include_company_name = 'includeCompanyName'
    include_contact_information = 'includeContactInformation'
    include_company_portal_link = 'includeCompanyPortalLink'
    include_device_details = 'includeDeviceDetails'
    unknown_future_value = 'unknownFutureValue'


class OAuthAppScope(Enum):
    unknown = 'unknown'
    read_calendar = 'readCalendar'
    read_contact = 'readContact'
    read_mail = 'readMail'
    read_all_chat = 'readAllChat'
    read_all_file = 'readAllFile'
    read_and_write_mail = 'readAndWriteMail'
    send_mail = 'sendMail'
    unknown_future_value = 'unknownFutureValue'


class ObjectDefinitionMetadata(Enum):
    property_name_account_enabled = 'PropertyNameAccountEnabled'
    property_name_soft_deleted = 'PropertyNameSoftDeleted'
    is_soft_deletion_supported = 'IsSoftDeletionSupported'
    is_synchronize_all_supported = 'IsSynchronizeAllSupported'
    connector_data_storage_required = 'ConnectorDataStorageRequired'
    extensions = 'Extensions'
    base_object_name = 'BaseObjectName'


class ObjectFlowTypes(Enum):
    none = 'None'
    add = 'Add'
    update = 'Update'
    delete = 'Delete'


class ObjectMappingMetadata(Enum):
    escrow_behavior = 'EscrowBehavior'
    disable_monitoring_for_changes = 'DisableMonitoringForChanges'
    original_joining_property = 'OriginalJoiningProperty'
    disposition = 'Disposition'
    is_customer_defined = 'IsCustomerDefined'
    exclude_from_reporting = 'ExcludeFromReporting'
    unsynchronized = 'Unsynchronized'


class ObliterationBehavior(Enum):
    default = 'default'
    do_not_obliterate = 'doNotObliterate'
    obliterate_with_warning = 'obliterateWithWarning'
    always = 'always'
    unknown_future_value = 'unknownFutureValue'


class OnenotePatchActionType(Enum):
    replace = 'Replace'
    append = 'Append'
    delete = 'Delete'
    insert = 'Insert'
    prepend = 'Prepend'


class OnenotePatchInsertPosition(Enum):
    after = 'After'
    before = 'Before'


class OnenoteSourceService(Enum):
    unknown = 'Unknown'
    one_drive = 'OneDrive'
    one_drive_for_business = 'OneDriveForBusiness'
    on_prem_one_drive_for_business = 'OnPremOneDriveForBusiness'


class OnenoteUserRole(Enum):
    none = 'None'
    owner = 'Owner'
    contributor = 'Contributor'
    reader = 'Reader'


class OnlineMeetingContentSharingDisabledReason(Enum):
    watermark_protection = 'watermarkProtection'
    unknown_future_value = 'unknownFutureValue'


class OnlineMeetingPresenters(Enum):
    everyone = 'everyone'
    organization = 'organization'
    role_is_presenter = 'roleIsPresenter'
    organizer = 'organizer'
    unknown_future_value = 'unknownFutureValue'


class OnlineMeetingProviderType(Enum):
    unknown = 'unknown'
    skype_for_business = 'skypeForBusiness'
    skype_for_consumer = 'skypeForConsumer'
    teams_for_business = 'teamsForBusiness'


class OnlineMeetingRole(Enum):
    attendee = 'attendee'
    presenter = 'presenter'
    unknown_future_value = 'unknownFutureValue'
    producer = 'producer'
    coorganizer = 'coorganizer'


class OnlineMeetingVideoDisabledReason(Enum):
    watermark_protection = 'watermarkProtection'
    unknown_future_value = 'unknownFutureValue'


class OnPremisesDirectorySynchronizationDeletionPreventionType(Enum):
    disabled = 'disabled'
    enabled_for_count = 'enabledForCount'
    enabled_for_percentage = 'enabledForPercentage'
    unknown_future_value = 'unknownFutureValue'


class OperatingSystemUpgradeEligibility(Enum):
    upgraded = 'upgraded'
    unknown = 'unknown'
    not_capable = 'notCapable'
    capable = 'capable'
    unknown_future_value = 'unknownFutureValue'


class OperationResult(Enum):
    success = 'success'
    failure = 'failure'
    timeout = 'timeout'
    unknown_future_value = 'unknownFutureValue'


class OperationStatus(Enum):
    not_started = 'NotStarted'
    running = 'Running'
    completed = 'Completed'
    failed = 'Failed'


class OutlierContainerType(Enum):
    group = 'group'
    unknown_future_value = 'unknownFutureValue'


class OutlierMemberType(Enum):
    user = 'user'
    unknown_future_value = 'unknownFutureValue'


class PageLayoutType(Enum):
    microsoft_reserved = 'microsoftReserved'
    article = 'article'
    home = 'home'
    unknown_future_value = 'unknownFutureValue'


class PagePromotionType(Enum):
    microsoft_reserved = 'microsoftReserved'
    page = 'page'
    news_post = 'newsPost'
    unknown_future_value = 'unknownFutureValue'


class PartnerTenantType(Enum):
    microsoft_support = 'microsoftSupport'
    syndicate_partner = 'syndicatePartner'
    breadth_partner = 'breadthPartner'
    breadth_partner_delegated_admin = 'breadthPartnerDelegatedAdmin'
    reseller_partner_delegated_admin = 'resellerPartnerDelegatedAdmin'
    value_added_reseller_partner_delegated_admin = (
        'valueAddedResellerPartnerDelegatedAdmin'
    )
    unknown_future_value = 'unknownFutureValue'


class PayloadBrand(Enum):
    unknown = 'unknown'
    other = 'other'
    american_express = 'americanExpress'
    capital_one = 'capitalOne'
    dhl = 'dhl'
    docu_sign = 'docuSign'
    dropbox = 'dropbox'
    facebook = 'facebook'
    first_american = 'firstAmerican'
    microsoft = 'microsoft'
    netflix = 'netflix'
    scotiabank = 'scotiabank'
    send_grid = 'sendGrid'
    stewart_title = 'stewartTitle'
    tesco = 'tesco'
    wells_fargo = 'wellsFargo'
    syrinx_cloud = 'syrinxCloud'
    adobe = 'adobe'
    teams = 'teams'
    zoom = 'zoom'
    unknown_future_value = 'unknownFutureValue'


class PayloadComplexity(Enum):
    unknown = 'unknown'
    low = 'low'
    medium = 'medium'
    high = 'high'
    unknown_future_value = 'unknownFutureValue'


class PayloadDeliveryPlatform(Enum):
    unknown = 'unknown'
    sms = 'sms'
    email = 'email'
    teams = 'teams'
    unknown_future_value = 'unknownFutureValue'


class PayloadIndustry(Enum):
    unknown = 'unknown'
    other = 'other'
    banking = 'banking'
    business_services = 'businessServices'
    consumer_services = 'consumerServices'
    education = 'education'
    energy = 'energy'
    construction = 'construction'
    consulting = 'consulting'
    financial_services = 'financialServices'
    government = 'government'
    hospitality = 'hospitality'
    insurance = 'insurance'
    legal = 'legal'
    courier_services = 'courierServices'
    it = 'IT'
    healthcare = 'healthcare'
    manufacturing = 'manufacturing'
    retail = 'retail'
    telecom = 'telecom'
    real_estate = 'realEstate'
    unknown_future_value = 'unknownFutureValue'


class PayloadTheme(Enum):
    unknown = 'unknown'
    other = 'other'
    account_activation = 'accountActivation'
    account_verification = 'accountVerification'
    billing = 'billing'
    clean_up_mail = 'cleanUpMail'
    controversial = 'controversial'
    document_received = 'documentReceived'
    expense = 'expense'
    fax = 'fax'
    finance_report = 'financeReport'
    incoming_messages = 'incomingMessages'
    invoice = 'invoice'
    item_received = 'itemReceived'
    login_alert = 'loginAlert'
    mail_received = 'mailReceived'
    password = 'password'
    payment = 'payment'
    payroll = 'payroll'
    personalized_offer = 'personalizedOffer'
    quarantine = 'quarantine'
    remote_work = 'remoteWork'
    review_message = 'reviewMessage'
    security_update = 'securityUpdate'
    service_suspended = 'serviceSuspended'
    signature_required = 'signatureRequired'
    upgrade_mailbox_storage = 'upgradeMailboxStorage'
    verify_mailbox = 'verifyMailbox'
    voicemail = 'voicemail'
    advertisement = 'advertisement'
    employee_engagement = 'employeeEngagement'
    unknown_future_value = 'unknownFutureValue'


class PermissionClassificationType(Enum):
    low = 'low'
    medium = 'medium'
    high = 'high'
    unknown_future_value = 'unknownFutureValue'


class PermissionType(Enum):
    delegated_user_consentable = 'delegatedUserConsentable'
    delegated = 'delegated'
    application = 'application'


class PersistentBrowserSessionMode(Enum):
    always = 'always'
    never = 'never'


class PhoneType(Enum):
    home = 'home'
    business = 'business'
    mobile = 'mobile'
    other = 'other'
    assistant = 'assistant'
    home_fax = 'homeFax'
    business_fax = 'businessFax'
    other_fax = 'otherFax'
    pager = 'pager'
    radio = 'radio'


class PhysicalAddressType(Enum):
    unknown = 'unknown'
    home = 'home'
    business = 'business'
    other = 'other'


class PlannerContainerType(Enum):
    group = 'group'
    unknown_future_value = 'unknownFutureValue'
    roster = 'roster'


class PlannerPreviewType(Enum):
    automatic = 'automatic'
    no_preview = 'noPreview'
    checklist = 'checklist'
    description = 'description'
    reference = 'reference'


class PolicyPlatformType(Enum):
    android = 'android'
    android_for_work = 'androidForWork'
    i_os = 'iOS'
    mac_os = 'macOS'
    windows_phone81 = 'windowsPhone81'
    windows81_and_later = 'windows81AndLater'
    windows10_and_later = 'windows10AndLater'
    all = 'all'


class PostType(Enum):
    regular = 'regular'
    quick = 'quick'
    strategic = 'strategic'
    unknown_future_value = 'unknownFutureValue'


class PrereleaseFeatures(Enum):
    user_defined = 'userDefined'
    settings_only = 'settingsOnly'
    settings_and_experimentations = 'settingsAndExperimentations'
    not_allowed = 'notAllowed'


class PrintColorMode(Enum):
    black_and_white = 'blackAndWhite'
    grayscale = 'grayscale'
    color = 'color'
    auto = 'auto'
    unknown_future_value = 'unknownFutureValue'


class PrintDuplexMode(Enum):
    flip_on_long_edge = 'flipOnLongEdge'
    flip_on_short_edge = 'flipOnShortEdge'
    one_sided = 'oneSided'
    unknown_future_value = 'unknownFutureValue'


class PrinterFeedOrientation(Enum):
    long_edge_first = 'longEdgeFirst'
    short_edge_first = 'shortEdgeFirst'
    unknown_future_value = 'unknownFutureValue'


class PrinterProcessingState(Enum):
    unknown = 'unknown'
    idle = 'idle'
    processing = 'processing'
    stopped = 'stopped'
    unknown_future_value = 'unknownFutureValue'


class PrinterProcessingStateDetail(Enum):
    paused = 'paused'
    media_jam = 'mediaJam'
    media_needed = 'mediaNeeded'
    media_low = 'mediaLow'
    media_empty = 'mediaEmpty'
    cover_open = 'coverOpen'
    interlock_open = 'interlockOpen'
    output_tray_missing = 'outputTrayMissing'
    output_area_full = 'outputAreaFull'
    marker_supply_low = 'markerSupplyLow'
    marker_supply_empty = 'markerSupplyEmpty'
    input_tray_missing = 'inputTrayMissing'
    output_area_almost_full = 'outputAreaAlmostFull'
    marker_waste_almost_full = 'markerWasteAlmostFull'
    marker_waste_full = 'markerWasteFull'
    fuser_over_temp = 'fuserOverTemp'
    fuser_under_temp = 'fuserUnderTemp'
    other = 'other'
    none = 'none'
    moving_to_paused = 'movingToPaused'
    shutdown = 'shutdown'
    connecting_to_device = 'connectingToDevice'
    timed_out = 'timedOut'
    stopping = 'stopping'
    stopped_partially = 'stoppedPartially'
    toner_low = 'tonerLow'
    toner_empty = 'tonerEmpty'
    spool_area_full = 'spoolAreaFull'
    door_open = 'doorOpen'
    optical_photo_conductor_near_end_of_life = 'opticalPhotoConductorNearEndOfLife'
    optical_photo_conductor_life_over = 'opticalPhotoConductorLifeOver'
    developer_low = 'developerLow'
    developer_empty = 'developerEmpty'
    interpreter_resource_unavailable = 'interpreterResourceUnavailable'
    unknown_future_value = 'unknownFutureValue'
    alert_removal_of_binary_change_entry = 'alertRemovalOfBinaryChangeEntry'
    bander_added = 'banderAdded'
    bander_almost_empty = 'banderAlmostEmpty'
    bander_almost_full = 'banderAlmostFull'
    bander_at_limit = 'banderAtLimit'
    bander_closed = 'banderClosed'
    bander_configuration_change = 'banderConfigurationChange'
    bander_cover_closed = 'banderCoverClosed'
    bander_cover_open = 'banderCoverOpen'
    bander_empty = 'banderEmpty'
    bander_full = 'banderFull'
    bander_interlock_closed = 'banderInterlockClosed'
    bander_interlock_open = 'banderInterlockOpen'
    bander_jam = 'banderJam'
    bander_life_almost_over = 'banderLifeAlmostOver'
    bander_life_over = 'banderLifeOver'
    bander_memory_exhausted = 'banderMemoryExhausted'
    bander_missing = 'banderMissing'
    bander_motor_failure = 'banderMotorFailure'
    bander_near_limit = 'banderNearLimit'
    bander_offline = 'banderOffline'
    bander_opened = 'banderOpened'
    bander_over_temperature = 'banderOverTemperature'
    bander_power_saver = 'banderPowerSaver'
    bander_recoverable_failure = 'banderRecoverableFailure'
    bander_recoverable_storage = 'banderRecoverableStorage'
    bander_removed = 'banderRemoved'
    bander_resource_added = 'banderResourceAdded'
    bander_resource_removed = 'banderResourceRemoved'
    bander_thermistor_failure = 'banderThermistorFailure'
    bander_timing_failure = 'banderTimingFailure'
    bander_turned_off = 'banderTurnedOff'
    bander_turned_on = 'banderTurnedOn'
    bander_under_temperature = 'banderUnderTemperature'
    bander_unrecoverable_failure = 'banderUnrecoverableFailure'
    bander_unrecoverable_storage_error = 'banderUnrecoverableStorageError'
    bander_warming_up = 'banderWarmingUp'
    binder_added = 'binderAdded'
    binder_almost_empty = 'binderAlmostEmpty'
    binder_almost_full = 'binderAlmostFull'
    binder_at_limit = 'binderAtLimit'
    binder_closed = 'binderClosed'
    binder_configuration_change = 'binderConfigurationChange'
    binder_cover_closed = 'binderCoverClosed'
    binder_cover_open = 'binderCoverOpen'
    binder_empty = 'binderEmpty'
    binder_full = 'binderFull'
    binder_interlock_closed = 'binderInterlockClosed'
    binder_interlock_open = 'binderInterlockOpen'
    binder_jam = 'binderJam'
    binder_life_almost_over = 'binderLifeAlmostOver'
    binder_life_over = 'binderLifeOver'
    binder_memory_exhausted = 'binderMemoryExhausted'
    binder_missing = 'binderMissing'
    binder_motor_failure = 'binderMotorFailure'
    binder_near_limit = 'binderNearLimit'
    binder_offline = 'binderOffline'
    binder_opened = 'binderOpened'
    binder_over_temperature = 'binderOverTemperature'
    binder_power_saver = 'binderPowerSaver'
    binder_recoverable_failure = 'binderRecoverableFailure'
    binder_recoverable_storage = 'binderRecoverableStorage'
    binder_removed = 'binderRemoved'
    binder_resource_added = 'binderResourceAdded'
    binder_resource_removed = 'binderResourceRemoved'
    binder_thermistor_failure = 'binderThermistorFailure'
    binder_timing_failure = 'binderTimingFailure'
    binder_turned_off = 'binderTurnedOff'
    binder_turned_on = 'binderTurnedOn'
    binder_under_temperature = 'binderUnderTemperature'
    binder_unrecoverable_failure = 'binderUnrecoverableFailure'
    binder_unrecoverable_storage_error = 'binderUnrecoverableStorageError'
    binder_warming_up = 'binderWarmingUp'
    camera_failure = 'cameraFailure'
    chamber_cooling = 'chamberCooling'
    chamber_failure = 'chamberFailure'
    chamber_heating = 'chamberHeating'
    chamber_temperature_high = 'chamberTemperatureHigh'
    chamber_temperature_low = 'chamberTemperatureLow'
    cleaner_life_almost_over = 'cleanerLifeAlmostOver'
    cleaner_life_over = 'cleanerLifeOver'
    configuration_change = 'configurationChange'
    deactivated = 'deactivated'
    deleted = 'deleted'
    die_cutter_added = 'dieCutterAdded'
    die_cutter_almost_empty = 'dieCutterAlmostEmpty'
    die_cutter_almost_full = 'dieCutterAlmostFull'
    die_cutter_at_limit = 'dieCutterAtLimit'
    die_cutter_closed = 'dieCutterClosed'
    die_cutter_configuration_change = 'dieCutterConfigurationChange'
    die_cutter_cover_closed = 'dieCutterCoverClosed'
    die_cutter_cover_open = 'dieCutterCoverOpen'
    die_cutter_empty = 'dieCutterEmpty'
    die_cutter_full = 'dieCutterFull'
    die_cutter_interlock_closed = 'dieCutterInterlockClosed'
    die_cutter_interlock_open = 'dieCutterInterlockOpen'
    die_cutter_jam = 'dieCutterJam'
    die_cutter_life_almost_over = 'dieCutterLifeAlmostOver'
    die_cutter_life_over = 'dieCutterLifeOver'
    die_cutter_memory_exhausted = 'dieCutterMemoryExhausted'
    die_cutter_missing = 'dieCutterMissing'
    die_cutter_motor_failure = 'dieCutterMotorFailure'
    die_cutter_near_limit = 'dieCutterNearLimit'
    die_cutter_offline = 'dieCutterOffline'
    die_cutter_opened = 'dieCutterOpened'
    die_cutter_over_temperature = 'dieCutterOverTemperature'
    die_cutter_power_saver = 'dieCutterPowerSaver'
    die_cutter_recoverable_failure = 'dieCutterRecoverableFailure'
    die_cutter_recoverable_storage = 'dieCutterRecoverableStorage'
    die_cutter_removed = 'dieCutterRemoved'
    die_cutter_resource_added = 'dieCutterResourceAdded'
    die_cutter_resource_removed = 'dieCutterResourceRemoved'
    die_cutter_thermistor_failure = 'dieCutterThermistorFailure'
    die_cutter_timing_failure = 'dieCutterTimingFailure'
    die_cutter_turned_off = 'dieCutterTurnedOff'
    die_cutter_turned_on = 'dieCutterTurnedOn'
    die_cutter_under_temperature = 'dieCutterUnderTemperature'
    die_cutter_unrecoverable_failure = 'dieCutterUnrecoverableFailure'
    die_cutter_unrecoverable_storage_error = 'dieCutterUnrecoverableStorageError'
    die_cutter_warming_up = 'dieCutterWarmingUp'
    extruder_cooling = 'extruderCooling'
    extruder_failure = 'extruderFailure'
    extruder_heating = 'extruderHeating'
    extruder_jam = 'extruderJam'
    extruder_temperature_high = 'extruderTemperatureHigh'
    extruder_temperature_low = 'extruderTemperatureLow'
    fan_failure = 'fanFailure'
    fax_modem_life_almost_over = 'faxModemLifeAlmostOver'
    fax_modem_life_over = 'faxModemLifeOver'
    fax_modem_missing = 'faxModemMissing'
    fax_modem_turned_off = 'faxModemTurnedOff'
    fax_modem_turned_on = 'faxModemTurnedOn'
    folder_added = 'folderAdded'
    folder_almost_empty = 'folderAlmostEmpty'
    folder_almost_full = 'folderAlmostFull'
    folder_at_limit = 'folderAtLimit'
    folder_closed = 'folderClosed'
    folder_configuration_change = 'folderConfigurationChange'
    folder_cover_closed = 'folderCoverClosed'
    folder_cover_open = 'folderCoverOpen'
    folder_empty = 'folderEmpty'
    folder_full = 'folderFull'
    folder_interlock_closed = 'folderInterlockClosed'
    folder_interlock_open = 'folderInterlockOpen'
    folder_jam = 'folderJam'
    folder_life_almost_over = 'folderLifeAlmostOver'
    folder_life_over = 'folderLifeOver'
    folder_memory_exhausted = 'folderMemoryExhausted'
    folder_missing = 'folderMissing'
    folder_motor_failure = 'folderMotorFailure'
    folder_near_limit = 'folderNearLimit'
    folder_offline = 'folderOffline'
    folder_opened = 'folderOpened'
    folder_over_temperature = 'folderOverTemperature'
    folder_power_saver = 'folderPowerSaver'
    folder_recoverable_failure = 'folderRecoverableFailure'
    folder_recoverable_storage = 'folderRecoverableStorage'
    folder_removed = 'folderRemoved'
    folder_resource_added = 'folderResourceAdded'
    folder_resource_removed = 'folderResourceRemoved'
    folder_thermistor_failure = 'folderThermistorFailure'
    folder_timing_failure = 'folderTimingFailure'
    folder_turned_off = 'folderTurnedOff'
    folder_turned_on = 'folderTurnedOn'
    folder_under_temperature = 'folderUnderTemperature'
    folder_unrecoverable_failure = 'folderUnrecoverableFailure'
    folder_unrecoverable_storage_error = 'folderUnrecoverableStorageError'
    folder_warming_up = 'folderWarmingUp'
    hibernate = 'hibernate'
    hold_new_jobs = 'holdNewJobs'
    identify_printer_requested = 'identifyPrinterRequested'
    imprinter_added = 'imprinterAdded'
    imprinter_almost_empty = 'imprinterAlmostEmpty'
    imprinter_almost_full = 'imprinterAlmostFull'
    imprinter_at_limit = 'imprinterAtLimit'
    imprinter_closed = 'imprinterClosed'
    imprinter_configuration_change = 'imprinterConfigurationChange'
    imprinter_cover_closed = 'imprinterCoverClosed'
    imprinter_cover_open = 'imprinterCoverOpen'
    imprinter_empty = 'imprinterEmpty'
    imprinter_full = 'imprinterFull'
    imprinter_interlock_closed = 'imprinterInterlockClosed'
    imprinter_interlock_open = 'imprinterInterlockOpen'
    imprinter_jam = 'imprinterJam'
    imprinter_life_almost_over = 'imprinterLifeAlmostOver'
    imprinter_life_over = 'imprinterLifeOver'
    imprinter_memory_exhausted = 'imprinterMemoryExhausted'
    imprinter_missing = 'imprinterMissing'
    imprinter_motor_failure = 'imprinterMotorFailure'
    imprinter_near_limit = 'imprinterNearLimit'
    imprinter_offline = 'imprinterOffline'
    imprinter_opened = 'imprinterOpened'
    imprinter_over_temperature = 'imprinterOverTemperature'
    imprinter_power_saver = 'imprinterPowerSaver'
    imprinter_recoverable_failure = 'imprinterRecoverableFailure'
    imprinter_recoverable_storage = 'imprinterRecoverableStorage'
    imprinter_removed = 'imprinterRemoved'
    imprinter_resource_added = 'imprinterResourceAdded'
    imprinter_resource_removed = 'imprinterResourceRemoved'
    imprinter_thermistor_failure = 'imprinterThermistorFailure'
    imprinter_timing_failure = 'imprinterTimingFailure'
    imprinter_turned_off = 'imprinterTurnedOff'
    imprinter_turned_on = 'imprinterTurnedOn'
    imprinter_under_temperature = 'imprinterUnderTemperature'
    imprinter_unrecoverable_failure = 'imprinterUnrecoverableFailure'
    imprinter_unrecoverable_storage_error = 'imprinterUnrecoverableStorageError'
    imprinter_warming_up = 'imprinterWarmingUp'
    input_cannot_feed_size_selected = 'inputCannotFeedSizeSelected'
    input_manual_input_request = 'inputManualInputRequest'
    input_media_color_change = 'inputMediaColorChange'
    input_media_form_parts_change = 'inputMediaFormPartsChange'
    input_media_size_change = 'inputMediaSizeChange'
    input_media_tray_failure = 'inputMediaTrayFailure'
    input_media_tray_feed_error = 'inputMediaTrayFeedError'
    input_media_tray_jam = 'inputMediaTrayJam'
    input_media_type_change = 'inputMediaTypeChange'
    input_media_weight_change = 'inputMediaWeightChange'
    input_pick_roller_failure = 'inputPickRollerFailure'
    input_pick_roller_life_over = 'inputPickRollerLifeOver'
    input_pick_roller_life_warn = 'inputPickRollerLifeWarn'
    input_pick_roller_missing = 'inputPickRollerMissing'
    input_tray_elevation_failure = 'inputTrayElevationFailure'
    input_tray_position_failure = 'inputTrayPositionFailure'
    inserter_added = 'inserterAdded'
    inserter_almost_empty = 'inserterAlmostEmpty'
    inserter_almost_full = 'inserterAlmostFull'
    inserter_at_limit = 'inserterAtLimit'
    inserter_closed = 'inserterClosed'
    inserter_configuration_change = 'inserterConfigurationChange'
    inserter_cover_closed = 'inserterCoverClosed'
    inserter_cover_open = 'inserterCoverOpen'
    inserter_empty = 'inserterEmpty'
    inserter_full = 'inserterFull'
    inserter_interlock_closed = 'inserterInterlockClosed'
    inserter_interlock_open = 'inserterInterlockOpen'
    inserter_jam = 'inserterJam'
    inserter_life_almost_over = 'inserterLifeAlmostOver'
    inserter_life_over = 'inserterLifeOver'
    inserter_memory_exhausted = 'inserterMemoryExhausted'
    inserter_missing = 'inserterMissing'
    inserter_motor_failure = 'inserterMotorFailure'
    inserter_near_limit = 'inserterNearLimit'
    inserter_offline = 'inserterOffline'
    inserter_opened = 'inserterOpened'
    inserter_over_temperature = 'inserterOverTemperature'
    inserter_power_saver = 'inserterPowerSaver'
    inserter_recoverable_failure = 'inserterRecoverableFailure'
    inserter_recoverable_storage = 'inserterRecoverableStorage'
    inserter_removed = 'inserterRemoved'
    inserter_resource_added = 'inserterResourceAdded'
    inserter_resource_removed = 'inserterResourceRemoved'
    inserter_thermistor_failure = 'inserterThermistorFailure'
    inserter_timing_failure = 'inserterTimingFailure'
    inserter_turned_off = 'inserterTurnedOff'
    inserter_turned_on = 'inserterTurnedOn'
    inserter_under_temperature = 'inserterUnderTemperature'
    inserter_unrecoverable_failure = 'inserterUnrecoverableFailure'
    inserter_unrecoverable_storage_error = 'inserterUnrecoverableStorageError'
    inserter_warming_up = 'inserterWarmingUp'
    interlock_closed = 'interlockClosed'
    interpreter_cartridge_added = 'interpreterCartridgeAdded'
    interpreter_cartridge_deleted = 'interpreterCartridgeDeleted'
    interpreter_complex_page_encountered = 'interpreterComplexPageEncountered'
    interpreter_memory_decrease = 'interpreterMemoryDecrease'
    interpreter_memory_increase = 'interpreterMemoryIncrease'
    interpreter_resource_added = 'interpreterResourceAdded'
    interpreter_resource_deleted = 'interpreterResourceDeleted'
    lamp_at_eol = 'lampAtEol'
    lamp_failure = 'lampFailure'
    lamp_near_eol = 'lampNearEol'
    laser_at_eol = 'laserAtEol'
    laser_failure = 'laserFailure'
    laser_near_eol = 'laserNearEol'
    make_envelope_added = 'makeEnvelopeAdded'
    make_envelope_almost_empty = 'makeEnvelopeAlmostEmpty'
    make_envelope_almost_full = 'makeEnvelopeAlmostFull'
    make_envelope_at_limit = 'makeEnvelopeAtLimit'
    make_envelope_closed = 'makeEnvelopeClosed'
    make_envelope_configuration_change = 'makeEnvelopeConfigurationChange'
    make_envelope_cover_closed = 'makeEnvelopeCoverClosed'
    make_envelope_cover_open = 'makeEnvelopeCoverOpen'
    make_envelope_empty = 'makeEnvelopeEmpty'
    make_envelope_full = 'makeEnvelopeFull'
    make_envelope_interlock_closed = 'makeEnvelopeInterlockClosed'
    make_envelope_interlock_open = 'makeEnvelopeInterlockOpen'
    make_envelope_jam = 'makeEnvelopeJam'
    make_envelope_life_almost_over = 'makeEnvelopeLifeAlmostOver'
    make_envelope_life_over = 'makeEnvelopeLifeOver'
    make_envelope_memory_exhausted = 'makeEnvelopeMemoryExhausted'
    make_envelope_missing = 'makeEnvelopeMissing'
    make_envelope_motor_failure = 'makeEnvelopeMotorFailure'
    make_envelope_near_limit = 'makeEnvelopeNearLimit'
    make_envelope_offline = 'makeEnvelopeOffline'
    make_envelope_opened = 'makeEnvelopeOpened'
    make_envelope_over_temperature = 'makeEnvelopeOverTemperature'
    make_envelope_power_saver = 'makeEnvelopePowerSaver'
    make_envelope_recoverable_failure = 'makeEnvelopeRecoverableFailure'
    make_envelope_recoverable_storage = 'makeEnvelopeRecoverableStorage'
    make_envelope_removed = 'makeEnvelopeRemoved'
    make_envelope_resource_added = 'makeEnvelopeResourceAdded'
    make_envelope_resource_removed = 'makeEnvelopeResourceRemoved'
    make_envelope_thermistor_failure = 'makeEnvelopeThermistorFailure'
    make_envelope_timing_failure = 'makeEnvelopeTimingFailure'
    make_envelope_turned_off = 'makeEnvelopeTurnedOff'
    make_envelope_turned_on = 'makeEnvelopeTurnedOn'
    make_envelope_under_temperature = 'makeEnvelopeUnderTemperature'
    make_envelope_unrecoverable_failure = 'makeEnvelopeUnrecoverableFailure'
    make_envelope_unrecoverable_storage_error = 'makeEnvelopeUnrecoverableStorageError'
    make_envelope_warming_up = 'makeEnvelopeWarmingUp'
    marker_adjusting_print_quality = 'markerAdjustingPrintQuality'
    marker_cleaner_missing = 'markerCleanerMissing'
    marker_developer_almost_empty = 'markerDeveloperAlmostEmpty'
    marker_developer_empty = 'markerDeveloperEmpty'
    marker_developer_missing = 'markerDeveloperMissing'
    marker_fuser_missing = 'markerFuserMissing'
    marker_fuser_thermistor_failure = 'markerFuserThermistorFailure'
    marker_fuser_timing_failure = 'markerFuserTimingFailure'
    marker_ink_almost_empty = 'markerInkAlmostEmpty'
    marker_ink_empty = 'markerInkEmpty'
    marker_ink_missing = 'markerInkMissing'
    marker_opc_missing = 'markerOpcMissing'
    marker_print_ribbon_almost_empty = 'markerPrintRibbonAlmostEmpty'
    marker_print_ribbon_empty = 'markerPrintRibbonEmpty'
    marker_print_ribbon_missing = 'markerPrintRibbonMissing'
    marker_supply_almost_empty = 'markerSupplyAlmostEmpty'
    marker_supply_missing = 'markerSupplyMissing'
    marker_toner_cartridge_missing = 'markerTonerCartridgeMissing'
    marker_toner_missing = 'markerTonerMissing'
    marker_waste_ink_receptacle_almost_full = 'markerWasteInkReceptacleAlmostFull'
    marker_waste_ink_receptacle_full = 'markerWasteInkReceptacleFull'
    marker_waste_ink_receptacle_missing = 'markerWasteInkReceptacleMissing'
    marker_waste_missing = 'markerWasteMissing'
    marker_waste_toner_receptacle_almost_full = 'markerWasteTonerReceptacleAlmostFull'
    marker_waste_toner_receptacle_full = 'markerWasteTonerReceptacleFull'
    marker_waste_toner_receptacle_missing = 'markerWasteTonerReceptacleMissing'
    material_empty = 'materialEmpty'
    material_low = 'materialLow'
    material_needed = 'materialNeeded'
    media_drying = 'mediaDrying'
    media_path_cannot_duplex_media_selected = 'mediaPathCannotDuplexMediaSelected'
    media_path_failure = 'mediaPathFailure'
    media_path_input_empty = 'mediaPathInputEmpty'
    media_path_input_feed_error = 'mediaPathInputFeedError'
    media_path_input_jam = 'mediaPathInputJam'
    media_path_input_request = 'mediaPathInputRequest'
    media_path_jam = 'mediaPathJam'
    media_path_media_tray_almost_full = 'mediaPathMediaTrayAlmostFull'
    media_path_media_tray_full = 'mediaPathMediaTrayFull'
    media_path_media_tray_missing = 'mediaPathMediaTrayMissing'
    media_path_output_feed_error = 'mediaPathOutputFeedError'
    media_path_output_full = 'mediaPathOutputFull'
    media_path_output_jam = 'mediaPathOutputJam'
    media_path_pick_roller_failure = 'mediaPathPickRollerFailure'
    media_path_pick_roller_life_over = 'mediaPathPickRollerLifeOver'
    media_path_pick_roller_life_warn = 'mediaPathPickRollerLifeWarn'
    media_path_pick_roller_missing = 'mediaPathPickRollerMissing'
    motor_failure = 'motorFailure'
    output_mailbox_select_failure = 'outputMailboxSelectFailure'
    output_media_tray_failure = 'outputMediaTrayFailure'
    output_media_tray_feed_error = 'outputMediaTrayFeedError'
    output_media_tray_jam = 'outputMediaTrayJam'
    perforater_added = 'perforaterAdded'
    perforater_almost_empty = 'perforaterAlmostEmpty'
    perforater_almost_full = 'perforaterAlmostFull'
    perforater_at_limit = 'perforaterAtLimit'
    perforater_closed = 'perforaterClosed'
    perforater_configuration_change = 'perforaterConfigurationChange'
    perforater_cover_closed = 'perforaterCoverClosed'
    perforater_cover_open = 'perforaterCoverOpen'
    perforater_empty = 'perforaterEmpty'
    perforater_full = 'perforaterFull'
    perforater_interlock_closed = 'perforaterInterlockClosed'
    perforater_interlock_open = 'perforaterInterlockOpen'
    perforater_jam = 'perforaterJam'
    perforater_life_almost_over = 'perforaterLifeAlmostOver'
    perforater_life_over = 'perforaterLifeOver'
    perforater_memory_exhausted = 'perforaterMemoryExhausted'
    perforater_missing = 'perforaterMissing'
    perforater_motor_failure = 'perforaterMotorFailure'
    perforater_near_limit = 'perforaterNearLimit'
    perforater_offline = 'perforaterOffline'
    perforater_opened = 'perforaterOpened'
    perforater_over_temperature = 'perforaterOverTemperature'
    perforater_power_saver = 'perforaterPowerSaver'
    perforater_recoverable_failure = 'perforaterRecoverableFailure'
    perforater_recoverable_storage = 'perforaterRecoverableStorage'
    perforater_removed = 'perforaterRemoved'
    perforater_resource_added = 'perforaterResourceAdded'
    perforater_resource_removed = 'perforaterResourceRemoved'
    perforater_thermistor_failure = 'perforaterThermistorFailure'
    perforater_timing_failure = 'perforaterTimingFailure'
    perforater_turned_off = 'perforaterTurnedOff'
    perforater_turned_on = 'perforaterTurnedOn'
    perforater_under_temperature = 'perforaterUnderTemperature'
    perforater_unrecoverable_failure = 'perforaterUnrecoverableFailure'
    perforater_unrecoverable_storage_error = 'perforaterUnrecoverableStorageError'
    perforater_warming_up = 'perforaterWarmingUp'
    platform_cooling = 'platformCooling'
    platform_failure = 'platformFailure'
    platform_heating = 'platformHeating'
    platform_temperature_high = 'platformTemperatureHigh'
    platform_temperature_low = 'platformTemperatureLow'
    power_down = 'powerDown'
    power_up = 'powerUp'
    printer_manual_reset = 'printerManualReset'
    printer_nms_reset = 'printerNmsReset'
    printer_ready_to_print = 'printerReadyToPrint'
    puncher_added = 'puncherAdded'
    puncher_almost_empty = 'puncherAlmostEmpty'
    puncher_almost_full = 'puncherAlmostFull'
    puncher_at_limit = 'puncherAtLimit'
    puncher_closed = 'puncherClosed'
    puncher_configuration_change = 'puncherConfigurationChange'
    puncher_cover_closed = 'puncherCoverClosed'
    puncher_cover_open = 'puncherCoverOpen'
    puncher_empty = 'puncherEmpty'
    puncher_full = 'puncherFull'
    puncher_interlock_closed = 'puncherInterlockClosed'
    puncher_interlock_open = 'puncherInterlockOpen'
    puncher_jam = 'puncherJam'
    puncher_life_almost_over = 'puncherLifeAlmostOver'
    puncher_life_over = 'puncherLifeOver'
    puncher_memory_exhausted = 'puncherMemoryExhausted'
    puncher_missing = 'puncherMissing'
    puncher_motor_failure = 'puncherMotorFailure'
    puncher_near_limit = 'puncherNearLimit'
    puncher_offline = 'puncherOffline'
    puncher_opened = 'puncherOpened'
    puncher_over_temperature = 'puncherOverTemperature'
    puncher_power_saver = 'puncherPowerSaver'
    puncher_recoverable_failure = 'puncherRecoverableFailure'
    puncher_recoverable_storage = 'puncherRecoverableStorage'
    puncher_removed = 'puncherRemoved'
    puncher_resource_added = 'puncherResourceAdded'
    puncher_resource_removed = 'puncherResourceRemoved'
    puncher_thermistor_failure = 'puncherThermistorFailure'
    puncher_timing_failure = 'puncherTimingFailure'
    puncher_turned_off = 'puncherTurnedOff'
    puncher_turned_on = 'puncherTurnedOn'
    puncher_under_temperature = 'puncherUnderTemperature'
    puncher_unrecoverable_failure = 'puncherUnrecoverableFailure'
    puncher_unrecoverable_storage_error = 'puncherUnrecoverableStorageError'
    puncher_warming_up = 'puncherWarmingUp'
    resuming = 'resuming'
    scan_media_path_failure = 'scanMediaPathFailure'
    scan_media_path_input_empty = 'scanMediaPathInputEmpty'
    scan_media_path_input_feed_error = 'scanMediaPathInputFeedError'
    scan_media_path_input_jam = 'scanMediaPathInputJam'
    scan_media_path_input_request = 'scanMediaPathInputRequest'
    scan_media_path_jam = 'scanMediaPathJam'
    scan_media_path_output_feed_error = 'scanMediaPathOutputFeedError'
    scan_media_path_output_full = 'scanMediaPathOutputFull'
    scan_media_path_output_jam = 'scanMediaPathOutputJam'
    scan_media_path_pick_roller_failure = 'scanMediaPathPickRollerFailure'
    scan_media_path_pick_roller_life_over = 'scanMediaPathPickRollerLifeOver'
    scan_media_path_pick_roller_life_warn = 'scanMediaPathPickRollerLifeWarn'
    scan_media_path_pick_roller_missing = 'scanMediaPathPickRollerMissing'
    scan_media_path_tray_almost_full = 'scanMediaPathTrayAlmostFull'
    scan_media_path_tray_full = 'scanMediaPathTrayFull'
    scan_media_path_tray_missing = 'scanMediaPathTrayMissing'
    scanner_light_failure = 'scannerLightFailure'
    scanner_light_life_almost_over = 'scannerLightLifeAlmostOver'
    scanner_light_life_over = 'scannerLightLifeOver'
    scanner_light_missing = 'scannerLightMissing'
    scanner_sensor_failure = 'scannerSensorFailure'
    scanner_sensor_life_almost_over = 'scannerSensorLifeAlmostOver'
    scanner_sensor_life_over = 'scannerSensorLifeOver'
    scanner_sensor_missing = 'scannerSensorMissing'
    separation_cutter_added = 'separationCutterAdded'
    separation_cutter_almost_empty = 'separationCutterAlmostEmpty'
    separation_cutter_almost_full = 'separationCutterAlmostFull'
    separation_cutter_at_limit = 'separationCutterAtLimit'
    separation_cutter_closed = 'separationCutterClosed'
    separation_cutter_configuration_change = 'separationCutterConfigurationChange'
    separation_cutter_cover_closed = 'separationCutterCoverClosed'
    separation_cutter_cover_open = 'separationCutterCoverOpen'
    separation_cutter_empty = 'separationCutterEmpty'
    separation_cutter_full = 'separationCutterFull'
    separation_cutter_interlock_closed = 'separationCutterInterlockClosed'
    separation_cutter_interlock_open = 'separationCutterInterlockOpen'
    separation_cutter_jam = 'separationCutterJam'
    separation_cutter_life_almost_over = 'separationCutterLifeAlmostOver'
    separation_cutter_life_over = 'separationCutterLifeOver'
    separation_cutter_memory_exhausted = 'separationCutterMemoryExhausted'
    separation_cutter_missing = 'separationCutterMissing'
    separation_cutter_motor_failure = 'separationCutterMotorFailure'
    separation_cutter_near_limit = 'separationCutterNearLimit'
    separation_cutter_offline = 'separationCutterOffline'
    separation_cutter_opened = 'separationCutterOpened'
    separation_cutter_over_temperature = 'separationCutterOverTemperature'
    separation_cutter_power_saver = 'separationCutterPowerSaver'
    separation_cutter_recoverable_failure = 'separationCutterRecoverableFailure'
    separation_cutter_recoverable_storage = 'separationCutterRecoverableStorage'
    separation_cutter_removed = 'separationCutterRemoved'
    separation_cutter_resource_added = 'separationCutterResourceAdded'
    separation_cutter_resource_removed = 'separationCutterResourceRemoved'
    separation_cutter_thermistor_failure = 'separationCutterThermistorFailure'
    separation_cutter_timing_failure = 'separationCutterTimingFailure'
    separation_cutter_turned_off = 'separationCutterTurnedOff'
    separation_cutter_turned_on = 'separationCutterTurnedOn'
    separation_cutter_under_temperature = 'separationCutterUnderTemperature'
    separation_cutter_unrecoverable_failure = 'separationCutterUnrecoverableFailure'
    separation_cutter_unrecoverable_storage_error = (
        'separationCutterUnrecoverableStorageError'
    )
    separation_cutter_warming_up = 'separationCutterWarmingUp'
    sheet_rotator_added = 'sheetRotatorAdded'
    sheet_rotator_almost_empty = 'sheetRotatorAlmostEmpty'
    sheet_rotator_almost_full = 'sheetRotatorAlmostFull'
    sheet_rotator_at_limit = 'sheetRotatorAtLimit'
    sheet_rotator_closed = 'sheetRotatorClosed'
    sheet_rotator_configuration_change = 'sheetRotatorConfigurationChange'
    sheet_rotator_cover_closed = 'sheetRotatorCoverClosed'
    sheet_rotator_cover_open = 'sheetRotatorCoverOpen'
    sheet_rotator_empty = 'sheetRotatorEmpty'
    sheet_rotator_full = 'sheetRotatorFull'
    sheet_rotator_interlock_closed = 'sheetRotatorInterlockClosed'
    sheet_rotator_interlock_open = 'sheetRotatorInterlockOpen'
    sheet_rotator_jam = 'sheetRotatorJam'
    sheet_rotator_life_almost_over = 'sheetRotatorLifeAlmostOver'
    sheet_rotator_life_over = 'sheetRotatorLifeOver'
    sheet_rotator_memory_exhausted = 'sheetRotatorMemoryExhausted'
    sheet_rotator_missing = 'sheetRotatorMissing'
    sheet_rotator_motor_failure = 'sheetRotatorMotorFailure'
    sheet_rotator_near_limit = 'sheetRotatorNearLimit'
    sheet_rotator_offline = 'sheetRotatorOffline'
    sheet_rotator_opened = 'sheetRotatorOpened'
    sheet_rotator_over_temperature = 'sheetRotatorOverTemperature'
    sheet_rotator_power_saver = 'sheetRotatorPowerSaver'
    sheet_rotator_recoverable_failure = 'sheetRotatorRecoverableFailure'
    sheet_rotator_recoverable_storage = 'sheetRotatorRecoverableStorage'
    sheet_rotator_removed = 'sheetRotatorRemoved'
    sheet_rotator_resource_added = 'sheetRotatorResourceAdded'
    sheet_rotator_resource_removed = 'sheetRotatorResourceRemoved'
    sheet_rotator_thermistor_failure = 'sheetRotatorThermistorFailure'
    sheet_rotator_timing_failure = 'sheetRotatorTimingFailure'
    sheet_rotator_turned_off = 'sheetRotatorTurnedOff'
    sheet_rotator_turned_on = 'sheetRotatorTurnedOn'
    sheet_rotator_under_temperature = 'sheetRotatorUnderTemperature'
    sheet_rotator_unrecoverable_failure = 'sheetRotatorUnrecoverableFailure'
    sheet_rotator_unrecoverable_storage_error = 'sheetRotatorUnrecoverableStorageError'
    sheet_rotator_warming_up = 'sheetRotatorWarmingUp'
    slitter_added = 'slitterAdded'
    slitter_almost_empty = 'slitterAlmostEmpty'
    slitter_almost_full = 'slitterAlmostFull'
    slitter_at_limit = 'slitterAtLimit'
    slitter_closed = 'slitterClosed'
    slitter_configuration_change = 'slitterConfigurationChange'
    slitter_cover_closed = 'slitterCoverClosed'
    slitter_cover_open = 'slitterCoverOpen'
    slitter_empty = 'slitterEmpty'
    slitter_full = 'slitterFull'
    slitter_interlock_closed = 'slitterInterlockClosed'
    slitter_interlock_open = 'slitterInterlockOpen'
    slitter_jam = 'slitterJam'
    slitter_life_almost_over = 'slitterLifeAlmostOver'
    slitter_life_over = 'slitterLifeOver'
    slitter_memory_exhausted = 'slitterMemoryExhausted'
    slitter_missing = 'slitterMissing'
    slitter_motor_failure = 'slitterMotorFailure'
    slitter_near_limit = 'slitterNearLimit'
    slitter_offline = 'slitterOffline'
    slitter_opened = 'slitterOpened'
    slitter_over_temperature = 'slitterOverTemperature'
    slitter_power_saver = 'slitterPowerSaver'
    slitter_recoverable_failure = 'slitterRecoverableFailure'
    slitter_recoverable_storage = 'slitterRecoverableStorage'
    slitter_removed = 'slitterRemoved'
    slitter_resource_added = 'slitterResourceAdded'
    slitter_resource_removed = 'slitterResourceRemoved'
    slitter_thermistor_failure = 'slitterThermistorFailure'
    slitter_timing_failure = 'slitterTimingFailure'
    slitter_turned_off = 'slitterTurnedOff'
    slitter_turned_on = 'slitterTurnedOn'
    slitter_under_temperature = 'slitterUnderTemperature'
    slitter_unrecoverable_failure = 'slitterUnrecoverableFailure'
    slitter_unrecoverable_storage_error = 'slitterUnrecoverableStorageError'
    slitter_warming_up = 'slitterWarmingUp'
    stacker_added = 'stackerAdded'
    stacker_almost_empty = 'stackerAlmostEmpty'
    stacker_almost_full = 'stackerAlmostFull'
    stacker_at_limit = 'stackerAtLimit'
    stacker_closed = 'stackerClosed'
    stacker_configuration_change = 'stackerConfigurationChange'
    stacker_cover_closed = 'stackerCoverClosed'
    stacker_cover_open = 'stackerCoverOpen'
    stacker_empty = 'stackerEmpty'
    stacker_full = 'stackerFull'
    stacker_interlock_closed = 'stackerInterlockClosed'
    stacker_interlock_open = 'stackerInterlockOpen'
    stacker_jam = 'stackerJam'
    stacker_life_almost_over = 'stackerLifeAlmostOver'
    stacker_life_over = 'stackerLifeOver'
    stacker_memory_exhausted = 'stackerMemoryExhausted'
    stacker_missing = 'stackerMissing'
    stacker_motor_failure = 'stackerMotorFailure'
    stacker_near_limit = 'stackerNearLimit'
    stacker_offline = 'stackerOffline'
    stacker_opened = 'stackerOpened'
    stacker_over_temperature = 'stackerOverTemperature'
    stacker_power_saver = 'stackerPowerSaver'
    stacker_recoverable_failure = 'stackerRecoverableFailure'
    stacker_recoverable_storage = 'stackerRecoverableStorage'
    stacker_removed = 'stackerRemoved'
    stacker_resource_added = 'stackerResourceAdded'
    stacker_resource_removed = 'stackerResourceRemoved'
    stacker_thermistor_failure = 'stackerThermistorFailure'
    stacker_timing_failure = 'stackerTimingFailure'
    stacker_turned_off = 'stackerTurnedOff'
    stacker_turned_on = 'stackerTurnedOn'
    stacker_under_temperature = 'stackerUnderTemperature'
    stacker_unrecoverable_failure = 'stackerUnrecoverableFailure'
    stacker_unrecoverable_storage_error = 'stackerUnrecoverableStorageError'
    stacker_warming_up = 'stackerWarmingUp'
    standby = 'standby'
    stapler_added = 'staplerAdded'
    stapler_almost_empty = 'staplerAlmostEmpty'
    stapler_almost_full = 'staplerAlmostFull'
    stapler_at_limit = 'staplerAtLimit'
    stapler_closed = 'staplerClosed'
    stapler_configuration_change = 'staplerConfigurationChange'
    stapler_cover_closed = 'staplerCoverClosed'
    stapler_cover_open = 'staplerCoverOpen'
    stapler_empty = 'staplerEmpty'
    stapler_full = 'staplerFull'
    stapler_interlock_closed = 'staplerInterlockClosed'
    stapler_interlock_open = 'staplerInterlockOpen'
    stapler_jam = 'staplerJam'
    stapler_life_almost_over = 'staplerLifeAlmostOver'
    stapler_life_over = 'staplerLifeOver'
    stapler_memory_exhausted = 'staplerMemoryExhausted'
    stapler_missing = 'staplerMissing'
    stapler_motor_failure = 'staplerMotorFailure'
    stapler_near_limit = 'staplerNearLimit'
    stapler_offline = 'staplerOffline'
    stapler_opened = 'staplerOpened'
    stapler_over_temperature = 'staplerOverTemperature'
    stapler_power_saver = 'staplerPowerSaver'
    stapler_recoverable_failure = 'staplerRecoverableFailure'
    stapler_recoverable_storage = 'staplerRecoverableStorage'
    stapler_removed = 'staplerRemoved'
    stapler_resource_added = 'staplerResourceAdded'
    stapler_resource_removed = 'staplerResourceRemoved'
    stapler_thermistor_failure = 'staplerThermistorFailure'
    stapler_timing_failure = 'staplerTimingFailure'
    stapler_turned_off = 'staplerTurnedOff'
    stapler_turned_on = 'staplerTurnedOn'
    stapler_under_temperature = 'staplerUnderTemperature'
    stapler_unrecoverable_failure = 'staplerUnrecoverableFailure'
    stapler_unrecoverable_storage_error = 'staplerUnrecoverableStorageError'
    stapler_warming_up = 'staplerWarmingUp'
    stitcher_added = 'stitcherAdded'
    stitcher_almost_empty = 'stitcherAlmostEmpty'
    stitcher_almost_full = 'stitcherAlmostFull'
    stitcher_at_limit = 'stitcherAtLimit'
    stitcher_closed = 'stitcherClosed'
    stitcher_configuration_change = 'stitcherConfigurationChange'
    stitcher_cover_closed = 'stitcherCoverClosed'
    stitcher_cover_open = 'stitcherCoverOpen'
    stitcher_empty = 'stitcherEmpty'
    stitcher_full = 'stitcherFull'
    stitcher_interlock_closed = 'stitcherInterlockClosed'
    stitcher_interlock_open = 'stitcherInterlockOpen'
    stitcher_jam = 'stitcherJam'
    stitcher_life_almost_over = 'stitcherLifeAlmostOver'
    stitcher_life_over = 'stitcherLifeOver'
    stitcher_memory_exhausted = 'stitcherMemoryExhausted'
    stitcher_missing = 'stitcherMissing'
    stitcher_motor_failure = 'stitcherMotorFailure'
    stitcher_near_limit = 'stitcherNearLimit'
    stitcher_offline = 'stitcherOffline'
    stitcher_opened = 'stitcherOpened'
    stitcher_over_temperature = 'stitcherOverTemperature'
    stitcher_power_saver = 'stitcherPowerSaver'
    stitcher_recoverable_failure = 'stitcherRecoverableFailure'
    stitcher_recoverable_storage = 'stitcherRecoverableStorage'
    stitcher_removed = 'stitcherRemoved'
    stitcher_resource_added = 'stitcherResourceAdded'
    stitcher_resource_removed = 'stitcherResourceRemoved'
    stitcher_thermistor_failure = 'stitcherThermistorFailure'
    stitcher_timing_failure = 'stitcherTimingFailure'
    stitcher_turned_off = 'stitcherTurnedOff'
    stitcher_turned_on = 'stitcherTurnedOn'
    stitcher_under_temperature = 'stitcherUnderTemperature'
    stitcher_unrecoverable_failure = 'stitcherUnrecoverableFailure'
    stitcher_unrecoverable_storage_error = 'stitcherUnrecoverableStorageError'
    stitcher_warming_up = 'stitcherWarmingUp'
    subunit_added = 'subunitAdded'
    subunit_almost_empty = 'subunitAlmostEmpty'
    subunit_almost_full = 'subunitAlmostFull'
    subunit_at_limit = 'subunitAtLimit'
    subunit_closed = 'subunitClosed'
    subunit_cooling_down = 'subunitCoolingDown'
    subunit_empty = 'subunitEmpty'
    subunit_full = 'subunitFull'
    subunit_life_almost_over = 'subunitLifeAlmostOver'
    subunit_life_over = 'subunitLifeOver'
    subunit_memory_exhausted = 'subunitMemoryExhausted'
    subunit_missing = 'subunitMissing'
    subunit_motor_failure = 'subunitMotorFailure'
    subunit_near_limit = 'subunitNearLimit'
    subunit_offline = 'subunitOffline'
    subunit_opened = 'subunitOpened'
    subunit_over_temperature = 'subunitOverTemperature'
    subunit_power_saver = 'subunitPowerSaver'
    subunit_recoverable_failure = 'subunitRecoverableFailure'
    subunit_recoverable_storage = 'subunitRecoverableStorage'
    subunit_removed = 'subunitRemoved'
    subunit_resource_added = 'subunitResourceAdded'
    subunit_resource_removed = 'subunitResourceRemoved'
    subunit_thermistor_failure = 'subunitThermistorFailure'
    subunit_timing_failure = 'subunitTimingFailure'
    subunit_turned_off = 'subunitTurnedOff'
    subunit_turned_on = 'subunitTurnedOn'
    subunit_under_temperature = 'subunitUnderTemperature'
    subunit_unrecoverable_failure = 'subunitUnrecoverableFailure'
    subunit_unrecoverable_storage = 'subunitUnrecoverableStorage'
    subunit_warming_up = 'subunitWarmingUp'
    suspend = 'suspend'
    testing = 'testing'
    trimmer_added = 'trimmerAdded'
    trimmer_almost_empty = 'trimmerAlmostEmpty'
    trimmer_almost_full = 'trimmerAlmostFull'
    trimmer_at_limit = 'trimmerAtLimit'
    trimmer_closed = 'trimmerClosed'
    trimmer_configuration_change = 'trimmerConfigurationChange'
    trimmer_cover_closed = 'trimmerCoverClosed'
    trimmer_cover_open = 'trimmerCoverOpen'
    trimmer_empty = 'trimmerEmpty'
    trimmer_full = 'trimmerFull'
    trimmer_interlock_closed = 'trimmerInterlockClosed'
    trimmer_interlock_open = 'trimmerInterlockOpen'
    trimmer_jam = 'trimmerJam'
    trimmer_life_almost_over = 'trimmerLifeAlmostOver'
    trimmer_life_over = 'trimmerLifeOver'
    trimmer_memory_exhausted = 'trimmerMemoryExhausted'
    trimmer_missing = 'trimmerMissing'
    trimmer_motor_failure = 'trimmerMotorFailure'
    trimmer_near_limit = 'trimmerNearLimit'
    trimmer_offline = 'trimmerOffline'
    trimmer_opened = 'trimmerOpened'
    trimmer_over_temperature = 'trimmerOverTemperature'
    trimmer_power_saver = 'trimmerPowerSaver'
    trimmer_recoverable_failure = 'trimmerRecoverableFailure'
    trimmer_recoverable_storage = 'trimmerRecoverableStorage'
    trimmer_removed = 'trimmerRemoved'
    trimmer_resource_added = 'trimmerResourceAdded'
    trimmer_resource_removed = 'trimmerResourceRemoved'
    trimmer_thermistor_failure = 'trimmerThermistorFailure'
    trimmer_timing_failure = 'trimmerTimingFailure'
    trimmer_turned_off = 'trimmerTurnedOff'
    trimmer_turned_on = 'trimmerTurnedOn'
    trimmer_under_temperature = 'trimmerUnderTemperature'
    trimmer_unrecoverable_failure = 'trimmerUnrecoverableFailure'
    trimmer_unrecoverable_storage_error = 'trimmerUnrecoverableStorageError'
    trimmer_warming_up = 'trimmerWarmingUp'
    unknown = 'unknown'
    wrapper_added = 'wrapperAdded'
    wrapper_almost_empty = 'wrapperAlmostEmpty'
    wrapper_almost_full = 'wrapperAlmostFull'
    wrapper_at_limit = 'wrapperAtLimit'
    wrapper_closed = 'wrapperClosed'
    wrapper_configuration_change = 'wrapperConfigurationChange'
    wrapper_cover_closed = 'wrapperCoverClosed'
    wrapper_cover_open = 'wrapperCoverOpen'
    wrapper_empty = 'wrapperEmpty'
    wrapper_full = 'wrapperFull'
    wrapper_interlock_closed = 'wrapperInterlockClosed'
    wrapper_interlock_open = 'wrapperInterlockOpen'
    wrapper_jam = 'wrapperJam'
    wrapper_life_almost_over = 'wrapperLifeAlmostOver'
    wrapper_life_over = 'wrapperLifeOver'
    wrapper_memory_exhausted = 'wrapperMemoryExhausted'
    wrapper_missing = 'wrapperMissing'
    wrapper_motor_failure = 'wrapperMotorFailure'
    wrapper_near_limit = 'wrapperNearLimit'
    wrapper_offline = 'wrapperOffline'
    wrapper_opened = 'wrapperOpened'
    wrapper_over_temperature = 'wrapperOverTemperature'
    wrapper_power_saver = 'wrapperPowerSaver'
    wrapper_recoverable_failure = 'wrapperRecoverableFailure'
    wrapper_recoverable_storage = 'wrapperRecoverableStorage'
    wrapper_removed = 'wrapperRemoved'
    wrapper_resource_added = 'wrapperResourceAdded'
    wrapper_resource_removed = 'wrapperResourceRemoved'
    wrapper_thermistor_failure = 'wrapperThermistorFailure'
    wrapper_timing_failure = 'wrapperTimingFailure'
    wrapper_turned_off = 'wrapperTurnedOff'
    wrapper_turned_on = 'wrapperTurnedOn'
    wrapper_under_temperature = 'wrapperUnderTemperature'
    wrapper_unrecoverable_failure = 'wrapperUnrecoverableFailure'
    wrapper_unrecoverable_storage_error = 'wrapperUnrecoverableStorageError'
    wrapper_warming_up = 'wrapperWarmingUp'


class PrintEvent(Enum):
    job_started = 'jobStarted'
    unknown_future_value = 'unknownFutureValue'


class PrintFinishing(Enum):
    none = 'none'
    staple = 'staple'
    punch = 'punch'
    cover = 'cover'
    bind = 'bind'
    saddle_stitch = 'saddleStitch'
    stitch_edge = 'stitchEdge'
    staple_top_left = 'stapleTopLeft'
    staple_bottom_left = 'stapleBottomLeft'
    staple_top_right = 'stapleTopRight'
    staple_bottom_right = 'stapleBottomRight'
    stitch_left_edge = 'stitchLeftEdge'
    stitch_top_edge = 'stitchTopEdge'
    stitch_right_edge = 'stitchRightEdge'
    stitch_bottom_edge = 'stitchBottomEdge'
    staple_dual_left = 'stapleDualLeft'
    staple_dual_top = 'stapleDualTop'
    staple_dual_right = 'stapleDualRight'
    staple_dual_bottom = 'stapleDualBottom'
    unknown_future_value = 'unknownFutureValue'
    staple_triple_left = 'stapleTripleLeft'
    staple_triple_top = 'stapleTripleTop'
    staple_triple_right = 'stapleTripleRight'
    staple_triple_bottom = 'stapleTripleBottom'
    bind_left = 'bindLeft'
    bind_top = 'bindTop'
    bind_right = 'bindRight'
    bind_bottom = 'bindBottom'
    fold_accordion = 'foldAccordion'
    fold_double_gate = 'foldDoubleGate'
    fold_gate = 'foldGate'
    fold_half = 'foldHalf'
    fold_half_z = 'foldHalfZ'
    fold_left_gate = 'foldLeftGate'
    fold_letter = 'foldLetter'
    fold_parallel = 'foldParallel'
    fold_poster = 'foldPoster'
    fold_right_gate = 'foldRightGate'
    fold_z = 'foldZ'
    fold_engineering_z = 'foldEngineeringZ'
    punch_top_left = 'punchTopLeft'
    punch_bottom_left = 'punchBottomLeft'
    punch_top_right = 'punchTopRight'
    punch_bottom_right = 'punchBottomRight'
    punch_dual_left = 'punchDualLeft'
    punch_dual_top = 'punchDualTop'
    punch_dual_right = 'punchDualRight'
    punch_dual_bottom = 'punchDualBottom'
    punch_triple_left = 'punchTripleLeft'
    punch_triple_top = 'punchTripleTop'
    punch_triple_right = 'punchTripleRight'
    punch_triple_bottom = 'punchTripleBottom'
    punch_quad_left = 'punchQuadLeft'
    punch_quad_top = 'punchQuadTop'
    punch_quad_right = 'punchQuadRight'
    punch_quad_bottom = 'punchQuadBottom'
    fold = 'fold'
    trim = 'trim'
    bale = 'bale'
    booklet_maker = 'bookletMaker'
    coat = 'coat'
    laminate = 'laminate'
    trim_after_pages = 'trimAfterPages'
    trim_after_documents = 'trimAfterDocuments'
    trim_after_copies = 'trimAfterCopies'
    trim_after_job = 'trimAfterJob'


class PrintJobProcessingState(Enum):
    unknown = 'unknown'
    pending = 'pending'
    processing = 'processing'
    paused = 'paused'
    stopped = 'stopped'
    completed = 'completed'
    canceled = 'canceled'
    aborted = 'aborted'
    unknown_future_value = 'unknownFutureValue'


class PrintJobStateDetail(Enum):
    upload_pending = 'uploadPending'
    transforming = 'transforming'
    completed_successfully = 'completedSuccessfully'
    completed_with_warnings = 'completedWithWarnings'
    completed_with_errors = 'completedWithErrors'
    release_wait = 'releaseWait'
    interpreting = 'interpreting'
    unknown_future_value = 'unknownFutureValue'


class PrintMultipageLayout(Enum):
    clockwise_from_top_left = 'clockwiseFromTopLeft'
    counterclockwise_from_top_left = 'counterclockwiseFromTopLeft'
    counterclockwise_from_top_right = 'counterclockwiseFromTopRight'
    clockwise_from_top_right = 'clockwiseFromTopRight'
    counterclockwise_from_bottom_left = 'counterclockwiseFromBottomLeft'
    clockwise_from_bottom_left = 'clockwiseFromBottomLeft'
    counterclockwise_from_bottom_right = 'counterclockwiseFromBottomRight'
    clockwise_from_bottom_right = 'clockwiseFromBottomRight'
    unknown_future_value = 'unknownFutureValue'


class PrintOperationProcessingState(Enum):
    not_started = 'notStarted'
    running = 'running'
    succeeded = 'succeeded'
    failed = 'failed'
    unknown_future_value = 'unknownFutureValue'


class PrintOrientation(Enum):
    portrait = 'portrait'
    landscape = 'landscape'
    reverse_landscape = 'reverseLandscape'
    reverse_portrait = 'reversePortrait'
    unknown_future_value = 'unknownFutureValue'


class PrintQuality(Enum):
    low = 'low'
    medium = 'medium'
    high = 'high'
    unknown_future_value = 'unknownFutureValue'


class PrintScaling(Enum):
    auto = 'auto'
    shrink_to_fit = 'shrinkToFit'
    fill = 'fill'
    fit = 'fit'
    none = 'none'
    unknown_future_value = 'unknownFutureValue'


class PrintTaskProcessingState(Enum):
    pending = 'pending'
    processing = 'processing'
    completed = 'completed'
    aborted = 'aborted'
    unknown_future_value = 'unknownFutureValue'


class PrivilegedAccessGroupAssignmentType(Enum):
    assigned = 'assigned'
    activated = 'activated'
    unknown_future_value = 'unknownFutureValue'


class PrivilegedAccessGroupMemberType(Enum):
    direct = 'direct'
    group = 'group'
    unknown_future_value = 'unknownFutureValue'


class PrivilegedAccessGroupRelationships(Enum):
    owner = 'owner'
    member = 'member'
    unknown_future_value = 'unknownFutureValue'


class ProcessIntegrityLevel(Enum):
    unknown = 'unknown'
    untrusted = 'untrusted'
    low = 'low'
    medium = 'medium'
    high = 'high'
    system = 'system'
    unknown_future_value = 'unknownFutureValue'


class PromptLoginBehavior(Enum):
    translate_to_fresh_password_authentication = (
        'translateToFreshPasswordAuthentication'
    )
    native_support = 'nativeSupport'
    disabled = 'disabled'
    unknown_future_value = 'unknownFutureValue'


class ProtectionPolicyStatus(Enum):
    inactive = 'inactive'
    active_with_errors = 'activeWithErrors'
    updating = 'updating'
    active = 'active'
    unknown_future_value = 'unknownFutureValue'


class ProtectionRuleStatus(Enum):
    draft = 'draft'
    active = 'active'
    completed = 'completed'
    completed_with_errors = 'completedWithErrors'
    unknown_future_value = 'unknownFutureValue'


class ProtectionUnitStatus(Enum):
    protect_requested = 'protectRequested'
    protected = 'protected'
    unprotect_requested = 'unprotectRequested'
    unprotected = 'unprotected'
    remove_requested = 'removeRequested'
    unknown_future_value = 'unknownFutureValue'


class ProvisioningAction(Enum):
    other = 'other'
    create = 'create'
    delete = 'delete'
    disable = 'disable'
    update = 'update'
    staged_delete = 'stagedDelete'
    unknown_future_value = 'unknownFutureValue'


class ProvisioningResult(Enum):
    success = 'success'
    failure = 'failure'
    skipped = 'skipped'
    warning = 'warning'
    unknown_future_value = 'unknownFutureValue'


class ProvisioningStatusErrorCategory(Enum):
    failure = 'failure'
    non_service_failure = 'nonServiceFailure'
    success = 'success'
    unknown_future_value = 'unknownFutureValue'


class ProvisioningStepType(Enum):
    import_ = 'import'
    scoping = 'scoping'
    matching = 'matching'
    processing = 'processing'
    reference_resolution = 'referenceResolution'
    export = 'export'
    unknown_future_value = 'unknownFutureValue'


class QuarantineReason(Enum):
    encountered_base_escrow_threshold = 'EncounteredBaseEscrowThreshold'
    encountered_total_escrow_threshold = 'EncounteredTotalEscrowThreshold'
    encountered_escrow_proportion_threshold = 'EncounteredEscrowProportionThreshold'
    encountered_quarantine_exception = 'EncounteredQuarantineException'
    unknown = 'Unknown'
    quarantined_on_demand = 'QuarantinedOnDemand'
    too_many_deletes = 'TooManyDeletes'
    ingestion_interrupted = 'IngestionInterrupted'


class RatingAppsType(Enum):
    all_allowed = 'allAllowed'
    all_blocked = 'allBlocked'
    ages_above4 = 'agesAbove4'
    ages_above9 = 'agesAbove9'
    ages_above12 = 'agesAbove12'
    ages_above17 = 'agesAbove17'


class RatingAustraliaMoviesType(Enum):
    all_allowed = 'allAllowed'
    all_blocked = 'allBlocked'
    general = 'general'
    parental_guidance = 'parentalGuidance'
    mature = 'mature'
    ages_above15 = 'agesAbove15'
    ages_above18 = 'agesAbove18'


class RatingAustraliaTelevisionType(Enum):
    all_allowed = 'allAllowed'
    all_blocked = 'allBlocked'
    preschoolers = 'preschoolers'
    children = 'children'
    general = 'general'
    parental_guidance = 'parentalGuidance'
    mature = 'mature'
    ages_above15 = 'agesAbove15'
    ages_above15_adult_violence = 'agesAbove15AdultViolence'


class RatingCanadaMoviesType(Enum):
    all_allowed = 'allAllowed'
    all_blocked = 'allBlocked'
    general = 'general'
    parental_guidance = 'parentalGuidance'
    ages_above14 = 'agesAbove14'
    ages_above18 = 'agesAbove18'
    restricted = 'restricted'


class RatingCanadaTelevisionType(Enum):
    all_allowed = 'allAllowed'
    all_blocked = 'allBlocked'
    children = 'children'
    children_above8 = 'childrenAbove8'
    general = 'general'
    parental_guidance = 'parentalGuidance'
    ages_above14 = 'agesAbove14'
    ages_above18 = 'agesAbove18'


class RatingFranceMoviesType(Enum):
    all_allowed = 'allAllowed'
    all_blocked = 'allBlocked'
    ages_above10 = 'agesAbove10'
    ages_above12 = 'agesAbove12'
    ages_above16 = 'agesAbove16'
    ages_above18 = 'agesAbove18'


class RatingFranceTelevisionType(Enum):
    all_allowed = 'allAllowed'
    all_blocked = 'allBlocked'
    ages_above10 = 'agesAbove10'
    ages_above12 = 'agesAbove12'
    ages_above16 = 'agesAbove16'
    ages_above18 = 'agesAbove18'


class RatingGermanyMoviesType(Enum):
    all_allowed = 'allAllowed'
    all_blocked = 'allBlocked'
    general = 'general'
    ages_above6 = 'agesAbove6'
    ages_above12 = 'agesAbove12'
    ages_above16 = 'agesAbove16'
    adults = 'adults'


class RatingGermanyTelevisionType(Enum):
    all_allowed = 'allAllowed'
    all_blocked = 'allBlocked'
    general = 'general'
    ages_above6 = 'agesAbove6'
    ages_above12 = 'agesAbove12'
    ages_above16 = 'agesAbove16'
    adults = 'adults'


class RatingIrelandMoviesType(Enum):
    all_allowed = 'allAllowed'
    all_blocked = 'allBlocked'
    general = 'general'
    parental_guidance = 'parentalGuidance'
    ages_above12 = 'agesAbove12'
    ages_above15 = 'agesAbove15'
    ages_above16 = 'agesAbove16'
    adults = 'adults'


class RatingIrelandTelevisionType(Enum):
    all_allowed = 'allAllowed'
    all_blocked = 'allBlocked'
    general = 'general'
    children = 'children'
    young_adults = 'youngAdults'
    parental_supervision = 'parentalSupervision'
    mature = 'mature'


class RatingJapanMoviesType(Enum):
    all_allowed = 'allAllowed'
    all_blocked = 'allBlocked'
    general = 'general'
    parental_guidance = 'parentalGuidance'
    ages_above15 = 'agesAbove15'
    ages_above18 = 'agesAbove18'


class RatingJapanTelevisionType(Enum):
    all_allowed = 'allAllowed'
    all_blocked = 'allBlocked'
    explicit_allowed = 'explicitAllowed'


class RatingNewZealandMoviesType(Enum):
    all_allowed = 'allAllowed'
    all_blocked = 'allBlocked'
    general = 'general'
    parental_guidance = 'parentalGuidance'
    mature = 'mature'
    ages_above13 = 'agesAbove13'
    ages_above15 = 'agesAbove15'
    ages_above16 = 'agesAbove16'
    ages_above18 = 'agesAbove18'
    restricted = 'restricted'
    ages_above16_restricted = 'agesAbove16Restricted'


class RatingNewZealandTelevisionType(Enum):
    all_allowed = 'allAllowed'
    all_blocked = 'allBlocked'
    general = 'general'
    parental_guidance = 'parentalGuidance'
    adults = 'adults'


class RatingUnitedKingdomMoviesType(Enum):
    all_allowed = 'allAllowed'
    all_blocked = 'allBlocked'
    general = 'general'
    universal_children = 'universalChildren'
    parental_guidance = 'parentalGuidance'
    ages_above12_video = 'agesAbove12Video'
    ages_above12_cinema = 'agesAbove12Cinema'
    ages_above15 = 'agesAbove15'
    adults = 'adults'


class RatingUnitedKingdomTelevisionType(Enum):
    all_allowed = 'allAllowed'
    all_blocked = 'allBlocked'
    caution = 'caution'


class RatingUnitedStatesMoviesType(Enum):
    all_allowed = 'allAllowed'
    all_blocked = 'allBlocked'
    general = 'general'
    parental_guidance = 'parentalGuidance'
    parental_guidance13 = 'parentalGuidance13'
    restricted = 'restricted'
    adults = 'adults'


class RatingUnitedStatesTelevisionType(Enum):
    all_allowed = 'allAllowed'
    all_blocked = 'allBlocked'
    children_all = 'childrenAll'
    children_above7 = 'childrenAbove7'
    general = 'general'
    parental_guidance = 'parentalGuidance'
    children_above14 = 'childrenAbove14'
    adults = 'adults'


class RecipientScopeType(Enum):
    none = 'none'
    internal = 'internal'
    external = 'external'
    external_partner = 'externalPartner'
    external_non_partner = 'externalNonPartner'


class RecordingStatus(Enum):
    unknown = 'unknown'
    not_recording = 'notRecording'
    recording = 'recording'
    failed = 'failed'
    unknown_future_value = 'unknownFutureValue'


class RecurrencePatternType(Enum):
    daily = 'daily'
    weekly = 'weekly'
    absolute_monthly = 'absoluteMonthly'
    relative_monthly = 'relativeMonthly'
    absolute_yearly = 'absoluteYearly'
    relative_yearly = 'relativeYearly'


class RecurrenceRangeType(Enum):
    end_date = 'endDate'
    no_end = 'noEnd'
    numbered = 'numbered'


class RegistryHive(Enum):
    unknown = 'unknown'
    current_config = 'currentConfig'
    current_user = 'currentUser'
    local_machine_sam = 'localMachineSam'
    local_machine_security = 'localMachineSecurity'
    local_machine_software = 'localMachineSoftware'
    local_machine_system = 'localMachineSystem'
    users_default = 'usersDefault'
    unknown_future_value = 'unknownFutureValue'


class RegistryOperation(Enum):
    unknown = 'unknown'
    create = 'create'
    modify = 'modify'
    delete = 'delete'
    unknown_future_value = 'unknownFutureValue'


class RegistryValueType(Enum):
    unknown = 'unknown'
    binary = 'binary'
    dword = 'dword'
    dword_little_endian = 'dwordLittleEndian'
    dword_big_endian = 'dwordBigEndian'
    expand_sz = 'expandSz'
    link = 'link'
    multi_sz = 'multiSz'
    none = 'none'
    qword = 'qword'
    qwordlittle_endian = 'qwordlittleEndian'
    sz = 'sz'
    unknown_future_value = 'unknownFutureValue'


class RejectReason(Enum):
    none = 'none'
    busy = 'busy'
    forbidden = 'forbidden'
    unknown_future_value = 'unknownFutureValue'


class RemindBeforeTimeInMinutesType(Enum):
    mins15 = 'mins15'
    unknown_future_value = 'unknownFutureValue'


class RemoteAssistanceOnboardingStatus(Enum):
    not_onboarded = 'notOnboarded'
    onboarding = 'onboarding'
    onboarded = 'onboarded'


class RequiredPasswordType(Enum):
    device_default = 'deviceDefault'
    alphanumeric = 'alphanumeric'
    numeric = 'numeric'


class ResponseType(Enum):
    none = 'none'
    organizer = 'organizer'
    tentatively_accepted = 'tentativelyAccepted'
    accepted = 'accepted'
    declined = 'declined'
    not_responded = 'notResponded'


class RestorableArtifact(Enum):
    message = 'message'
    unknown_future_value = 'unknownFutureValue'


class RestorePointPreference(Enum):
    latest = 'latest'
    oldest = 'oldest'
    unknown_future_value = 'unknownFutureValue'


class RestorePointTags(Enum):
    none = 'none'
    fast_restore = 'fastRestore'
    unknown_future_value = 'unknownFutureValue'


class RestoreSessionStatus(Enum):
    draft = 'draft'
    activating = 'activating'
    active = 'active'
    completed_with_error = 'completedWithError'
    completed = 'completed'
    unknown_future_value = 'unknownFutureValue'
    failed = 'failed'


class RiskDetail(Enum):
    none = 'none'
    admin_generated_temporary_password = 'adminGeneratedTemporaryPassword'
    user_performed_secured_password_change = 'userPerformedSecuredPasswordChange'
    user_performed_secured_password_reset = 'userPerformedSecuredPasswordReset'
    admin_confirmed_signin_safe = 'adminConfirmedSigninSafe'
    ai_confirmed_signin_safe = 'aiConfirmedSigninSafe'
    user_passed_mfa_driven_by_risk_based_policy = 'userPassedMFADrivenByRiskBasedPolicy'
    admin_dismissed_all_risk_for_user = 'adminDismissedAllRiskForUser'
    admin_confirmed_signin_compromised = 'adminConfirmedSigninCompromised'
    hidden = 'hidden'
    admin_confirmed_user_compromised = 'adminConfirmedUserCompromised'
    unknown_future_value = 'unknownFutureValue'
    m365_d_admin_dismissed_detection = 'm365DAdminDismissedDetection'
    admin_confirmed_service_principal_compromised = (
        'adminConfirmedServicePrincipalCompromised'
    )
    admin_dismissed_all_risk_for_service_principal = (
        'adminDismissedAllRiskForServicePrincipal'
    )
    user_changed_password_on_premises = 'userChangedPasswordOnPremises'
    admin_dismissed_risk_for_sign_in = 'adminDismissedRiskForSignIn'
    admin_confirmed_account_safe = 'adminConfirmedAccountSafe'


class RiskDetectionTimingType(Enum):
    not_defined = 'notDefined'
    realtime = 'realtime'
    near_realtime = 'nearRealtime'
    offline = 'offline'
    unknown_future_value = 'unknownFutureValue'


class RiskEventType(Enum):
    unlikely_travel = 'unlikelyTravel'
    anonymized_ip_address = 'anonymizedIPAddress'
    malicious_ip_address = 'maliciousIPAddress'
    unfamiliar_features = 'unfamiliarFeatures'
    malware_infected_ip_address = 'malwareInfectedIPAddress'
    suspicious_ip_address = 'suspiciousIPAddress'
    leaked_credentials = 'leakedCredentials'
    investigations_threat_intelligence = 'investigationsThreatIntelligence'
    generic = 'generic'
    admin_confirmed_user_compromised = 'adminConfirmedUserCompromised'
    mcas_impossible_travel = 'mcasImpossibleTravel'
    mcas_suspicious_inbox_manipulation_rules = 'mcasSuspiciousInboxManipulationRules'
    investigations_threat_intelligence_signin_linked = (
        'investigationsThreatIntelligenceSigninLinked'
    )
    malicious_ip_address_valid_credentials_blocked_ip = (
        'maliciousIPAddressValidCredentialsBlockedIP'
    )
    unknown_future_value = 'unknownFutureValue'


class RiskLevel(Enum):
    low = 'low'
    medium = 'medium'
    high = 'high'
    hidden = 'hidden'
    none = 'none'
    unknown_future_value = 'unknownFutureValue'


class RiskState(Enum):
    none = 'none'
    confirmed_safe = 'confirmedSafe'
    remediated = 'remediated'
    dismissed = 'dismissed'
    at_risk = 'atRisk'
    confirmed_compromised = 'confirmedCompromised'
    unknown_future_value = 'unknownFutureValue'


class RoleAssignmentScheduleFilterByCurrentUserOptions(Enum):
    principal = 'principal'
    unknown_future_value = 'unknownFutureValue'


class RoleAssignmentScheduleInstanceFilterByCurrentUserOptions(Enum):
    principal = 'principal'
    unknown_future_value = 'unknownFutureValue'


class RoleAssignmentScheduleRequestFilterByCurrentUserOptions(Enum):
    principal = 'principal'
    created_by = 'createdBy'
    approver = 'approver'
    unknown_future_value = 'unknownFutureValue'


class RoleEligibilityScheduleFilterByCurrentUserOptions(Enum):
    principal = 'principal'
    unknown_future_value = 'unknownFutureValue'


class RoleEligibilityScheduleInstanceFilterByCurrentUserOptions(Enum):
    principal = 'principal'
    unknown_future_value = 'unknownFutureValue'


class RoleEligibilityScheduleRequestFilterByCurrentUserOptions(Enum):
    principal = 'principal'
    created_by = 'createdBy'
    approver = 'approver'
    unknown_future_value = 'unknownFutureValue'


class RoutingMode(Enum):
    one_to_one = 'oneToOne'
    multicast = 'multicast'
    unknown_future_value = 'unknownFutureValue'


class RoutingType(Enum):
    forwarded = 'forwarded'
    lookup = 'lookup'
    self_fork = 'selfFork'
    unknown_future_value = 'unknownFutureValue'


class RunAsAccountType(Enum):
    system = 'system'
    user = 'user'


class SafeSearchFilterType(Enum):
    user_defined = 'userDefined'
    strict = 'strict'
    moderate = 'moderate'


class ScheduleChangeRequestActor(Enum):
    sender = 'sender'
    recipient = 'recipient'
    manager = 'manager'
    system = 'system'
    unknown_future_value = 'unknownFutureValue'


class ScheduleChangeState(Enum):
    pending = 'pending'
    approved = 'approved'
    declined = 'declined'
    unknown_future_value = 'unknownFutureValue'


class ScheduleEntityTheme(Enum):
    white = 'white'
    blue = 'blue'
    green = 'green'
    purple = 'purple'
    pink = 'pink'
    yellow = 'yellow'
    gray = 'gray'
    dark_blue = 'darkBlue'
    dark_green = 'darkGreen'
    dark_purple = 'darkPurple'
    dark_pink = 'darkPink'
    dark_yellow = 'darkYellow'
    unknown_future_value = 'unknownFutureValue'


class ScheduleRequestActions(Enum):
    admin_assign = 'adminAssign'
    admin_update = 'adminUpdate'
    admin_remove = 'adminRemove'
    self_activate = 'selfActivate'
    self_deactivate = 'selfDeactivate'
    admin_extend = 'adminExtend'
    admin_renew = 'adminRenew'
    self_extend = 'selfExtend'
    self_renew = 'selfRenew'
    unknown_future_value = 'unknownFutureValue'


class ScopeOperatorMultiValuedComparisonType(Enum):
    all = 'All'
    any = 'Any'


class ScopeOperatorType(Enum):
    binary = 'Binary'
    unary = 'Unary'


class ScreenSharingRole(Enum):
    viewer = 'viewer'
    sharer = 'sharer'


class SearchAlterationType(Enum):
    suggestion = 'suggestion'
    modification = 'modification'
    unknown_future_value = 'unknownFutureValue'


class SearchContent(Enum):
    shared_content = 'sharedContent'
    private_content = 'privateContent'
    unknown_future_value = 'unknownFutureValue'


class SectionEmphasisType(Enum):
    none = 'none'
    neutral = 'neutral'
    soft = 'soft'
    strong = 'strong'
    unknown_future_value = 'unknownFutureValue'


class SecurityNetworkProtocol(Enum):
    unknown = 'unknown'
    ip = 'ip'
    icmp = 'icmp'
    igmp = 'igmp'
    ggp = 'ggp'
    ipv4 = 'ipv4'
    tcp = 'tcp'
    pup = 'pup'
    udp = 'udp'
    idp = 'idp'
    ipv6 = 'ipv6'
    ipv6_routing_header = 'ipv6RoutingHeader'
    ipv6_fragment_header = 'ipv6FragmentHeader'
    ip_sec_encapsulating_security_payload = 'ipSecEncapsulatingSecurityPayload'
    ip_sec_authentication_header = 'ipSecAuthenticationHeader'
    icmp_v6 = 'icmpV6'
    ipv6_no_next_header = 'ipv6NoNextHeader'
    ipv6_destination_options = 'ipv6DestinationOptions'
    nd = 'nd'
    raw = 'raw'
    ipx = 'ipx'
    spx = 'spx'
    spx_ii = 'spxII'
    unknown_future_value = 'unknownFutureValue'


class SecurityResourceType(Enum):
    unknown = 'unknown'
    attacked = 'attacked'
    related = 'related'
    unknown_future_value = 'unknownFutureValue'


class SelectionLikelihoodInfo(Enum):
    not_specified = 'notSpecified'
    high = 'high'


class SendDtmfCompletionReason(Enum):
    unknown = 'unknown'
    completed_successfully = 'completedSuccessfully'
    media_operation_canceled = 'mediaOperationCanceled'
    unknown_future_value = 'unknownFutureValue'


class Sensitivity(Enum):
    normal = 'normal'
    personal = 'personal'
    private = 'private'
    confidential = 'confidential'


class SensitivityLabelAssignmentMethod(Enum):
    standard = 'standard'
    privileged = 'privileged'
    auto = 'auto'
    unknown_future_value = 'unknownFutureValue'


class ServiceAppStatus(Enum):
    inactive = 'inactive'
    active = 'active'
    pending_active = 'pendingActive'
    pending_inactive = 'pendingInactive'
    unknown_future_value = 'unknownFutureValue'


class ServiceHealthClassificationType(Enum):
    advisory = 'advisory'
    incident = 'incident'
    unknown_future_value = 'unknownFutureValue'


class ServiceHealthOrigin(Enum):
    microsoft = 'microsoft'
    third_party = 'thirdParty'
    customer = 'customer'
    unknown_future_value = 'unknownFutureValue'


class ServiceHealthStatus(Enum):
    service_operational = 'serviceOperational'
    investigating = 'investigating'
    restoring_service = 'restoringService'
    verifying_service = 'verifyingService'
    service_restored = 'serviceRestored'
    post_incident_review_published = 'postIncidentReviewPublished'
    service_degradation = 'serviceDegradation'
    service_interruption = 'serviceInterruption'
    extended_recovery = 'extendedRecovery'
    false_positive = 'falsePositive'
    investigation_suspended = 'investigationSuspended'
    resolved = 'resolved'
    mitigated_external = 'mitigatedExternal'
    mitigated = 'mitigated'
    resolved_external = 'resolvedExternal'
    confirmed = 'confirmed'
    reported = 'reported'
    unknown_future_value = 'unknownFutureValue'


class ServiceUpdateCategory(Enum):
    prevent_or_fix_issue = 'preventOrFixIssue'
    plan_for_change = 'planForChange'
    stay_informed = 'stayInformed'
    unknown_future_value = 'unknownFutureValue'


class ServiceUpdateSeverity(Enum):
    normal = 'normal'
    high = 'high'
    critical = 'critical'
    unknown_future_value = 'unknownFutureValue'


class SettingSourceType(Enum):
    device_configuration = 'deviceConfiguration'
    device_intent = 'deviceIntent'


class SharedPCAccountDeletionPolicyType(Enum):
    immediate = 'immediate'
    disk_space_threshold = 'diskSpaceThreshold'
    disk_space_threshold_or_inactive_threshold = 'diskSpaceThresholdOrInactiveThreshold'


class SharedPCAllowedAccountType(Enum):
    guest = 'guest'
    domain = 'domain'


class SharingCapabilities(Enum):
    disabled = 'disabled'
    external_user_sharing_only = 'externalUserSharingOnly'
    external_user_and_guest_sharing = 'externalUserAndGuestSharing'
    existing_external_user_sharing_only = 'existingExternalUserSharingOnly'
    unknown_future_value = 'unknownFutureValue'


class SharingDomainRestrictionMode(Enum):
    none = 'none'
    allow_list = 'allowList'
    block_list = 'blockList'
    unknown_future_value = 'unknownFutureValue'


class SignInFrequencyAuthenticationType(Enum):
    primary_and_secondary_authentication = 'primaryAndSecondaryAuthentication'
    secondary_authentication = 'secondaryAuthentication'
    unknown_future_value = 'unknownFutureValue'


class SignInFrequencyInterval(Enum):
    time_based = 'timeBased'
    every_time = 'everyTime'
    unknown_future_value = 'unknownFutureValue'


class SigninFrequencyType(Enum):
    days = 'days'
    hours = 'hours'


class SignInUserType(Enum):
    member = 'member'
    guest = 'guest'
    unknown_future_value = 'unknownFutureValue'


class SimulationAttackTechnique(Enum):
    unknown = 'unknown'
    credential_harvesting = 'credentialHarvesting'
    attachment_malware = 'attachmentMalware'
    drive_by_url = 'driveByUrl'
    link_in_attachment = 'linkInAttachment'
    link_to_malware_file = 'linkToMalwareFile'
    unknown_future_value = 'unknownFutureValue'


class SimulationAttackType(Enum):
    unknown = 'unknown'
    social = 'social'
    cloud = 'cloud'
    endpoint = 'endpoint'
    unknown_future_value = 'unknownFutureValue'


class SimulationAutomationRunStatus(Enum):
    unknown = 'unknown'
    running = 'running'
    succeeded = 'succeeded'
    failed = 'failed'
    skipped = 'skipped'
    unknown_future_value = 'unknownFutureValue'


class SimulationAutomationStatus(Enum):
    unknown = 'unknown'
    draft = 'draft'
    not_running = 'notRunning'
    running = 'running'
    completed = 'completed'
    unknown_future_value = 'unknownFutureValue'


class SimulationContentSource(Enum):
    unknown = 'unknown'
    global_ = 'global'
    tenant = 'tenant'
    unknown_future_value = 'unknownFutureValue'


class SimulationContentStatus(Enum):
    unknown = 'unknown'
    draft = 'draft'
    ready = 'ready'
    archive = 'archive'
    delete = 'delete'
    unknown_future_value = 'unknownFutureValue'


class SimulationStatus(Enum):
    unknown = 'unknown'
    draft = 'draft'
    running = 'running'
    scheduled = 'scheduled'
    succeeded = 'succeeded'
    failed = 'failed'
    cancelled = 'cancelled'
    excluded = 'excluded'
    unknown_future_value = 'unknownFutureValue'


class SiteArchiveStatus(Enum):
    recently_archived = 'recentlyArchived'
    fully_archived = 'fullyArchived'
    reactivating = 'reactivating'
    unknown_future_value = 'unknownFutureValue'


class SiteLockState(Enum):
    unlocked = 'unlocked'
    locked_read_only = 'lockedReadOnly'
    locked_no_access = 'lockedNoAccess'
    locked_no_additions = 'lockedNoAdditions'
    unknown_future_value = 'unknownFutureValue'


class SiteSecurityLevel(Enum):
    user_defined = 'userDefined'
    low = 'low'
    medium_low = 'mediumLow'
    medium = 'medium'
    medium_high = 'mediumHigh'
    high = 'high'


class SocialIdentitySourceType(Enum):
    facebook = 'facebook'
    unknown_future_value = 'unknownFutureValue'


class StagedFeatureName(Enum):
    passthrough_authentication = 'passthroughAuthentication'
    seamless_sso = 'seamlessSso'
    password_hash_sync = 'passwordHashSync'
    email_as_alternate_id = 'emailAsAlternateId'
    unknown_future_value = 'unknownFutureValue'
    certificate_based_authentication = 'certificateBasedAuthentication'
    multi_factor_authentication = 'multiFactorAuthentication'


class StateManagementSetting(Enum):
    not_configured = 'notConfigured'
    blocked = 'blocked'
    allowed = 'allowed'


class Status(Enum):
    active = 'active'
    updated = 'updated'
    deleted = 'deleted'
    ignored = 'ignored'
    unknown_future_value = 'unknownFutureValue'


class SubjectRightsRequestStage(Enum):
    content_retrieval = 'contentRetrieval'
    content_review = 'contentReview'
    generate_report = 'generateReport'
    content_deletion = 'contentDeletion'
    case_resolved = 'caseResolved'
    content_estimate = 'contentEstimate'
    unknown_future_value = 'unknownFutureValue'
    approval = 'approval'


class SubjectRightsRequestStageStatus(Enum):
    not_started = 'notStarted'
    current = 'current'
    completed = 'completed'
    failed = 'failed'
    unknown_future_value = 'unknownFutureValue'


class SubjectRightsRequestStatus(Enum):
    active = 'active'
    closed = 'closed'
    unknown_future_value = 'unknownFutureValue'


class SubjectRightsRequestType(Enum):
    export = 'export'
    delete = 'delete'
    access = 'access'
    tag_for_action = 'tagForAction'
    unknown_future_value = 'unknownFutureValue'


class SynchronizationDisposition(Enum):
    normal = 'Normal'
    discard = 'Discard'
    escrow = 'Escrow'


class SynchronizationJobRestartScope(Enum):
    none = 'None'
    connector_data_store = 'ConnectorDataStore'
    escrows = 'Escrows'
    watermark = 'Watermark'
    quarantine_state = 'QuarantineState'
    full = 'Full'
    force_deletes = 'ForceDeletes'


class SynchronizationMetadata(Enum):
    gallery_application_identifier = 'GalleryApplicationIdentifier'
    gallery_application_key = 'GalleryApplicationKey'
    is_o_auth_enabled = 'IsOAuthEnabled'
    is_synchronization_agent_assignment_required = (
        'IsSynchronizationAgentAssignmentRequired'
    )
    is_synchronization_agent_required = 'IsSynchronizationAgentRequired'
    is_synchronization_in_preview = 'IsSynchronizationInPreview'
    o_auth_settings = 'OAuthSettings'
    synchronization_learn_more_ibiza_fw_link = 'SynchronizationLearnMoreIbizaFwLink'
    configuration_fields = 'ConfigurationFields'


class SynchronizationScheduleState(Enum):
    active = 'Active'
    disabled = 'Disabled'
    paused = 'Paused'


class SynchronizationSecret(Enum):
    none = 'None'
    user_name = 'UserName'
    password = 'Password'
    secret_token = 'SecretToken'
    app_key = 'AppKey'
    base_address = 'BaseAddress'
    client_identifier = 'ClientIdentifier'
    client_secret = 'ClientSecret'
    single_sign_on_type = 'SingleSignOnType'
    sandbox = 'Sandbox'
    url = 'Url'
    domain = 'Domain'
    consumer_key = 'ConsumerKey'
    consumer_secret = 'ConsumerSecret'
    token_key = 'TokenKey'
    token_expiration = 'TokenExpiration'
    oauth2_access_token = 'Oauth2AccessToken'
    oauth2_access_token_creation_time = 'Oauth2AccessTokenCreationTime'
    oauth2_refresh_token = 'Oauth2RefreshToken'
    sync_all = 'SyncAll'
    instance_name = 'InstanceName'
    oauth2_client_id = 'Oauth2ClientId'
    oauth2_client_secret = 'Oauth2ClientSecret'
    company_id = 'CompanyId'
    update_key_on_soft_delete = 'UpdateKeyOnSoftDelete'
    synchronization_schedule = 'SynchronizationSchedule'
    system_of_record = 'SystemOfRecord'
    sandbox_name = 'SandboxName'
    enforce_domain = 'EnforceDomain'
    sync_notification_settings = 'SyncNotificationSettings'
    skip_out_of_scope_deletions = 'SkipOutOfScopeDeletions'
    oauth2_authorization_code = 'Oauth2AuthorizationCode'
    oauth2_redirect_uri = 'Oauth2RedirectUri'
    application_template_identifier = 'ApplicationTemplateIdentifier'
    oauth2_token_exchange_uri = 'Oauth2TokenExchangeUri'
    oauth2_authorization_uri = 'Oauth2AuthorizationUri'
    authentication_type = 'AuthenticationType'
    server = 'Server'
    perform_inbound_entitlement_grants = 'PerformInboundEntitlementGrants'
    hard_deletes_enabled = 'HardDeletesEnabled'
    sync_agent_compatibility_key = 'SyncAgentCompatibilityKey'
    sync_agent_ad_container = 'SyncAgentADContainer'
    validate_domain = 'ValidateDomain'
    test_references = 'TestReferences'
    connection_string = 'ConnectionString'


class SynchronizationStatusCode(Enum):
    not_configured = 'NotConfigured'
    not_run = 'NotRun'
    active = 'Active'
    paused = 'Paused'
    quarantine = 'Quarantine'


class SynchronizationTaskExecutionResult(Enum):
    succeeded = 'Succeeded'
    failed = 'Failed'
    entry_level_errors = 'EntryLevelErrors'


class TargetedManagedAppGroupType(Enum):
    selected_public_apps = 'selectedPublicApps'
    all_core_microsoft_apps = 'allCoreMicrosoftApps'
    all_microsoft_apps = 'allMicrosoftApps'
    all_apps = 'allApps'


class TargettedUserType(Enum):
    unknown = 'unknown'
    clicked = 'clicked'
    compromised = 'compromised'
    all_users = 'allUsers'
    unknown_future_value = 'unknownFutureValue'


class TaskStatus(Enum):
    not_started = 'notStarted'
    in_progress = 'inProgress'
    completed = 'completed'
    waiting_on_others = 'waitingOnOthers'
    deferred = 'deferred'


class TeamsAppDistributionMethod(Enum):
    store = 'store'
    organization = 'organization'
    sideloaded = 'sideloaded'
    unknown_future_value = 'unknownFutureValue'


class TeamsAppPublishingState(Enum):
    submitted = 'submitted'
    rejected = 'rejected'
    published = 'published'
    unknown_future_value = 'unknownFutureValue'


class TeamsAppResourceSpecificPermissionType(Enum):
    delegated = 'delegated'
    application = 'application'
    unknown_future_value = 'unknownFutureValue'


class TeamsAsyncOperationStatus(Enum):
    invalid = 'invalid'
    not_started = 'notStarted'
    in_progress = 'inProgress'
    succeeded = 'succeeded'
    failed = 'failed'
    unknown_future_value = 'unknownFutureValue'


class TeamsAsyncOperationType(Enum):
    invalid = 'invalid'
    clone_team = 'cloneTeam'
    archive_team = 'archiveTeam'
    unarchive_team = 'unarchiveTeam'
    create_team = 'createTeam'
    unknown_future_value = 'unknownFutureValue'
    teamify_group = 'teamifyGroup'
    create_channel = 'createChannel'
    archive_channel = 'archiveChannel'
    unarchive_channel = 'unarchiveChannel'


class TeamSpecialization(Enum):
    none = 'none'
    education_standard = 'educationStandard'
    education_class = 'educationClass'
    education_professional_learning_community = 'educationProfessionalLearningCommunity'
    education_staff = 'educationStaff'
    healthcare_standard = 'healthcareStandard'
    healthcare_care_coordination = 'healthcareCareCoordination'
    unknown_future_value = 'unknownFutureValue'


class TeamVisibilityType(Enum):
    private = 'private'
    public = 'public'
    hidden_membership = 'hiddenMembership'
    unknown_future_value = 'unknownFutureValue'


class TeamworkActivityTopicSource(Enum):
    entity_url = 'entityUrl'
    text = 'text'


class TeamworkApplicationIdentityType(Enum):
    aad_application = 'aadApplication'
    bot = 'bot'
    tenant_bot = 'tenantBot'
    office365_connector = 'office365Connector'
    outgoing_webhook = 'outgoingWebhook'
    unknown_future_value = 'unknownFutureValue'


class TeamworkCallEventType(Enum):
    call = 'call'
    meeting = 'meeting'
    screen_share = 'screenShare'
    unknown_future_value = 'unknownFutureValue'


class TeamworkConversationIdentityType(Enum):
    team = 'team'
    channel = 'channel'
    chat = 'chat'
    unknown_future_value = 'unknownFutureValue'


class TeamworkTagType(Enum):
    standard = 'standard'
    unknown_future_value = 'unknownFutureValue'


class TeamworkUserIdentityType(Enum):
    aad_user = 'aadUser'
    on_premise_aad_user = 'onPremiseAadUser'
    anonymous_guest = 'anonymousGuest'
    federated_user = 'federatedUser'
    personal_microsoft_account_user = 'personalMicrosoftAccountUser'
    skype_user = 'skypeUser'
    phone_user = 'phoneUser'
    unknown_future_value = 'unknownFutureValue'
    email_user = 'emailUser'


class TemplateApplicationLevel(Enum):
    none = 'none'
    new_partners = 'newPartners'
    existing_partners = 'existingPartners'
    unknown_future_value = 'unknownFutureValue'


class TemplateScenarios(Enum):
    new = 'new'
    secure_foundation = 'secureFoundation'
    zero_trust = 'zeroTrust'
    remote_work = 'remoteWork'
    protect_admins = 'protectAdmins'
    emerging_threats = 'emergingThreats'
    unknown_future_value = 'unknownFutureValue'


class ThreatAssessmentContentType(Enum):
    mail = 'mail'
    url = 'url'
    file = 'file'


class ThreatAssessmentRequestSource(Enum):
    undefined = 'undefined'
    user = 'user'
    administrator = 'administrator'


class ThreatAssessmentResultType(Enum):
    check_policy = 'checkPolicy'
    rescan = 'rescan'
    unknown_future_value = 'unknownFutureValue'


class ThreatAssessmentStatus(Enum):
    pending = 'pending'
    completed = 'completed'


class ThreatCategory(Enum):
    undefined = 'undefined'
    spam = 'spam'
    phishing = 'phishing'
    malware = 'malware'
    unknown_future_value = 'unknownFutureValue'


class ThreatExpectedAssessment(Enum):
    block = 'block'
    unblock = 'unblock'


class TimeOffReasonIconType(Enum):
    none = 'none'
    car = 'car'
    calendar = 'calendar'
    running = 'running'
    plane = 'plane'
    first_aid = 'firstAid'
    doctor = 'doctor'
    not_working = 'notWorking'
    clock = 'clock'
    jury_duty = 'juryDuty'
    globe = 'globe'
    cup = 'cup'
    phone = 'phone'
    weather = 'weather'
    umbrella = 'umbrella'
    piggy_bank = 'piggyBank'
    dog = 'dog'
    cake = 'cake'
    traffic_cone = 'trafficCone'
    pin = 'pin'
    sunny = 'sunny'
    unknown_future_value = 'unknownFutureValue'


class TimeZoneStandard(Enum):
    windows = 'windows'
    iana = 'iana'


class TitleAreaLayoutType(Enum):
    image_and_title = 'imageAndTitle'
    plain = 'plain'
    color_block = 'colorBlock'
    overlap = 'overlap'
    unknown_future_value = 'unknownFutureValue'


class TitleAreaTextAlignmentType(Enum):
    left = 'left'
    center = 'center'
    unknown_future_value = 'unknownFutureValue'


class TokenIssuerType(Enum):
    azure_ad = 'AzureAD'
    ad_federation_services = 'ADFederationServices'
    unknown_future_value = 'UnknownFutureValue'
    azure_ad_backup_auth = 'AzureADBackupAuth'
    ad_federation_services_mfa_adapter = 'ADFederationServicesMFAAdapter'
    nps_extension = 'NPSExtension'


class Tone(Enum):
    tone0 = 'tone0'
    tone1 = 'tone1'
    tone2 = 'tone2'
    tone3 = 'tone3'
    tone4 = 'tone4'
    tone5 = 'tone5'
    tone6 = 'tone6'
    tone7 = 'tone7'
    tone8 = 'tone8'
    tone9 = 'tone9'
    star = 'star'
    pound = 'pound'
    a = 'a'
    b = 'b'
    c = 'c'
    d = 'd'
    flash = 'flash'


class TrainingAssignedTo(Enum):
    none = 'none'
    all_users = 'allUsers'
    clicked_payload = 'clickedPayload'
    compromised = 'compromised'
    reported_phish = 'reportedPhish'
    read_but_not_clicked = 'readButNotClicked'
    did_nothing = 'didNothing'
    unknown_future_value = 'unknownFutureValue'


class TrainingAvailabilityStatus(Enum):
    unknown = 'unknown'
    not_available = 'notAvailable'
    available = 'available'
    archive = 'archive'
    delete = 'delete'
    unknown_future_value = 'unknownFutureValue'


class TrainingCompletionDuration(Enum):
    week = 'week'
    fortnite = 'fortnite'
    month = 'month'
    unknown_future_value = 'unknownFutureValue'


class TrainingSettingType(Enum):
    microsoft_custom = 'microsoftCustom'
    microsoft_managed = 'microsoftManaged'
    no_training = 'noTraining'
    custom = 'custom'
    unknown_future_value = 'unknownFutureValue'


class TrainingStatus(Enum):
    unknown = 'unknown'
    assigned = 'assigned'
    in_progress = 'inProgress'
    completed = 'completed'
    overdue = 'overdue'
    unknown_future_value = 'unknownFutureValue'


class TrainingType(Enum):
    unknown = 'unknown'
    phishing = 'phishing'
    unknown_future_value = 'unknownFutureValue'


class UnifiedRoleManagementPolicyRuleTargetOperations(Enum):
    all = 'all'
    activate = 'activate'
    deactivate = 'deactivate'
    assign = 'assign'
    update = 'update'
    remove = 'remove'
    extend = 'extend'
    renew = 'renew'
    unknown_future_value = 'unknownFutureValue'


class UnifiedRoleScheduleRequestActions(Enum):
    admin_assign = 'adminAssign'
    admin_update = 'adminUpdate'
    admin_remove = 'adminRemove'
    self_activate = 'selfActivate'
    self_deactivate = 'selfDeactivate'
    admin_extend = 'adminExtend'
    admin_renew = 'adminRenew'
    self_extend = 'selfExtend'
    self_renew = 'selfRenew'
    unknown_future_value = 'unknownFutureValue'


class UserAccountSecurityType(Enum):
    unknown = 'unknown'
    standard = 'standard'
    power = 'power'
    administrator = 'administrator'
    unknown_future_value = 'unknownFutureValue'


class UserDefaultAuthenticationMethod(Enum):
    push = 'push'
    oath = 'oath'
    voice_mobile = 'voiceMobile'
    voice_alternate_mobile = 'voiceAlternateMobile'
    voice_office = 'voiceOffice'
    sms = 'sms'
    none = 'none'
    unknown_future_value = 'unknownFutureValue'


class UserExperienceAnalyticsHealthState(Enum):
    unknown = 'unknown'
    insufficient_data = 'insufficientData'
    needs_attention = 'needsAttention'
    meeting_goals = 'meetingGoals'
    unknown_future_value = 'unknownFutureValue'


class UserExperienceAnalyticsInsightSeverity(Enum):
    none = 'none'
    informational = 'informational'
    warning = 'warning'
    error = 'error'
    unknown_future_value = 'unknownFutureValue'


class UserExperienceAnalyticsOperatingSystemRestartCategory(Enum):
    unknown = 'unknown'
    restart_with_update = 'restartWithUpdate'
    restart_without_update = 'restartWithoutUpdate'
    blue_screen = 'blueScreen'
    shutdown_with_update = 'shutdownWithUpdate'
    shutdown_without_update = 'shutdownWithoutUpdate'
    long_power_button_press = 'longPowerButtonPress'
    boot_error = 'bootError'
    update = 'update'
    unknown_future_value = 'unknownFutureValue'


class UserExperienceAnalyticsSummarizedBy(Enum):
    none = 'none'
    model = 'model'
    all_regressions = 'allRegressions'
    model_regression = 'modelRegression'
    manufacturer_regression = 'manufacturerRegression'
    operating_system_version_regression = 'operatingSystemVersionRegression'
    unknown_future_value = 'unknownFutureValue'


class UserFlowType(Enum):
    sign_up = 'signUp'
    sign_in = 'signIn'
    sign_up_or_sign_in = 'signUpOrSignIn'
    password_reset = 'passwordReset'
    profile_update = 'profileUpdate'
    resource_owner = 'resourceOwner'
    unknown_future_value = 'unknownFutureValue'


class UserPurpose(Enum):
    user = 'user'
    linked = 'linked'
    shared = 'shared'
    room = 'room'
    equipment = 'equipment'
    others = 'others'
    unknown_future_value = 'unknownFutureValue'


class UserSignInRecommendationScope(Enum):
    tenant = 'tenant'
    application = 'application'
    unknown_future_value = 'unknownFutureValue'


class UserType(Enum):
    member = 'member'
    guest = 'guest'
    unknown_future_value = 'unknownFutureValue'


class VirtualAppointmentMessageType(Enum):
    confirmation = 'confirmation'
    reschedule = 'reschedule'
    cancellation = 'cancellation'
    unknown_future_value = 'unknownFutureValue'


class VirtualEventAttendeeRegistrationStatus(Enum):
    registered = 'registered'
    canceled = 'canceled'
    waitlisted = 'waitlisted'
    pending_approval = 'pendingApproval'
    rejected_by_organizer = 'rejectedByOrganizer'
    unknown_future_value = 'unknownFutureValue'


class VirtualEventRegistrationPredefinedQuestionLabel(Enum):
    street = 'street'
    city = 'city'
    state = 'state'
    postal_code = 'postalCode'
    country_or_region = 'countryOrRegion'
    industry = 'industry'
    job_title = 'jobTitle'
    organization = 'organization'
    unknown_future_value = 'unknownFutureValue'


class VirtualEventRegistrationQuestionAnswerInputType(Enum):
    text = 'text'
    multiline_text = 'multilineText'
    single_choice = 'singleChoice'
    multi_choice = 'multiChoice'
    boolean = 'boolean'
    unknown_future_value = 'unknownFutureValue'


class VirtualEventStatus(Enum):
    draft = 'draft'
    published = 'published'
    canceled = 'canceled'
    unknown_future_value = 'unknownFutureValue'


class VisibilitySetting(Enum):
    not_configured = 'notConfigured'
    hide = 'hide'
    show = 'show'


class VolumeType(Enum):
    operating_system_volume = 'operatingSystemVolume'
    fixed_data_volume = 'fixedDataVolume'
    removable_data_volume = 'removableDataVolume'
    unknown_future_value = 'unknownFutureValue'


class VppTokenAccountType(Enum):
    business = 'business'
    education = 'education'


class VppTokenState(Enum):
    unknown = 'unknown'
    valid = 'valid'
    expired = 'expired'
    invalid = 'invalid'
    assigned_to_external_mdm = 'assignedToExternalMDM'


class VppTokenSyncStatus(Enum):
    none = 'none'
    in_progress = 'inProgress'
    completed = 'completed'
    failed = 'failed'


class WeakAlgorithms(Enum):
    rsa_sha1 = 'rsaSha1'
    unknown_future_value = 'unknownFutureValue'


class WebBrowserCookieSettings(Enum):
    browser_default = 'browserDefault'
    block_always = 'blockAlways'
    allow_current_web_site = 'allowCurrentWebSite'
    allow_from_websites_visited = 'allowFromWebsitesVisited'
    allow_always = 'allowAlways'


class WebsiteType(Enum):
    other = 'other'
    home = 'home'
    work = 'work'
    blog = 'blog'
    profile = 'profile'


class WeekIndex(Enum):
    first = 'first'
    second = 'second'
    third = 'third'
    fourth = 'fourth'
    last = 'last'


class WeeklySchedule(Enum):
    user_defined = 'userDefined'
    everyday = 'everyday'
    sunday = 'sunday'
    monday = 'monday'
    tuesday = 'tuesday'
    wednesday = 'wednesday'
    thursday = 'thursday'
    friday = 'friday'
    saturday = 'saturday'


class WelcomeScreenMeetingInformation(Enum):
    user_defined = 'userDefined'
    show_organizer_and_time_only = 'showOrganizerAndTimeOnly'
    show_organizer_and_time_and_subject = 'showOrganizerAndTimeAndSubject'


class WellknownListName(Enum):
    none = 'none'
    default_list = 'defaultList'
    flagged_emails = 'flaggedEmails'
    unknown_future_value = 'unknownFutureValue'


class Win32LobAppDeliveryOptimizationPriority(Enum):
    not_configured = 'notConfigured'
    foreground = 'foreground'


class Win32LobAppFileSystemOperationType(Enum):
    not_configured = 'notConfigured'
    exists = 'exists'
    modified_date = 'modifiedDate'
    created_date = 'createdDate'
    version = 'version'
    size_in_mb = 'sizeInMB'


class Win32LobAppMsiPackageType(Enum):
    per_machine = 'perMachine'
    per_user = 'perUser'
    dual_purpose = 'dualPurpose'


class Win32LobAppNotification(Enum):
    show_all = 'showAll'
    show_reboot = 'showReboot'
    hide_all = 'hideAll'


class Win32LobAppPowerShellScriptRuleOperationType(Enum):
    not_configured = 'notConfigured'
    string = 'string'
    date_time = 'dateTime'
    integer = 'integer'
    float = 'float'
    version = 'version'
    boolean = 'boolean'


class Win32LobAppRegistryRuleOperationType(Enum):
    not_configured = 'notConfigured'
    exists = 'exists'
    does_not_exist = 'doesNotExist'
    string = 'string'
    integer = 'integer'
    version = 'version'


class Win32LobAppRestartBehavior(Enum):
    based_on_return_code = 'basedOnReturnCode'
    allow = 'allow'
    suppress = 'suppress'
    force = 'force'


class Win32LobAppReturnCodeType(Enum):
    failed = 'failed'
    success = 'success'
    soft_reboot = 'softReboot'
    hard_reboot = 'hardReboot'
    retry = 'retry'


class Win32LobAppRuleOperator(Enum):
    not_configured = 'notConfigured'
    equal = 'equal'
    not_equal = 'notEqual'
    greater_than = 'greaterThan'
    greater_than_or_equal = 'greaterThanOrEqual'
    less_than = 'lessThan'
    less_than_or_equal = 'lessThanOrEqual'


class Win32LobAppRuleType(Enum):
    detection = 'detection'
    requirement = 'requirement'


class Win32LobAutoUpdateSupersededAppsState(Enum):
    not_configured = 'notConfigured'
    enabled = 'enabled'
    unknown_future_value = 'unknownFutureValue'


class Windows10EditionType(Enum):
    windows10_enterprise = 'windows10Enterprise'
    windows10_enterprise_n = 'windows10EnterpriseN'
    windows10_education = 'windows10Education'
    windows10_education_n = 'windows10EducationN'
    windows10_mobile_enterprise = 'windows10MobileEnterprise'
    windows10_holographic_enterprise = 'windows10HolographicEnterprise'
    windows10_professional = 'windows10Professional'
    windows10_professional_n = 'windows10ProfessionalN'
    windows10_professional_education = 'windows10ProfessionalEducation'
    windows10_professional_education_n = 'windows10ProfessionalEducationN'
    windows10_professional_workstation = 'windows10ProfessionalWorkstation'
    windows10_professional_workstation_n = 'windows10ProfessionalWorkstationN'


class WindowsArchitecture(Enum):
    none = 'none'
    x86 = 'x86'
    x64 = 'x64'
    arm = 'arm'
    neutral = 'neutral'


class WindowsAutopilotDeviceType(Enum):
    windows_pc = 'windowsPc'
    holo_lens = 'holoLens'
    unknown_future_value = 'unknownFutureValue'


class WindowsDefenderProductStatus(Enum):
    no_status = 'noStatus'
    service_not_running = 'serviceNotRunning'
    service_started_without_malware_protection = (
        'serviceStartedWithoutMalwareProtection'
    )
    pending_full_scan_due_to_threat_action = 'pendingFullScanDueToThreatAction'
    pending_reboot_due_to_threat_action = 'pendingRebootDueToThreatAction'
    pending_manual_steps_due_to_threat_action = 'pendingManualStepsDueToThreatAction'
    av_signatures_out_of_date = 'avSignaturesOutOfDate'
    as_signatures_out_of_date = 'asSignaturesOutOfDate'
    no_quick_scan_happened_for_specified_period = (
        'noQuickScanHappenedForSpecifiedPeriod'
    )
    no_full_scan_happened_for_specified_period = 'noFullScanHappenedForSpecifiedPeriod'
    system_initiated_scan_in_progress = 'systemInitiatedScanInProgress'
    system_initiated_clean_in_progress = 'systemInitiatedCleanInProgress'
    samples_pending_submission = 'samplesPendingSubmission'
    product_running_in_evaluation_mode = 'productRunningInEvaluationMode'
    product_running_in_non_genuine_mode = 'productRunningInNonGenuineMode'
    product_expired = 'productExpired'
    offline_scan_required = 'offlineScanRequired'
    service_shutdown_as_part_of_system_shutdown = (
        'serviceShutdownAsPartOfSystemShutdown'
    )
    threat_remediation_failed_critically = 'threatRemediationFailedCritically'
    threat_remediation_failed_non_critically = 'threatRemediationFailedNonCritically'
    no_status_flags_set = 'noStatusFlagsSet'
    platform_out_of_date = 'platformOutOfDate'
    platform_update_in_progress = 'platformUpdateInProgress'
    platform_about_to_be_outdated = 'platformAboutToBeOutdated'
    signature_or_platform_end_of_life_is_past_or_is_impending = (
        'signatureOrPlatformEndOfLifeIsPastOrIsImpending'
    )
    windows_s_mode_signatures_in_use_on_non_win10_s_install = (
        'windowsSModeSignaturesInUseOnNonWin10SInstall'
    )


class WindowsDeliveryOptimizationMode(Enum):
    user_defined = 'userDefined'
    http_only = 'httpOnly'
    http_with_peering_nat = 'httpWithPeeringNat'
    http_with_peering_private_group = 'httpWithPeeringPrivateGroup'
    http_with_internet_peering = 'httpWithInternetPeering'
    simple_download = 'simpleDownload'
    bypass_mode = 'bypassMode'


class WindowsDeviceHealthState(Enum):
    clean = 'clean'
    full_scan_pending = 'fullScanPending'
    reboot_pending = 'rebootPending'
    manual_steps_pending = 'manualStepsPending'
    offline_scan_pending = 'offlineScanPending'
    critical = 'critical'


class WindowsDeviceType(Enum):
    none = 'none'
    desktop = 'desktop'
    mobile = 'mobile'
    holographic = 'holographic'
    team = 'team'
    unknown_future_value = 'unknownFutureValue'


class WindowsDeviceUsageType(Enum):
    single_user = 'singleUser'
    shared = 'shared'
    unknown_future_value = 'unknownFutureValue'


class WindowsHelloForBusinessPinUsage(Enum):
    allowed = 'allowed'
    required = 'required'
    disallowed = 'disallowed'


class WindowsInformationProtectionEnforcementLevel(Enum):
    no_protection = 'noProtection'
    encrypt_and_audit_only = 'encryptAndAuditOnly'
    encrypt_audit_and_prompt = 'encryptAuditAndPrompt'
    encrypt_audit_and_block = 'encryptAuditAndBlock'


class WindowsInformationProtectionPinCharacterRequirements(Enum):
    not_allow = 'notAllow'
    require_at_least_one = 'requireAtLeastOne'
    allow = 'allow'


class WindowsMalwareCategory(Enum):
    invalid = 'invalid'
    adware = 'adware'
    spyware = 'spyware'
    password_stealer = 'passwordStealer'
    trojan_downloader = 'trojanDownloader'
    worm = 'worm'
    backdoor = 'backdoor'
    remote_access_trojan = 'remoteAccessTrojan'
    trojan = 'trojan'
    email_flooder = 'emailFlooder'
    keylogger = 'keylogger'
    dialer = 'dialer'
    monitoring_software = 'monitoringSoftware'
    browser_modifier = 'browserModifier'
    cookie = 'cookie'
    browser_plugin = 'browserPlugin'
    aol_exploit = 'aolExploit'
    nuker = 'nuker'
    security_disabler = 'securityDisabler'
    joke_program = 'jokeProgram'
    hostile_active_x_control = 'hostileActiveXControl'
    software_bundler = 'softwareBundler'
    stealth_notifier = 'stealthNotifier'
    settings_modifier = 'settingsModifier'
    tool_bar = 'toolBar'
    remote_control_software = 'remoteControlSoftware'
    trojan_ftp = 'trojanFtp'
    potential_unwanted_software = 'potentialUnwantedSoftware'
    icq_exploit = 'icqExploit'
    trojan_telnet = 'trojanTelnet'
    exploit = 'exploit'
    filesharing_program = 'filesharingProgram'
    malware_creation_tool = 'malwareCreationTool'
    remote_control_software_1 = 'remote_Control_Software'
    tool = 'tool'
    trojan_denial_of_service = 'trojanDenialOfService'
    trojan_dropper = 'trojanDropper'
    trojan_mass_mailer = 'trojanMassMailer'
    trojan_monitoring_software = 'trojanMonitoringSoftware'
    trojan_proxy_server = 'trojanProxyServer'
    virus = 'virus'
    known = 'known'
    unknown = 'unknown'
    spp = 'spp'
    behavior = 'behavior'
    vulnerability = 'vulnerability'
    policy = 'policy'
    enterprise_unwanted_software = 'enterpriseUnwantedSoftware'
    ransom = 'ransom'
    hips_rule = 'hipsRule'


class WindowsMalwareExecutionState(Enum):
    unknown = 'unknown'
    blocked = 'blocked'
    allowed = 'allowed'
    running = 'running'
    not_running = 'notRunning'


class WindowsMalwareSeverity(Enum):
    unknown = 'unknown'
    low = 'low'
    moderate = 'moderate'
    high = 'high'
    severe = 'severe'


class WindowsMalwareState(Enum):
    unknown = 'unknown'
    detected = 'detected'
    cleaned = 'cleaned'
    quarantined = 'quarantined'
    removed = 'removed'
    allowed = 'allowed'
    blocked = 'blocked'
    clean_failed = 'cleanFailed'
    quarantine_failed = 'quarantineFailed'
    remove_failed = 'removeFailed'
    allow_failed = 'allowFailed'
    abandoned = 'abandoned'
    block_failed = 'blockFailed'


class WindowsMalwareThreatState(Enum):
    active = 'active'
    action_failed = 'actionFailed'
    manual_steps_required = 'manualStepsRequired'
    full_scan_required = 'fullScanRequired'
    reboot_required = 'rebootRequired'
    remediated_with_non_critical_failures = 'remediatedWithNonCriticalFailures'
    quarantined = 'quarantined'
    removed = 'removed'
    cleaned = 'cleaned'
    allowed = 'allowed'
    no_status_cleared = 'noStatusCleared'


class WindowsSettingType(Enum):
    roaming = 'roaming'
    backup = 'backup'
    unknown_future_value = 'unknownFutureValue'


class WindowsSpotlightEnablementSettings(Enum):
    not_configured = 'notConfigured'
    disabled = 'disabled'
    enabled = 'enabled'


class WindowsStartMenuAppListVisibilityType(Enum):
    user_defined = 'userDefined'
    collapse = 'collapse'
    remove = 'remove'
    disable_settings_app = 'disableSettingsApp'


class WindowsStartMenuModeType(Enum):
    user_defined = 'userDefined'
    full_screen = 'fullScreen'
    non_full_screen = 'nonFullScreen'


class WindowsUpdateForBusinessUpdateWeeks(Enum):
    user_defined = 'userDefined'
    first_week = 'firstWeek'
    second_week = 'secondWeek'
    third_week = 'thirdWeek'
    fourth_week = 'fourthWeek'
    every_week = 'everyWeek'
    unknown_future_value = 'unknownFutureValue'


class WindowsUpdateNotificationDisplayOption(Enum):
    not_configured = 'notConfigured'
    default_notifications = 'defaultNotifications'
    restart_warnings_only = 'restartWarningsOnly'
    disable_all_notifications = 'disableAllNotifications'
    unknown_future_value = 'unknownFutureValue'


class WindowsUpdateType(Enum):
    user_defined = 'userDefined'
    all = 'all'
    business_ready_only = 'businessReadyOnly'
    windows_insider_build_fast = 'windowsInsiderBuildFast'
    windows_insider_build_slow = 'windowsInsiderBuildSlow'
    windows_insider_build_release = 'windowsInsiderBuildRelease'


class WindowsUserAccountControlSettings(Enum):
    user_defined = 'userDefined'
    always_notify = 'alwaysNotify'
    notify_on_app_changes = 'notifyOnAppChanges'
    notify_on_app_changes_without_dimming = 'notifyOnAppChangesWithoutDimming'
    never_notify = 'neverNotify'


class WindowsUserType(Enum):
    administrator = 'administrator'
    standard = 'standard'
    unknown_future_value = 'unknownFutureValue'


class WorkbookOperationStatus(Enum):
    not_started = 'notStarted'
    running = 'running'
    succeeded = 'succeeded'
    failed = 'failed'


class WorkforceIntegrationEncryptionProtocol(Enum):
    shared_secret = 'sharedSecret'
    unknown_future_value = 'unknownFutureValue'


class WorkforceIntegrationSupportedEntities(Enum):
    none = 'none'
    shift = 'shift'
    swap_request = 'swapRequest'
    user_shift_preferences = 'userShiftPreferences'
    open_shift = 'openShift'
    open_shift_request = 'openShiftRequest'
    offer_shift_request = 'offerShiftRequest'
    unknown_future_value = 'unknownFutureValue'
    time_off_reason = 'timeOffReason'
    time_off = 'timeOff'
    time_off_request = 'timeOffRequest'


class X509CertificateAffinityLevel(Enum):
    low = 'low'
    high = 'high'
    unknown_future_value = 'unknownFutureValue'


class X509CertificateAuthenticationMode(Enum):
    x509_certificate_single_factor = 'x509CertificateSingleFactor'
    x509_certificate_multi_factor = 'x509CertificateMultiFactor'
    unknown_future_value = 'unknownFutureValue'


class X509CertificateCRLValidationConfigurationState(Enum):
    disabled = 'disabled'
    enabled = 'enabled'
    unknown_future_value = 'unknownFutureValue'


class X509CertificateRuleType(Enum):
    issuer_subject = 'issuerSubject'
    policy_oid = 'policyOID'
    unknown_future_value = 'unknownFutureValue'
    issuer_subject_and_policy_oid = 'issuerSubjectAndPolicyOID'


class AccessPackageQuestion(Entity):
    is_answer_editable: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether the requestor is allowed to edit answers to questions for an assignment by posting an update to accessPackageAssignmentRequest.'
        ),
    ] = None
    is_required: Annotated[
        Optional[bool],
        Field(
            description='Whether the requestor is required to supply an answer or not.'
        ),
    ] = None
    localizations: Annotated[
        Optional[List[AccessPackageLocalizedText]],
        Field(
            description='The text of the question represented in a format for a specific locale.'
        ),
    ] = None
    sequence: Annotated[
        Optional[float],
        Field(
            description='Relative position of this question when displaying a list of questions to the requestor.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    text: Annotated[
        Optional[str],
        Field(description='The text of the question to show to the requestor.'),
    ] = None
    field_odata_type: str


class AccessPackageTextInputQuestion(AccessPackageQuestion):
    is_single_line_question: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the answer is in single or multiple line format.'
        ),
    ] = None
    regex_pattern: Annotated[
        Optional[str],
        Field(
            description='The regular expression pattern that any answer to this question must match.'
        ),
    ] = None
    field_odata_type: str


class AccessReviewHistoryInstance(Entity):
    download_uri: Annotated[
        Optional[str],
        Field(
            description='Uri that can be used to retrieve review history data. This URI will be active for 24 hours after being generated. Required.'
        ),
    ] = None
    expiration_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Timestamp when this instance and associated data expires and the history is deleted. Required.',
        ),
    ] = None
    fulfilled_date_time: Annotated[
        Optional[datetime],
        Field(
            description="Timestamp when all of the available data for this instance was collected and is set after this instance's status is set to done. Required.",
        ),
    ] = None
    review_history_period_end_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Timestamp reviews ending on or before this date will be included in the fetched history data.',
        ),
    ] = None
    review_history_period_start_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Timestamp reviews starting on or after this date will be included in the fetched history data.',
        ),
    ] = None
    run_date_time: Annotated[
        Optional[datetime],
        Field(
            description="Timestamp when the instance's history data is scheduled to be generated.",
        ),
    ] = None
    status: Annotated[
        Optional[Union[AccessReviewHistoryStatus, Dict[str, Any]]],
        Field(
            description="Represents the status of the review history data collection. The possible values are: done, inProgress, error, requested, unknownFutureValue. Once the status has been marked as done, a link can be generated to retrieve the instance's data by calling generateDownloadUri method."
        ),
    ] = None
    field_odata_type: str


class AccessReviewInstanceDecisionItem(Entity):
    access_review_id: Annotated[
        Optional[str],
        Field(
            description='The identifier of the accessReviewInstance parent. Supports $select. Read-only.'
        ),
    ] = None
    applied_by: Annotated[
        Optional[Union[UserIdentity, Dict[str, Any]]],
        Field(
            description='The identifier of the user who applied the decision. Read-only.'
        ),
    ] = None
    applied_date_time: Annotated[
        Optional[datetime],
        Field(
            description="The timestamp when the approval decision was applied.00000000-0000-0000-0000-000000000000 if the assigned reviewer hasn't applied the decision or it was automatically applied. The DatetimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.  Supports $select. Read-only.",
        ),
    ] = None
    apply_result: Annotated[
        Optional[str],
        Field(
            description='The result of applying the decision. Possible values: New, AppliedSuccessfully, AppliedWithUnknownFailure, AppliedSuccessfullyButObjectNotFound and ApplyNotSupported. Supports $select, $orderby, and $filter (eq only). Read-only.'
        ),
    ] = None
    decision: Annotated[
        Optional[str],
        Field(
            description='Result of the review. Possible values: Approve, Deny, NotReviewed, or DontKnow. Supports $select, $orderby, and $filter (eq only).'
        ),
    ] = None
    justification: Annotated[
        Optional[str],
        Field(
            description='Justification left by the reviewer when they made the decision.'
        ),
    ] = None
    principal: Annotated[
        Optional[Union[Identity, Dict[str, Any]]],
        Field(
            description="Every decision item in an access review represents a principal's access to a resource. This property represents details of the principal. For example, if a decision item represents access of User 'Bob' to Group 'Sales' - The principal is 'Bob' and the resource is 'Sales'. Principals can be of two types - userIdentity and servicePrincipalIdentity. Supports $select. Read-only."
        ),
    ] = None
    principal_link: Annotated[
        Optional[str],
        Field(
            description='A link to the principal object. For example, https://graph.microsoft.com/v1.0/users/a6c7aecb-cbfd-4763-87ef-e91b4bd509d9. Read-only.'
        ),
    ] = None
    recommendation: Annotated[
        Optional[str],
        Field(
            description='A system-generated recommendation for the approval decision based off last interactive sign-in to tenant. The value is Approve if the sign-in is fewer than 30 days after the start of review, Deny if the sign-in is greater than 30 days after, or NoInfoAvailable. Possible values: Approve, Deny, or NoInfoAvailable. Supports $select, $orderby, and $filter (eq only). Read-only.'
        ),
    ] = None
    resource: Annotated[
        Optional[Union[AccessReviewInstanceDecisionItemResource, Dict[str, Any]]],
        Field(
            description="Every decision item in an access review represents a principal's access to a resource. This property represents details of the resource. For example, if a decision item represents access of User 'Bob' to Group 'Sales' - The principal is Bob and the resource is 'Sales'. Resources can be of multiple types. See accessReviewInstanceDecisionItemResource. Read-only."
        ),
    ] = None
    resource_link: Annotated[
        Optional[str],
        Field(
            description='A link to the resource. For example, https://graph.microsoft.com/v1.0/servicePrincipals/c86300f3-8695-4320-9f6e-32a2555f5ff8. Supports $select. Read-only.'
        ),
    ] = None
    reviewed_by: Annotated[
        Optional[Union[UserIdentity, Dict[str, Any]]],
        Field(
            description="The identifier of the reviewer.00000000-0000-0000-0000-000000000000 if the assigned reviewer hasn't reviewed. Supports $select. Read-only."
        ),
    ] = None
    reviewed_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The timestamp when the review decision occurred. Supports $select. Read-only.',
        ),
    ] = None
    insights: Annotated[
        Optional[List[GovernanceInsight]],
        Field(
            description='Insights are recommendations to reviewers on whether to approve or deny a decision. There can be multiple insights associated with an accessReviewInstanceDecisionItem.'
        ),
    ] = None
    field_odata_type: str


class AccessReviewReviewer(Entity):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date when the reviewer was added for the access review.',
        ),
    ] = None
    display_name: Annotated[Optional[str], Field(description='Name of reviewer.')] = (
        None
    )
    user_principal_name: Annotated[
        Optional[str], Field(description='User principal name of the reviewer.')
    ] = None
    field_odata_type: str


class AccessReviewStage(Entity):
    end_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time in ISO 8601 format and UTC time when the review stage is scheduled to end. This property is the cumulative total of the durationInDays for all stages. Read-only.',
        ),
    ] = None
    fallback_reviewers: Annotated[
        Optional[List[AccessReviewReviewerScope]],
        Field(
            description="This collection of reviewer scopes is used to define the list of fallback reviewers. These fallback reviewers are notified to take action if no users are found from the list of reviewers specified. This could occur when either the group owner is specified as the reviewer but the group owner doesn't exist, or manager is specified as reviewer but a user's manager doesn't exist."
        ),
    ] = None
    reviewers: Annotated[
        Optional[List[AccessReviewReviewerScope]],
        Field(
            description='This collection of access review scopes is used to define who the reviewers are. For examples of options for assigning reviewers, see Assign reviewers to your access review definition using the Microsoft Graph API.'
        ),
    ] = None
    start_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time in ISO 8601 format and UTC time when the review stage is scheduled to start. Read-only.',
        ),
    ] = None
    status: Annotated[
        Optional[str],
        Field(
            description='Specifies the status of an accessReviewStage. Possible values: Initializing, NotStarted, Starting, InProgress, Completing, Completed, AutoReviewing, and AutoReviewed. Supports $orderby, and $filter (eq only). Read-only.'
        ),
    ] = None
    decisions: Annotated[
        Optional[List[AccessReviewInstanceDecisionItem]],
        Field(
            description='Each user reviewed in an accessReviewStage has a decision item representing if they were approved, denied, or not yet reviewed.'
        ),
    ] = None
    field_odata_type: str


class AdminConsentRequestPolicy(Entity):
    is_enabled: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether the admin consent request feature is enabled or disabled. Required.'
        ),
    ] = None
    notify_reviewers: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether reviewers will receive notifications. Required.'
        ),
    ] = None
    reminders_enabled: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether reviewers will receive reminder emails. Required.'
        ),
    ] = None
    request_duration_in_days: Annotated[
        Optional[float],
        Field(
            description='Specifies the duration the request is active before it automatically expires if no decision is applied.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    reviewers: Annotated[
        Optional[List[AccessReviewReviewerScope]],
        Field(description='The list of reviewers for the admin consent. Required.'),
    ] = None
    version: Annotated[
        Optional[float],
        Field(
            description='Specifies the version of this policy. When the policy is updated, this version is updated. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class AdminReportSettings(Entity):
    display_concealed_names: Annotated[
        Optional[bool],
        Field(
            description='If set to true, all reports conceal user information such as usernames, groups, and sites. If false, all reports show identifiable information. This property represents a setting in the Microsoft 365 admin center. Required.'
        ),
    ] = None
    field_odata_type: str


class AgreementAcceptance(Entity):
    agreement_file_id: Annotated[
        Optional[str],
        Field(description='The identifier of the agreement file accepted by the user.'),
    ] = None
    agreement_id: Annotated[
        Optional[str], Field(description='The identifier of the agreement.')
    ] = None
    device_display_name: Annotated[
        Optional[str],
        Field(
            description='The display name of the device used for accepting the agreement.'
        ),
    ] = None
    device_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier of the device used for accepting the agreement. Supports $filter (eq) and eq for null values.'
        ),
    ] = None
    device_os_type: Annotated[
        Optional[str],
        Field(description='The operating system used to accept the agreement.'),
    ] = None
    device_os_version: Annotated[
        Optional[str],
        Field(
            description='The operating system version of the device used to accept the agreement.'
        ),
    ] = None
    expiration_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The expiration date time of the acceptance. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Supports $filter (eq, ge, le) and eq for null values.',
        ),
    ] = None
    recorded_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    state: Annotated[
        Optional[Union[AgreementAcceptanceState, Dict[str, Any]]],
        Field(
            description='The state of the agreement acceptance. Possible values are: accepted, declined. Supports $filter (eq).'
        ),
    ] = None
    user_display_name: Annotated[
        Optional[str],
        Field(description='Display name of the user when the acceptance was recorded.'),
    ] = None
    user_email: Annotated[
        Optional[str],
        Field(description='Email of the user when the acceptance was recorded.'),
    ] = None
    user_id: Annotated[
        Optional[str],
        Field(
            description='The identifier of the user who accepted the agreement. Supports $filter (eq).'
        ),
    ] = None
    user_principal_name: Annotated[
        Optional[str],
        Field(description='UPN of the user when the acceptance was recorded.'),
    ] = None
    field_odata_type: str


class AgreementFileProperties(Entity):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date time representing when the file was created. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='Localized display name of the policy file of an agreement. The localized display name is shown to end users who view the agreement.'
        ),
    ] = None
    file_data: Annotated[
        Optional[Union[AgreementFileData, Dict[str, Any]]],
        Field(
            description='Data that represents the terms of use PDF document. Read-only.'
        ),
    ] = None
    file_name: Annotated[
        Optional[str],
        Field(
            description='Name of the agreement file (for example, TOU.pdf). Read-only.'
        ),
    ] = None
    is_default: Annotated[
        Optional[bool],
        Field(
            description='If none of the languages matches the client preference, indicates whether this is the default agreement file. If none of the files are marked as default, the first one is treated as the default. Read-only.'
        ),
    ] = None
    is_major_version: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether the agreement file is a major version update. Major version updates invalidate the agreement's acceptances on the corresponding language."
        ),
    ] = None
    language: Annotated[
        Optional[str],
        Field(
            description="The language of the agreement file in the format 'languagecode2-country/regioncode2'. 'languagecode2' is a lowercase two-letter code derived from ISO 639-1, while 'country/regioncode2' is derived from ISO 3166 and usually consists of two uppercase letters, or a BCP-47 language tag. For example, U.S. English is en-US. Read-only."
        ),
    ] = None
    field_odata_type: str


class AgreementFileVersion(AgreementFileProperties):
    field_odata_type: str


class AllowedValue(Entity):
    is_active: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether the predefined value is active or deactivated. If set to false, this predefined value can't be assigned to any other supported directory objects."
        ),
    ] = None
    field_odata_type: str


class AppleManagedIdentityProvider(IdentityProviderBase):
    certificate_data: Annotated[
        Optional[str],
        Field(
            description='The certificate data, which is a long string of text from the certificate. Can be null.'
        ),
    ] = None
    developer_id: Annotated[
        Optional[str], Field(description='The Apple developer identifier. Required.')
    ] = None
    key_id: Annotated[
        Optional[str], Field(description='The Apple key identifier. Required.')
    ] = None
    service_id: Annotated[
        Optional[str], Field(description='The Apple service identifier. Required.')
    ] = None
    field_odata_type: str


class ApplePushNotificationCertificate(Entity):
    apple_identifier: Annotated[
        Optional[str],
        Field(
            description='Apple Id of the account used to create the MDM push certificate.'
        ),
    ] = None
    certificate: Annotated[Optional[str], Field(description='Not yet documented')] = (
        None
    )
    certificate_serial_number: Annotated[
        Optional[str],
        Field(description='Certificate serial number. This property is read-only.'),
    ] = None
    certificate_upload_failure_reason: Annotated[
        Optional[str], Field(description='The reason the certificate upload failed.')
    ] = None
    certificate_upload_status: Annotated[
        Optional[str], Field(description='The certificate upload status.')
    ] = None
    expiration_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The expiration date and time for Apple push notification certificate.',
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Last modified date and time for Apple push notification certificate.',
        ),
    ] = None
    topic_identifier: Annotated[Optional[str], Field(description='Topic Id.')] = None
    field_odata_type: str


class ApplicationTemplate(Entity):
    categories: Annotated[
        Optional[List[str]],
        Field(
            description='The list of categories for the application. Supported values can be: Collaboration, Business Management, Consumer, Content management, CRM, Data services, Developer services, E-commerce, Education, ERP, Finance, Health, Human resources, IT infrastructure, Mail, Management, Marketing, Media, Productivity, Project management, Telecommunications, Tools, Travel, and Web design & hosting.'
        ),
    ] = None
    description: Annotated[
        Optional[str], Field(description='A description of the application.')
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The name of the application.')
    ] = None
    home_page_url: Annotated[
        Optional[str], Field(description='The home page URL of the application.')
    ] = None
    logo_url: Annotated[
        Optional[str],
        Field(description='The URL to get the logo for this application.'),
    ] = None
    publisher: Annotated[
        Optional[str],
        Field(description='The name of the publisher for this application.'),
    ] = None
    supported_provisioning_types: Annotated[
        Optional[List[str]],
        Field(
            description='The list of provisioning modes supported by this application. The only valid value is sync.'
        ),
    ] = None
    supported_single_sign_on_modes: Annotated[
        Optional[List[str]],
        Field(
            description='The list of single sign-on modes supported by this application. The supported values are oidc, password, saml, and notSupported.'
        ),
    ] = None
    field_odata_type: str


class AppLogCollectionRequest(Entity):
    completed_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Time at which the upload log request reached a completed state if not completed yet NULL will be returned.',
        ),
    ] = None
    custom_log_folders: Annotated[
        Optional[List[str]], Field(description='List of log folders.')
    ] = None
    error_message: Annotated[
        Optional[str],
        Field(description='Indicates error message if any during the upload process.'),
    ] = None
    status: Optional[AppLogUploadState] = None
    field_odata_type: str


class ApprovalStage(Entity):
    assigned_to_me: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the stage is assigned to the calling user to review. Read-only.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='The label provided by the policy creator to identify an approval stage. Read-only.'
        ),
    ] = None
    justification: Annotated[
        Optional[str],
        Field(
            description='The justification associated with the approval stage decision.'
        ),
    ] = None
    reviewed_by: Annotated[
        Optional[Union[Identity, Dict[str, Any]]],
        Field(
            description="The identifier of the reviewer. 00000000-0000-0000-0000-000000000000 if the assigned reviewer hasn't reviewed. Read-only."
        ),
    ] = None
    reviewed_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when a decision was recorded. The date and time information uses ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.',
        ),
    ] = None
    review_result: Annotated[
        Optional[str],
        Field(
            description='The result of this approval record. Possible values include: NotReviewed, Approved, Denied.'
        ),
    ] = None
    status: Annotated[
        Optional[str],
        Field(
            description='The stage status. Possible values: InProgress, Initializing, Completed, Expired. Read-only.'
        ),
    ] = None
    field_odata_type: str


class AppScope(Entity):
    display_name: Annotated[
        Optional[str],
        Field(
            description='Provides the display name of the app-specific resource represented by the app scope. Provided for display purposes since appScopeId is often an immutable, non-human-readable id. Read-only.'
        ),
    ] = None
    type: Annotated[
        Optional[str],
        Field(
            description='Describes the type of app-specific resource represented by the app scope and is provided for display purposes, so a user interface can convey to the user the kind of app specific resource represented by the app scope. Read-only.'
        ),
    ] = None
    field_odata_type: str


class Attachment(Entity):
    content_type: Annotated[Optional[str], Field(description='The MIME type.')] = None
    is_inline: Annotated[
        Optional[bool],
        Field(
            description='true if the attachment is an inline attachment; otherwise, false.'
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z',
        ),
    ] = None
    name: Annotated[Optional[str], Field(description="The attachment's file name.")] = (
        None
    )
    size: Annotated[
        Optional[float],
        Field(
            description='The length of the attachment in bytes.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class AttachmentBase(Entity):
    content_type: Annotated[Optional[str], Field(description='The MIME type.')] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    name: Annotated[
        Optional[str],
        Field(
            description="The display name of the attachment. This doesn't need to be the actual file name."
        ),
    ] = None
    size: Annotated[
        Optional[float],
        Field(
            description='The length of the attachment in bytes.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class AttachmentSession(Entity):
    content: Annotated[
        Optional[str], Field(description='The content streams that are uploaded.')
    ] = None
    expiration_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time in UTC when the upload session will expire. The complete file must be uploaded before this expiration time is reached.',
        ),
    ] = None
    next_expected_ranges: Annotated[
        Optional[List[str]],
        Field(
            description='Indicates a single value {start} that represents the location in the file where the next upload should begin.'
        ),
    ] = None
    field_odata_type: str


class AttendanceRecord(Entity):
    attendance_intervals: Annotated[
        Optional[List[AttendanceInterval]],
        Field(
            description='List of time periods between joining and leaving a meeting.'
        ),
    ] = None
    email_address: Annotated[
        Optional[str],
        Field(
            description='Email address of the user associated with this attendance record.'
        ),
    ] = None
    identity: Annotated[
        Optional[Union[Identity, Dict[str, Any]]],
        Field(
            description='Identity of the user associated with this attendance record.'
        ),
    ] = None
    role: Annotated[
        Optional[str],
        Field(
            description='Role of the attendee. Possible values are: None, Attendee, Presenter, and Organizer.'
        ),
    ] = None
    total_attendance_in_seconds: Annotated[
        Optional[float],
        Field(
            description='Total duration of the attendances in seconds.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class AttributeSet(Entity):
    description: Annotated[
        Optional[str],
        Field(
            description='Description of the attribute set. Can be up to 128 characters long and include Unicode characters. Can be changed later.'
        ),
    ] = None
    max_attributes_per_set: Annotated[
        Optional[float],
        Field(
            description='Maximum number of custom security attributes that can be defined in this attribute set. Default value is null. If not specified, the administrator can add up to the maximum of 500 active attributes per tenant. Can be changed later.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class AudioRoutingGroup(Entity):
    receivers: Annotated[
        Optional[List[str]], Field(description='List of receiving participant ids.')
    ] = None
    routing_mode: Optional[RoutingMode] = None
    sources: Annotated[
        Optional[List[str]], Field(description='List of source participant ids.')
    ] = None
    field_odata_type: str


class AuditEvent(Entity):
    activity: Annotated[
        Optional[str], Field(description='Friendly name of the activity.')
    ] = None
    activity_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date time in UTC when the activity was performed.',
        ),
    ] = None
    activity_operation_type: Annotated[
        Optional[str], Field(description='The HTTP operation type of the activity.')
    ] = None
    activity_result: Annotated[
        Optional[str], Field(description='The result of the activity.')
    ] = None
    activity_type: Annotated[
        Optional[str],
        Field(description='The type of activity that was being performed.'),
    ] = None
    actor: Annotated[
        Optional[Union[AuditActor, Dict[str, Any]]],
        Field(
            description='AAD user and application that are associated with the audit event.'
        ),
    ] = None
    category: Annotated[Optional[str], Field(description='Audit category.')] = None
    component_name: Annotated[Optional[str], Field(description='Component name.')] = (
        None
    )
    correlation_id: Annotated[
        Optional[UUID],
        Field(
            description='The client request Id that is used to correlate activity within the system.',
        ),
    ] = None
    display_name: Annotated[Optional[str], Field(description='Event display name.')] = (
        None
    )
    resources: Annotated[
        Optional[List[AuditResource]], Field(description='Resources being modified.')
    ] = None
    field_odata_type: str


class AuthenticationCombinationConfiguration(Entity):
    applies_to_combinations: Annotated[
        Optional[List[AuthenticationMethodModes]],
        Field(
            description="Which authentication method combinations this configuration applies to. Must be an allowedCombinations object, part of the authenticationStrengthPolicy. The only possible value for fido2combinationConfigurations is 'fido2'."
        ),
    ] = None
    field_odata_type: str


class AuthenticationContextClassReference(Entity):
    description: Annotated[
        Optional[str],
        Field(
            description='A short explanation of the policies that are enforced by authenticationContextClassReference. This value should be used to provide secondary text to describe the authentication context class reference when building user-facing admin experiences. For example, a selection UX.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='The display name is the friendly name of the authenticationContextClassReference object. This value should be used to identify the authentication context class reference when building user-facing admin experiences. For example, a selection UX.'
        ),
    ] = None
    is_available: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether the authenticationContextClassReference has been published by the security admin and is ready for use by apps. When it's set to false, it shouldn't be shown in authentication context selection UX, or used to protect app resources. It's shown and available for Conditional Access policy authoring. The default value is false.  Supports $filter (eq)."
        ),
    ] = None
    field_odata_type: str


class AuthenticationFlowsPolicy(Entity):
    description: Annotated[
        Optional[str],
        Field(
            description='Inherited property. A description of the policy. Optional. Read-only.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='Inherited property. The human-readable name of the policy. Optional. Read-only.'
        ),
    ] = None
    self_service_sign_up: Annotated[
        Optional[
            Union[SelfServiceSignUpAuthenticationFlowConfiguration, Dict[str, Any]]
        ],
        Field(
            description='Contains selfServiceSignUpAuthenticationFlowConfiguration settings that convey whether self-service sign-up is enabled or disabled. Optional. Read-only.'
        ),
    ] = None
    field_odata_type: str


class AuthenticationMethod(Entity):
    field_odata_type: str


class AuthenticationMethodModeDetail(Entity):
    authentication_method: Optional[BaseAuthenticationMethod] = None
    display_name: Annotated[
        Optional[str], Field(description='The display name of this mode')
    ] = None
    field_odata_type: str


class AuthenticationMethodTarget(Entity):
    is_registration_required: Annotated[
        Optional[bool],
        Field(
            description='Determines if the user is enforced to register the authentication method.'
        ),
    ] = None
    target_type: Optional[AuthenticationMethodTargetType] = None
    field_odata_type: str


class AuthenticationStrengthPolicy(Entity):
    allowed_combinations: Annotated[
        Optional[List[AuthenticationMethodModes]],
        Field(
            description='A collection of authentication method modes that are required be used to satify this authentication strength.'
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The datetime when this policy was created.',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(description='The human-readable description of this policy.'),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='The human-readable display name of this policy. Supports $filter (eq, ne, not , and in).'
        ),
    ] = None
    modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The datetime when this policy was last modified.',
        ),
    ] = None
    policy_type: Optional[AuthenticationStrengthPolicyType] = None
    requirements_satisfied: Optional[AuthenticationStrengthRequirements] = None
    combination_configurations: Annotated[
        Optional[List[AuthenticationCombinationConfiguration]],
        Field(
            description='Settings that may be used to require specific types or instances of an authentication method to be used when authenticating with a specified combination of authentication methods.'
        ),
    ] = None
    field_odata_type: str


class AuthenticationStrengthRoot(Entity):
    combinations: Optional[List[AuthenticationMethodModes]] = None
    authentication_method_modes: Annotated[
        Optional[List[AuthenticationMethodModeDetail]],
        Field(
            description='Names and descriptions of all valid authentication method modes in the system.'
        ),
    ] = None
    policies: Annotated[
        Optional[List[AuthenticationStrengthPolicy]],
        Field(
            description='A collection of authentication strength policies that exist for this tenant, including both built-in and custom policies.'
        ),
    ] = None
    field_odata_type: str


class BaseItemVersion(Entity):
    last_modified_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(
            description='Identity of the user which last modified the version. Read-only.'
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time the version was last modified. Read-only.',
        ),
    ] = None
    publication: Annotated[
        Optional[Union[PublicationFacet, Dict[str, Any]]],
        Field(
            description='Indicates the publication status of this particular version. Read-only.'
        ),
    ] = None
    field_odata_type: str


class BitlockerRecoveryKey(Entity):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the key was originally backed up to Microsoft Entra ID. Not nullable.',
        ),
    ] = None
    device_id: Annotated[
        Optional[str],
        Field(
            description='Identifier of the device the BitLocker key is originally backed up from. Supports $filter (eq).'
        ),
    ] = None
    key: Annotated[
        Optional[str],
        Field(
            description='The BitLocker recovery key. Returned only on $select. Not nullable.'
        ),
    ] = None
    volume_type: Annotated[
        Optional[Union[VolumeType, Dict[str, Any]]],
        Field(
            description='Indicates the type of volume the BitLocker key is associated with. The possible values are: 1 (for operatingSystemVolume), 2 (for fixedDataVolume), 3 (for removableDataVolume), and 4 (for unknownFutureValue).'
        ),
    ] = None
    field_odata_type: str


class BookingCurrency(Entity):
    symbol: Annotated[
        Optional[str],
        Field(
            description='The currency symbol. For example, the currency symbol for the US dollar and for the Australian dollar is $.'
        ),
    ] = None
    field_odata_type: str


class BookingCustomerBase(Entity):
    field_odata_type: str


class BookingCustomQuestion(Entity):
    answer_input_type: Annotated[
        Optional[Union[AnswerInputType, Dict[str, Any]]],
        Field(
            description='The expected answer type. The possible values are: text, radioButton, unknownFutureValue.'
        ),
    ] = None
    answer_options: Annotated[
        Optional[List[str]], Field(description='List of possible answer values.')
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date, time, and time zone when the custom question was created. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    display_name: Annotated[Optional[str], Field(description='The question.')] = None
    last_updated_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date, time, and time zone when the custom question was last updated. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    field_odata_type: str


class BookingStaffMemberBase(Entity):
    field_odata_type: str


class BuiltInIdentityProvider(IdentityProviderBase):
    identity_provider_type: Annotated[
        Optional[str],
        Field(
            description='The identity provider type. For a B2B scenario, possible values: AADSignup, MicrosoftAccount, EmailOTP. Required.'
        ),
    ] = None
    field_odata_type: str


class BulkUpload(Entity):
    field_odata_type: str


class CalendarPermission(Entity):
    allowed_roles: Annotated[
        Optional[List[Union[CalendarRoleType, Dict[str, Any]]]],
        Field(
            description='List of allowed sharing or delegating permission levels for the calendar. Possible values are: none, freeBusyRead, limitedRead, read, write, delegateWithoutPrivateEventAccess, delegateWithPrivateEventAccess, custom.'
        ),
    ] = None
    email_address: Annotated[
        Optional[Union[EmailAddress, Dict[str, Any]]],
        Field(
            description="Represents a share recipient or delegate who has access to the calendar. For the 'My Organization' share recipient, the address property is null. Read-only."
        ),
    ] = None
    is_inside_organization: Annotated[
        Optional[bool],
        Field(
            description='True if the user in context (recipient or delegate) is inside the same organization as the calendar owner.'
        ),
    ] = None
    is_removable: Annotated[
        Optional[bool],
        Field(
            description="True if the user can be removed from the list of recipients or delegates for the specified calendar, false otherwise. The 'My organization' user determines the permissions other people within your organization have to the given calendar. You can't remove 'My organization' as a share recipient to a calendar."
        ),
    ] = None
    role: Annotated[
        Optional[Union[CalendarRoleType, Dict[str, Any]]],
        Field(
            description='Current permission level of the calendar share recipient or delegate.'
        ),
    ] = None
    field_odata_type: str


class CallRecording(Entity):
    call_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier for the call that is related to this recording. Read-only.'
        ),
    ] = None
    content: Annotated[
        Optional[str], Field(description='The content of the recording. Read-only.')
    ] = None
    content_correlation_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier that links the transcript with its corresponding recording. Read-only.'
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time at which the recording was created. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.',
        ),
    ] = None
    end_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time at which the recording ends. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.',
        ),
    ] = None
    meeting_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier of the onlineMeeting related to this recording. Read-only.'
        ),
    ] = None
    meeting_organizer: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(
            description='The identity information of the organizer of the onlineMeeting related to this recording. Read-only.'
        ),
    ] = None
    recording_content_url: Annotated[
        Optional[str],
        Field(
            description='The URL that can be used to access the content of the recording. Read-only.'
        ),
    ] = None
    field_odata_type: str


class CallTranscript(Entity):
    call_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier for the call that is related to this transcript. Read-only.'
        ),
    ] = None
    content: Annotated[
        Optional[str], Field(description='The content of the transcript. Read-only.')
    ] = None
    content_correlation_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier that links the transcript with its corresponding recording. Read-only.'
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time at which the transcript was created. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.',
        ),
    ] = None
    end_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time at which the transcription ends. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.',
        ),
    ] = None
    meeting_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier of the online meeting related to this transcript. Read-only.'
        ),
    ] = None
    meeting_organizer: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(
            description='The identity information of the organizer of the onlineMeeting related to this transcript. Read-only.'
        ),
    ] = None
    metadata_content: Annotated[
        Optional[str],
        Field(
            description='The time-aligned metadata of the utterances in the transcript. Read-only.'
        ),
    ] = None
    transcript_content_url: Annotated[
        Optional[str],
        Field(
            description='The URL that can be used to access the content of the transcript. Read-only.'
        ),
    ] = None
    field_odata_type: str


class CertificateBasedAuthConfiguration(Entity):
    certificate_authorities: Annotated[
        Optional[List[CertificateAuthority]],
        Field(
            description='Collection of certificate authorities which creates a trusted certificate chain.'
        ),
    ] = None
    field_odata_type: str


class ChangeTrackedEntity(Entity):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z',
        ),
    ] = None
    last_modified_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Identity of the person who last modified the entity.'),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z',
        ),
    ] = None
    field_odata_type: str


class ChatMessageHostedContent(TeamworkHostedContent):
    field_odata_type: str


class ChecklistItem(Entity):
    checked_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the checklistItem was finished.',
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the checklistItem was created.',
        ),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='Indicates the title of the checklistItem.')
    ] = None
    is_checked: Annotated[
        Optional[bool],
        Field(
            description='State that indicates whether the item is checked off or not.'
        ),
    ] = None
    field_odata_type: str


class CloudClipboardItem(Entity):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Set by the server. DateTime in UTC when the object was created on the server.',
        ),
    ] = None
    expiration_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Set by the server. DateTime in UTC when the object expires and after that the object is no longer available. The default and also maximum TTL is 12 hours after the creation, but it might change for performance optimization.',
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description="Set by the server if not provided in the client's request. DateTime in UTC when the object was modified by the client.",
        ),
    ] = None
    payloads: Annotated[
        Optional[List[CloudClipboardItemPayload]],
        Field(
            description='A cloudClipboardItem can have multiple cloudClipboardItemPayload objects in the payloads. A window can place more than one clipboard object on the clipboard. Each one represents the same information in a different clipboard format.'
        ),
    ] = None
    field_odata_type: str


class CloudClipboardRoot(Entity):
    items: Annotated[
        Optional[List[CloudClipboardItem]],
        Field(description='Represents a collection of Cloud Clipboard items.'),
    ] = None
    field_odata_type: str


class CloudPC(Entity):
    aad_device_id: Annotated[
        Optional[str],
        Field(
            description='The Microsoft Entra device ID for the Cloud PC, also known as the Azure Active Directory (Azure AD) device ID, that consists of 32 characters in a GUID format. Generated on a VM joined to Microsoft Entra ID. Read-only.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='The display name for the Cloud PC. Maximum length is 64 characters. Read-only. You can use the cloudPC: rename API to modify the Cloud PC name.'
        ),
    ] = None
    grace_period_end_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the grace period ends and reprovisioning or deprovisioning happen. Required only if the status is inGracePeriod. The timestamp is shown in ISO 8601 format and Coordinated Universal Time (UTC). For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    image_display_name: Annotated[
        Optional[str],
        Field(
            description="The name of the operating system image used for the Cloud PC. Maximum length is 50 characters. Only letters (A-Z, a-z), numbers (0-9), and special characters (-,,.) are allowed for this property. The property value can't begin or end with an underscore. Read-only."
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The last modified date and time of the Cloud PC. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    managed_device_id: Annotated[
        Optional[str],
        Field(
            description="The Intune enrolled device ID for the Cloud PC that consists of 32 characters in a GUID format. The managedDeviceId property of Windows 365 Business Cloud PCs is always null as Windows 365 Business Cloud PCs aren't Intune-enrolled automatically by Windows 365. Read-only."
        ),
    ] = None
    managed_device_name: Annotated[
        Optional[str],
        Field(
            description="The Intune enrolled device name for the Cloud PC. The managedDeviceName property of Windows 365 Business Cloud PCs is always null as Windows 365 Business Cloud PCs aren't Intune-enrolled automatically by Windows 365. Read-only."
        ),
    ] = None
    on_premises_connection_name: Annotated[
        Optional[str],
        Field(
            description='The on-premises connection that applied during the provisioning of Cloud PCs. Read-only.'
        ),
    ] = None
    provisioning_policy_id: Annotated[
        Optional[str],
        Field(
            description='The provisioning policy ID for the Cloud PC that consists of 32 characters in a GUID format. A policy defines the type of Cloud PC the user wants to create. Read-only.'
        ),
    ] = None
    provisioning_policy_name: Annotated[
        Optional[str],
        Field(
            description='The provisioning policy that applied during the provisioning of Cloud PCs. Maximum length is 120 characters. Read-only.'
        ),
    ] = None
    provisioning_type: Annotated[
        Optional[Union[CloudPcProvisioningType, Dict[str, Any]]],
        Field(
            description='The type of licenses to be used when provisioning Cloud PCs using this policy. Possible values are: dedicated, shared, unknownFutureValue. The default value is dedicated.'
        ),
    ] = None
    service_plan_id: Annotated[
        Optional[str],
        Field(
            description='The service plan ID for the Cloud PC that consists of 32 characters in a GUID format. For more information about service plans, see Product names and service plan identifiers for licensing. Read-only.'
        ),
    ] = None
    service_plan_name: Annotated[
        Optional[str],
        Field(
            description='The service plan name for the customer-facing Cloud PC entity. Read-only.'
        ),
    ] = None
    user_principal_name: Annotated[
        Optional[str],
        Field(
            description='The user principal name (UPN) of the user assigned to the Cloud PC. Maximum length is 113 characters. For more information on username policies, see Password policies and account restrictions in Microsoft Entra ID. Read-only.'
        ),
    ] = None
    field_odata_type: str


class CloudPcDeviceImage(Entity):
    display_name: Annotated[
        Optional[str],
        Field(
            description='The display name of the associated device image. The device image display name and the version are used to uniquely identify the Cloud PC device image. Read-only.'
        ),
    ] = None
    error_code: Annotated[
        Optional[Union[CloudPcDeviceImageErrorCode, Dict[str, Any]]],
        Field(
            description='The error code of the status of the image that indicates why the upload failed, if applicable. Possible values are: internalServerError, sourceImageNotFound, osVersionNotSupported, sourceImageInvalid, sourceImageNotGeneralized, unknownFutureValue, vmAlreadyAzureAdJoined, paidSourceImageNotSupport, sourceImageNotSupportCustomizeVMName, sourceImageSizeExceedsLimitation. Use the Prefer: include-unknown-enum-members request header to get the following values from this evolvable enum: vmAlreadyAzureAdJoined, paidSourceImageNotSupport, sourceImageNotSupportCustomizeVMName, sourceImageSizeExceedsLimitation. Read-only.'
        ),
    ] = None
    expiration_date: Annotated[
        Optional[date],
        Field(
            description='The date when the image became unavailable. Read-only.',
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The data and time when the image was last modified. The timestamp represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.',
        ),
    ] = None
    operating_system: Annotated[
        Optional[str],
        Field(
            description='The operating system (OS) of the image. For example, Windows 10 Enterprise. Read-only.'
        ),
    ] = None
    os_build_number: Annotated[
        Optional[str],
        Field(
            description='The OS build version of the image. For example, 1909. Read-only.'
        ),
    ] = None
    os_status: Annotated[
        Optional[Union[CloudPcDeviceImageOsStatus, Dict[str, Any]]],
        Field(
            description='The OS status of this image. Possible values are: supported, supportedWithWarning, unknown, unknownFutureValue. The default value is unknown. Read-only.'
        ),
    ] = None
    source_image_resource_id: Annotated[
        Optional[str],
        Field(
            description="The unique identifier (ID) of the source image resource on Azure. The required ID format is: '/subscriptions/{subscription-id}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/images/{imageName}'. Read-only."
        ),
    ] = None
    status: Annotated[
        Optional[Union[CloudPcDeviceImageStatus, Dict[str, Any]]],
        Field(
            description='The status of the image on the Cloud PC. Possible values are: pending, ready, failed, unknownFutureValue. Read-only.'
        ),
    ] = None
    version: Annotated[
        Optional[str],
        Field(
            description='The image version. For example, 0.0.1 and 1.5.13. Read-only.'
        ),
    ] = None
    field_odata_type: str


class CloudPcGalleryImage(Entity):
    display_name: Annotated[
        Optional[str],
        Field(
            description='The display name of this gallery image. For example, Windows 11 Enterprise + Microsoft 365 Apps 22H2. Read-only.'
        ),
    ] = None
    end_date: Annotated[
        Optional[date],
        Field(
            description='The date when the status of the image becomes supportedWithWarning. Users can still provision new Cloud PCs if the current time is later than endDate and earlier than expirationDate. For example, assume the endDate of a gallery image is 2023-9-14 and expirationDate is 2024-3-14, users are able to provision new Cloud PCs if today is 2023-10-01. Read-only.',
        ),
    ] = None
    expiration_date: Annotated[
        Optional[date],
        Field(
            description='The date when the image is no longer available. Users are unable to provision new Cloud PCs if the current time is later than expirationDate. The value is usually endDate plus six months. For example, if the startDate is 2025-10-14, the expirationDate is usually 2026-04-14. Read-only.',
        ),
    ] = None
    offer_name: Annotated[
        Optional[str],
        Field(
            description='The offer name of this gallery image that is passed to Azure Resource Manager (ARM) to retrieve the image resource. Read-only.'
        ),
    ] = None
    publisher_name: Annotated[
        Optional[str],
        Field(
            description='The publisher name of this gallery image that is passed to Azure Resource Manager (ARM) to retrieve the image resource. Read-only.'
        ),
    ] = None
    size_in_gb: Annotated[
        Optional[float],
        Field(
            description='Indicates the size of this image in gigabytes. For example, 64. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    sku_name: Annotated[
        Optional[str],
        Field(
            description='The SKU name of this image that is passed to Azure Resource Manager (ARM) to retrieve the image resource. Read-only.'
        ),
    ] = None
    start_date: Annotated[
        Optional[date],
        Field(
            description='The date when the Cloud PC image is available for provisioning new Cloud PCs. For example, 2022-09-20. Read-only.',
        ),
    ] = None
    status: Annotated[
        Optional[Union[CloudPcGalleryImageStatus, Dict[str, Any]]],
        Field(
            description='The status of the gallery image on the Cloud PC. Possible values are: supported, supportedWithWarning, notSupported, unknownFutureValue. The default value is supported. Read-only.'
        ),
    ] = None
    field_odata_type: str


class CloudPcUserSettingAssignment(Entity):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when this assignment was created. The timestamp type represents the date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    target: Annotated[
        Optional[Union[CloudPcManagementAssignmentTarget, Dict[str, Any]]],
        Field(
            description='The assignment target for the user setting. Currently, the only target supported for this user setting is a user group. For details, see cloudPcManagementGroupAssignmentTarget.'
        ),
    ] = None
    field_odata_type: str


class ColumnLink(Entity):
    name: Annotated[
        Optional[str],
        Field(description='The name of the column  in this content type.'),
    ] = None
    field_odata_type: str


class CommsOperation(Entity):
    client_context: Annotated[
        Optional[str],
        Field(description='Unique Client Context string. Max limit is 256 chars.'),
    ] = None
    result_info: Annotated[
        Optional[Union[ResultInfo, Dict[str, Any]]],
        Field(description='The result information. Read-only.'),
    ] = None
    status: Optional[OperationStatus] = None
    field_odata_type: str


class CompanySubscription(Entity):
    commerce_subscription_id: Annotated[
        Optional[str],
        Field(
            description='The ID of this subscription in the commerce system. Alternate key.'
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when this subscription was created. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    is_trial: Annotated[
        Optional[bool],
        Field(description='Whether the subscription is a free trial or purchased.'),
    ] = None
    next_lifecycle_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the subscription will move to the next state (as defined by the status property) if not renewed by the tenant. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    owner_id: Annotated[
        Optional[str], Field(description='The object ID of the account admin.')
    ] = None
    owner_tenant_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier for the Microsoft partner tenant that created the subscription on a customer tenant.'
        ),
    ] = None
    owner_type: Annotated[
        Optional[str],
        Field(
            description="Indicates the entity that ownerId belongs to, for example, 'User'."
        ),
    ] = None
    service_status: Annotated[
        Optional[List[ServicePlanInfo]],
        Field(
            description='The provisioning status of each service included in this subscription.'
        ),
    ] = None
    sku_id: Annotated[
        Optional[str],
        Field(
            description='The object ID of the SKU associated with this subscription.'
        ),
    ] = None
    sku_part_number: Annotated[
        Optional[str], Field(description='The SKU associated with this subscription.')
    ] = None
    status: Annotated[
        Optional[str],
        Field(
            description='The status of this subscription. Possible values are: Enabled, Deleted, Suspended, Warning, LockedOut.'
        ),
    ] = None
    total_licenses: Annotated[
        Optional[float],
        Field(
            description='The number of licenses included in this subscription.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class Contact(OutlookItem):
    assistant_name: Annotated[
        Optional[str], Field(description="The name of the contact's assistant.")
    ] = None
    birthday: Annotated[
        Optional[datetime],
        Field(
            description="The contact's birthday. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z",
        ),
    ] = None
    business_address: Annotated[
        Optional[Union[PhysicalAddress, Dict[str, Any]]],
        Field(description="The contact's business address."),
    ] = None
    business_home_page: Annotated[
        Optional[str], Field(description='The business home page of the contact.')
    ] = None
    business_phones: Annotated[
        Optional[List[str]], Field(description="The contact's business phone numbers.")
    ] = None
    children: Annotated[
        Optional[List[str]], Field(description="The names of the contact's children.")
    ] = None
    company_name: Annotated[
        Optional[str], Field(description="The name of the contact's company.")
    ] = None
    department: Annotated[
        Optional[str], Field(description="The contact's department.")
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description="The contact's display name. You can specify the display name in a create or update operation. Note that later updates to other properties may cause an automatically generated value to overwrite the displayName value you have specified. To preserve a pre-existing value, always include it as displayName in an update operation."
        ),
    ] = None
    email_addresses: Annotated[
        Optional[List[EmailAddress]],
        Field(description="The contact's email addresses."),
    ] = None
    file_as: Annotated[
        Optional[str], Field(description='The name the contact is filed under.')
    ] = None
    generation: Annotated[Optional[str], Field(description="The contact's suffix.")] = (
        None
    )
    given_name: Annotated[
        Optional[str], Field(description="The contact's given name.")
    ] = None
    home_address: Annotated[
        Optional[Union[PhysicalAddress, Dict[str, Any]]],
        Field(description="The contact's home address."),
    ] = None
    home_phones: Annotated[
        Optional[List[str]], Field(description="The contact's home phone numbers.")
    ] = None
    im_addresses: Annotated[
        Optional[List[str]],
        Field(description="The contact's instant messaging (IM) addresses."),
    ] = None
    initials: Annotated[Optional[str], Field(description="The contact's initials.")] = (
        None
    )
    job_title: Annotated[
        Optional[str], Field(description='The contacts job title.')
    ] = None
    manager: Annotated[
        Optional[str], Field(description="The name of the contact's manager.")
    ] = None
    middle_name: Annotated[
        Optional[str], Field(description="The contact's middle name.")
    ] = None
    mobile_phone: Annotated[
        Optional[str], Field(description="The contact's mobile phone number.")
    ] = None
    nick_name: Annotated[
        Optional[str], Field(description="The contact's nickname.")
    ] = None
    office_location: Annotated[
        Optional[str], Field(description="The location of the contact's office.")
    ] = None
    other_address: Annotated[
        Optional[Union[PhysicalAddress, Dict[str, Any]]],
        Field(description='Other addresses for the contact.'),
    ] = None
    parent_folder_id: Annotated[
        Optional[str], Field(description="The ID of the contact's parent folder.")
    ] = None
    personal_notes: Annotated[
        Optional[str], Field(description="The user's notes about the contact.")
    ] = None
    profession: Annotated[
        Optional[str], Field(description="The contact's profession.")
    ] = None
    spouse_name: Annotated[
        Optional[str], Field(description="The name of the contact's spouse/partner.")
    ] = None
    surname: Annotated[Optional[str], Field(description="The contact's surname.")] = (
        None
    )
    title: Annotated[Optional[str], Field(description="The contact's title.")] = None
    yomi_company_name: Annotated[
        Optional[str],
        Field(description='The phonetic Japanese company name of the contact.'),
    ] = None
    yomi_given_name: Annotated[
        Optional[str],
        Field(
            description='The phonetic Japanese given name (first name) of the contact.'
        ),
    ] = None
    yomi_surname: Annotated[
        Optional[str],
        Field(description='The phonetic Japanese surname (last name)  of the contact.'),
    ] = None
    extensions: Annotated[
        Optional[List[Extension]],
        Field(
            description='The collection of open extensions defined for the contact. Read-only. Nullable.'
        ),
    ] = None
    multi_value_extended_properties: Annotated[
        Optional[List[MultiValueLegacyExtendedProperty]],
        Field(
            description='The collection of multi-value extended properties defined for the contact. Read-only. Nullable.'
        ),
    ] = None
    photo: Annotated[
        Optional[Union[ProfilePhoto, Dict[str, Any]]],
        Field(
            description='Optional contact picture. You can get or set a photo for a contact.'
        ),
    ] = None
    single_value_extended_properties: Annotated[
        Optional[List[SingleValueLegacyExtendedProperty]],
        Field(
            description='The collection of single-value extended properties defined for the contact. Read-only. Nullable.'
        ),
    ] = None
    field_odata_type: str


class ContactFolder(Entity):
    display_name: Annotated[
        Optional[str], Field(description="The folder's display name.")
    ] = None
    parent_folder_id: Annotated[
        Optional[str], Field(description="The ID of the folder's parent folder.")
    ] = None
    child_folders: Annotated[
        Optional[List[ContactFolder]],
        Field(
            description='The collection of child folders in the folder. Navigation property. Read-only. Nullable.'
        ),
    ] = None
    contacts: Annotated[
        Optional[List[Contact]],
        Field(
            description='The contacts in the folder. Navigation property. Read-only. Nullable.'
        ),
    ] = None
    multi_value_extended_properties: Annotated[
        Optional[List[MultiValueLegacyExtendedProperty]],
        Field(
            description='The collection of multi-value extended properties defined for the contactFolder. Read-only. Nullable.'
        ),
    ] = None
    single_value_extended_properties: Annotated[
        Optional[List[SingleValueLegacyExtendedProperty]],
        Field(
            description='The collection of single-value extended properties defined for the contactFolder. Read-only. Nullable.'
        ),
    ] = None
    field_odata_type: str


class ContentSharingSession(Entity):
    field_odata_type: str


class ConversationMember(Entity):
    display_name: Annotated[
        Optional[str], Field(description='The display name of the user.')
    ] = None
    roles: Annotated[
        Optional[List[str]],
        Field(
            description="The roles for that user. This property contains more qualifiers only when relevant - for example, if the member has owner privileges, the roles property contains owner as one of the values. Similarly, if the member is an in-tenant guest, the roles property contains guest as one of the values. A basic member shouldn't have any values specified in the roles property. An Out-of-tenant external member is assigned the owner role."
        ),
    ] = None
    visible_history_start_date_time: Annotated[
        Optional[datetime],
        Field(
            description="The timestamp denoting how far back a conversation's history is shared with the conversation member. This property is settable only for members of a chat.",
        ),
    ] = None
    field_odata_type: str


class CountryNamedLocation(NamedLocation):
    countries_and_regions: Annotated[
        Optional[List[str]],
        Field(
            description='List of countries and/or regions in two-letter format specified by ISO 3166-2. Required.'
        ),
    ] = None
    country_lookup_method: Annotated[
        Optional[Union[CountryLookupMethodType, Dict[str, Any]]],
        Field(
            description='Determines what method is used to decide which country the user is located in. Possible values are clientIpAddress(default) and authenticatorAppGps. Note: authenticatorAppGps is not yet supported in the Microsoft Cloud for US Government.'
        ),
    ] = None
    include_unknown_countries_and_regions: Annotated[
        Optional[bool],
        Field(
            description="true if IP addresses that don't map to a country or region should be included in the named location. Optional. Default value is false."
        ),
    ] = None
    field_odata_type: str


class CrossTenantIdentitySyncPolicyPartner(BaseModel):
    display_name: Annotated[
        Optional[str],
        Field(
            description='Display name for the cross-tenant user synchronization policy. Use the name of the partner Microsoft Entra tenant to easily identify the policy. Optional.'
        ),
    ] = None
    tenant_id: Annotated[
        Optional[str],
        Field(
            description='Tenant identifier for the partner Microsoft Entra organization. Read-only.'
        ),
    ] = None
    user_sync_inbound: Annotated[
        Optional[Union[CrossTenantUserSyncInbound, Dict[str, Any]]],
        Field(
            description='Defines whether users can be synchronized from the partner tenant. Key.'
        ),
    ] = None
    field_odata_type: str


class CustomCalloutExtension(Entity):
    authentication_configuration: Annotated[
        Optional[Union[CustomExtensionAuthenticationConfiguration, Dict[str, Any]]],
        Field(
            description='Configuration for securing the API call to the logic app. For example, using OAuth client credentials flow.'
        ),
    ] = None
    client_configuration: Annotated[
        Optional[Union[CustomExtensionClientConfiguration, Dict[str, Any]]],
        Field(
            description='HTTP connection settings that define how long Microsoft Entra ID can wait for a connection to a logic app, how many times you can retry a timed-out connection and the exception scenarios when retries are allowed.'
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(description='Description for the customCalloutExtension object.'),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(description='Display name for the customCalloutExtension object.'),
    ] = None
    endpoint_configuration: Annotated[
        Optional[Union[CustomExtensionEndpointConfiguration, Dict[str, Any]]],
        Field(
            description="The type and details for configuring the endpoint to call the logic app's workflow."
        ),
    ] = None
    field_odata_type: str


class CustomExtensionStageSetting(Entity):
    stage: Optional[AccessPackageCustomExtensionStage] = None
    custom_extension: Annotated[
        Optional[Union[CustomCalloutExtension, Dict[str, Any]]],
        Field(
            description='Indicates the custom workflow extension that will be executed at this stage. Nullable. Supports $expand.'
        ),
    ] = None
    field_odata_type: str


class CustomSecurityAttributeDefinition(Entity):
    attribute_set: Annotated[
        Optional[str], Field(description='Name of the attribute set. Case insensitive.')
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='Description of the custom security attribute. Can be up to 128 characters long and include Unicode characters. Can be changed later.'
        ),
    ] = None
    is_collection: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether multiple values can be assigned to the custom security attribute. Cannot be changed later. If type is set to Boolean, isCollection cannot be set to true.'
        ),
    ] = None
    is_searchable: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether custom security attribute values are indexed for searching on objects that are assigned attribute values. Cannot be changed later.'
        ),
    ] = None
    name: Annotated[
        Optional[str],
        Field(
            description='Name of the custom security attribute. Must be unique within an attribute set. Can be up to 32 characters long and include Unicode characters. Cannot contain spaces or special characters. Cannot be changed later. Case insensitive.'
        ),
    ] = None
    status: Annotated[
        Optional[str],
        Field(
            description='Specifies whether the custom security attribute is active or deactivated. Acceptable values are: Available and Deprecated. Can be changed later.'
        ),
    ] = None
    type: Annotated[
        Optional[str],
        Field(
            description='Data type for the custom security attribute values. Supported types are: Boolean, Integer, and String. Cannot be changed later.'
        ),
    ] = None
    use_pre_defined_values_only: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether only predefined values can be assigned to the custom security attribute. If set to false, free-form values are allowed. Can later be changed from true to false, but cannot be changed from false to true. If type is set to Boolean, usePreDefinedValuesOnly cannot be set to true.'
        ),
    ] = None
    allowed_values: Annotated[
        Optional[List[AllowedValue]],
        Field(
            description='Values that are predefined for this custom security attribute. This navigation property is not returned by default and must be specified in an $expand query. For example, /directory/customSecurityAttributeDefinitions?$expand=allowedValues.'
        ),
    ] = None
    field_odata_type: str


class DataPolicyOperation(Entity):
    completed_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Represents when the request for this data policy operation was completed, in UTC time, using the ISO 8601 format. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Null until the operation completes.',
        ),
    ] = None
    progress: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='Specifies the progress of an operation.'),
    ] = None
    status: Annotated[
        Optional[Union[DataPolicyOperationStatus, Dict[str, Any]]],
        Field(
            description='Possible values are: notStarted, running, complete, failed, unknownFutureValue.'
        ),
    ] = None
    storage_location: Annotated[
        Optional[str],
        Field(
            description='The URL location to where data is being exported for export requests.'
        ),
    ] = None
    submitted_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Represents when the request for this data operation was submitted, in UTC time, using the ISO 8601 format. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z',
        ),
    ] = None
    user_id: Annotated[
        Optional[str],
        Field(description='The id for the user on whom the operation is performed.'),
    ] = None
    field_odata_type: str


class DelegatedAdminRelationshipOperation(Entity):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The time in ISO 8601 format and in UTC time when the long-running operation was created. Read-only.',
        ),
    ] = None
    data: Annotated[
        Optional[str],
        Field(description='The data (payload) for the operation. Read-only.'),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The time in ISO 8601 format and in UTC time when the long-running operation was last modified. Read-only.',
        ),
    ] = None
    operation_type: Optional[DelegatedAdminRelationshipOperationType] = None
    status: Optional[LongRunningOperationStatus] = None
    field_odata_type: str


class DelegatedAdminRelationshipRequest(Entity):
    action: Optional[DelegatedAdminRelationshipRequestAction] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time in ISO 8601 format and in UTC time when the relationship request was created. Read-only.',
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time in ISO 8601 format and UTC time when this relationship request was last modified. Read-only.',
        ),
    ] = None
    status: Annotated[
        Optional[Union[DelegatedAdminRelationshipRequestStatus, Dict[str, Any]]],
        Field(
            description='The status of the request. Read-only. The possible values are: created, pending, succeeded, failed, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class DelegatedAdminServiceManagementDetail(Entity):
    service_management_url: Annotated[
        Optional[str],
        Field(
            description='The URL of the management portal for the managed service. Read-only.'
        ),
    ] = None
    service_name: Annotated[
        Optional[str], Field(description='The name of a managed service. Read-only.')
    ] = None
    field_odata_type: str


class DelegatedPermissionClassification(Entity):
    classification: Annotated[
        Optional[Union[PermissionClassificationType, Dict[str, Any]]],
        Field(
            description="The classification value. Possible values: low, medium (preview), high (preview). Doesn't support $filter."
        ),
    ] = None
    permission_id: Annotated[
        Optional[str],
        Field(
            description="The unique identifier (id) for the delegated permission listed in the oauth2PermissionScopes collection of the servicePrincipal. Required on create. Doesn't support $filter."
        ),
    ] = None
    permission_name: Annotated[
        Optional[str],
        Field(
            description="The claim value (value) for the delegated permission listed in the oauth2PermissionScopes collection of the servicePrincipal. Doesn't support $filter."
        ),
    ] = None
    field_odata_type: str


class DeletedChat(Entity):
    field_odata_type: str


class DeviceCategory(Entity):
    description: Annotated[
        Optional[str],
        Field(description='Optional description for the device category.'),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='Display name for the device category.')
    ] = None
    field_odata_type: str


class DeviceComplianceActionItem(Entity):
    action_type: Optional[DeviceComplianceActionType] = None
    grace_period_hours: Annotated[
        Optional[float],
        Field(
            description='Number of hours to wait till the action will be enforced. Valid values 0 to 8760',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    notification_message_cc_list: Annotated[
        Optional[List[str]],
        Field(
            description='A list of group IDs to speicify who to CC this notification message to.'
        ),
    ] = None
    notification_template_id: Annotated[
        Optional[str], Field(description='What notification Message template to use')
    ] = None
    field_odata_type: str


class DeviceComplianceDeviceOverview(Entity):
    configuration_version: Annotated[
        Optional[float],
        Field(
            description='Version of the policy for that overview',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    error_count: Annotated[
        Optional[float],
        Field(description='Number of error devices', ge=-2147483648.0, le=2147483647.0),
    ] = None
    failed_count: Annotated[
        Optional[float],
        Field(
            description='Number of failed devices', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    last_update_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Last update time',
        ),
    ] = None
    not_applicable_count: Annotated[
        Optional[float],
        Field(
            description='Number of not applicable devices',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    pending_count: Annotated[
        Optional[float],
        Field(
            description='Number of pending devices', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    success_count: Annotated[
        Optional[float],
        Field(
            description='Number of succeeded devices', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    field_odata_type: str


class DeviceComplianceDeviceStatus(Entity):
    compliance_grace_period_expiration_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The DateTime when device compliance grace period expires',
        ),
    ] = None
    device_display_name: Annotated[
        Optional[str], Field(description='Device name of the DevicePolicyStatus.')
    ] = None
    device_model: Annotated[
        Optional[str], Field(description='The device model that is being reported')
    ] = None
    last_reported_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Last modified date time of the policy report.',
        ),
    ] = None
    status: Optional[ComplianceStatus] = None
    user_name: Annotated[
        Optional[str], Field(description='The User Name that is being reported')
    ] = None
    user_principal_name: Annotated[
        Optional[str], Field(description='UserPrincipalName.')
    ] = None
    field_odata_type: str


class DeviceCompliancePolicyAssignment(Entity):
    target: Annotated[
        Optional[Union[DeviceAndAppManagementAssignmentTarget, Dict[str, Any]]],
        Field(description='Target for the compliance policy assignment.'),
    ] = None
    field_odata_type: str


class DeviceCompliancePolicyDeviceStateSummary(Entity):
    compliant_device_count: Annotated[
        Optional[float],
        Field(
            description='Number of compliant devices', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    config_manager_count: Annotated[
        Optional[float],
        Field(
            description='Number of devices that have compliance managed by System Center Configuration Manager',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    conflict_device_count: Annotated[
        Optional[float],
        Field(
            description='Number of conflict devices', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    error_device_count: Annotated[
        Optional[float],
        Field(description='Number of error devices', ge=-2147483648.0, le=2147483647.0),
    ] = None
    in_grace_period_count: Annotated[
        Optional[float],
        Field(
            description='Number of devices that are in grace period',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    non_compliant_device_count: Annotated[
        Optional[float],
        Field(
            description='Number of NonCompliant devices',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    not_applicable_device_count: Annotated[
        Optional[float],
        Field(
            description='Number of not applicable devices',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    remediated_device_count: Annotated[
        Optional[float],
        Field(
            description='Number of remediated devices',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    unknown_device_count: Annotated[
        Optional[float],
        Field(
            description='Number of unknown devices', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    field_odata_type: str


class DeviceComplianceScheduledActionForRule(Entity):
    rule_name: Annotated[
        Optional[str],
        Field(
            description='Name of the rule which this scheduled action applies to. Currently scheduled actions are created per policy instead of per rule, thus RuleName is always set to default value PasswordRequired.'
        ),
    ] = None
    scheduled_action_configurations: Annotated[
        Optional[List[DeviceComplianceActionItem]],
        Field(
            description='The list of scheduled action configurations for this compliance policy. Compliance policy must have one and only one block scheduled action.'
        ),
    ] = None
    field_odata_type: str


class DeviceComplianceSettingState(Entity):
    compliance_grace_period_expiration_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The DateTime when device compliance grace period expires',
        ),
    ] = None
    device_id: Annotated[
        Optional[str], Field(description='The Device Id that is being reported')
    ] = None
    device_model: Annotated[
        Optional[str], Field(description='The device model that is being reported')
    ] = None
    device_name: Annotated[
        Optional[str], Field(description='The Device Name that is being reported')
    ] = None
    setting: Annotated[
        Optional[str], Field(description='The setting class name and property name.')
    ] = None
    setting_name: Annotated[
        Optional[str], Field(description='The Setting Name that is being reported')
    ] = None
    state: Optional[ComplianceStatus] = None
    user_email: Annotated[
        Optional[str],
        Field(description='The User email address that is being reported'),
    ] = None
    user_id: Annotated[
        Optional[str], Field(description='The user Id that is being reported')
    ] = None
    user_name: Annotated[
        Optional[str], Field(description='The User Name that is being reported')
    ] = None
    user_principal_name: Annotated[
        Optional[str],
        Field(description='The User PrincipalName that is being reported'),
    ] = None
    field_odata_type: str


class DeviceComplianceUserOverview(Entity):
    configuration_version: Annotated[
        Optional[float],
        Field(
            description='Version of the policy for that overview',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    error_count: Annotated[
        Optional[float],
        Field(description='Number of error Users', ge=-2147483648.0, le=2147483647.0),
    ] = None
    failed_count: Annotated[
        Optional[float],
        Field(description='Number of failed Users', ge=-2147483648.0, le=2147483647.0),
    ] = None
    last_update_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Last update time',
        ),
    ] = None
    not_applicable_count: Annotated[
        Optional[float],
        Field(
            description='Number of not applicable users',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    pending_count: Annotated[
        Optional[float],
        Field(description='Number of pending Users', ge=-2147483648.0, le=2147483647.0),
    ] = None
    success_count: Annotated[
        Optional[float],
        Field(
            description='Number of succeeded Users', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    field_odata_type: str


class DeviceComplianceUserStatus(Entity):
    devices_count: Annotated[
        Optional[float],
        Field(
            description='Devices count for that user.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    last_reported_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Last modified date time of the policy report.',
        ),
    ] = None
    status: Optional[ComplianceStatus] = None
    user_display_name: Annotated[
        Optional[str], Field(description='User name of the DevicePolicyStatus.')
    ] = None
    user_principal_name: Annotated[
        Optional[str], Field(description='UserPrincipalName.')
    ] = None
    field_odata_type: str


class DeviceConfigurationAssignment(Entity):
    target: Annotated[
        Optional[Union[DeviceAndAppManagementAssignmentTarget, Dict[str, Any]]],
        Field(description='The assignment target for the device configuration.'),
    ] = None
    field_odata_type: str


class DeviceConfigurationDeviceOverview(Entity):
    configuration_version: Annotated[
        Optional[float],
        Field(
            description='Version of the policy for that overview',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    error_count: Annotated[
        Optional[float],
        Field(description='Number of error devices', ge=-2147483648.0, le=2147483647.0),
    ] = None
    failed_count: Annotated[
        Optional[float],
        Field(
            description='Number of failed devices', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    last_update_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Last update time',
        ),
    ] = None
    not_applicable_count: Annotated[
        Optional[float],
        Field(
            description='Number of not applicable devices',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    pending_count: Annotated[
        Optional[float],
        Field(
            description='Number of pending devices', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    success_count: Annotated[
        Optional[float],
        Field(
            description='Number of succeeded devices', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    field_odata_type: str


class DeviceConfigurationDeviceStateSummary(Entity):
    compliant_device_count: Annotated[
        Optional[float],
        Field(
            description='Number of compliant devices', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    conflict_device_count: Annotated[
        Optional[float],
        Field(
            description='Number of conflict devices', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    error_device_count: Annotated[
        Optional[float],
        Field(description='Number of error devices', ge=-2147483648.0, le=2147483647.0),
    ] = None
    non_compliant_device_count: Annotated[
        Optional[float],
        Field(
            description='Number of NonCompliant devices',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    not_applicable_device_count: Annotated[
        Optional[float],
        Field(
            description='Number of not applicable devices',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    remediated_device_count: Annotated[
        Optional[float],
        Field(
            description='Number of remediated devices',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    unknown_device_count: Annotated[
        Optional[float],
        Field(
            description='Number of unknown devices', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    field_odata_type: str


class DeviceConfigurationDeviceStatus(Entity):
    compliance_grace_period_expiration_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The DateTime when device compliance grace period expires',
        ),
    ] = None
    device_display_name: Annotated[
        Optional[str], Field(description='Device name of the DevicePolicyStatus.')
    ] = None
    device_model: Annotated[
        Optional[str], Field(description='The device model that is being reported')
    ] = None
    last_reported_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Last modified date time of the policy report.',
        ),
    ] = None
    status: Optional[ComplianceStatus] = None
    user_name: Annotated[
        Optional[str], Field(description='The User Name that is being reported')
    ] = None
    user_principal_name: Annotated[
        Optional[str], Field(description='UserPrincipalName.')
    ] = None
    field_odata_type: str


class DeviceConfigurationUserOverview(Entity):
    configuration_version: Annotated[
        Optional[float],
        Field(
            description='Version of the policy for that overview',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    error_count: Annotated[
        Optional[float],
        Field(description='Number of error Users', ge=-2147483648.0, le=2147483647.0),
    ] = None
    failed_count: Annotated[
        Optional[float],
        Field(description='Number of failed Users', ge=-2147483648.0, le=2147483647.0),
    ] = None
    last_update_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Last update time',
        ),
    ] = None
    not_applicable_count: Annotated[
        Optional[float],
        Field(
            description='Number of not applicable users',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    pending_count: Annotated[
        Optional[float],
        Field(description='Number of pending Users', ge=-2147483648.0, le=2147483647.0),
    ] = None
    success_count: Annotated[
        Optional[float],
        Field(
            description='Number of succeeded Users', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    field_odata_type: str


class DeviceConfigurationUserStatus(Entity):
    devices_count: Annotated[
        Optional[float],
        Field(
            description='Devices count for that user.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    last_reported_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Last modified date time of the policy report.',
        ),
    ] = None
    status: Optional[ComplianceStatus] = None
    user_display_name: Annotated[
        Optional[str], Field(description='User name of the DevicePolicyStatus.')
    ] = None
    user_principal_name: Annotated[
        Optional[str], Field(description='UserPrincipalName.')
    ] = None
    field_odata_type: str


class DeviceInstallState(Entity):
    device_id: Annotated[Optional[str], Field(description='Device Id.')] = None
    device_name: Annotated[Optional[str], Field(description='Device name.')] = None
    error_code: Annotated[
        Optional[str], Field(description='The error code for install failures.')
    ] = None
    install_state: Optional[InstallState] = None
    last_sync_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Last sync date and time.',
        ),
    ] = None
    os_description: Annotated[Optional[str], Field(description='OS Description.')] = (
        None
    )
    os_version: Annotated[Optional[str], Field(description='OS Version.')] = None
    user_name: Annotated[Optional[str], Field(description='Device User Name.')] = None
    field_odata_type: str


class DeviceLocalCredentialInfo(Entity):
    credentials: Annotated[
        Optional[List[DeviceLocalCredential]],
        Field(
            description="The credentials of the device's local administrator account backed up to Azure Active Directory."
        ),
    ] = None
    device_name: Annotated[
        Optional[str],
        Field(
            description='Display name of the device that the local credentials are associated with.'
        ),
    ] = None
    last_backup_date_time: Annotated[
        Optional[datetime],
        Field(
            description='When the local administrator account credential was backed up to Azure Active Directory.',
        ),
    ] = None
    refresh_date_time: Annotated[
        Optional[datetime],
        Field(
            description='When the local administrator account credential will be refreshed and backed up to Azure Active Directory.',
        ),
    ] = None
    field_odata_type: str


class DeviceLogCollectionResponse(Entity):
    enrolled_by_user: Annotated[
        Optional[str],
        Field(
            description='The User Principal Name (UPN) of the user that enrolled the device.'
        ),
    ] = None
    expiration_date_time_utc: Annotated[
        Optional[datetime],
        Field(
            description='The DateTime of the expiration of the logs.',
        ),
    ] = None
    initiated_by_user_principal_name: Annotated[
        Optional[str], Field(description='The UPN for who initiated the request.')
    ] = None
    managed_device_id: Annotated[
        Optional[UUID],
        Field(
            description='Indicates Intune device unique identifier.',
        ),
    ] = None
    received_date_time_utc: Annotated[
        Optional[datetime],
        Field(
            description='The DateTime the request was received.',
        ),
    ] = None
    requested_date_time_utc: Annotated[
        Optional[datetime],
        Field(
            description='The DateTime of the request.',
        ),
    ] = None
    size_in_kb: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='The size of the logs in KB. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    status: Optional[AppLogUploadState] = None
    field_odata_type: str


class DeviceManagementCachedReportConfiguration(Entity):
    field_odata_type: str


class DeviceManagementExchangeConnector(Entity):
    connector_server_name: Annotated[
        Optional[str],
        Field(description='The name of the server hosting the Exchange Connector.'),
    ] = None
    exchange_alias: Annotated[
        Optional[str], Field(description='An alias assigned to the Exchange server')
    ] = None
    exchange_connector_type: Optional[DeviceManagementExchangeConnectorType] = None
    exchange_organization: Annotated[
        Optional[str], Field(description='Exchange Organization to the Exchange server')
    ] = None
    last_sync_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Last sync time for the Exchange Connector',
        ),
    ] = None
    primary_smtp_address: Annotated[
        Optional[str],
        Field(
            description='Email address used to configure the Service To Service Exchange Connector.'
        ),
    ] = None
    server_name: Annotated[
        Optional[str], Field(description='The name of the Exchange server.')
    ] = None
    status: Optional[DeviceManagementExchangeConnectorStatus] = None
    version: Annotated[
        Optional[str], Field(description='The version of the ExchangeConnectorAgent')
    ] = None
    field_odata_type: str


class DeviceManagementExportJob(Entity):
    expiration_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Time that the exported report expires',
        ),
    ] = None
    filter: Annotated[
        Optional[str], Field(description='Filters applied on the report')
    ] = None
    format: Optional[DeviceManagementReportFileFormat] = None
    localization_type: Optional[DeviceManagementExportJobLocalizationType] = None
    report_name: Annotated[Optional[str], Field(description='Name of the report')] = (
        None
    )
    request_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Time that the exported report was requested',
        ),
    ] = None
    select: Annotated[
        Optional[List[str]], Field(description='Columns selected from the report')
    ] = None
    snapshot_id: Annotated[
        Optional[str],
        Field(
            description='A snapshot is an identifiable subset of the dataset represented by the ReportName. A sessionId or CachedReportConfiguration id can be used here. If a sessionId is specified, Filter, Select, and OrderBy are applied to the data represented by the sessionId. Filter, Select, and OrderBy cannot be specified together with a CachedReportConfiguration id.'
        ),
    ] = None
    status: Optional[DeviceManagementReportStatus] = None
    url: Annotated[
        Optional[str], Field(description='Temporary location of the exported report')
    ] = None
    field_odata_type: str


class DeviceManagementPartner(Entity):
    display_name: Annotated[
        Optional[str], Field(description='Partner display name')
    ] = None
    groups_requiring_partner_enrollment: Annotated[
        Optional[List[DeviceManagementPartnerAssignment]],
        Field(
            description='User groups that specifies whether enrollment is through partner.'
        ),
    ] = None
    is_configured: Annotated[
        Optional[bool],
        Field(description='Whether device management partner is configured or not'),
    ] = None
    last_heartbeat_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Timestamp of last heartbeat after admin enabled option Connect to Device management Partner',
        ),
    ] = None
    partner_app_type: Optional[DeviceManagementPartnerAppType] = None
    partner_state: Optional[DeviceManagementPartnerTenantState] = None
    single_tenant_app_id: Annotated[
        Optional[str], Field(description='Partner Single tenant App id')
    ] = None
    when_partner_devices_will_be_marked_as_non_compliant_date_time: Annotated[
        Optional[datetime],
        Field(
            description='DateTime in UTC when PartnerDevices will be marked as NonCompliant',
        ),
    ] = None
    when_partner_devices_will_be_removed_date_time: Annotated[
        Optional[datetime],
        Field(
            description='DateTime in UTC when PartnerDevices will be removed',
        ),
    ] = None
    field_odata_type: str


class DeviceManagementReports(Entity):
    export_jobs: Annotated[
        Optional[List[DeviceManagementExportJob]],
        Field(description='Entity representing a job to export a report'),
    ] = None
    field_odata_type: str


class DeviceManagementTroubleshootingEvent(Entity):
    correlation_id: Annotated[
        Optional[str],
        Field(description='Id used for tracing the failure in the service.'),
    ] = None
    event_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Time when the event occurred .',
        ),
    ] = None
    field_odata_type: str


class DirectoryObject(Entity):
    deleted_date_time: Annotated[
        Optional[datetime],
        Field(
            description="Date and time when this object was deleted. Always null when the object hasn't been deleted.",
        ),
    ] = None
    field_odata_type: str


class DirectoryObjectPartnerReference(DirectoryObject):
    description: Annotated[
        Optional[str],
        Field(description='Description of the object returned. Read-only.'),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='Name of directory object being returned, like group or application. Read-only.'
        ),
    ] = None
    external_partner_tenant_id: Annotated[
        Optional[UUID],
        Field(
            description='The tenant identifier for the partner tenant. Read-only.',
        ),
    ] = None
    object_type: Annotated[
        Optional[str],
        Field(
            description='The type of the referenced object in the partner tenant. Read-only.'
        ),
    ] = None
    field_odata_type: str


class DirectoryRoleTemplate(DirectoryObject):
    description: Annotated[
        Optional[str],
        Field(description='The description to set for the directory role. Read-only.'),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(description='The display name to set for the directory role. Read-only.'),
    ] = None
    field_odata_type: str


class DomainDnsRecord(Entity):
    is_optional: Annotated[
        Optional[bool],
        Field(
            description='If false, the customer must configure this record at the DNS host for Microsoft Online Services to operate correctly with the domain.'
        ),
    ] = None
    label: Annotated[
        Optional[str],
        Field(
            description='Value used when configuring the name of the DNS record at the DNS host.'
        ),
    ] = None
    record_type: Annotated[
        Optional[str],
        Field(
            description='Indicates what type of DNS record this entity represents. The value can be CName, Mx, Srv, or Txt.'
        ),
    ] = None
    supported_service: Annotated[
        Optional[str],
        Field(
            description='Microsoft Online Service or feature that has a dependency on this DNS record. Can be one of the following values: null, Email, Sharepoint, EmailInternalRelayOnly, OfficeCommunicationsOnline, SharePointDefaultDomain, FullRedelegation, SharePointPublic, OrgIdAuthentication, Yammer, Intune.'
        ),
    ] = None
    ttl: Annotated[
        Optional[float],
        Field(
            description='Value to use when configuring the time-to-live (ttl) property of the DNS record at the DNS host. Not nullable.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class DomainDnsSrvRecord(DomainDnsRecord):
    name_target: Annotated[
        Optional[str],
        Field(
            description='Value to use when configuring the Target property of the SRV record at the DNS host.'
        ),
    ] = None
    port: Annotated[
        Optional[float],
        Field(
            description='Value to use when configuring the port property of the SRV record at the DNS host.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    priority: Annotated[
        Optional[float],
        Field(
            description='Value to use when configuring the priority property of the SRV record at the DNS host.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    protocol: Annotated[
        Optional[str],
        Field(
            description='Value to use when configuring the protocol property of the SRV record at the DNS host.'
        ),
    ] = None
    service: Annotated[
        Optional[str],
        Field(
            description='Value to use when configuring the service property of the SRV record at the DNS host.'
        ),
    ] = None
    weight: Annotated[
        Optional[float],
        Field(
            description='Value to use when configuring the weight property of the SRV record at the DNS host.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class DomainDnsTxtRecord(DomainDnsRecord):
    text: Annotated[
        Optional[str],
        Field(
            description='Value used when configuring the text property at the DNS host.'
        ),
    ] = None
    field_odata_type: str


class DomainDnsUnavailableRecord(DomainDnsRecord):
    description: Annotated[
        Optional[str],
        Field(
            description='Provides the reason why the DomainDnsUnavailableRecord entity is returned.'
        ),
    ] = None
    field_odata_type: str


class DriveItemVersion(BaseItemVersion):
    content: Annotated[
        Optional[str],
        Field(description='The content stream for this version of the item.'),
    ] = None
    size: Annotated[
        Optional[float],
        Field(
            description='Indicates the size of the content stream for this version of the item.'
        ),
    ] = None
    field_odata_type: str


class EBookInstallSummary(Entity):
    failed_device_count: Annotated[
        Optional[float],
        Field(
            description='Number of Devices that have failed to install this book.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    failed_user_count: Annotated[
        Optional[float],
        Field(
            description='Number of Users that have 1 or more device that failed to install this book.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    installed_device_count: Annotated[
        Optional[float],
        Field(
            description='Number of Devices that have successfully installed this book.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    installed_user_count: Annotated[
        Optional[float],
        Field(
            description='Number of Users whose devices have all succeeded to install this book.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    not_installed_device_count: Annotated[
        Optional[float],
        Field(
            description='Number of Devices that does not have this book installed.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    not_installed_user_count: Annotated[
        Optional[float],
        Field(
            description='Number of Users that did not install this book.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class EducationAssignmentDefaults(Entity):
    added_student_action: Annotated[
        Optional[Union[EducationAddedStudentAction, Dict[str, Any]]],
        Field(
            description='Class-level default behavior for handling students who are added after the assignment is published. Possible values are: none, assignIfOpen.'
        ),
    ] = None
    add_to_calendar_action: Annotated[
        Optional[Union[EducationAddToCalendarOptions, Dict[str, Any]]],
        Field(
            description="Optional field to control adding assignments to students' and teachers' calendars when the assignment is published. The possible values are: none, studentsAndPublisher, studentsAndTeamOwners, unknownFutureValue, and studentsOnly. Use the Prefer: include-unknown-enum-members request header to get the following value in this evolvable enum: studentsOnly. The default value is none."
        ),
    ] = None
    due_time: Annotated[
        Optional[time],
        Field(
            description='Class-level default value for due time field. Default value is 23:59:00.',
        ),
    ] = None
    notification_channel_url: Annotated[
        Optional[str],
        Field(
            description='Default Teams channel to which notifications are sent. Default value is null.'
        ),
    ] = None
    field_odata_type: str


class EducationCategory(Entity):
    display_name: Annotated[
        Optional[str], Field(description='Unique identifier for the category.')
    ] = None
    field_odata_type: str


class EducationGradingCategory(Entity):
    display_name: Annotated[
        Optional[str], Field(description='The name of the grading category.')
    ] = None
    percentage_weight: Annotated[
        Optional[float],
        Field(
            description='The weight of the category; an integer between 0 and 100.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class EducationOrganization(Entity):
    description: Annotated[
        Optional[str], Field(description='Organization description.')
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='Organization display name.')
    ] = None
    external_source: Annotated[
        Optional[Union[EducationExternalSource, Dict[str, Any]]],
        Field(
            description='Source where this organization was created from. Possible values are: sis, manual.'
        ),
    ] = None
    external_source_detail: Annotated[
        Optional[str],
        Field(
            description='The name of the external source this resource was generated from.'
        ),
    ] = None
    field_odata_type: str


class EducationOutcome(Entity):
    last_modified_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='The individual who updated the resource.'),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The moment in time when the resource was last modified. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2021 is 2021-01-01T00:00:00Z.',
        ),
    ] = None
    field_odata_type: str


class EmailAuthenticationMethod(AuthenticationMethod):
    email_address: Annotated[
        Optional[str], Field(description='The email address registered to this user.')
    ] = None
    field_odata_type: str


class Endpoint(DirectoryObject):
    capability: Optional[str] = None
    provider_id: Optional[str] = None
    provider_name: Optional[str] = None
    provider_resource_id: Optional[str] = None
    uri: Optional[str] = None
    field_odata_type: str


class EnrollmentConfigurationAssignment(Entity):
    target: Annotated[
        Optional[Union[DeviceAndAppManagementAssignmentTarget, Dict[str, Any]]],
        Field(description='Represents an assignment to managed devices in the tenant'),
    ] = None
    field_odata_type: str


class EnrollmentTroubleshootingEvent(DeviceManagementTroubleshootingEvent):
    device_id: Annotated[
        Optional[str], Field(description='Azure AD device identifier.')
    ] = None
    enrollment_type: Optional[DeviceEnrollmentType] = None
    failure_category: Optional[DeviceEnrollmentFailureReason] = None
    failure_reason: Annotated[
        Optional[str], Field(description='Detailed failure reason.')
    ] = None
    managed_device_identifier: Annotated[
        Optional[str],
        Field(description='Device identifier created or collected by Intune.'),
    ] = None
    operating_system: Annotated[
        Optional[str], Field(description='Operating System.')
    ] = None
    os_version: Annotated[Optional[str], Field(description='OS Version.')] = None
    user_id: Annotated[
        Optional[str],
        Field(description='Identifier for the user that tried to enroll the device.'),
    ] = None
    field_odata_type: str


class EnterpriseCodeSigningCertificate(Entity):
    content: Annotated[
        Optional[str],
        Field(
            description='The Windows Enterprise Code-Signing Certificate in the raw data format. Set to null once certificate has been uploaded and other properties have been populated.'
        ),
    ] = None
    expiration_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The cert expiration date and time (using ISO 8601 format, in UTC time). Uploading a valid cert file through the Intune admin console will automatically populate this value in the HTTP response. Supports: $filter, $select, $top, $OrderBy, $skip. $Search is not supported.',
        ),
    ] = None
    issuer: Annotated[
        Optional[str],
        Field(
            description='The issuer value for the cert. This might contain information such as country (C), state or province (S), locality (L), common name of the cert (CN), organization (O), and organizational unit (OU). Uploading a valid cert file through the Intune admin console will automatically populate this value in the HTTP response. Supports: $filter, $select, $top, $OrderBy, $skip. $Search is not supported.'
        ),
    ] = None
    issuer_name: Annotated[
        Optional[str],
        Field(
            description='The issuer name for the cert. This might contain information such as country (C), state or province (S), locality (L), common name of the cert (CN), organization (O), and organizational unit (OU). Uploading a valid cert file through the Intune admin console will automatically populate this value in the HTTP response. Supports: $filter, $select, $top, $OrderBy, $skip. $Search is not supported.'
        ),
    ] = None
    status: Optional[CertificateStatus] = None
    subject: Annotated[
        Optional[str],
        Field(
            description='The subject value for the cert. This might contain information such as country (C), state or province (S), locality (L), common name of the cert (CN), organization (O), and organizational unit (OU). Uploading a valid cert file through the Intune admin console will automatically populate this value in the HTTP response. Supports: $filter, $select, $top, $OrderBy, $skip. $Search is not supported.'
        ),
    ] = None
    subject_name: Annotated[
        Optional[str],
        Field(
            description='The subject name for the cert. This might contain information such as country (C), state or province (S), locality (L), common name of the cert (CN), organization (O), and organizational unit (OU). Uploading a valid cert file through the Intune admin console will automatically populate this value in the HTTP response. Supports: $filter, $select, $top, $OrderBy, $skip. $Search is not supported.'
        ),
    ] = None
    upload_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date time of CodeSigning Cert when it is uploaded (using ISO 8601 format, in UTC time). Uploading a valid cert file through the Intune admin console will automatically populate this value in the HTTP response. Supports: $filter, $select, $top, $OrderBy, $skip. $Search is not supported.',
        ),
    ] = None
    field_odata_type: str


class EntitlementManagementSettings(Entity):
    duration_until_external_user_deleted_after_blocked: Annotated[
        Optional[timedelta],
        Field(
            description='If externalUserLifecycleAction is blockSignInAndDelete, the duration, typically many days, after an external user is blocked from sign in before their account is deleted.',
        ),
    ] = None
    external_user_lifecycle_action: Annotated[
        Optional[Union[AccessPackageExternalUserLifecycleAction, Dict[str, Any]]],
        Field(
            description="Automatic action that the service should take when an external user's last access package assignment is removed. The possible values are: none, blockSignIn, blockSignInAndDelete, unknownFutureValue."
        ),
    ] = None
    field_odata_type: str


class ExtensionProperty(DirectoryObject):
    app_display_name: Annotated[
        Optional[str],
        Field(
            description='Display name of the application object on which this extension property is defined. Read-only.'
        ),
    ] = None
    data_type: Annotated[
        Optional[str],
        Field(
            description='Specifies the data type of the value the extension property can hold. Following values are supported. Binary - 256 bytes maximumBooleanDateTime - Must be specified in ISO 8601 format. Will be stored in UTC.Integer - 32-bit value.LargeInteger - 64-bit value.String - 256 characters maximumNot nullable. For multivalued directory extensions, these limits apply per value in the collection.'
        ),
    ] = None
    is_multi_valued: Annotated[
        Optional[bool],
        Field(
            description="Defines the directory extension as a multi-valued property. When true, the directory extension property can store a collection of objects of the dataType; for example, a collection of string types such as 'extensionb7b1c57b532f40b8b5ed4b7a7ba67401jobGroupTracker': ['String 1', 'String 2']. The default value is false. Supports $filter (eq)."
        ),
    ] = None
    is_synced_from_on_premises: Annotated[
        Optional[bool],
        Field(
            description='Indicates if this extension property was synced from on-premises active directory using Microsoft Entra Connect. Read-only.'
        ),
    ] = None
    name: Annotated[
        Optional[str],
        Field(
            description='Name of the extension property. Not nullable. Supports $filter (eq).'
        ),
    ] = None
    target_objects: Annotated[
        Optional[List[str]],
        Field(
            description='Following values are supported. Not nullable. UserGroupAdministrativeUnitApplicationDeviceOrganization'
        ),
    ] = None
    field_odata_type: str


class FeatureRolloutPolicy(Entity):
    description: Annotated[
        Optional[str],
        Field(description='A description for this feature rollout policy.'),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(description='The display name for this  feature rollout policy.'),
    ] = None
    feature: Optional[StagedFeatureName] = None
    is_applied_to_organization: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether this feature rollout policy should be applied to the entire organization.'
        ),
    ] = None
    is_enabled: Annotated[
        Optional[bool],
        Field(description='Indicates whether the feature rollout is enabled.'),
    ] = None
    applies_to: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description='Nullable. Specifies a list of directoryObject resources that feature is enabled for.'
        ),
    ] = None
    field_odata_type: str


class Fido2AuthenticationMethod(AuthenticationMethod):
    aa_guid: Annotated[
        Optional[str],
        Field(
            description='Authenticator Attestation GUID, an identifier that indicates the type (e.g. make and model) of the authenticator.'
        ),
    ] = None
    attestation_certificates: Annotated[
        Optional[List[str]],
        Field(
            description='The attestation certificate(s) attached to this security key.'
        ),
    ] = None
    attestation_level: Annotated[
        Optional[Union[AttestationLevel, Dict[str, Any]]],
        Field(
            description='The attestation level of this FIDO2 security key. Possible values are: attested, or notAttested.'
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The timestamp when this key was registered to the user.',
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(description='The display name of the key as given by the user.'),
    ] = None
    model: Annotated[
        Optional[str],
        Field(description='The manufacturer-assigned model of the FIDO2 security key.'),
    ] = None
    field_odata_type: str


class Fido2CombinationConfiguration(AuthenticationCombinationConfiguration):
    allowed_aagui_ds: Annotated[
        Optional[List[str]],
        Field(
            description='A list of AAGUIDs allowed to be used as part of the specified authentication method combinations.'
        ),
    ] = None
    field_odata_type: str


class FileAttachment(Attachment):
    content_bytes: Annotated[
        Optional[str], Field(description='The base64-encoded contents of the file.')
    ] = None
    content_id: Annotated[
        Optional[str],
        Field(description='The ID of the attachment in the Exchange store.'),
    ] = None
    content_location: Annotated[
        Optional[str],
        Field(description="Don't use this property as it isn't supported."),
    ] = None
    field_odata_type: str


class FilterOperatorSchema(Entity):
    arity: Optional[ScopeOperatorType] = None
    multivalued_comparison_type: Optional[ScopeOperatorMultiValuedComparisonType] = None
    supported_attribute_types: Annotated[
        Optional[List[AttributeType]],
        Field(
            description='Attribute types supported by the operator. Possible values are: Boolean, Binary, Reference, Integer, String.'
        ),
    ] = None
    field_odata_type: str


class GroupSetting(Entity):
    display_name: Annotated[
        Optional[str],
        Field(
            description='Display name of this group of settings, which comes from the associated template.'
        ),
    ] = None
    template_id: Annotated[
        Optional[str],
        Field(
            description="Unique identifier for the tenant-level groupSettingTemplates object that's been customized for this group-level settings object. Read-only."
        ),
    ] = None
    values: Annotated[
        Optional[List[SettingValue]],
        Field(
            description='Collection of name-value pairs corresponding to the name and defaultValue properties in the referenced groupSettingTemplates object.'
        ),
    ] = None
    field_odata_type: str


class GroupSettingTemplate(DirectoryObject):
    description: Annotated[
        Optional[str], Field(description='Description of the template.')
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='Display name of the template. The template named Group.Unified can be used to configure tenant-wide Microsoft 365 group settings, while the template named Group.Unified.Guest can be used to configure group-specific settings.'
        ),
    ] = None
    values: Annotated[
        Optional[List[SettingTemplateValue]],
        Field(
            description='Collection of settingTemplateValues that list the set of available settings, defaults and types that make up this template.'
        ),
    ] = None
    field_odata_type: str


class HorizontalSectionColumn(Entity):
    width: Annotated[
        Optional[float],
        Field(
            description='Width of the column. A horizontal section is divided into 12 grids. A column should have a value of 1-12 to represent its range spans. For example, there can be two columns both have a width of 6 in a section.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    webparts: Annotated[
        Optional[List[WebPart]],
        Field(description='The collection of WebParts in this column.'),
    ] = None
    field_odata_type: str


class IdentityApiConnector(Entity):
    authentication_configuration: Annotated[
        Optional[Union[ApiAuthenticationConfigurationBase, Dict[str, Any]]],
        Field(
            description='The object which describes the authentication configuration details for calling the API. Basic and PKCS 12 client certificate are supported.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The name of the API connector.')
    ] = None
    target_url: Annotated[
        Optional[str], Field(description='The URL of the API endpoint to call.')
    ] = None
    field_odata_type: str


class IdentityUserFlow(Entity):
    user_flow_type: Optional[UserFlowType] = None
    user_flow_type_version: Optional[Union[float, str, ReferenceNumeric]] = None
    field_odata_type: str


class IdentityUserFlowAttribute(Entity):
    data_type: Optional[IdentityUserFlowAttributeDataType] = None
    description: Annotated[
        Optional[str],
        Field(
            description="The description of the user flow attribute that's shown to the user at the time of sign up."
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='The display name of the user flow attribute.  Supports $filter (eq, ne).'
        ),
    ] = None
    user_flow_attribute_type: Optional[IdentityUserFlowAttributeType] = None
    field_odata_type: str


class IdentityUserFlowAttributeAssignment(Entity):
    display_name: Annotated[
        Optional[str],
        Field(
            description='The display name of the identityUserFlowAttribute within a user flow.'
        ),
    ] = None
    is_optional: Annotated[
        Optional[bool],
        Field(
            description="Determines whether the identityUserFlowAttribute is optional. true means the user doesn't have to provide a value. false means the user can't complete sign-up without providing a value."
        ),
    ] = None
    requires_verification: Annotated[
        Optional[bool],
        Field(
            description="Determines whether the identityUserFlowAttribute requires verification, and is only used for verifying the user's phone number or email address."
        ),
    ] = None
    user_attribute_values: Annotated[
        Optional[List[UserAttributeValuesItem]],
        Field(
            description='The input options for the user flow attribute. Only applicable when the userInputType is radioSingleSelect, dropdownSingleSelect, or checkboxMultiSelect.'
        ),
    ] = None
    user_input_type: Optional[IdentityUserFlowAttributeInputType] = None
    user_attribute: Annotated[
        Optional[Union[IdentityUserFlowAttribute, Dict[str, Any]]],
        Field(description='The user attribute that you want to add to your user flow.'),
    ] = None
    field_odata_type: str


class InferenceClassificationOverride(Entity):
    classify_as: Annotated[
        Optional[Union[InferenceClassificationType, Dict[str, Any]]],
        Field(
            description='Specifies how incoming messages from a specific sender should always be classified as. The possible values are: focused, other.'
        ),
    ] = None
    sender_email_address: Annotated[
        Optional[Union[EmailAddress, Dict[str, Any]]],
        Field(
            description='The email address information of the sender for whom the override is created.'
        ),
    ] = None
    field_odata_type: str


class InviteParticipantsOperation(CommsOperation):
    participants: Annotated[
        Optional[List[InvitationParticipantInfo]],
        Field(description='The participants to invite.'),
    ] = None
    field_odata_type: str


class IosLobAppProvisioningConfigurationAssignment(Entity):
    target: Annotated[
        Optional[Union[DeviceAndAppManagementAssignmentTarget, Dict[str, Any]]],
        Field(description='The target group assignment defined by the admin.'),
    ] = None
    field_odata_type: str


class IosUpdateDeviceStatus(Entity):
    compliance_grace_period_expiration_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The DateTime when device compliance grace period expires',
        ),
    ] = None
    device_display_name: Annotated[
        Optional[str], Field(description='Device name of the DevicePolicyStatus.')
    ] = None
    device_id: Annotated[
        Optional[str], Field(description='The device id that is being reported.')
    ] = None
    device_model: Annotated[
        Optional[str], Field(description='The device model that is being reported')
    ] = None
    install_status: Optional[IosUpdatesInstallStatus] = None
    last_reported_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Last modified date time of the policy report.',
        ),
    ] = None
    os_version: Annotated[
        Optional[str], Field(description='The device version that is being reported.')
    ] = None
    status: Optional[ComplianceStatus] = None
    user_id: Annotated[
        Optional[str], Field(description='The User id that is being reported.')
    ] = None
    user_name: Annotated[
        Optional[str], Field(description='The User Name that is being reported')
    ] = None
    user_principal_name: Annotated[
        Optional[str], Field(description='UserPrincipalName.')
    ] = None
    field_odata_type: str


class IpNamedLocation(NamedLocation):
    ip_ranges: Annotated[
        Optional[List[IpRange]],
        Field(
            description='List of IP address ranges in IPv4 CIDR format (for example, 1.2.3.4/32) or any allowable IPv6 format from IETF RFC5969. Required.'
        ),
    ] = None
    is_trusted: Annotated[
        Optional[bool],
        Field(
            description='true if this location is explicitly trusted. Optional. Default value is false.'
        ),
    ] = None
    field_odata_type: str


class ItemAttachment(Attachment):
    item: Annotated[
        Optional[Union[OutlookItem, Dict[str, Any]]],
        Field(description='The attached message or event. Navigation property.'),
    ] = None
    field_odata_type: str


class LearningContent(Entity):
    additional_tags: Annotated[
        Optional[List[str]],
        Field(
            description='Keywords, topics, and other tags associated with the learning content. Optional.'
        ),
    ] = None
    content_web_url: Annotated[
        Optional[str],
        Field(description='The content web URL for the learning content. Required.'),
    ] = None
    contributors: Annotated[
        Optional[List[str]],
        Field(
            description='The authors, creators, or contributors of the learning content. Optional.'
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the learning content was created. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Optional.',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='The description or summary for the learning content. Optional.'
        ),
    ] = None
    duration: Annotated[
        Optional[timedelta],
        Field(
            description='The duration of the learning content in seconds. The value is represented in ISO 8601 format for durations. Optional.',
        ),
    ] = None
    external_id: Annotated[
        Optional[str],
        Field(
            description='Unique external content ID for the learning content. Required.'
        ),
    ] = None
    format: Annotated[
        Optional[str],
        Field(
            description='The format of the learning content. For example, Course, Video, Book, Book Summary, Audiobook Summary. Optional.'
        ),
    ] = None
    is_active: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether the content is active or not. Inactive content doesn't show up in the UI. The default value is true. Optional."
        ),
    ] = None
    is_premium: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the learning content requires the user to sign-in on the learning provider platform or not. The default value is false. Optional.'
        ),
    ] = None
    is_searchable: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the learning content is searchable or not. The default value is true. Optional.'
        ),
    ] = None
    language_tag: Annotated[
        Optional[str],
        Field(
            description='The language of the learning content, for example, en-us or fr-fr. Required.'
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the learning content was last modified. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Optional.',
        ),
    ] = None
    level: Annotated[
        Optional[Union[Level, Dict[str, Any]]],
        Field(
            description='The difficulty level of the learning content. Possible values are: Beginner, Intermediate, Advanced, unknownFutureValue. Optional.'
        ),
    ] = None
    number_of_pages: Annotated[
        Optional[float],
        Field(
            description='The number of pages of the learning content, for example, 9. Optional.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    skill_tags: Annotated[
        Optional[List[str]],
        Field(
            description='The skills tags associated with the learning content. Optional.'
        ),
    ] = None
    source_name: Annotated[
        Optional[str],
        Field(
            description='The source name of the learning content, such as LinkedIn Learning or Coursera. Optional.'
        ),
    ] = None
    thumbnail_web_url: Annotated[
        Optional[str],
        Field(description='The URL of learning content thumbnail image. Optional.'),
    ] = None
    title: Annotated[
        Optional[str], Field(description='The title of the learning content. Required.')
    ] = None
    field_odata_type: str


class LearningCourseActivity(Entity):
    completed_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when the assignment was completed. Optional.',
        ),
    ] = None
    completion_percentage: Annotated[
        Optional[float],
        Field(
            description='The percentage completion value of the course activity. Optional.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    externalcourse_activity_id: Optional[str] = None
    learner_user_id: Annotated[
        Optional[str],
        Field(
            description='The user ID of the learner to whom the activity is assigned. Required.'
        ),
    ] = None
    learning_content_id: Annotated[
        Optional[str],
        Field(
            description='The ID of the learning content created in Viva Learning. Required.'
        ),
    ] = None
    learning_provider_id: Annotated[
        Optional[str],
        Field(description='The registration ID of the provider. Required.'),
    ] = None
    status: Annotated[
        Optional[Union[CourseStatus, Dict[str, Any]]],
        Field(
            description='The status of the course activity. Possible values are: notStarted, inProgress, completed. Required.'
        ),
    ] = None
    field_odata_type: str


class LearningProvider(Entity):
    display_name: Annotated[
        Optional[str],
        Field(description='The display name that appears in Viva Learning. Required.'),
    ] = None
    is_course_activity_sync_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether a provider can ingest learning course activity records. The default value is false. Set to true to make learningCourseActivities available for this provider.'
        ),
    ] = None
    login_web_url: Annotated[
        Optional[str],
        Field(
            description='Authentication URL to access the courses for the provider. Optional.'
        ),
    ] = None
    long_logo_web_url_for_dark_theme: Annotated[
        Optional[str],
        Field(
            description='The long logo URL for the dark mode that needs to be a publicly accessible image. This image would be saved to the blob storage of Viva Learning for rendering within the Viva Learning app. Required.'
        ),
    ] = None
    long_logo_web_url_for_light_theme: Annotated[
        Optional[str],
        Field(
            description='The long logo URL for the light mode that needs to be a publicly accessible image. This image would be saved to the blob storage of Viva Learning for rendering within the Viva Learning app. Required.'
        ),
    ] = None
    square_logo_web_url_for_dark_theme: Annotated[
        Optional[str],
        Field(
            description='The square logo URL for the dark mode that needs to be a publicly accessible image. This image would be saved to the blob storage of Viva Learning for rendering within the Viva Learning app. Required.'
        ),
    ] = None
    square_logo_web_url_for_light_theme: Annotated[
        Optional[str],
        Field(
            description='The square logo URL for the light mode that needs to be a publicly accessible image. This image would be saved to the blob storage of Viva Learning for rendering within the Viva Learning app. Required.'
        ),
    ] = None
    learning_contents: Annotated[
        Optional[List[LearningContent]],
        Field(description='Learning catalog items for the provider.'),
    ] = None
    learning_course_activities: Optional[List[LearningCourseActivity]] = None
    field_odata_type: str


class LearningSelfInitiatedCourse(LearningCourseActivity):
    started_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time on which the learner started the self-initiated course. Optional.',
        ),
    ] = None
    field_odata_type: str


class LicenseDetails(Entity):
    service_plans: Annotated[
        Optional[List[ServicePlanInfo]],
        Field(
            description='Information about the service plans assigned with the license. Read-only. Not nullable.'
        ),
    ] = None
    sku_id: Annotated[
        Optional[UUID],
        Field(
            description='Unique identifier (GUID) for the service SKU. Equal to the skuId property on the related subscribedSku object. Read-only.',
        ),
    ] = None
    sku_part_number: Annotated[
        Optional[str],
        Field(
            description='Unique SKU display name. Equal to the skuPartNumber on the related subscribedSku object; for example, AAD_Premium. Read-only.'
        ),
    ] = None
    field_odata_type: str


class ListItemVersion(BaseItemVersion):
    fields: Annotated[
        Optional[Union[FieldValueSet, Dict[str, Any]]],
        Field(
            description='A collection of the fields and values for this version of the list item.'
        ),
    ] = None
    field_odata_type: str


class LongRunningOperation(Entity):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The start time of the operation. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    last_action_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The time of the last action in the operation. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    resource_location: Annotated[
        Optional[str],
        Field(description='URI of the resource that the operation is performed on.'),
    ] = None
    status: Annotated[
        Optional[Union[LongRunningOperationStatus, Dict[str, Any]]],
        Field(
            description='The status of the operation. The possible values are: notStarted, running, succeeded, failed, unknownFutureValue.'
        ),
    ] = None
    status_detail: Annotated[
        Optional[str], Field(description='Details about the status of the operation.')
    ] = None
    field_odata_type: str


class M365AppsInstallationOptions(Entity):
    apps_for_mac: Optional[AppsInstallationOptionsForMac] = None
    apps_for_windows: Optional[AppsInstallationOptionsForWindows] = None
    update_channel: Optional[AppsUpdateChannelType] = None
    field_odata_type: str


class MalwareStateForWindowsDevice(Entity):
    detection_count: Annotated[
        Optional[float],
        Field(
            description='Indicates the number of times the malware is detected',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    device_name: Annotated[
        Optional[str],
        Field(
            description='Indicates the name of the device being evaluated for malware state'
        ),
    ] = None
    execution_state: Annotated[
        Optional[Union[WindowsMalwareExecutionState, Dict[str, Any]]],
        Field(
            description='Indicates execution status of the malware. Possible values are: unknown, blocked, allowed, running, notRunning. Defaults to unknown. Possible values are: unknown, blocked, allowed, running, notRunning.'
        ),
    ] = None
    initial_detection_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Initial detection datetime of the malware',
        ),
    ] = None
    last_state_change_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The last time this particular threat was changed',
        ),
    ] = None
    threat_state: Annotated[
        Optional[Union[WindowsMalwareThreatState, Dict[str, Any]]],
        Field(
            description='Indicates threat status of the malware. Possible values are: active, actionFailed, manualStepsRequired, fullScanRequired, rebootRequired, remediatedWithNonCriticalFailures, quarantined, removed, cleaned, allowed, noStatusCleared. defaults to noStatusCleared. Possible values are: active, actionFailed, manualStepsRequired, fullScanRequired, rebootRequired, remediatedWithNonCriticalFailures, quarantined, removed, cleaned, allowed, noStatusCleared.'
        ),
    ] = None
    field_odata_type: str


class ManagedAppConfiguration(ManagedAppPolicy):
    custom_settings: Annotated[
        Optional[List[KeyValuePair]],
        Field(
            description='A set of string key and string value pairs to be sent to apps for users to whom the configuration is scoped, unalterned by this service'
        ),
    ] = None
    field_odata_type: str


class ManagedAppProtection(ManagedAppPolicy):
    allowed_data_storage_locations: Annotated[
        Optional[List[ManagedAppDataStorageLocation]],
        Field(
            description='Data storage locations where a user may store managed data.'
        ),
    ] = None
    allowed_inbound_data_transfer_sources: Optional[ManagedAppDataTransferLevel] = None
    allowed_outbound_clipboard_sharing_level: Optional[
        ManagedAppClipboardSharingLevel
    ] = None
    allowed_outbound_data_transfer_destinations: Optional[
        ManagedAppDataTransferLevel
    ] = None
    contact_sync_blocked: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether contacts can be synced to the user's device."
        ),
    ] = None
    data_backup_blocked: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether the backup of a managed app's data is blocked."
        ),
    ] = None
    device_compliance_required: Annotated[
        Optional[bool],
        Field(description='Indicates whether device compliance is required.'),
    ] = None
    disable_app_pin_if_device_pin_is_set: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether use of the app pin is required if the device pin is set.'
        ),
    ] = None
    fingerprint_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether use of the fingerprint reader is allowed in place of a pin if PinRequired is set to True.'
        ),
    ] = None
    managed_browser: Optional[ManagedBrowserType] = None
    managed_browser_to_open_links_required: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether internet links should be opened in the managed browser app, or any custom browser specified by CustomBrowserProtocol (for iOS) or CustomBrowserPackageId/CustomBrowserDisplayName (for Android)'
        ),
    ] = None
    maximum_pin_retries: Annotated[
        Optional[float],
        Field(
            description='Maximum number of incorrect pin retry attempts before the managed app is either blocked or wiped.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    minimum_pin_length: Annotated[
        Optional[float],
        Field(
            description='Minimum pin length required for an app-level pin if PinRequired is set to True',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    minimum_required_app_version: Annotated[
        Optional[str],
        Field(
            description='Versions less than the specified version will block the managed app from accessing company data.'
        ),
    ] = None
    minimum_required_os_version: Annotated[
        Optional[str],
        Field(
            description='Versions less than the specified version will block the managed app from accessing company data.'
        ),
    ] = None
    minimum_warning_app_version: Annotated[
        Optional[str],
        Field(
            description='Versions less than the specified version will result in warning message on the managed app.'
        ),
    ] = None
    minimum_warning_os_version: Annotated[
        Optional[str],
        Field(
            description='Versions less than the specified version will result in warning message on the managed app from accessing company data.'
        ),
    ] = None
    organizational_credentials_required: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether organizational credentials are required for app use.'
        ),
    ] = None
    period_before_pin_reset: Annotated[
        Optional[timedelta],
        Field(
            description='TimePeriod before the all-level pin must be reset if PinRequired is set to True.',
        ),
    ] = None
    period_offline_before_access_check: Annotated[
        Optional[timedelta],
        Field(
            description='The period after which access is checked when the device is not connected to the internet.',
        ),
    ] = None
    period_offline_before_wipe_is_enforced: Annotated[
        Optional[timedelta],
        Field(
            description='The amount of time an app is allowed to remain disconnected from the internet before all managed data it is wiped.',
        ),
    ] = None
    period_online_before_access_check: Annotated[
        Optional[timedelta],
        Field(
            description='The period after which access is checked when the device is connected to the internet.',
        ),
    ] = None
    pin_character_set: Optional[ManagedAppPinCharacterSet] = None
    pin_required: Annotated[
        Optional[bool],
        Field(description='Indicates whether an app-level pin is required.'),
    ] = None
    print_blocked: Annotated[
        Optional[bool],
        Field(description='Indicates whether printing is allowed from managed apps.'),
    ] = None
    save_as_blocked: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether users may use the 'Save As' menu item to save a copy of protected files."
        ),
    ] = None
    simple_pin_blocked: Annotated[
        Optional[bool], Field(description='Indicates whether simplePin is blocked.')
    ] = None
    field_odata_type: str


class ManagedAppRegistration(Entity):
    app_identifier: Annotated[
        Optional[Union[MobileAppIdentifier, Dict[str, Any]]],
        Field(description='The app package Identifier'),
    ] = None
    application_version: Annotated[Optional[str], Field(description='App version')] = (
        None
    )
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time of creation',
        ),
    ] = None
    device_name: Annotated[Optional[str], Field(description='Host device name')] = None
    device_tag: Annotated[
        Optional[str],
        Field(
            description='App management SDK generated tag, which helps relate apps hosted on the same device. Not guaranteed to relate apps in all conditions.'
        ),
    ] = None
    device_type: Annotated[Optional[str], Field(description='Host device type')] = None
    flagged_reasons: Annotated[
        Optional[List[ManagedAppFlaggedReason]],
        Field(
            description='Zero or more reasons an app registration is flagged. E.g. app running on rooted device'
        ),
    ] = None
    last_sync_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time of last the app synced with management service.',
        ),
    ] = None
    management_sdk_version: Annotated[
        Optional[str], Field(description='App management SDK version')
    ] = None
    platform_version: Annotated[
        Optional[str], Field(description='Operating System version')
    ] = None
    user_id: Annotated[
        Optional[str],
        Field(description='The user Id to who this app registration belongs.'),
    ] = None
    version: Annotated[Optional[str], Field(description='Version of the entity.')] = (
        None
    )
    applied_policies: Annotated[
        Optional[List[ManagedAppPolicy]],
        Field(
            description='Zero or more policys already applied on the registered app when it last synchronized with managment service.'
        ),
    ] = None
    intended_policies: Annotated[
        Optional[List[ManagedAppPolicy]],
        Field(
            description='Zero or more policies admin intended for the app as of now.'
        ),
    ] = None
    operations: Annotated[
        Optional[List[ManagedAppOperation]],
        Field(
            description='Zero or more long running operations triggered on the app registration.'
        ),
    ] = None
    field_odata_type: str


class ManagedDeviceMobileAppConfigurationAssignment(Entity):
    target: Annotated[
        Optional[Union[DeviceAndAppManagementAssignmentTarget, Dict[str, Any]]],
        Field(description='Assignment target that the T&C policy is assigned to.'),
    ] = None
    field_odata_type: str


class ManagedDeviceMobileAppConfigurationDeviceStatus(Entity):
    compliance_grace_period_expiration_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The DateTime when device compliance grace period expires',
        ),
    ] = None
    device_display_name: Annotated[
        Optional[str], Field(description='Device name of the DevicePolicyStatus.')
    ] = None
    device_model: Annotated[
        Optional[str], Field(description='The device model that is being reported')
    ] = None
    last_reported_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Last modified date time of the policy report.',
        ),
    ] = None
    status: Optional[ComplianceStatus] = None
    user_name: Annotated[
        Optional[str], Field(description='The User Name that is being reported')
    ] = None
    user_principal_name: Annotated[
        Optional[str], Field(description='UserPrincipalName.')
    ] = None
    field_odata_type: str


class ManagedDeviceMobileAppConfigurationUserStatus(Entity):
    devices_count: Annotated[
        Optional[float],
        Field(
            description='Devices count for that user.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    last_reported_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Last modified date time of the policy report.',
        ),
    ] = None
    status: Optional[ComplianceStatus] = None
    user_display_name: Annotated[
        Optional[str], Field(description='User name of the DevicePolicyStatus.')
    ] = None
    user_principal_name: Annotated[
        Optional[str], Field(description='UserPrincipalName.')
    ] = None
    field_odata_type: str


class ManagedDeviceOverview(Entity):
    device_exchange_access_state_summary: Annotated[
        Optional[Union[DeviceExchangeAccessStateSummary, Dict[str, Any]]],
        Field(description='Distribution of Exchange Access State in Intune'),
    ] = None
    device_operating_system_summary: Annotated[
        Optional[Union[DeviceOperatingSystemSummary, Dict[str, Any]]],
        Field(description='Device operating system summary.'),
    ] = None
    dual_enrolled_device_count: Annotated[
        Optional[float],
        Field(
            description='The number of devices enrolled in both MDM and EAS',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    enrolled_device_count: Annotated[
        Optional[float],
        Field(
            description='Total enrolled device count. Does not include PC devices managed via Intune PC Agent',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    mdm_enrolled_count: Annotated[
        Optional[float],
        Field(
            description='The number of devices enrolled in MDM',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class ManagedEBookAssignment(Entity):
    install_intent: Optional[InstallIntent] = None
    target: Annotated[
        Optional[Union[DeviceAndAppManagementAssignmentTarget, Dict[str, Any]]],
        Field(description='The assignment target for eBook.'),
    ] = None
    field_odata_type: str


class ManagedMobileApp(Entity):
    mobile_app_identifier: Annotated[
        Optional[Union[MobileAppIdentifier, Dict[str, Any]]],
        Field(description="The identifier for an app with it's operating system type."),
    ] = None
    version: Annotated[Optional[str], Field(description='Version of the entity.')] = (
        None
    )
    field_odata_type: str


class MeetingAttendanceReport(Entity):
    meeting_end_date_time: Annotated[
        Optional[datetime],
        Field(
            description='UTC time when the meeting ended. Read-only.',
        ),
    ] = None
    meeting_start_date_time: Annotated[
        Optional[datetime],
        Field(
            description='UTC time when the meeting started. Read-only.',
        ),
    ] = None
    total_participant_count: Annotated[
        Optional[float],
        Field(
            description='Total number of participants. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    attendance_records: Annotated[
        Optional[List[AttendanceRecord]],
        Field(
            description='List of attendance records of an attendance report. Read-only.'
        ),
    ] = None
    field_odata_type: str


class MicrosoftAccountUserConversationMember(ConversationMember):
    user_id: Annotated[
        Optional[str], Field(description='Microsoft Account ID of the user.')
    ] = None
    field_odata_type: str


class MicrosoftAuthenticatorAuthenticationMethodTarget(AuthenticationMethodTarget):
    authentication_mode: Optional[MicrosoftAuthenticatorAuthenticationMode] = None
    field_odata_type: str


class MobileAppAssignment(Entity):
    intent: Optional[InstallIntent] = None
    settings: Annotated[
        Optional[Union[MobileAppAssignmentSettings, Dict[str, Any]]],
        Field(description='The settings for target assignment defined by the admin.'),
    ] = None
    target: Annotated[
        Optional[Union[DeviceAndAppManagementAssignmentTarget, Dict[str, Any]]],
        Field(description='The target group assignment defined by the admin.'),
    ] = None
    field_odata_type: str


class MobileAppContentFile(Entity):
    azure_storage_uri: Annotated[
        Optional[str], Field(description='The Azure Storage URI.')
    ] = None
    azure_storage_uri_expiration_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The time the Azure storage Uri expires.',
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The time the file was created.',
        ),
    ] = None
    is_committed: Annotated[
        Optional[bool],
        Field(description='A value indicating whether the file is committed.'),
    ] = None
    is_dependency: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether this content file is a dependency for the main content file. TRUE means that the content file is a dependency, FALSE means that the content file is not a dependency and is the main content file. Defaults to FALSE.'
        ),
    ] = None
    manifest: Annotated[
        Optional[str], Field(description='The manifest information.')
    ] = None
    name: Annotated[Optional[str], Field(description='the file name.')] = None
    size: Annotated[
        Optional[float], Field(description='The size of the file prior to encryption.')
    ] = None
    size_encrypted: Annotated[
        Optional[float], Field(description='The size of the file after encryption.')
    ] = None
    upload_state: Optional[MobileAppContentFileUploadState] = None
    field_odata_type: str


class MobileAppTroubleshootingEvent(Entity):
    app_log_collection_requests: Annotated[
        Optional[List[AppLogCollectionRequest]],
        Field(description='Indicates collection of App Log Upload Request.'),
    ] = None
    field_odata_type: str


class MobileThreatDefenseConnector(Entity):
    allow_partner_to_collect_ios_application_metadata: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates the Mobile Threat Defense partner may collect metadata about installed applications from Intune for IOS devices. When FALSE, indicates the Mobile Threat Defense partner may not collect metadata about installed applications from Intune for IOS devices. Default value is FALSE.'
        ),
    ] = None
    allow_partner_to_collect_ios_personal_application_metadata: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates the Mobile Threat Defense partner may collect metadata about personally installed applications from Intune for IOS devices. When FALSE, indicates the Mobile Threat Defense partner may not collect metadata about personally installed applications from Intune for IOS devices. Default value is FALSE.'
        ),
    ] = None
    android_device_blocked_on_missing_partner_data: Annotated[
        Optional[bool],
        Field(
            description='For Android, set whether Intune must receive data from the Mobile Threat Defense partner prior to marking a device compliant'
        ),
    ] = None
    android_enabled: Annotated[
        Optional[bool],
        Field(
            description='For Android, set whether data from the Mobile Threat Defense partner should be used during compliance evaluations'
        ),
    ] = None
    android_mobile_application_management_enabled: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, inidicates that data from the Mobile Threat Defense partner can be used during Mobile Application Management (MAM) evaluations for Android devices. When FALSE, inidicates that data from the Mobile Threat Defense partner should not be used during Mobile Application Management (MAM) evaluations for Android devices. Only one partner per platform may be enabled for Mobile Application Management (MAM) evaluation. Default value is FALSE.'
        ),
    ] = None
    ios_device_blocked_on_missing_partner_data: Annotated[
        Optional[bool],
        Field(
            description='For IOS, set whether Intune must receive data from the Mobile Threat Defense partner prior to marking a device compliant'
        ),
    ] = None
    ios_enabled: Annotated[
        Optional[bool],
        Field(
            description='For IOS, get or set whether data from the Mobile Threat Defense partner should be used during compliance evaluations'
        ),
    ] = None
    ios_mobile_application_management_enabled: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, inidicates that data from the Mobile Threat Defense partner can be used during Mobile Application Management (MAM) evaluations for IOS devices. When FALSE, inidicates that data from the Mobile Threat Defense partner should not be used during Mobile Application Management (MAM) evaluations for IOS devices. Only one partner per platform may be enabled for Mobile Application Management (MAM) evaluation. Default value is FALSE.'
        ),
    ] = None
    last_heartbeat_date_time: Annotated[
        Optional[datetime],
        Field(
            description='DateTime of last Heartbeat recieved from the Mobile Threat Defense partner',
        ),
    ] = None
    microsoft_defender_for_endpoint_attach_enabled: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, inidicates that configuration profile management via Microsoft Defender for Endpoint is enabled. When FALSE, inidicates that configuration profile management via Microsoft Defender for Endpoint is disabled. Default value is FALSE.'
        ),
    ] = None
    partner_state: Optional[MobileThreatPartnerTenantState] = None
    partner_unresponsiveness_threshold_in_days: Annotated[
        Optional[float],
        Field(
            description='Get or Set days the per tenant tolerance to unresponsiveness for this partner integration',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    partner_unsupported_os_version_blocked: Annotated[
        Optional[bool],
        Field(
            description='Get or set whether to block devices on the enabled platforms that do not meet the minimum version requirements of the Mobile Threat Defense partner'
        ),
    ] = None
    windows_device_blocked_on_missing_partner_data: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, inidicates that Intune must receive data from the Mobile Threat Defense partner prior to marking a device compliant for Windows. When FALSE, inidicates that Intune may make a device compliant without receiving data from the Mobile Threat Defense partner for Windows. Default value is FALSE.'
        ),
    ] = None
    windows_enabled: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, inidicates that data from the Mobile Threat Defense partner can be used during compliance evaluations for Windows. When FALSE, inidicates that data from the Mobile Threat Defense partner should not be used during compliance evaluations for Windows. Default value is FALSE.'
        ),
    ] = None
    field_odata_type: str


class MultiTenantOrganizationIdentitySyncPolicyTemplate(Entity):
    template_application_level: Optional[TemplateApplicationLevel] = None
    user_sync_inbound: Annotated[
        Optional[Union[CrossTenantUserSyncInbound, Dict[str, Any]]],
        Field(
            description='Defines whether users can be synchronized from the partner tenant.'
        ),
    ] = None
    field_odata_type: str


class MuteParticipantOperation(CommsOperation):
    field_odata_type: str


class NotificationMessageTemplate(Entity):
    branding_options: Optional[NotificationTemplateBrandingOptions] = None
    default_locale: Annotated[
        Optional[str],
        Field(
            description='The default locale to fallback onto when the requested locale is not available.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(description='Display name for the Notification Message Template.'),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='DateTime the object was last modified.',
        ),
    ] = None
    role_scope_tag_ids: Annotated[
        Optional[List[str]],
        Field(description='List of Scope Tags for this Entity instance.'),
    ] = None
    localized_notification_messages: Annotated[
        Optional[List[LocalizedNotificationMessage]],
        Field(
            description='The list of localized messages for this Notification Message Template.'
        ),
    ] = None
    field_odata_type: str


class OnenoteEntityHierarchyModel(OnenoteEntitySchemaObjectModel):
    created_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(
            description='Identity of the user, device, and application that created the item. Read-only.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The name of the notebook.')
    ] = None
    last_modified_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(
            description='Identity of the user, device, and application that created the item. Read-only.'
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the notebook was last modified. The timestamp represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.',
        ),
    ] = None
    field_odata_type: str


class Operation(Entity):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The start time of the operation.',
        ),
    ] = None
    last_action_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The time of the last action of the operation.',
        ),
    ] = None
    status: Annotated[
        Optional[Union[OperationStatus, Dict[str, Any]]],
        Field(
            description='The current status of the operation: notStarted, running, completed, failed'
        ),
    ] = None
    field_odata_type: str


class OutlookCategory(Entity):
    color: Annotated[
        Optional[Union[CategoryColor, Dict[str, Any]]],
        Field(
            description='A pre-set color constant that characterizes a category, and that is mapped to one of 25 predefined colors. For more details, see the following note.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description="A unique name that identifies a category in the user's mailbox. After a category is created, the name cannot be changed. Read-only."
        ),
    ] = None
    field_odata_type: str


class OutlookUser(Entity):
    master_categories: Annotated[
        Optional[List[OutlookCategory]],
        Field(description='A list of categories defined for the user.'),
    ] = None
    field_odata_type: str


class PasswordAuthenticationMethod(AuthenticationMethod):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when this password was last updated. This property is currently not populated. Read-only. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    password: Annotated[
        Optional[str],
        Field(
            description='For security, the password is always returned as null from a LIST or GET operation.'
        ),
    ] = None
    field_odata_type: str


class PermissionGrantConditionSet(Entity):
    client_application_ids: Annotated[
        Optional[List[str]],
        Field(
            description='A list of appId values for the client applications to match with, or a list with the single value all to match any client application. Default is the single value all.'
        ),
    ] = None
    client_application_publisher_ids: Annotated[
        Optional[List[str]],
        Field(
            description='A list of Microsoft Partner Network (MPN) IDs for verified publishers of the client application, or a list with the single value all to match with client apps from any publisher. Default is the single value all.'
        ),
    ] = None
    client_applications_from_verified_publisher_only: Annotated[
        Optional[bool],
        Field(
            description="Set to true to only match on client applications with a verified publisher. Set to false to match on any client app, even if it doesn't have a verified publisher. Default is false."
        ),
    ] = None
    client_application_tenant_ids: Annotated[
        Optional[List[str]],
        Field(
            description='A list of Microsoft Entra tenant IDs in which the client application is registered, or a list with the single value all to match with client apps registered in any tenant. Default is the single value all.'
        ),
    ] = None
    permission_classification: Annotated[
        Optional[str],
        Field(
            description="The permission classification for the permission being granted, or all to match with any permission classification (including permissions that aren't classified). Default is all."
        ),
    ] = None
    permissions: Annotated[
        Optional[List[str]],
        Field(
            description="The list of id values for the specific permissions to match with, or a list with the single value all to match with any permission. The id of delegated permissions can be found in the oauth2PermissionScopes property of the API's servicePrincipal object. The id of application permissions can be found in the appRoles property of the API's servicePrincipal object. The id of resource-specific application permissions can be found in the resourceSpecificApplicationPermissions property of the API's servicePrincipal object. Default is the single value all."
        ),
    ] = None
    permission_type: Annotated[
        Optional[Union[PermissionType, Dict[str, Any]]],
        Field(
            description="The permission type of the permission being granted. Possible values: application for application permissions (for example app roles), or delegated for delegated permissions. The value delegatedUserConsentable indicates delegated permissions that haven't been configured by the API publisher to require admin consentthis value may be used in built-in permission grant policies, but can't be used in custom permission grant policies. Required."
        ),
    ] = None
    resource_application: Annotated[
        Optional[str],
        Field(
            description='The appId of the resource application (for example the API) for which a permission is being granted, or any to match with any resource application or API. Default is any.'
        ),
    ] = None
    field_odata_type: str


class PhoneAuthenticationMethod(AuthenticationMethod):
    phone_number: Annotated[
        Optional[str],
        Field(
            description="The phone number to text or call for authentication. Phone numbers use the format +{country code} {number}x{extension}, with extension optional. For example, +1 5555551234 or +1 5555551234x123 are valid. Numbers are rejected when creating or updating if they don't match the required format."
        ),
    ] = None
    phone_type: Annotated[
        Optional[Union[AuthenticationPhoneType, Dict[str, Any]]],
        Field(
            description='The type of this phone. Possible values are: mobile, alternateMobile, or office.'
        ),
    ] = None
    sms_sign_in_state: Annotated[
        Optional[Union[AuthenticationMethodSignInState, Dict[str, Any]]],
        Field(
            description='Whether a phone is ready to be used for SMS sign-in or not. Possible values are: notSupported, notAllowedByPolicy, notEnabled, phoneNumberNotUnique, ready, or notConfigured, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class PlannerAssignedToTaskBoardTaskFormat(Entity):
    order_hints_by_assignee: Annotated[
        Optional[Union[PlannerOrderHintsByAssignee, Dict[str, Any]]],
        Field(
            description='Dictionary of hints used to order tasks on the AssignedTo view of the Task Board. The key of each entry is one of the users the task is assigned to and the value is the order hint. The format of each value is defined as outlined here.'
        ),
    ] = None
    unassigned_order_hint: Annotated[
        Optional[str],
        Field(
            description="Hint value used to order the task on the AssignedTo view of the Task Board when the task isn't assigned to anyone, or if the orderHintsByAssignee dictionary doesn't provide an order hint for the user the task is assigned to. The format is defined as outlined here."
        ),
    ] = None
    field_odata_type: str


class PlannerPlanDetails(Entity):
    category_descriptions: Annotated[
        Optional[Union[PlannerCategoryDescriptions, Dict[str, Any]]],
        Field(
            description='An object that specifies the descriptions of the 25 categories that can be associated with tasks in the plan.'
        ),
    ] = None
    shared_with: Annotated[
        Optional[Union[PlannerUserIds, Dict[str, Any]]],
        Field(
            description="Set of user IDs that this plan is shared with. If you're using Microsoft 365 groups, use the Groups API to manage group membership to share the group's plan. You can also add existing members of the group to this collection, although it isn't required for them to access the plan owned by the group."
        ),
    ] = None
    field_odata_type: str


class PlannerTaskDetails(Entity):
    checklist: Annotated[
        Optional[Union[PlannerChecklistItems, Dict[str, Any]]],
        Field(description='The collection of checklist items on the task.'),
    ] = None
    description: Annotated[
        Optional[str], Field(description='Description of the task.')
    ] = None
    preview_type: Annotated[
        Optional[Union[PlannerPreviewType, Dict[str, Any]]],
        Field(
            description='This sets the type of preview that shows up on the task. The possible values are: automatic, noPreview, checklist, description, reference. When set to automatic the displayed preview is chosen by the app viewing the task.'
        ),
    ] = None
    references: Annotated[
        Optional[Union[PlannerExternalReferences, Dict[str, Any]]],
        Field(description='The collection of references on the task.'),
    ] = None
    field_odata_type: str


class PlayPromptOperation(CommsOperation):
    field_odata_type: str


class PolicyBase(DirectoryObject):
    description: Annotated[
        Optional[str], Field(description='Description for this policy. Required.')
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='Display name for this policy. Required.')
    ] = None
    field_odata_type: str


class PrintService(Entity):
    endpoints: Annotated[
        Optional[List[PrintServiceEndpoint]],
        Field(
            description='Endpoints that can be used to access the service. Read-only. Nullable.'
        ),
    ] = None
    field_odata_type: str


class ProfileCardProperty(Entity):
    annotations: Annotated[
        Optional[List[ProfileCardAnnotation]],
        Field(
            description='Allows an administrator to set a custom display label for the directory property and localize it for the users in their tenant.'
        ),
    ] = None
    directory_property_name: Annotated[
        Optional[str],
        Field(
            description='Identifies a profileCardProperty resource in Get, Update, or Delete operations. Allows an administrator to surface hidden Microsoft Entra ID properties on the Microsoft 365 profile card within their tenant. When present, the Microsoft Entra ID field referenced in this property is visible to all users in your tenant on the contact pane of the profile card. Allowed values for this field are: UserPrincipalName, Fax, StreetAddress, PostalCode, StateOrProvince, Alias, CustomAttribute1,  CustomAttribute2, CustomAttribute3, CustomAttribute4, CustomAttribute5, CustomAttribute6, CustomAttribute7, CustomAttribute8, CustomAttribute9, CustomAttribute10, CustomAttribute11, CustomAttribute12, CustomAttribute13, CustomAttribute14, CustomAttribute15.'
        ),
    ] = None
    field_odata_type: str


class ProtectionPolicyBase(Entity):
    created_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='The identity of person who created the policy.'),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The time of creation of the policy.',
        ),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The name of the policy to be created.')
    ] = None
    last_modified_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='The identity of the person who last modified the policy.'),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The timestamp of the last modification of the policy.',
        ),
    ] = None
    retention_settings: Annotated[
        Optional[List[RetentionSetting]],
        Field(description='Contains the retention setting details for the policy.'),
    ] = None
    status: Annotated[
        Optional[Union[ProtectionPolicyStatus, Dict[str, Any]]],
        Field(
            description='The aggregated status of the protection units associated with the policy. The possible values are: inactive, activeWithErrors, updating, active, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class RecordOperation(CommsOperation):
    recording_access_token: Annotated[
        Optional[str],
        Field(description='The access token required to retrieve the recording.'),
    ] = None
    recording_location: Annotated[
        Optional[str], Field(description='The location where the recording is located.')
    ] = None
    field_odata_type: str


class ReferenceAttachment(Attachment):
    field_odata_type: str


class RelyingPartyDetailedSummary(Entity):
    failed_sign_in_count: Annotated[
        Optional[float],
        Field(
            description='Number of failed sign ins on AD FS in the period specified. Supports $orderby, $filter (eq).'
        ),
    ] = None
    migration_status: Optional[MigrationStatus] = None
    migration_validation_details: Annotated[
        Optional[List[KeyValuePair]],
        Field(
            description='Specifies all the validations checks done on applications config details.'
        ),
    ] = None
    relying_party_id: Annotated[
        Optional[str],
        Field(
            description="Identifies the relying party to this federation service. It's used when issuing claims to the relying party. Supports $orderby, $filter (eq)."
        ),
    ] = None
    relying_party_name: Annotated[
        Optional[str],
        Field(
            description="Name of the relying party's website or other entity on the Internet that uses an identity provider to authenticate a user who wants to log in. Supports $orderby, $filter (eq)."
        ),
    ] = None
    reply_urls: Annotated[
        Optional[List[str]],
        Field(
            description='Specifies where the relying party expects to receive the token.'
        ),
    ] = None
    service_id: Annotated[
        Optional[str],
        Field(
            description='Uniquely identifies the Active Directory forest. Supports $orderby, $filter (eq).'
        ),
    ] = None
    sign_in_success_rate: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='Calculated as Number of successful / (Number of successful + Number of failed sign ins) or successfulSignInCount / totalSignInCount on AD FS in the period specified. Supports $orderby, $filter (eq).'
        ),
    ] = None
    successful_sign_in_count: Annotated[
        Optional[float],
        Field(
            description='Number of successful sign ins on AD FS. Supports $orderby, $filter (eq).'
        ),
    ] = None
    total_sign_in_count: Annotated[
        Optional[float],
        Field(
            description='Number of successful + failed sign ins on AD FS in the period specified. Supports $orderby, $filter (eq).'
        ),
    ] = None
    unique_user_count: Annotated[
        Optional[float],
        Field(
            description='Number of unique users that signed into the application. Supports $orderby, $filter (eq).'
        ),
    ] = None
    field_odata_type: str


class RemoteAssistancePartner(Entity):
    display_name: Annotated[
        Optional[str], Field(description='Display name of the partner.')
    ] = None
    last_connection_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Timestamp of the last request sent to Intune by the TEM partner.',
        ),
    ] = None
    onboarding_status: Optional[RemoteAssistanceOnboardingStatus] = None
    onboarding_url: Annotated[
        Optional[str],
        Field(
            description="URL of the partner's onboarding portal, where an administrator can configure their Remote Assistance service."
        ),
    ] = None
    field_odata_type: str


class RemoteDesktopSecurityConfiguration(Entity):
    is_remote_desktop_protocol_enabled: Annotated[
        Optional[bool],
        Field(
            description='Determines if Microsoft Entra ID RDS authentication protocol for RDP is enabled.'
        ),
    ] = None
    target_device_groups: Annotated[
        Optional[List[TargetDeviceGroup]],
        Field(
            description='The collection of target device groups that are associated with the RDS security configuration that will be enabled for SSO when a client connects to the target device over RDP using the new Microsoft Entra ID RDS authentication protocol.'
        ),
    ] = None
    field_odata_type: str


class Request(Entity):
    approval_id: Annotated[
        Optional[str],
        Field(description='The identifier of the approval of the request.'),
    ] = None
    completed_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The request completion date time.',
        ),
    ] = None
    created_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='The principal that created the request.'),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The request creation date time.',
        ),
    ] = None
    custom_data: Annotated[
        Optional[str],
        Field(
            description='Free text field to define any custom data for the request. Not used.'
        ),
    ] = None
    status: Annotated[
        Optional[str],
        Field(
            description='The status of the request. Not nullable. The possible values are: Canceled, Denied, Failed, Granted, PendingAdminDecision, PendingApproval, PendingProvisioning, PendingScheduleCreation, Provisioned, Revoked, and ScheduleCreated. Not nullable.'
        ),
    ] = None
    field_odata_type: str


class ResourceSpecificPermissionGrant(DirectoryObject):
    client_app_id: Annotated[
        Optional[str],
        Field(
            description='ID of the service principal of the Microsoft Entra app that has been granted access. Read-only.'
        ),
    ] = None
    client_id: Annotated[
        Optional[str],
        Field(
            description='ID of the Microsoft Entra app that has been granted access. Read-only.'
        ),
    ] = None
    permission: Annotated[
        Optional[str],
        Field(description='The name of the resource-specific permission. Read-only.'),
    ] = None
    permission_type: Annotated[
        Optional[str],
        Field(
            description='The type of permission. Possible values are: Application, Delegated. Read-only.'
        ),
    ] = None
    resource_app_id: Annotated[
        Optional[str],
        Field(
            description='ID of the Microsoft Entra app that is hosting the resource. Read-only.'
        ),
    ] = None
    field_odata_type: str


class SamlOrWsFedProvider(IdentityProviderBase):
    issuer_uri: Annotated[
        Optional[str], Field(description='Issuer URI of the federation server.')
    ] = None
    metadata_exchange_uri: Annotated[
        Optional[str],
        Field(
            description='URI of the metadata exchange endpoint used for authentication from rich client applications.'
        ),
    ] = None
    passive_sign_in_uri: Annotated[
        Optional[str],
        Field(
            description='URI that web-based clients are directed to when signing in to Microsoft Entra services.'
        ),
    ] = None
    preferred_authentication_protocol: Annotated[
        Optional[Union[AuthenticationProtocol, Dict[str, Any]]],
        Field(
            description='Preferred authentication protocol. The possible values are: wsFed, saml, unknownFutureValue.'
        ),
    ] = None
    signing_certificate: Annotated[
        Optional[str],
        Field(
            description="Current certificate used to sign tokens passed to the Microsoft identity platform. The certificate is formatted as a Base64 encoded string of the public portion of the federated IdP's token signing certificate and must be compatible with the X509Certificate2 class.   This property is used in the following scenarios:  if a rollover is required outside of the autorollover update a new federation service is being set up  if the new token signing certificate isn't present in the federation properties after the federation service certificate has been updated.   Microsoft Entra ID updates certificates via an autorollover process in which it attempts to retrieve a new certificate from the federation service metadata, 30 days before expiry of the current certificate. If a new certificate isn't available, Microsoft Entra ID monitors the metadata daily and will update the federation settings for the domain when a new certificate is available."
        ),
    ] = None
    field_odata_type: str


class ScheduleChangeRequest(ChangeTrackedEntity):
    assigned_to: Optional[Union[ScheduleChangeRequestActor, Dict[str, Any]]] = None
    manager_action_date_time: Annotated[
        Optional[datetime],
        Field(
        ),
    ] = None
    manager_action_message: Optional[str] = None
    manager_user_id: Optional[str] = None
    sender_date_time: Annotated[
        Optional[datetime],
        Field(
        ),
    ] = None
    sender_message: Optional[str] = None
    sender_user_id: Optional[str] = None
    state: Optional[Union[ScheduleChangeState, Dict[str, Any]]] = None
    field_odata_type: str


class SchedulingGroup(ChangeTrackedEntity):
    display_name: Annotated[
        Optional[str],
        Field(description='The display name for the schedulingGroup. Required.'),
    ] = None
    is_active: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the schedulingGroup can be used when creating new entities or updating existing ones. Required.'
        ),
    ] = None
    user_ids: Annotated[
        Optional[List[str]],
        Field(
            description='The list of user IDs that are a member of the schedulingGroup. Required.'
        ),
    ] = None
    field_odata_type: str


class SchemaExtension(Entity):
    description: Annotated[
        Optional[str],
        Field(
            description='Description for the schema extension. Supports $filter (eq).'
        ),
    ] = None
    owner: Annotated[
        Optional[str],
        Field(
            description="The appId of the application that is the owner of the schema extension. The owner of the schema definition must be explicitly specified during the Create and Update operations, or it will be implied and auto-assigned by Microsoft Entra ID as follows: In delegated access: The signed-in user must be the owner of the app that calls Microsoft Graph to create the schema extension definition.  If the signed-in user isn't the owner of the calling app, they must explicitly specify the owner property, and assign it the appId of an app that they own. In app-only access:  The owner property isn't required in the request body. Instead, the calling app is assigned ownership of the schema extension. So, for example, if creating a new schema extension definition using Graph Explorer, you must supply the owner property. Once set, this property is read-only and cannot be changed. Supports $filter (eq)."
        ),
    ] = None
    properties: Annotated[
        Optional[List[ExtensionSchemaProperty]],
        Field(
            description='The collection of property names and types that make up the schema extension definition.'
        ),
    ] = None
    status: Annotated[
        Optional[str],
        Field(
            description='The lifecycle state of the schema extension. Possible states are InDevelopment, Available, and Deprecated. Automatically set to InDevelopment on creation. For more information about the possible state transitions and behaviors, see Schema extensions lifecycle. Supports $filter (eq).'
        ),
    ] = None
    target_types: Annotated[
        Optional[List[str]],
        Field(
            description='Set of Microsoft Graph types (that can support extensions) that the schema extension can be applied to. Select from administrativeUnit, contact, device, event, group, message, organization, post, todoTask, todoTaskList, or user.'
        ),
    ] = None
    field_odata_type: str


class ScopedRoleMembership(Entity):
    administrative_unit_id: Annotated[
        Optional[str],
        Field(
            description='Unique identifier for the administrative unit that the directory role is scoped to'
        ),
    ] = None
    role_id: Annotated[
        Optional[str],
        Field(
            description='Unique identifier for the directory role that the member is in.'
        ),
    ] = None
    role_member_info: Optional[Identity] = None
    field_odata_type: str


class SecureScoreControlProfile(Entity):
    action_type: Annotated[
        Optional[str],
        Field(description='Control action type (Config, Review, Behavior).'),
    ] = None
    action_url: Annotated[
        Optional[str], Field(description='URL to where the control can be actioned.')
    ] = None
    azure_tenant_id: Annotated[
        Optional[str], Field(description='GUID string for tenant ID.')
    ] = None
    compliance_information: Annotated[
        Optional[List[ComplianceInformation]],
        Field(
            description='The collection of compliance information associated with secure score control'
        ),
    ] = None
    control_category: Annotated[
        Optional[str],
        Field(
            description='Control action category (Identity, Data, Device, Apps, Infrastructure).'
        ),
    ] = None
    control_state_updates: Annotated[
        Optional[List[SecureScoreControlStateUpdate]],
        Field(
            description='Flag to indicate where the tenant has marked a control (ignored, thirdParty, reviewed) (supports update).'
        ),
    ] = None
    deprecated: Annotated[
        Optional[bool],
        Field(description='Flag to indicate if a control is depreciated.'),
    ] = None
    implementation_cost: Annotated[
        Optional[str],
        Field(
            description='Resource cost of implemmentating control (low, moderate, high).'
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Time at which the control profile entity was last modified. The Timestamp type represents date and time',
        ),
    ] = None
    max_score: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='max attainable score for the control.'),
    ] = None
    rank: Annotated[
        Optional[float],
        Field(
            description="Microsoft's stack ranking of control.",
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    remediation: Annotated[
        Optional[str],
        Field(description='Description of what the control will help remediate.'),
    ] = None
    remediation_impact: Annotated[
        Optional[str],
        Field(description='Description of the impact on users of the remediation.'),
    ] = None
    service: Annotated[
        Optional[str],
        Field(
            description='Service that owns the control (Exchange, Sharepoint, Microsoft Entra ID).'
        ),
    ] = None
    threats: Annotated[
        Optional[List[str]],
        Field(
            description='List of threats the control mitigates (accountBreach, dataDeletion, dataExfiltration, dataSpillage, elevationOfPrivilege, maliciousInsider, passwordCracking, phishingOrWhaling, spoofing).'
        ),
    ] = None
    tier: Annotated[
        Optional[str],
        Field(description='Control tier (Core, Defense in Depth, Advanced.)'),
    ] = None
    title: Annotated[Optional[str], Field(description='Title of the control.')] = None
    user_impact: Annotated[
        Optional[str],
        Field(description='User impact of implementing control (low, moderate, high).'),
    ] = None
    vendor_information: Annotated[
        Optional[Union[SecurityVendorInformation, Dict[str, Any]]],
        Field(
            description='Complex type containing details about the security product/service vendor, provider, and subprovider (for example, vendor=Microsoft; provider=SecureScore). Required.'
        ),
    ] = None
    field_odata_type: str


class SendDtmfTonesOperation(CommsOperation):
    completion_reason: Annotated[
        Optional[Union[SendDtmfCompletionReason, Dict[str, Any]]],
        Field(
            description='The results of the action. Possible values are: unknown, completedSuccessfully, mediaOperationCanceled, unknownfutureValue.'
        ),
    ] = None
    field_odata_type: str


class ServiceAnnouncementBase(Entity):
    details: Annotated[
        Optional[List[KeyValuePair]],
        Field(
            description="More details about service event. This property doesn't support filters."
        ),
    ] = None
    end_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The end time of the service event.',
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The last modified time of the service event.',
        ),
    ] = None
    start_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The start time of the service event.',
        ),
    ] = None
    title: Annotated[
        Optional[str], Field(description='The title of the service event.')
    ] = None
    field_odata_type: str


class ServiceApp(Entity):
    application: Annotated[
        Optional[Union[Identity, Dict[str, Any]]],
        Field(description='The Entra ID application ID.'),
    ] = None
    effective_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Timestamp of the effective activation of the service app.',
        ),
    ] = None
    last_modified_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Identity of the person who last modified the entity.'),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Timestamp of the last modification of the entity.',
        ),
    ] = None
    registration_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Timestamp of the creation of the service app entity.',
        ),
    ] = None
    status: Annotated[
        Optional[Union[ServiceAppStatus, Dict[str, Any]]],
        Field(
            description='The status of the service app. This value indicates whether or not the application can be used to control the backup service. The possible values are: inactive, active, pendingActive, pendingInactive, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class ServiceStorageQuotaBreakdown(StorageQuotaBreakdown):
    field_odata_type: str


class SharedInsight(Entity):
    last_shared: Annotated[
        Optional[Union[SharingDetail, Dict[str, Any]]],
        Field(description='Details about the shared item. Read only.'),
    ] = None
    resource_reference: Annotated[
        Optional[Union[ResourceReference, Dict[str, Any]]],
        Field(
            description='Reference properties of the shared document, such as the url and type of the document. Read-only'
        ),
    ] = None
    resource_visualization: Annotated[
        Optional[Union[ResourceVisualization, Dict[str, Any]]],
        Field(
            description='Properties that you can use to visualize the document in your experience. Read-only'
        ),
    ] = None
    sharing_history: Optional[List[SharingDetail]] = None
    last_shared_method: Optional[Union[Entity, Dict[str, Any]]] = None
    resource: Annotated[
        Optional[Union[Entity, Dict[str, Any]]],
        Field(
            description='Used for navigating to the item that was shared. For file attachments, the type is fileAttachment. For linked attachments, the type is driveItem.'
        ),
    ] = None
    field_odata_type: str


class SharepointSettings(Entity):
    allowed_domain_guids_for_sync_app: Annotated[
        Optional[List[AllowedDomainGuidsForSyncAppItem]],
        Field(
            description='Collection of trusted domain GUIDs for the OneDrive sync app.'
        ),
    ] = None
    available_managed_paths_for_site_creation: Annotated[
        Optional[List[str]],
        Field(
            description='Collection of managed paths available for site creation. Read-only.'
        ),
    ] = None
    deleted_user_personal_site_retention_period_in_days: Annotated[
        Optional[float],
        Field(
            description="The number of days for preserving a deleted user's OneDrive.",
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    excluded_file_extensions_for_sync_app: Annotated[
        Optional[List[str]],
        Field(
            description='Collection of file extensions not uploaded by the OneDrive sync app.'
        ),
    ] = None
    idle_session_sign_out: Annotated[
        Optional[Union[IdleSessionSignOut, Dict[str, Any]]],
        Field(
            description='Specifies the idle session sign-out policies for the tenant.'
        ),
    ] = None
    image_tagging_option: Annotated[
        Optional[Union[ImageTaggingChoice, Dict[str, Any]]],
        Field(
            description='Specifies the image tagging option for the tenant. Possible values are: disabled, basic, enhanced.'
        ),
    ] = None
    is_commenting_on_site_pages_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether comments are allowed on modern site pages in SharePoint.'
        ),
    ] = None
    is_file_activity_notification_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether push notifications are enabled for OneDrive events.'
        ),
    ] = None
    is_legacy_auth_protocols_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether legacy authentication protocols are enabled for the tenant.'
        ),
    ] = None
    is_loop_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether if Fluid Framework is allowed on SharePoint sites.'
        ),
    ] = None
    is_mac_sync_app_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether files can be synced using the OneDrive sync app for Mac.'
        ),
    ] = None
    is_require_accepting_user_to_match_invited_user_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether guests must sign in using the same account to which sharing invitations are sent.'
        ),
    ] = None
    is_resharing_by_external_users_enabled: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether guests are allowed to reshare files, folders, and sites they don't own."
        ),
    ] = None
    is_share_point_mobile_notification_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether mobile push notifications are enabled for SharePoint.'
        ),
    ] = None
    is_share_point_newsfeed_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the newsfeed is allowed on the modern site pages in SharePoint.'
        ),
    ] = None
    is_site_creation_enabled: Annotated[
        Optional[bool],
        Field(description='Indicates whether users are allowed to create sites.'),
    ] = None
    is_site_creation_ui_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the UI commands for creating sites are shown.'
        ),
    ] = None
    is_site_pages_creation_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether creating new modern pages is allowed on SharePoint sites.'
        ),
    ] = None
    is_sites_storage_limit_automatic: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether site storage space is automatically managed or if specific storage limits are set per site.'
        ),
    ] = None
    is_sync_button_hidden_on_personal_site: Annotated[
        Optional[bool],
        Field(description='Indicates whether the sync button in OneDrive is hidden.'),
    ] = None
    is_unmanaged_sync_app_for_tenant_restricted: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether users are allowed to sync files only on PCs joined to specific domains.'
        ),
    ] = None
    personal_site_default_storage_limit_in_mb: Annotated[
        Optional[float],
        Field(
            description='The default OneDrive storage limit for all new and existing users who are assigned a qualifying license. Measured in megabytes (MB).'
        ),
    ] = None
    sharing_allowed_domain_list: Annotated[
        Optional[List[str]],
        Field(
            description='Collection of email domains that are allowed for sharing outside the organization.'
        ),
    ] = None
    sharing_blocked_domain_list: Annotated[
        Optional[List[str]],
        Field(
            description='Collection of email domains that are blocked for sharing outside the organization.'
        ),
    ] = None
    sharing_capability: Annotated[
        Optional[Union[SharingCapabilities, Dict[str, Any]]],
        Field(
            description='Sharing capability for the tenant. Possible values are: disabled, externalUserSharingOnly, externalUserAndGuestSharing, existingExternalUserSharingOnly.'
        ),
    ] = None
    sharing_domain_restriction_mode: Annotated[
        Optional[Union[SharingDomainRestrictionMode, Dict[str, Any]]],
        Field(
            description='Specifies the external sharing mode for domains. Possible values are: none, allowList, blockList.'
        ),
    ] = None
    site_creation_default_managed_path: Annotated[
        Optional[str],
        Field(
            description='The value of the team site managed path. This is the path under which new team sites will be created.'
        ),
    ] = None
    site_creation_default_storage_limit_in_mb: Annotated[
        Optional[float],
        Field(
            description='The default storage quota for a new site upon creation. Measured in megabytes (MB).',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    tenant_default_timezone: Annotated[
        Optional[str],
        Field(
            description='The default timezone of a tenant for newly created sites. For a list of possible values, see SPRegionalSettings.TimeZones property.'
        ),
    ] = None
    field_odata_type: str


class SimulationAutomationRun(Entity):
    end_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when the run ends in an attack simulation automation.',
        ),
    ] = None
    simulation_id: Annotated[
        Optional[str],
        Field(
            description='Unique identifier for the attack simulation campaign initiated in the attack simulation automation run.'
        ),
    ] = None
    start_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when the run starts in an attack simulation automation.',
        ),
    ] = None
    status: Annotated[
        Optional[Union[SimulationAutomationRunStatus, Dict[str, Any]]],
        Field(
            description='Status of the attack simulation automation run. The possible values are: unknown, running, succeeded, failed, skipped, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class SkypeForBusinessUserConversationMember(ConversationMember):
    tenant_id: Annotated[
        Optional[str], Field(description='ID of the tenant that the user belongs to.')
    ] = None
    user_id: Annotated[
        Optional[str], Field(description='Microsoft Entra ID of the user.')
    ] = None
    field_odata_type: str


class SkypeUserConversationMember(ConversationMember):
    skype_id: Annotated[Optional[str], Field(description='Skype ID of the user.')] = (
        None
    )
    field_odata_type: str


class SmsAuthenticationMethodTarget(AuthenticationMethodTarget):
    is_usable_for_sign_in: Annotated[
        Optional[bool],
        Field(
            description='Determines if users can use this authentication method to sign in to Microsoft Entra ID. true if users can use this method for primary authentication, otherwise false.'
        ),
    ] = None
    field_odata_type: str


class SoftwareOathAuthenticationMethod(AuthenticationMethod):
    secret_key: Annotated[
        Optional[str],
        Field(description='The secret key of the method. Always returns null.'),
    ] = None
    field_odata_type: str


class StandardWebPart(WebPart):
    container_text_web_part_id: Annotated[
        Optional[str],
        Field(
            description='The instance identifier of the container text webPart. It only works for inline standard webPart in rich text webParts.'
        ),
    ] = None
    data: Annotated[
        Optional[Union[WebPartData, Dict[str, Any]]],
        Field(description='Data of the webPart.'),
    ] = None
    web_part_type: Annotated[
        Optional[str], Field(description='A Guid that indicates the webPart type.')
    ] = None
    field_odata_type: str


class StartHoldMusicOperation(CommsOperation):
    field_odata_type: str


class StopHoldMusicOperation(CommsOperation):
    field_odata_type: str


class StsPolicy(PolicyBase):
    definition: Annotated[
        Optional[List[str]],
        Field(
            description='A string collection containing a JSON string that defines the rules and settings for a policy. The syntax for the definition differs for each derived policy type. Required.'
        ),
    ] = None
    is_organization_default: Annotated[
        Optional[bool],
        Field(
            description='If set to true, activates this policy. There can be many policies for the same policy type, but only one can be activated as the organization default. Optional, default value is false.'
        ),
    ] = None
    applies_to: Optional[List[DirectoryObject]] = None
    field_odata_type: str


class SubscribedSku(Entity):
    account_id: Annotated[
        Optional[str],
        Field(description='The unique ID of the account this SKU belongs to.'),
    ] = None
    account_name: Annotated[
        Optional[str], Field(description='The name of the account this SKU belongs to.')
    ] = None
    applies_to: Annotated[
        Optional[str],
        Field(
            description='The target class for this SKU. Only SKUs with target class User are assignable. Possible values are: User, Company.'
        ),
    ] = None
    capability_status: Annotated[
        Optional[str],
        Field(
            description='Enabled indicates that the prepaidUnits property has at least one unit that is enabled. LockedOut indicates that the customer canceled their subscription. Possible values are: Enabled, Warning, Suspended, Deleted, LockedOut.'
        ),
    ] = None
    consumed_units: Annotated[
        Optional[float],
        Field(
            description='The number of licenses that have been assigned.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    prepaid_units: Annotated[
        Optional[Union[LicenseUnitsDetail, Dict[str, Any]]],
        Field(
            description='Information about the number and status of prepaid licenses.'
        ),
    ] = None
    service_plans: Annotated[
        Optional[List[ServicePlanInfo]],
        Field(
            description='Information about the service plans that are available with the SKU. Not nullable.'
        ),
    ] = None
    sku_id: Annotated[
        Optional[UUID],
        Field(
            description='The unique identifier (GUID) for the service SKU.',
        ),
    ] = None
    sku_part_number: Annotated[
        Optional[str],
        Field(
            description='The SKU part number; for example: AAD_PREMIUM or RMSBASIC. To get a list of commercial subscriptions that an organization has acquired, see List subscribedSkus.'
        ),
    ] = None
    subscription_ids: Annotated[
        Optional[List[str]],
        Field(description='A list of all subscription IDs associated with this SKU.'),
    ] = None
    field_odata_type: str


class SubscribeToToneOperation(CommsOperation):
    field_odata_type: str


class TargetedManagedAppPolicyAssignment(Entity):
    target: Annotated[
        Optional[Union[DeviceAndAppManagementAssignmentTarget, Dict[str, Any]]],
        Field(description='Identifier for deployment to a group or app'),
    ] = None
    field_odata_type: str


class TargetedManagedAppProtection(ManagedAppProtection):
    is_assigned: Annotated[
        Optional[bool],
        Field(
            description='Indicates if the policy is deployed to any inclusion groups or not.'
        ),
    ] = None
    assignments: Annotated[
        Optional[List[TargetedManagedAppPolicyAssignment]],
        Field(
            description='Navigation property to list of inclusion and exclusion groups to which the policy is deployed.'
        ),
    ] = None
    field_odata_type: str


class TaskFileAttachment(AttachmentBase):
    content_bytes: Annotated[
        Optional[str], Field(description='The base64-encoded contents of the file.')
    ] = None
    field_odata_type: str


class TeamsAsyncOperation(Entity):
    attempts_count: Annotated[
        Optional[float],
        Field(
            description='Number of times the operation was attempted before being marked successful or failed.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Time when the operation was created.',
        ),
    ] = None
    error: Annotated[
        Optional[Union[OperationError, Dict[str, Any]]],
        Field(description='Any error that causes the async operation to fail.'),
    ] = None
    last_action_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Time when the async operation was last updated.',
        ),
    ] = None
    operation_type: Optional[TeamsAsyncOperationType] = None
    status: Optional[TeamsAsyncOperationStatus] = None
    target_resource_id: Annotated[
        Optional[str],
        Field(
            description="The ID of the object that's created or modified as result of this async operation, typically a team."
        ),
    ] = None
    target_resource_location: Annotated[
        Optional[str],
        Field(
            description="The location of the object that's created or modified as result of this async operation. This URL should be treated as an opaque value and not parsed into its component paths."
        ),
    ] = None
    field_odata_type: str


class TeamworkTag(Entity):
    description: Annotated[
        Optional[str],
        Field(
            description="The description of the tag as it appears to the user in Microsoft Teams. A teamworkTag can't have more than 200 teamworkTagMembers."
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='The name of the tag as it appears to the user in Microsoft Teams.'
        ),
    ] = None
    member_count: Annotated[
        Optional[float],
        Field(
            description='The number of users assigned to the tag.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    tag_type: Annotated[
        Optional[Union[TeamworkTagType, Dict[str, Any]]],
        Field(description='The type of the tag. Default is standard.'),
    ] = None
    team_id: Annotated[
        Optional[str], Field(description='ID of the team in which the tag is defined.')
    ] = None
    members: Annotated[
        Optional[List[TeamworkTagMember]],
        Field(description='Users assigned to the tag.'),
    ] = None
    field_odata_type: str


class TemporaryAccessPassAuthenticationMethod(AuthenticationMethod):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the Temporary Access Pass was created.',
        ),
    ] = None
    is_usable: Annotated[
        Optional[bool],
        Field(
            description="The state of the authentication method that indicates whether it's currently usable by the user."
        ),
    ] = None
    is_usable_once: Annotated[
        Optional[bool],
        Field(
            description='Determines whether the pass is limited to a one-time use. If true, the pass can be used once; if false, the pass can be used multiple times within the Temporary Access Pass lifetime.'
        ),
    ] = None
    lifetime_in_minutes: Annotated[
        Optional[float],
        Field(
            description='The lifetime of the Temporary Access Pass in minutes starting at startDateTime. Must be between 10 and 43200 inclusive (equivalent to 30 days).',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    method_usability_reason: Annotated[
        Optional[str],
        Field(
            description='Details about the usability state (isUsable). Reasons can include: EnabledByPolicy, DisabledByPolicy, Expired, NotYetValid, OneTimeUsed.'
        ),
    ] = None
    start_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the Temporary Access Pass becomes available to use and when isUsable is true is enforced.',
        ),
    ] = None
    temporary_access_pass: Annotated[
        Optional[str],
        Field(
            description='The Temporary Access Pass used to authenticate. Returned only on creation of a new temporaryAccessPassAuthenticationMethod object; Hidden in subsequent read operations and returned as null with GET.'
        ),
    ] = None
    field_odata_type: str


class TermsAndConditionsAssignment(Entity):
    target: Annotated[
        Optional[Union[DeviceAndAppManagementAssignmentTarget, Dict[str, Any]]],
        Field(description='Assignment target that the T&C policy is assigned to.'),
    ] = None
    field_odata_type: str


class TextWebPart(WebPart):
    inner_html: Annotated[
        Optional[str], Field(description='The HTML string in text web part.')
    ] = None
    field_odata_type: str


class ThreatAssessmentResult(Entity):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    message: Annotated[
        Optional[str],
        Field(description='The result message for each threat assessment.'),
    ] = None
    result_type: Annotated[
        Optional[Union[ThreatAssessmentResultType, Dict[str, Any]]],
        Field(
            description='The threat assessment result type. Possible values are: checkPolicy, rescan.'
        ),
    ] = None
    field_odata_type: str


class ThumbnailSet(Entity):
    large: Annotated[
        Optional[Union[Thumbnail, Dict[str, Any]]],
        Field(description='A 1920x1920 scaled thumbnail.'),
    ] = None
    medium: Annotated[
        Optional[Union[Thumbnail, Dict[str, Any]]],
        Field(description='A 176x176 scaled thumbnail.'),
    ] = None
    small: Annotated[
        Optional[Union[Thumbnail, Dict[str, Any]]],
        Field(description='A 48x48 cropped thumbnail.'),
    ] = None
    source: Annotated[
        Optional[Union[Thumbnail, Dict[str, Any]]],
        Field(
            description='A custom thumbnail image or the original image used to generate other thumbnails.'
        ),
    ] = None
    field_odata_type: str


class TimeOffReason(ChangeTrackedEntity):
    display_name: Annotated[
        Optional[str], Field(description='The name of the timeOffReason. Required.')
    ] = None
    icon_type: Annotated[
        Optional[Union[TimeOffReasonIconType, Dict[str, Any]]],
        Field(
            description='Supported icon types are: none, car, calendar, running, plane, firstAid, doctor, notWorking, clock, juryDuty, globe, cup, phone, weather, umbrella, piggyBank, dog, cake, trafficCone, pin, sunny. Required.'
        ),
    ] = None
    is_active: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the timeOffReason can be used when creating new entities or updating existing ones. Required.'
        ),
    ] = None
    field_odata_type: str


class TimeOffRequest(ScheduleChangeRequest):
    end_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z',
        ),
    ] = None
    start_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z',
        ),
    ] = None
    time_off_reason_id: Annotated[
        Optional[str], Field(description='The reason for the time off.')
    ] = None
    field_odata_type: str


class TokenIssuancePolicy(StsPolicy):
    field_odata_type: str


class TokenLifetimePolicy(StsPolicy):
    field_odata_type: str


class Trending(Entity):
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z',
        ),
    ] = None
    resource_reference: Annotated[
        Optional[Union[ResourceReference, Dict[str, Any]]],
        Field(
            description='Reference properties of the trending document, such as the url and type of the document.'
        ),
    ] = None
    resource_visualization: Annotated[
        Optional[Union[ResourceVisualization, Dict[str, Any]]],
        Field(
            description='Properties that you can use to visualize the document in your experience.'
        ),
    ] = None
    weight: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='Value indicating how much the document is currently trending. The larger the number, the more the document is currently trending around the user (the more relevant it is). Returned documents are sorted by this value.'
        ),
    ] = None
    resource: Annotated[
        Optional[Union[Entity, Dict[str, Any]]],
        Field(description='Used for navigating to the trending document.'),
    ] = None
    field_odata_type: str


class UnifiedRoleDefinition(Entity):
    description: Annotated[
        Optional[str],
        Field(
            description='The description for the unifiedRoleDefinition. Read-only when isBuiltIn is true.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='The display name for the unifiedRoleDefinition. Read-only when isBuiltIn is true. Required.  Supports $filter (eq, in).'
        ),
    ] = None
    is_built_in: Annotated[
        Optional[bool],
        Field(
            description='Flag indicating whether the role definition is part of the default set included in Microsoft Entra or a custom definition. Read-only. Supports $filter (eq, in).'
        ),
    ] = None
    is_enabled: Annotated[
        Optional[bool],
        Field(
            description='Flag indicating whether the role is enabled for assignment. If false the role is not available for assignment. Read-only when isBuiltIn is true.'
        ),
    ] = None
    resource_scopes: Annotated[
        Optional[List[str]],
        Field(
            description='List of the scopes or permissions the role definition applies to. Currently only / is supported. Read-only when isBuiltIn is true. DO NOT USE. This will be deprecated soon. Attach scope to role assignment.'
        ),
    ] = None
    role_permissions: Annotated[
        Optional[List[UnifiedRolePermission]],
        Field(
            description='List of permissions included in the role. Read-only when isBuiltIn is true. Required.'
        ),
    ] = None
    template_id: Annotated[
        Optional[str],
        Field(
            description='Custom template identifier that can be set when isBuiltIn is false but is read-only when isBuiltIn is true. This identifier is typically used if one needs an identifier to be the same across different directories.'
        ),
    ] = None
    version: Annotated[
        Optional[str],
        Field(
            description='Indicates version of the role definition. Read-only when isBuiltIn is true.'
        ),
    ] = None
    inherits_permissions_from: Annotated[
        Optional[List[UnifiedRoleDefinition]],
        Field(
            description='Read-only collection of role definitions that the given role definition inherits from. Only Microsoft Entra built-in roles (isBuiltIn is true) support this attribute. Supports $expand.'
        ),
    ] = None
    field_odata_type: str


class UnifiedRoleScheduleBase(Entity):
    app_scope_id: Annotated[
        Optional[str],
        Field(
            description='Identifier of the app-specific scope when the assignment or eligibility is scoped to an app. The scope of an assignment or eligibility determines the set of resources for which the principal has been granted access. App scopes are scopes that are defined and understood by this application only. Use / for tenant-wide app scopes. Use directoryScopeId to limit the scope to particular directory objects, for example, administrative units.'
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='When the schedule was created.',
        ),
    ] = None
    created_using: Annotated[
        Optional[str],
        Field(
            description='Identifier of the object through which this schedule was created.'
        ),
    ] = None
    directory_scope_id: Annotated[
        Optional[str],
        Field(
            description='Identifier of the directory object representing the scope of the assignment or eligibility. The scope of an assignment or eligibility determines the set of resources for which the principal has been granted access. Directory scopes are shared scopes stored in the directory that are understood by multiple applications. Use / for tenant-wide scope. Use appScopeId to limit the scope to an application only.'
        ),
    ] = None
    modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='When the schedule was last modified.',
        ),
    ] = None
    principal_id: Annotated[
        Optional[str],
        Field(
            description='Identifier of the principal that has been granted the role assignment or eligibility.'
        ),
    ] = None
    role_definition_id: Annotated[
        Optional[str],
        Field(
            description='Identifier of the unifiedRoleDefinition object that is being assigned to the principal or that a principal is eligible for.'
        ),
    ] = None
    status: Annotated[
        Optional[str],
        Field(description='The status of the role assignment or eligibility request.'),
    ] = None
    app_scope: Annotated[
        Optional[Union[AppScope, Dict[str, Any]]],
        Field(
            description='Read-only property with details of the app-specific scope when the role eligibility or assignment is scoped to an app. Nullable.'
        ),
    ] = None
    directory_scope: Annotated[
        Optional[Union[DirectoryObject, Dict[str, Any]]],
        Field(
            description='The directory object that is the scope of the role eligibility or assignment. Read-only.'
        ),
    ] = None
    principal: Annotated[
        Optional[Union[DirectoryObject, Dict[str, Any]]],
        Field(
            description="The principal that's getting a role assignment or that's eligible for a role through the request."
        ),
    ] = None
    role_definition: Annotated[
        Optional[Union[UnifiedRoleDefinition, Dict[str, Any]]],
        Field(
            description='Detailed information for the roleDefinition object that is referenced through the roleDefinitionId property.'
        ),
    ] = None
    field_odata_type: str


class UnifiedRoleScheduleInstanceBase(Entity):
    app_scope_id: Annotated[
        Optional[str],
        Field(
            description='Identifier of the app-specific scope when the assignment or role eligibility is scoped to an app. The scope of an assignment or role eligibility determines the set of resources for which the principal has been granted access. App scopes are scopes that are defined and understood by this application only. Use / for tenant-wide app scopes. Use directoryScopeId to limit the scope to particular directory objects, for example, administrative units.'
        ),
    ] = None
    directory_scope_id: Annotated[
        Optional[str],
        Field(
            description='Identifier of the directory object representing the scope of the assignment or role eligibility. The scope of an assignment or role eligibility determines the set of resources for which the principal has been granted access. Directory scopes are shared scopes stored in the directory that are understood by multiple applications. Use / for tenant-wide scope. Use appScopeId to limit the scope to an application only.'
        ),
    ] = None
    principal_id: Annotated[
        Optional[str],
        Field(
            description="Identifier of the principal that has been granted the role assignment or that's eligible for a role."
        ),
    ] = None
    role_definition_id: Annotated[
        Optional[str],
        Field(
            description='Identifier of the unifiedRoleDefinition object that is being assigned to the principal or that the principal is eligible for.'
        ),
    ] = None
    app_scope: Annotated[
        Optional[Union[AppScope, Dict[str, Any]]],
        Field(
            description='Read-only property with details of the app-specific scope when the assignment or role eligibility is scoped to an app. Nullable.'
        ),
    ] = None
    directory_scope: Annotated[
        Optional[Union[DirectoryObject, Dict[str, Any]]],
        Field(
            description='The directory object that is the scope of the assignment or role eligibility. Read-only.'
        ),
    ] = None
    principal: Annotated[
        Optional[Union[DirectoryObject, Dict[str, Any]]],
        Field(
            description="The principal that's getting a role assignment or role eligibility through the request."
        ),
    ] = None
    role_definition: Annotated[
        Optional[Union[UnifiedRoleDefinition, Dict[str, Any]]],
        Field(
            description='Detailed information for the roleDefinition object that is referenced through the roleDefinitionId property.'
        ),
    ] = None
    field_odata_type: str


class UnifiedStorageQuota(Entity):
    deleted: Optional[float] = None
    manage_web_url: Optional[str] = None
    remaining: Optional[float] = None
    state: Optional[str] = None
    total: Optional[float] = None
    used: Optional[float] = None
    services: Optional[List[ServiceStorageQuotaBreakdown]] = None
    field_odata_type: str


class UnmuteParticipantOperation(CommsOperation):
    field_odata_type: str


class UpdateRecordingStatusOperation(CommsOperation):
    field_odata_type: str


class UsedInsight(Entity):
    last_used: Annotated[
        Optional[Union[UsageDetails, Dict[str, Any]]],
        Field(
            description='Information about when the item was last viewed or modified by the user. Read only.'
        ),
    ] = None
    resource_reference: Annotated[
        Optional[Union[ResourceReference, Dict[str, Any]]],
        Field(
            description='Reference properties of the used document, such as the url and type of the document. Read-only'
        ),
    ] = None
    resource_visualization: Annotated[
        Optional[Union[ResourceVisualization, Dict[str, Any]]],
        Field(
            description='Properties that you can use to visualize the document in your experience. Read-only'
        ),
    ] = None
    resource: Annotated[
        Optional[Union[Entity, Dict[str, Any]]],
        Field(
            description='Used for navigating to the item that was used. For file attachments, the type is fileAttachment. For linked attachments, the type is driveItem.'
        ),
    ] = None
    field_odata_type: str


class UserExperienceAnalyticsAppHealthApplicationPerformance(Entity):
    active_device_count: Annotated[
        Optional[float],
        Field(
            description='The health score of the application. Valid values 0 to 100. Supports: $filter, $select, $OrderBy. Read-only. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    app_crash_count: Annotated[
        Optional[float],
        Field(
            description='The number of crashes for the application. Valid values 0 to 2147483647. Supports: $select, $OrderBy. Read-only. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    app_display_name: Annotated[
        Optional[str],
        Field(
            description='The friendly name of the application. Possible values are: Outlook, Excel. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    app_hang_count: Annotated[
        Optional[float],
        Field(
            description='The number of hangs for the application. Supports: $select, $OrderBy. Read-only. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    app_health_score: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='The health score of the application. Valid values 0 to 100. Supports: $filter, $select, $OrderBy. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    app_name: Annotated[
        Optional[str],
        Field(
            description='The name of the application. Possible values are: outlook.exe, excel.exe. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    app_publisher: Annotated[
        Optional[str],
        Field(
            description='The publisher of the application. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    app_usage_duration: Annotated[
        Optional[float],
        Field(
            description='The total usage time of the application in minutes. Valid values 0 to 2147483647. Supports: $select, $OrderBy. Read-only. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    mean_time_to_failure_in_minutes: Annotated[
        Optional[float],
        Field(
            description='The mean time to failure for the application in minutes. Valid values 0 to 2147483647. Supports: $select, $OrderBy. Read-only. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class UserExperienceAnalyticsAppHealthDeviceModelPerformance(Entity):
    active_device_count: Annotated[
        Optional[float],
        Field(
            description='The number of active devices for the model. Valid values 0 to 2147483647. Supports: $filter, $select, $OrderBy. Read-only. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    device_manufacturer: Annotated[
        Optional[str],
        Field(
            description='The manufacturer name of the device. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    device_model: Annotated[
        Optional[str],
        Field(
            description='The model name of the device. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    health_status: Optional[UserExperienceAnalyticsHealthState] = None
    mean_time_to_failure_in_minutes: Annotated[
        Optional[float],
        Field(
            description='The mean time to failure for the application in minutes. Valid values 0 to 2147483647. Supports: $filter, $select, $OrderBy. Read-only. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    model_app_health_score: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='The application health score of the device model. Valid values 0 to 100. Supports: $filter, $select, $OrderBy. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    field_odata_type: str


class UserExperienceAnalyticsAppHealthDevicePerformance(Entity):
    app_crash_count: Annotated[
        Optional[float],
        Field(
            description='The number of application crashes for the device. Valid values 0 to 2147483647. Supports: $filter, $select, $OrderBy. Read-only. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    app_hang_count: Annotated[
        Optional[float],
        Field(
            description='The number of application hangs for the device. Valid values 0 to 2147483647. Supports: $select, $OrderBy. Read-only. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    crashed_app_count: Annotated[
        Optional[float],
        Field(
            description='The number of distinct application crashes for the device. Valid values 0 to 2147483647. Supports: $select, $OrderBy. Read-only. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    device_app_health_score: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='The application health score of the device. Valid values 0 to 100. Supports: $filter, $select, $OrderBy. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    device_display_name: Annotated[
        Optional[str],
        Field(
            description='The name of the device. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    device_id: Annotated[
        Optional[str],
        Field(
            description='The Intune device id of the device. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    device_manufacturer: Annotated[
        Optional[str],
        Field(
            description='The manufacturer name of the device. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    device_model: Annotated[
        Optional[str],
        Field(
            description='The model name of the device. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    health_status: Optional[UserExperienceAnalyticsHealthState] = None
    mean_time_to_failure_in_minutes: Annotated[
        Optional[float],
        Field(
            description='The mean time to failure for the application in minutes. Valid values 0 to 2147483647. Supports: $filter, $select, $OrderBy. Read-only. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    processed_date_time: Annotated[
        Optional[datetime],
        Field(
            description="The date and time when the statistics were last computed. The value cannot be modified and is automatically populated when the statistics are computed. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2022 would look like this: '2022-01-01T00:00:00Z'. Returned by default. Read-only.",
        ),
    ] = None
    field_odata_type: str


class UserExperienceAnalyticsAppHealthOSVersionPerformance(Entity):
    active_device_count: Annotated[
        Optional[float],
        Field(
            description='The number of active devices for the OS version. Valid values 0 to 2147483647. Supports: $filter, $select, $OrderBy. Read-only. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    mean_time_to_failure_in_minutes: Annotated[
        Optional[float],
        Field(
            description='The mean time to failure for the application in minutes. Valid values 0 to 2147483647. Supports: $filter, $select, $OrderBy. Read-only. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    os_build_number: Annotated[
        Optional[str],
        Field(
            description='The OS build number installed on the device. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    os_version: Annotated[
        Optional[str],
        Field(
            description='The OS version installed on the device. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    os_version_app_health_score: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='The application health score of the OS version. Valid values 0 to 100. Supports: $filter, $select, $OrderBy. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    field_odata_type: str


class UserExperienceAnalyticsDevicePerformance(Entity):
    average_blue_screens: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='Average (mean) number of Blue Screens per device in the last 30 days. Valid values 0 to 9999999'
        ),
    ] = None
    average_restarts: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='Average (mean) number of Restarts per device in the last 30 days. Valid values 0 to 9999999'
        ),
    ] = None
    blue_screen_count: Annotated[
        Optional[float],
        Field(
            description='Number of Blue Screens in the last 30 days. Valid values 0 to 9999999',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    boot_score: Annotated[
        Optional[float],
        Field(
            description='The user experience analytics device boot score.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    core_boot_time_in_ms: Annotated[
        Optional[float],
        Field(
            description='The user experience analytics device core boot time in milliseconds.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    core_login_time_in_ms: Annotated[
        Optional[float],
        Field(
            description='The user experience analytics device core login time in milliseconds.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    device_count: Annotated[
        Optional[float],
        Field(description='User experience analytics summarized device count.'),
    ] = None
    device_name: Annotated[
        Optional[str], Field(description='The user experience analytics device name.')
    ] = None
    disk_type: Optional[DiskType] = None
    group_policy_boot_time_in_ms: Annotated[
        Optional[float],
        Field(
            description='The user experience analytics device group policy boot time in milliseconds.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    group_policy_login_time_in_ms: Annotated[
        Optional[float],
        Field(
            description='The user experience analytics device group policy login time in milliseconds.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    health_status: Optional[UserExperienceAnalyticsHealthState] = None
    login_score: Annotated[
        Optional[float],
        Field(
            description='The user experience analytics device login score.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    manufacturer: Annotated[
        Optional[str],
        Field(description='The user experience analytics device manufacturer.'),
    ] = None
    model: Annotated[
        Optional[str], Field(description='The user experience analytics device model.')
    ] = None
    model_startup_performance_score: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='The user experience analytics model level startup performance score. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    operating_system_version: Annotated[
        Optional[str],
        Field(
            description='The user experience analytics device Operating System version.'
        ),
    ] = None
    responsive_desktop_time_in_ms: Annotated[
        Optional[float],
        Field(
            description='The user experience analytics responsive desktop time in milliseconds.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    restart_count: Annotated[
        Optional[float],
        Field(
            description='Number of Restarts in the last 30 days. Valid values 0 to 9999999',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    startup_performance_score: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='The user experience analytics device startup performance score. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    field_odata_type: str


class UserExperienceAnalyticsDeviceScores(Entity):
    app_reliability_score: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='Indicates a score calculated from application health data to indicate when a device is having problems running one or more applications. Valid values range from 0-100. Value -1 means associated score is unavailable. A higher score indicates a healthier device. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    battery_health_score: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description="Indicates a calulated score indicating the health of the device's battery. Valid values range from 0-100. Value -1 means associated score is unavailable. A higher score indicates a healthier device. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308"
        ),
    ] = None
    device_name: Annotated[
        Optional[str],
        Field(
            description='The name of the device. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    endpoint_analytics_score: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='Indicates a weighted average of the various scores. Valid values range from 0-100. Value -1 means associated score is unavailable. A higher score indicates a healthier device. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    health_status: Optional[UserExperienceAnalyticsHealthState] = None
    manufacturer: Annotated[
        Optional[str],
        Field(
            description='The manufacturer name of the device. Examples: Microsoft Corporation, HP, Lenovo. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    model: Annotated[
        Optional[str],
        Field(
            description='The model name of the device. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    startup_performance_score: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='Indicates a weighted average of boot score and logon score used for measuring startup performance. Valid values range from 0-100. Value -1 means associated score is unavailable. A higher score indicates a healthier device. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    work_from_anywhere_score: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='Indicates a weighted score of the work from anywhere on a device level. Valid values range from 0-100. Value -1 means associated score is unavailable. A higher score indicates a healthier device. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    field_odata_type: str


class UserExperienceAnalyticsDeviceStartupHistory(Entity):
    core_boot_time_in_ms: Annotated[
        Optional[float],
        Field(
            description='The device core boot time in milliseconds. Supports: $select, $OrderBy. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    core_login_time_in_ms: Annotated[
        Optional[float],
        Field(
            description='The device core login time in milliseconds. Supports: $select, $OrderBy. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    device_id: Annotated[
        Optional[str],
        Field(
            description='The Intune device id of the device. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    feature_update_boot_time_in_ms: Annotated[
        Optional[float],
        Field(
            description='The impact of device feature updates on boot time in milliseconds. Supports: $select, $OrderBy. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    group_policy_boot_time_in_ms: Annotated[
        Optional[float],
        Field(
            description='The impact of device group policy client on boot time in milliseconds. Supports: $select, $OrderBy. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    group_policy_login_time_in_ms: Annotated[
        Optional[float],
        Field(
            description='The impact of device group policy client on login time in milliseconds. Supports: $select, $OrderBy. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    is_feature_update: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates the device boot record is associated with feature updates. When FALSE, indicates the device boot record is not associated with feature updates. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    is_first_login: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates the device login is the first login after a reboot. When FALSE, indicates the device login is not the first login after a reboot. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    operating_system_version: Annotated[
        Optional[str],
        Field(
            description="The user experience analytics device boot record's operating system version. Supports: $select, $OrderBy. Read-only."
        ),
    ] = None
    responsive_desktop_time_in_ms: Annotated[
        Optional[float],
        Field(
            description='The time for desktop to become responsive during login process in milliseconds. Supports: $select, $OrderBy. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    restart_category: Optional[
        UserExperienceAnalyticsOperatingSystemRestartCategory
    ] = None
    restart_fault_bucket: Annotated[
        Optional[str],
        Field(
            description='OS restart fault bucket. The fault bucket is used to find additional information about a system crash. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    restart_stop_code: Annotated[
        Optional[str],
        Field(
            description='OS restart stop code. This shows the bug check code which can be used to look up the blue screen reason. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    start_time: Annotated[
        Optional[datetime],
        Field(
            description="The device boot start time. The value cannot be modified and is automatically populated when the device performs a reboot. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2022 would look like this: '2022-01-01T00:00:00Z'. Returned by default. Read-only.",
        ),
    ] = None
    total_boot_time_in_ms: Annotated[
        Optional[float],
        Field(
            description='The device total boot time in milliseconds. Supports: $select, $OrderBy. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    total_login_time_in_ms: Annotated[
        Optional[float],
        Field(
            description='The device total login time in milliseconds. Supports: $select, $OrderBy. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class UserExperienceAnalyticsMetric(Entity):
    unit: Annotated[
        Optional[str],
        Field(
            description='The unit of the user experience analytics metric. Examples: none, percentage, count, seconds, score.'
        ),
    ] = None
    value: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='The value of the user experience analytics metric.'),
    ] = None
    field_odata_type: str


class UserExperienceAnalyticsModelScores(Entity):
    app_reliability_score: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='Indicates a score calculated from application health data to indicate when a device is having problems running one or more applications. Valid values range from 0-100. Value -1 means associated score is unavailable. A higher score indicates a healthier device. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    battery_health_score: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description="Indicates a calulated score indicating the health of the device's battery. Valid values range from 0-100. Value -1 means associated score is unavailable. A higher score indicates a healthier device. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308"
        ),
    ] = None
    endpoint_analytics_score: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='Indicates a weighted average of the various scores. Valid values range from 0-100. Value -1 means associated score is unavailable. A higher score indicates a healthier device. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    health_status: Optional[UserExperienceAnalyticsHealthState] = None
    manufacturer: Annotated[
        Optional[str],
        Field(
            description='The manufacturer name of the device. Examples: Microsoft Corporation, HP, Lenovo. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    model: Annotated[
        Optional[str],
        Field(
            description='The model name of the device. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    model_device_count: Annotated[
        Optional[float],
        Field(
            description='Indicates unique devices count of given model in a consolidated report. Supports: $select, $OrderBy. Read-only. Valid values -9.22337203685478E+18 to 9.22337203685478E+18'
        ),
    ] = None
    startup_performance_score: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='Indicates a weighted average of boot score and logon score used for measuring startup performance. Valid values range from 0-100. Value -1 means associated score is unavailable. A higher score indicates a healthier device. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    work_from_anywhere_score: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='Indicates a weighted score of the work from anywhere on a device level. Valid values range from 0-100. Value -1 means associated score is unavailable. A higher score indicates a healthier device. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    field_odata_type: str


class UserExperienceAnalyticsWorkFromAnywhereDevice(Entity):
    auto_pilot_profile_assigned: Annotated[
        Optional[bool],
        Field(
            description="When TRUE, indicates the intune device's autopilot profile is assigned. When FALSE, indicates it's not Assigned. Supports: $select, $OrderBy. Read-only."
        ),
    ] = None
    auto_pilot_registered: Annotated[
        Optional[bool],
        Field(
            description="When TRUE, indicates the intune device's autopilot is registered. When FALSE, indicates it's not registered. Supports: $select, $OrderBy. Read-only."
        ),
    ] = None
    azure_ad_device_id: Annotated[
        Optional[str],
        Field(
            description='The Azure Active Directory (Azure AD) device Id. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    azure_ad_join_type: Annotated[
        Optional[str],
        Field(
            description="The work from anywhere device's Azure Active Directory (Azure AD) join type. Supports: $select, $OrderBy. Read-only."
        ),
    ] = None
    azure_ad_registered: Annotated[
        Optional[bool],
        Field(
            description="When TRUE, indicates the device's Azure Active Directory (Azure AD) is registered. When False, indicates it's not registered. Supports: $select, $OrderBy. Read-only."
        ),
    ] = None
    cloud_identity_score: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='Indicates per device cloud identity score. Valid values 0 to 100. Value -1 means associated score is unavailable. Supports: $select, $OrderBy. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    cloud_management_score: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='Indicates per device cloud management score. Valid values 0 to 100. Value -1 means associated score is unavailable. Supports: $select, $OrderBy. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    cloud_provisioning_score: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='Indicates per device cloud provisioning score. Valid values 0 to 100. Value -1 means associated score is unavailable. Supports: $select, $OrderBy. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    compliance_policy_set_to_intune: Annotated[
        Optional[bool],
        Field(
            description="When TRUE, indicates the device's compliance policy is set to intune. When FALSE, indicates it's not set to intune. Supports: $select, $OrderBy. Read-only."
        ),
    ] = None
    device_id: Annotated[
        Optional[str],
        Field(
            description='The Intune device id of the device. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    device_name: Annotated[
        Optional[str],
        Field(
            description='The name of the device. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    health_status: Optional[UserExperienceAnalyticsHealthState] = None
    is_cloud_managed_gateway_enabled: Annotated[
        Optional[bool],
        Field(
            description="When TRUE, indicates the device's Cloud Management Gateway for Configuration Manager is enabled. When FALSE, indicates it's not enabled. Supports: $select, $OrderBy. Read-only."
        ),
    ] = None
    managed_by: Annotated[
        Optional[str],
        Field(
            description='The management agent of the device. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    manufacturer: Annotated[
        Optional[str],
        Field(
            description='The manufacturer name of the device. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    model: Annotated[
        Optional[str],
        Field(
            description='The model name of the device. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    os_check_failed: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates OS check failed for device to upgrade to the latest version of windows. When FALSE, indicates the check succeeded. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    os_description: Annotated[
        Optional[str],
        Field(
            description='The OS description of the device. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    os_version: Annotated[
        Optional[str],
        Field(
            description='The OS version of the device. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    other_workloads_set_to_intune: Annotated[
        Optional[bool],
        Field(
            description="When TRUE, indicates the device's other workloads is set to intune. When FALSE, indicates it's not set to intune. Supports: $select, $OrderBy. Read-only."
        ),
    ] = None
    ownership: Annotated[
        Optional[str],
        Field(
            description='Ownership of the device. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    processor64_bit_check_failed: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates processor hardware 64-bit architecture check failed for device to upgrade to the latest version of windows. When FALSE, indicates the check succeeded. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    processor_core_count_check_failed: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates processor hardware core count check failed for device to upgrade to the latest version of windows. When FALSE, indicates the check succeeded. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    processor_family_check_failed: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates processor hardware family check failed for device to upgrade to the latest version of windows. When FALSE, indicates the check succeeded. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    processor_speed_check_failed: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates processor hardware speed check failed for device to upgrade to the latest version of windows. When FALSE, indicates the check succeeded. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    ram_check_failed: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates RAM hardware check failed for device to upgrade to the latest version of windows. When FALSE, indicates the check succeeded. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    secure_boot_check_failed: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates secure boot hardware check failed for device to upgrade to the latest version of windows. When FALSE, indicates the check succeeded. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    serial_number: Annotated[
        Optional[str],
        Field(
            description='The serial number of the device. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    storage_check_failed: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates storage hardware check failed for device to upgrade to the latest version of windows. When FALSE, indicates the check succeeded. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    tenant_attached: Annotated[
        Optional[bool],
        Field(
            description="When TRUE, indicates the device is Tenant Attached. When FALSE, indicates it's not Tenant Attached. Supports: $select, $OrderBy. Read-only."
        ),
    ] = None
    tpm_check_failed: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates Trusted Platform Module (TPM) hardware check failed for device to the latest version of upgrade to windows. When FALSE, indicates the check succeeded. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    upgrade_eligibility: Optional[OperatingSystemUpgradeEligibility] = None
    windows_score: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='Indicates per device windows score. Valid values 0 to 100. Value -1 means associated score is unavailable. Supports: $select, $OrderBy. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    work_from_anywhere_score: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='Indicates work from anywhere per device overall score. Valid values 0 to 100. Value -1 means associated score is unavailable. Supports: $select, $OrderBy. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    field_odata_type: str


class UserExperienceAnalyticsWorkFromAnywhereHardwareReadinessMetric(Entity):
    os_check_failed_percentage: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='The percentage of devices for which OS check has failed. Valid values 0 to 100. Supports: $select, $OrderBy. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    processor64_bit_check_failed_percentage: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='The percentage of devices for which processor hardware 64-bit architecture check has failed. Valid values 0 to 100. Supports: $select, $OrderBy. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    processor_core_count_check_failed_percentage: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='The percentage of devices for which processor hardware core count check has failed. Valid values 0 to 100. Supports: $select, $OrderBy. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    processor_family_check_failed_percentage: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='The percentage of devices for which processor hardware family check has failed. Valid values 0 to 100. Supports: $select, $OrderBy. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    processor_speed_check_failed_percentage: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='The percentage of devices for which processor hardware speed check has failed. Valid values 0 to 100. Supports: $select, $OrderBy. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    ram_check_failed_percentage: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='The percentage of devices for which RAM hardware check has failed. Valid values 0 to 100. Supports: $select, $OrderBy. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    secure_boot_check_failed_percentage: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='The percentage of devices for which secure boot hardware check has failed. Valid values 0 to 100. Supports: $select, $OrderBy. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    storage_check_failed_percentage: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='The percentage of devices for which storage hardware check has failed. Valid values 0 to 100. Supports: $select, $OrderBy. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    total_device_count: Annotated[
        Optional[float],
        Field(
            description='The count of total devices in an organization. Valid values 0 to 2147483647. Supports: $select, $OrderBy. Read-only. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    tpm_check_failed_percentage: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='The percentage of devices for which Trusted Platform Module (TPM) hardware check has failed. Valid values 0 to 100. Supports: $select, $OrderBy. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    upgrade_eligible_device_count: Annotated[
        Optional[float],
        Field(
            description='The count of devices in an organization eligible for windows upgrade. Valid values 0 to 2147483647. Supports: $select, $OrderBy. Read-only. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class UserExperienceAnalyticsWorkFromAnywhereMetric(Entity):
    metric_devices: Annotated[
        Optional[List[UserExperienceAnalyticsWorkFromAnywhereDevice]],
        Field(description='The work from anywhere metric devices. Read-only.'),
    ] = None
    field_odata_type: str


class UserExperienceAnalyticsWorkFromAnywhereModelPerformance(Entity):
    cloud_identity_score: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='The cloud identity score of the device model. Valid values 0 to 100. Value -1 means associated score is unavailable. Supports: $select, $OrderBy. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    cloud_management_score: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='The cloud management score of the device model. Valid values 0 to 100. Value -1 means associated score is unavailable. Supports: $select, $OrderBy. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    cloud_provisioning_score: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='The cloud provisioning score of the device model.  Valid values 0 to 100. Value -1 means associated score is unavailable. Supports: $select, $OrderBy. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    health_status: Optional[UserExperienceAnalyticsHealthState] = None
    manufacturer: Annotated[
        Optional[str],
        Field(
            description='The manufacturer name of the device. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    model: Annotated[
        Optional[str],
        Field(
            description='The model name of the device. Supports: $select, $OrderBy. Read-only.'
        ),
    ] = None
    model_device_count: Annotated[
        Optional[float],
        Field(
            description='The devices count for the model. Supports: $select, $OrderBy. Read-only. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    windows_score: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='The window score of the device model. Valid values 0 to 100. Value -1 means associated score is unavailable. Supports: $select, $OrderBy. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    work_from_anywhere_score: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='The work from anywhere score of the device model. Valid values 0 to 100. Value -1 means associated score is unavailable. Supports: $select, $OrderBy. Read-only. Valid values -1.79769313486232E+308 to 1.79769313486232E+308'
        ),
    ] = None
    field_odata_type: str


class UserFlowLanguageConfiguration(Entity):
    display_name: Annotated[
        Optional[str],
        Field(description='The language name to display. This property is read-only.'),
    ] = None
    is_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the language is enabled within the user flow.'
        ),
    ] = None
    default_pages: Annotated[
        Optional[List[UserFlowLanguagePage]],
        Field(
            description="Collection of pages with the default content to display in a user flow for a specified language. This collection doesn't allow any kind of modification."
        ),
    ] = None
    overrides_pages: Annotated[
        Optional[List[UserFlowLanguagePage]],
        Field(
            description="Collection of pages with the overrides messages to display in a user flow for a specified language. This collection only allows you to modify the content of the page, any other modification isn't allowed (creation or deletion of pages)."
        ),
    ] = None
    field_odata_type: str


class UserInstallStateSummary(Entity):
    failed_device_count: Annotated[
        Optional[float],
        Field(description='Failed Device Count.', ge=-2147483648.0, le=2147483647.0),
    ] = None
    installed_device_count: Annotated[
        Optional[float],
        Field(description='Installed Device Count.', ge=-2147483648.0, le=2147483647.0),
    ] = None
    not_installed_device_count: Annotated[
        Optional[float],
        Field(
            description='Not installed device count.', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    user_name: Annotated[Optional[str], Field(description='User name.')] = None
    device_states: Annotated[
        Optional[List[DeviceInstallState]],
        Field(description='The install state of the eBook.'),
    ] = None
    field_odata_type: str


class UserRegistrationDetails(Entity):
    is_admin: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the user has an admin role in the tenant. This value can be used to check the authentication methods that privileged accounts are registered for and capable of.'
        ),
    ] = None
    is_mfa_capable: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the user has registered a strong authentication method for multifactor authentication. The method must be allowed by the authentication methods policy. Supports $filter (eq).'
        ),
    ] = None
    is_mfa_registered: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the user has registered a strong authentication method for multifactor authentication. The method may not necessarily be allowed by the authentication methods policy. Supports $filter (eq).'
        ),
    ] = None
    is_passwordless_capable: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the user has registered a passwordless strong authentication method (including FIDO2, Windows Hello for Business, and Microsoft Authenticator (Passwordless)) that is allowed by the authentication methods policy. Supports $filter (eq).'
        ),
    ] = None
    is_sspr_capable: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the user has registered the required number of authentication methods for self-service password reset and the user is allowed to perform self-service password reset by policy. Supports $filter (eq).'
        ),
    ] = None
    is_sspr_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the user is allowed to perform self-service password reset by policy. The user may not necessarily have registered the required number of authentication methods for self-service password reset. Supports $filter (eq).'
        ),
    ] = None
    is_sspr_registered: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the user has registered the required number of authentication methods for self-service password reset. The user may not necessarily be allowed to perform self-service password reset by policy. Supports $filter (eq).'
        ),
    ] = None
    is_system_preferred_authentication_method_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether system preferred authentication method is enabled. If enabled, the system dynamically determines the most secure authentication method among the methods registered by the user. Supports $filter (eq).'
        ),
    ] = None
    last_updated_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time (UTC) when the report was last updated. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    methods_registered: Annotated[
        Optional[List[str]],
        Field(
            description='Collection of authentication methods registered, such as mobilePhone, email, passKeyDeviceBound. Supports $filter (any with eq).'
        ),
    ] = None
    system_preferred_authentication_methods: Annotated[
        Optional[List[str]],
        Field(
            description='Collection of authentication methods that the system determined to be the most secure authentication methods among the registered methods for second factor authentication. Possible values are: push, oath, voiceMobile, voiceAlternateMobile, voiceOffice, sms, none, unknownFutureValue. Supports $filter (any with eq).'
        ),
    ] = None
    user_display_name: Annotated[
        Optional[str],
        Field(
            description='The user display name, such as Adele Vance. Supports $filter (eq, startsWith) and $orderby.'
        ),
    ] = None
    user_preferred_method_for_secondary_authentication: Annotated[
        Optional[Union[UserDefaultAuthenticationMethod, Dict[str, Any]]],
        Field(
            description='The method the user selected as the default second-factor for performing multifactor authentication. Possible values are: push, oath, voiceMobile, voiceAlternateMobile, voiceOffice, sms, none, unknownFutureValue. This property is used as preferred MFA method when isSystemPreferredAuthenticationMethodEnabled is false. Supports $filter (any with eq).'
        ),
    ] = None
    user_principal_name: Annotated[
        Optional[str],
        Field(
            description='The user principal name, such as AdeleV@contoso.com. Supports $filter (eq, startsWith) and $orderby.'
        ),
    ] = None
    user_type: Annotated[
        Optional[Union[SignInUserType, Dict[str, Any]]],
        Field(
            description='Identifies whether the user is a member or guest in the tenant. The possible values are: member, guest, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class UserSolutionRoot(Entity):
    working_time_schedule: Annotated[
        Optional[Union[WorkingTimeSchedule, Dict[str, Any]]],
        Field(
            description='The working time schedule entity associated with the solution.'
        ),
    ] = None
    field_odata_type: str


class UserStorage(Entity):
    quota: Optional[Union[UnifiedStorageQuota, Dict[str, Any]]] = None
    field_odata_type: str


class VerticalSection(Entity):
    emphasis: Annotated[
        Optional[Union[SectionEmphasisType, Dict[str, Any]]],
        Field(
            description='Enumeration value that indicates the emphasis of the section background. The possible values are: none, netural, soft, strong, unknownFutureValue.'
        ),
    ] = None
    webparts: Annotated[
        Optional[List[WebPart]],
        Field(description='The set of web parts in this section.'),
    ] = None
    field_odata_type: str


class VirtualEventRegistrationConfiguration(Entity):
    capacity: Annotated[
        Optional[float],
        Field(
            description='Total capacity of the virtual event.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    registration_web_url: Annotated[
        Optional[str], Field(description='Registration URL of the virtual event.')
    ] = None
    questions: Annotated[
        Optional[List[VirtualEventRegistrationQuestionBase]],
        Field(description='Registration questions.'),
    ] = None
    field_odata_type: str


class VirtualEventRegistrationCustomQuestion(VirtualEventRegistrationQuestionBase):
    answer_choices: Annotated[
        Optional[List[str]],
        Field(
            description='Answer choices when answerInputType is singleChoice or multiChoice.'
        ),
    ] = None
    answer_input_type: Annotated[
        Optional[
            Union[VirtualEventRegistrationQuestionAnswerInputType, Dict[str, Any]]
        ],
        Field(
            description='Input type of the registration question answer. Possible values are text, multilineText, singleChoice, multiChoice, boolean, and unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class VirtualEventRegistrationPredefinedQuestion(VirtualEventRegistrationQuestionBase):
    label: Annotated[
        Optional[
            Union[VirtualEventRegistrationPredefinedQuestionLabel, Dict[str, Any]]
        ],
        Field(
            description='Label of the predefined registration question. It accepts a single line of text: street, city, state, postalCode, countryOrRegion, industry, jobTitle, organization, and unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class VirtualEventWebinarRegistrationConfiguration(
    VirtualEventRegistrationConfiguration
):
    is_manual_approval_enabled: Optional[bool] = None
    is_waitlist_enabled: Optional[bool] = None
    field_odata_type: str


class VppToken(Entity):
    apple_id: Annotated[
        Optional[str],
        Field(
            description='The apple Id associated with the given Apple Volume Purchase Program Token.'
        ),
    ] = None
    automatically_update_apps: Annotated[
        Optional[bool],
        Field(
            description='Whether or not apps for the VPP token will be automatically updated.'
        ),
    ] = None
    country_or_region: Annotated[
        Optional[str],
        Field(
            description='Whether or not apps for the VPP token will be automatically updated.'
        ),
    ] = None
    expiration_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The expiration date time of the Apple Volume Purchase Program Token.',
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Last modification date time associated with the Apple Volume Purchase Program Token.',
        ),
    ] = None
    last_sync_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The last time when an application sync was done with the Apple volume purchase program service using the the Apple Volume Purchase Program Token.',
        ),
    ] = None
    last_sync_status: Optional[VppTokenSyncStatus] = None
    organization_name: Annotated[
        Optional[str],
        Field(
            description='The organization associated with the Apple Volume Purchase Program Token'
        ),
    ] = None
    state: Optional[VppTokenState] = None
    token: Annotated[
        Optional[str],
        Field(
            description='The Apple Volume Purchase Program Token string downloaded from the Apple Volume Purchase Program.'
        ),
    ] = None
    vpp_token_account_type: Optional[VppTokenAccountType] = None
    field_odata_type: str


class WindowsAutopilotDeviceIdentity(Entity):
    addressable_user_name: Annotated[
        Optional[str], Field(description='Addressable user name.')
    ] = None
    azure_active_directory_device_id: Annotated[
        Optional[str], Field(description='AAD Device ID - to be deprecated')
    ] = None
    display_name: Annotated[Optional[str], Field(description='Display Name')] = None
    enrollment_state: Optional[EnrollmentState] = None
    group_tag: Annotated[
        Optional[str], Field(description='Group Tag of the Windows autopilot device.')
    ] = None
    last_contacted_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Intune Last Contacted Date Time of the Windows autopilot device.',
        ),
    ] = None
    managed_device_id: Annotated[
        Optional[str], Field(description='Managed Device ID')
    ] = None
    manufacturer: Annotated[
        Optional[str],
        Field(description='Oem manufacturer of the Windows autopilot device.'),
    ] = None
    model: Annotated[
        Optional[str], Field(description='Model name of the Windows autopilot device.')
    ] = None
    product_key: Annotated[
        Optional[str], Field(description='Product Key of the Windows autopilot device.')
    ] = None
    purchase_order_identifier: Annotated[
        Optional[str],
        Field(description='Purchase Order Identifier of the Windows autopilot device.'),
    ] = None
    resource_name: Annotated[Optional[str], Field(description='Resource Name.')] = None
    serial_number: Annotated[
        Optional[str],
        Field(description='Serial number of the Windows autopilot device.'),
    ] = None
    sku_number: Annotated[Optional[str], Field(description='SKU Number')] = None
    system_family: Annotated[Optional[str], Field(description='System Family')] = None
    user_principal_name: Annotated[
        Optional[str], Field(description='User Principal Name.')
    ] = None
    field_odata_type: str


class WindowsDeviceMalwareState(Entity):
    additional_information_url: Annotated[
        Optional[str],
        Field(description='Information URL to learn more about the malware'),
    ] = None
    category: Annotated[
        Optional[Union[WindowsMalwareCategory, Dict[str, Any]]],
        Field(
            description='Category of the malware. Possible values are: invalid, adware, spyware, passwordStealer, trojanDownloader, worm, backdoor, remoteAccessTrojan, trojan, emailFlooder, keylogger, dialer, monitoringSoftware, browserModifier, cookie, browserPlugin, aolExploit, nuker, securityDisabler, jokeProgram, hostileActiveXControl, softwareBundler, stealthNotifier, settingsModifier, toolBar, remoteControlSoftware, trojanFtp, potentialUnwantedSoftware, icqExploit, trojanTelnet, exploit, filesharingProgram, malwareCreationTool, remoteControlSoftware, tool, trojanDenialOfService, trojanDropper, trojanMassMailer, trojanMonitoringSoftware, trojanProxyServer, virus, known, unknown, spp, behavior, vulnerability, policy, enterpriseUnwantedSoftware, ransom, hipsRule.'
        ),
    ] = None
    detection_count: Annotated[
        Optional[float],
        Field(
            description='Number of times the malware is detected',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    display_name: Annotated[Optional[str], Field(description='Malware name')] = None
    execution_state: Annotated[
        Optional[Union[WindowsMalwareExecutionState, Dict[str, Any]]],
        Field(
            description='Execution status of the malware like blocked/executing etc. Possible values are: unknown, blocked, allowed, running, notRunning.'
        ),
    ] = None
    initial_detection_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Initial detection datetime of the malware',
        ),
    ] = None
    last_state_change_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The last time this particular threat was changed',
        ),
    ] = None
    severity: Annotated[
        Optional[Union[WindowsMalwareSeverity, Dict[str, Any]]],
        Field(
            description='Severity of the malware. Possible values are: unknown, low, moderate, high, severe.'
        ),
    ] = None
    state: Annotated[
        Optional[Union[WindowsMalwareState, Dict[str, Any]]],
        Field(
            description='Current status of the malware like cleaned/quarantined/allowed etc. Possible values are: unknown, detected, cleaned, quarantined, removed, allowed, blocked, cleanFailed, quarantineFailed, removeFailed, allowFailed, abandoned, blockFailed.'
        ),
    ] = None
    threat_state: Annotated[
        Optional[Union[WindowsMalwareThreatState, Dict[str, Any]]],
        Field(
            description='Current status of the malware like cleaned/quarantined/allowed etc. Possible values are: active, actionFailed, manualStepsRequired, fullScanRequired, rebootRequired, remediatedWithNonCriticalFailures, quarantined, removed, cleaned, allowed, noStatusCleared.'
        ),
    ] = None
    field_odata_type: str


class WindowsInformationProtection(ManagedAppPolicy):
    azure_rights_management_services_allowed: Annotated[
        Optional[bool],
        Field(description='Specifies whether to allow Azure RMS encryption for WIP'),
    ] = None
    data_recovery_certificate: Annotated[
        Optional[
            Union[WindowsInformationProtectionDataRecoveryCertificate, Dict[str, Any]]
        ],
        Field(
            description='Specifies a recovery certificate that can be used for data recovery of encrypted files. This is the same as the data recovery agent(DRA) certificate for encrypting file system(EFS)'
        ),
    ] = None
    enforcement_level: Optional[WindowsInformationProtectionEnforcementLevel] = None
    enterprise_domain: Annotated[
        Optional[str], Field(description='Primary enterprise domain')
    ] = None
    enterprise_internal_proxy_servers: Annotated[
        Optional[List[WindowsInformationProtectionResourceCollection]],
        Field(
            description="This is the comma-separated list of internal proxy servers. For example, '157.54.14.28, 157.54.11.118, 10.202.14.167, 157.53.14.163, 157.69.210.59'. These proxies have been configured by the admin to connect to specific resources on the Internet. They are considered to be enterprise network locations. The proxies are only leveraged in configuring the EnterpriseProxiedDomains policy to force traffic to the matched domains through these proxies"
        ),
    ] = None
    enterprise_ip_ranges: Annotated[
        Optional[List[WindowsInformationProtectionIPRangeCollection]],
        Field(
            description='Sets the enterprise IP ranges that define the computers in the enterprise network. Data that comes from those computers will be considered part of the enterprise and protected. These locations will be considered a safe destination for enterprise data to be shared to'
        ),
    ] = None
    enterprise_ip_ranges_are_authoritative: Annotated[
        Optional[bool],
        Field(
            description='Boolean value that tells the client to accept the configured list and not to use heuristics to attempt to find other subnets. Default is false'
        ),
    ] = None
    enterprise_network_domain_names: Annotated[
        Optional[List[WindowsInformationProtectionResourceCollection]],
        Field(
            description='This is the list of domains that comprise the boundaries of the enterprise. Data from one of these domains that is sent to a device will be considered enterprise data and protected These locations will be considered a safe destination for enterprise data to be shared to'
        ),
    ] = None
    enterprise_protected_domain_names: Annotated[
        Optional[List[WindowsInformationProtectionResourceCollection]],
        Field(description='List of enterprise domains to be protected'),
    ] = None
    enterprise_proxied_domains: Annotated[
        Optional[List[WindowsInformationProtectionProxiedDomainCollection]],
        Field(
            description='Contains a list of Enterprise resource domains hosted in the cloud that need to be protected. Connections to these resources are considered enterprise data. If a proxy is paired with a cloud resource, traffic to the cloud resource will be routed through the enterprise network via the denoted proxy server (on Port 80). A proxy server used for this purpose must also be configured using the EnterpriseInternalProxyServers policy'
        ),
    ] = None
    enterprise_proxy_servers: Annotated[
        Optional[List[WindowsInformationProtectionResourceCollection]],
        Field(
            description='This is a list of proxy servers. Any server not on this list is considered non-enterprise'
        ),
    ] = None
    enterprise_proxy_servers_are_authoritative: Annotated[
        Optional[bool],
        Field(
            description='Boolean value that tells the client to accept the configured list of proxies and not try to detect other work proxies. Default is false'
        ),
    ] = None
    exempt_apps: Annotated[
        Optional[List[WindowsInformationProtectionApp]],
        Field(
            description='Exempt applications can also access enterprise data, but the data handled by those applications are not protected. This is because some critical enterprise applications may have compatibility problems with encrypted data.'
        ),
    ] = None
    icons_visible: Annotated[
        Optional[bool],
        Field(
            description='Determines whether overlays are added to icons for WIP protected files in Explorer and enterprise only app tiles in the Start menu. Starting in Windows 10, version 1703 this setting also configures the visibility of the WIP icon in the title bar of a WIP-protected app'
        ),
    ] = None
    indexing_encrypted_stores_or_items_blocked: Annotated[
        Optional[bool],
        Field(
            description='This switch is for the Windows Search Indexer, to allow or disallow indexing of items'
        ),
    ] = None
    is_assigned: Annotated[
        Optional[bool],
        Field(
            description='Indicates if the policy is deployed to any inclusion groups or not.'
        ),
    ] = None
    neutral_domain_resources: Annotated[
        Optional[List[WindowsInformationProtectionResourceCollection]],
        Field(
            description='List of domain names that can used for work or personal resource'
        ),
    ] = None
    protected_apps: Annotated[
        Optional[List[WindowsInformationProtectionApp]],
        Field(
            description='Protected applications can access enterprise data and the data handled by those applications are protected with encryption'
        ),
    ] = None
    protection_under_lock_config_required: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether the protection under lock feature (also known as encrypt under pin) should be configured'
        ),
    ] = None
    revoke_on_unenroll_disabled: Annotated[
        Optional[bool],
        Field(
            description="This policy controls whether to revoke the WIP keys when a device unenrolls from the management service. If set to 1 (Don't revoke keys), the keys will not be revoked and the user will continue to have access to protected files after unenrollment. If the keys are not revoked, there will be no revoked file cleanup subsequently."
        ),
    ] = None
    rights_management_services_template_id: Annotated[
        Optional[UUID],
        Field(
            description='TemplateID GUID to use for RMS encryption. The RMS template allows the IT admin to configure the details about who has access to RMS-protected file and how long they have access',
        ),
    ] = None
    smb_auto_encrypted_file_extensions: Annotated[
        Optional[List[WindowsInformationProtectionResourceCollection]],
        Field(
            description='Specifies a list of file extensions, so that files with these extensions are encrypted when copying from an SMB share within the corporate boundary'
        ),
    ] = None
    assignments: Annotated[
        Optional[List[TargetedManagedAppPolicyAssignment]],
        Field(
            description='Navigation property to list of security groups targeted for policy.'
        ),
    ] = None
    exempt_app_locker_files: Annotated[
        Optional[List[WindowsInformationProtectionAppLockerFile]],
        Field(description='Another way to input exempt apps through xml files'),
    ] = None
    protected_app_locker_files: Annotated[
        Optional[List[WindowsInformationProtectionAppLockerFile]],
        Field(description='Another way to input protected apps through xml files'),
    ] = None
    field_odata_type: str


class WindowsInformationProtectionAppLearningSummary(Entity):
    application_name: Annotated[
        Optional[str], Field(description='Application Name')
    ] = None
    application_type: Optional[ApplicationType] = None
    device_count: Annotated[
        Optional[float],
        Field(description='Device Count', ge=-2147483648.0, le=2147483647.0),
    ] = None
    field_odata_type: str


class WindowsInformationProtectionPolicy(WindowsInformationProtection):
    days_without_contact_before_unenroll: Annotated[
        Optional[float],
        Field(
            description='Offline interval before app data is wiped (days)',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    mdm_enrollment_url: Annotated[
        Optional[str], Field(description='Enrollment url for the MDM')
    ] = None
    minutes_of_inactivity_before_device_lock: Annotated[
        Optional[float],
        Field(
            description='Specifies the maximum amount of time (in minutes) allowed after the device is idle that will cause the device to become PIN or password locked.   Range is an integer X where 0 <= X <= 999.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    number_of_past_pins_remembered: Annotated[
        Optional[float],
        Field(
            description="Integer value that specifies the number of past PINs that can be associated to a user account that can't be reused. The largest number you can configure for this policy setting is 50. The lowest number you can configure for this policy setting is 0. If this policy is set to 0, then storage of previous PINs is not required. This node was added in Windows 10, version 1511. Default is 0.",
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_maximum_attempt_count: Annotated[
        Optional[float],
        Field(
            description='The number of authentication failures allowed before the device will be wiped. A value of 0 disables device wipe functionality. Range is an integer X where 4 <= X <= 16 for desktop and 0 <= X <= 999 for mobile devices.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    pin_expiration_days: Annotated[
        Optional[float],
        Field(
            description="Integer value specifies the period of time (in days) that a PIN can be used before the system requires the user to change it. The largest number you can configure for this policy setting is 730. The lowest number you can configure for this policy setting is 0. If this policy is set to 0, then the user's PIN will never expire. This node was added in Windows 10, version 1511. Default is 0.",
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    pin_lowercase_letters: Optional[
        WindowsInformationProtectionPinCharacterRequirements
    ] = None
    pin_minimum_length: Annotated[
        Optional[float],
        Field(
            description='Integer value that sets the minimum number of characters required for the PIN. Default value is 4. The lowest number you can configure for this policy setting is 4. The largest number you can configure must be less than the number configured in the Maximum PIN length policy setting or the number 127, whichever is the lowest.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    pin_special_characters: Optional[
        WindowsInformationProtectionPinCharacterRequirements
    ] = None
    pin_uppercase_letters: Optional[
        WindowsInformationProtectionPinCharacterRequirements
    ] = None
    revoke_on_mdm_handoff_disabled: Annotated[
        Optional[bool], Field(description='New property in RS2, pending documentation')
    ] = None
    windows_hello_for_business_blocked: Annotated[
        Optional[bool],
        Field(
            description='Boolean value that sets Windows Hello for Business as a method for signing into Windows.'
        ),
    ] = None
    field_odata_type: str


class WindowsMalwareInformation(Entity):
    additional_information_url: Annotated[
        Optional[str],
        Field(
            description='Indicates an informational URL to learn more about the malware'
        ),
    ] = None
    category: Annotated[
        Optional[Union[WindowsMalwareCategory, Dict[str, Any]]],
        Field(
            description='Category of the malware. Possible values are: invalid, adware, spyware, passwordStealer, trojanDownloader, worm, backdoor, remoteAccessTrojan, trojan, emailFlooder, keylogger, dialer, monitoringSoftware, browserModifier, cookie, browserPlugin, aolExploit, nuker, securityDisabler, jokeProgram, hostileActiveXControl, softwareBundler, stealthNotifier, settingsModifier, toolBar, remoteControlSoftware, trojanFtp, potentialUnwantedSoftware, icqExploit, trojanTelnet, exploit, filesharingProgram, malwareCreationTool, remoteControlSoftware, tool, trojanDenialOfService, trojanDropper, trojanMassMailer, trojanMonitoringSoftware, trojanProxyServer, virus, known, unknown, spp, behavior, vulnerability, policy, enterpriseUnwantedSoftware, ransom, hipsRule. default value is invalid. Possible values are: invalid, adware, spyware, passwordStealer, trojanDownloader, worm, backdoor, remoteAccessTrojan, trojan, emailFlooder, keylogger, dialer, monitoringSoftware, browserModifier, cookie, browserPlugin, aolExploit, nuker, securityDisabler, jokeProgram, hostileActiveXControl, softwareBundler, stealthNotifier, settingsModifier, toolBar, remoteControlSoftware, trojanFtp, potentialUnwantedSoftware, icqExploit, trojanTelnet, exploit, filesharingProgram, malwareCreationTool, remoteControlSoftware, tool, trojanDenialOfService, trojanDropper, trojanMassMailer, trojanMonitoringSoftware, trojanProxyServer, virus, known, unknown, spp, behavior, vulnerability, policy, enterpriseUnwantedSoftware, ransom, hipsRule.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='Indicates the name of the malware')
    ] = None
    last_detection_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Indicates the last time the malware was detected in UTC',
        ),
    ] = None
    severity: Annotated[
        Optional[Union[WindowsMalwareSeverity, Dict[str, Any]]],
        Field(
            description='Severity of the malware. Possible values are: unknown, low, moderate, high, severe. default is unknown. Possible values are: unknown, low, moderate, high, severe.'
        ),
    ] = None
    device_malware_states: Annotated[
        Optional[List[MalwareStateForWindowsDevice]],
        Field(
            description='List of devices affected by current malware with the malware state on each device'
        ),
    ] = None
    field_odata_type: str


class WindowsProtectionState(Entity):
    anti_malware_version: Annotated[
        Optional[str], Field(description='Current anti malware version')
    ] = None
    device_state: Annotated[
        Optional[Union[WindowsDeviceHealthState, Dict[str, Any]]],
        Field(
            description="Indicates device's health state. Possible values are: clean, fullScanPending, rebootPending, manualStepsPending, offlineScanPending, critical. Possible values are: clean, fullScanPending, rebootPending, manualStepsPending, offlineScanPending, critical."
        ),
    ] = None
    engine_version: Annotated[
        Optional[str], Field(description="Current endpoint protection engine's version")
    ] = None
    full_scan_overdue: Annotated[
        Optional[bool],
        Field(
            description='When TRUE indicates full scan is overdue, when FALSE indicates full scan is not overdue. Defaults to setting on client device.'
        ),
    ] = None
    full_scan_required: Annotated[
        Optional[bool],
        Field(
            description='When TRUE indicates full scan is required, when FALSE indicates full scan is not required. Defaults to setting on client device.'
        ),
    ] = None
    is_virtual_machine: Annotated[
        Optional[bool],
        Field(
            description='When TRUE indicates the device is a virtual machine, when FALSE indicates the device is not a virtual machine. Defaults to setting on client device.'
        ),
    ] = None
    last_full_scan_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Last quick scan datetime',
        ),
    ] = None
    last_full_scan_signature_version: Annotated[
        Optional[str], Field(description='Last full scan signature version')
    ] = None
    last_quick_scan_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Last quick scan datetime',
        ),
    ] = None
    last_quick_scan_signature_version: Annotated[
        Optional[str], Field(description='Last quick scan signature version')
    ] = None
    last_reported_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Last device health status reported time',
        ),
    ] = None
    malware_protection_enabled: Annotated[
        Optional[bool],
        Field(
            description='When TRUE indicates anti malware is enabled when FALSE indicates anti malware is not enabled.'
        ),
    ] = None
    network_inspection_system_enabled: Annotated[
        Optional[bool],
        Field(
            description='When TRUE indicates network inspection system enabled, when FALSE indicates network inspection system is not enabled. Defaults to setting on client device.'
        ),
    ] = None
    product_status: Annotated[
        Optional[Union[WindowsDefenderProductStatus, Dict[str, Any]]],
        Field(
            description='Product Status of Windows Defender Antivirus. Possible values are: noStatus, serviceNotRunning, serviceStartedWithoutMalwareProtection, pendingFullScanDueToThreatAction, pendingRebootDueToThreatAction, pendingManualStepsDueToThreatAction, avSignaturesOutOfDate, asSignaturesOutOfDate, noQuickScanHappenedForSpecifiedPeriod, noFullScanHappenedForSpecifiedPeriod, systemInitiatedScanInProgress, systemInitiatedCleanInProgress, samplesPendingSubmission, productRunningInEvaluationMode, productRunningInNonGenuineMode, productExpired, offlineScanRequired, serviceShutdownAsPartOfSystemShutdown, threatRemediationFailedCritically, threatRemediationFailedNonCritically, noStatusFlagsSet, platformOutOfDate, platformUpdateInProgress, platformAboutToBeOutdated, signatureOrPlatformEndOfLifeIsPastOrIsImpending, windowsSModeSignaturesInUseOnNonWin10SInstall. Possible values are: noStatus, serviceNotRunning, serviceStartedWithoutMalwareProtection, pendingFullScanDueToThreatAction, pendingRebootDueToThreatAction, pendingManualStepsDueToThreatAction, avSignaturesOutOfDate, asSignaturesOutOfDate, noQuickScanHappenedForSpecifiedPeriod, noFullScanHappenedForSpecifiedPeriod, systemInitiatedScanInProgress, systemInitiatedCleanInProgress, samplesPendingSubmission, productRunningInEvaluationMode, productRunningInNonGenuineMode, productExpired, offlineScanRequired, serviceShutdownAsPartOfSystemShutdown, threatRemediationFailedCritically, threatRemediationFailedNonCritically, noStatusFlagsSet, platformOutOfDate, platformUpdateInProgress, platformAboutToBeOutdated, signatureOrPlatformEndOfLifeIsPastOrIsImpending, windowsSModeSignaturesInUseOnNonWin10SInstall.'
        ),
    ] = None
    quick_scan_overdue: Annotated[
        Optional[bool],
        Field(
            description='When TRUE indicates quick scan is overdue, when FALSE indicates quick scan is not overdue. Defaults to setting on client device.'
        ),
    ] = None
    real_time_protection_enabled: Annotated[
        Optional[bool],
        Field(
            description='When TRUE indicates real time protection is enabled, when FALSE indicates real time protection is not enabled. Defaults to setting on client device.'
        ),
    ] = None
    reboot_required: Annotated[
        Optional[bool],
        Field(
            description='When TRUE indicates reboot is required, when FALSE indicates when TRUE indicates reboot is not required. Defaults to setting on client device.'
        ),
    ] = None
    signature_update_overdue: Annotated[
        Optional[bool],
        Field(
            description='When TRUE indicates signature is out of date, when FALSE indicates signature is not out of date. Defaults to setting on client device.'
        ),
    ] = None
    signature_version: Annotated[
        Optional[str], Field(description='Current malware definitions version')
    ] = None
    tamper_protection_enabled: Annotated[
        Optional[bool],
        Field(
            description='When TRUE indicates the Windows Defender tamper protection feature is enabled, when FALSE indicates the Windows Defender tamper protection feature is not enabled. Defaults to setting on client device.'
        ),
    ] = None
    detected_malware_state: Annotated[
        Optional[List[WindowsDeviceMalwareState]],
        Field(description='Device malware list'),
    ] = None
    field_odata_type: str


class WindowsSetting(Entity):
    payload_type: Annotated[
        Optional[str],
        Field(
            description='The type of setting payloads contained in the instances navigation property.'
        ),
    ] = None
    setting_type: Optional[WindowsSettingType] = None
    windows_device_id: Annotated[
        Optional[str],
        Field(
            description='A unique identifier for the device the setting might belong to if it is of the settingType backup.'
        ),
    ] = None
    instances: Annotated[
        Optional[List[WindowsSettingInstance]],
        Field(description='A collection of setting values for a given windowsSetting.'),
    ] = None
    field_odata_type: str


class WorkbookChartFont(Entity):
    bold: Annotated[
        Optional[bool], Field(description='Indicates whether the fond is bold.')
    ] = None
    color: Annotated[
        Optional[str],
        Field(
            description='The HTML color code representation of the text color. For example #FF0000 represents Red.'
        ),
    ] = None
    italic: Annotated[
        Optional[bool], Field(description='Indicates whether the fond is italic.')
    ] = None
    name: Annotated[
        Optional[str], Field(description="The font name. For example 'Calibri'.")
    ] = None
    size: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='The size of the font. For example,  11.'),
    ] = None
    underline: Annotated[
        Optional[str],
        Field(
            description='The type of underlining applied to the font. The possible values are: None, Single.'
        ),
    ] = None
    field_odata_type: str


class WorkbookChartGridlinesFormat(Entity):
    line: Annotated[
        Optional[Union[WorkbookChartLineFormat, Dict[str, Any]]],
        Field(description='Represents chart line formatting. Read-only.'),
    ] = None
    field_odata_type: str


class WorkbookChartLegendFormat(Entity):
    fill: Annotated[
        Optional[Union[WorkbookChartFill, Dict[str, Any]]],
        Field(
            description='Represents the fill format of an object, which includes background formating information. Read-only.'
        ),
    ] = None
    font: Annotated[
        Optional[Union[WorkbookChartFont, Dict[str, Any]]],
        Field(
            description='Represents the font attributes such as font name, font size, color, etc. of a chart legend. Read-only.'
        ),
    ] = None
    field_odata_type: str


class WorkbookChartPoint(Entity):
    value: Annotated[
        Optional[Any], Field(description='The value of a chart point. Read-only.')
    ] = None
    format: Annotated[
        Optional[Union[WorkbookChartPointFormat, Dict[str, Any]]],
        Field(description='The format properties of the chart point. Read-only.'),
    ] = None
    field_odata_type: str


class WorkbookChartSeries(Entity):
    name: Annotated[
        Optional[str], Field(description='The name of a series in a chart.')
    ] = None
    format: Annotated[
        Optional[Union[WorkbookChartSeriesFormat, Dict[str, Any]]],
        Field(
            description='The formatting of a chart series, which includes fill and line formatting. Read-only.'
        ),
    ] = None
    points: Annotated[
        Optional[List[WorkbookChartPoint]],
        Field(description='A collection of all points in the series. Read-only.'),
    ] = None
    field_odata_type: str


class WorkbookChartTitleFormat(Entity):
    fill: Annotated[
        Optional[Union[WorkbookChartFill, Dict[str, Any]]],
        Field(
            description='Represents the fill format of an object, which includes background formatting information. Read-only.'
        ),
    ] = None
    font: Annotated[
        Optional[Union[WorkbookChartFont, Dict[str, Any]]],
        Field(
            description='Represents the font attributes (font name, font size, color, etc.) for the current object. Read-only.'
        ),
    ] = None
    field_odata_type: str


class WorkbookComment(Entity):
    content: Annotated[
        Optional[str], Field(description='The content of the comment.')
    ] = None
    content_type: Annotated[
        Optional[str], Field(description='The content type of the comment.')
    ] = None
    replies: Annotated[
        Optional[List[WorkbookCommentReply]],
        Field(description='The list of replies to the comment. Read-only. Nullable.'),
    ] = None
    field_odata_type: str


class WorkbookOperation(Entity):
    error: Annotated[
        Optional[Union[WorkbookOperationError, Dict[str, Any]]],
        Field(description='The error returned by the operation.'),
    ] = None
    resource_location: Annotated[
        Optional[str], Field(description='The resource URI for the result.')
    ] = None
    status: Optional[WorkbookOperationStatus] = None
    field_odata_type: str


class WorkbookRangeFont(Entity):
    bold: Annotated[
        Optional[bool], Field(description='Inidicates whether the font is bold.')
    ] = None
    color: Annotated[
        Optional[str],
        Field(
            description='The HTML color code representation of the text color. For example, #FF0000 represents the color red.'
        ),
    ] = None
    italic: Annotated[
        Optional[bool], Field(description='Inidicates whether the font is italic.')
    ] = None
    name: Annotated[
        Optional[str], Field(description="The font name. For example, 'Calibri'.")
    ] = None
    size: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='The font size.'),
    ] = None
    underline: Annotated[
        Optional[str],
        Field(
            description='The type of underlining applied to the font. The possible values are: None, Single, Double, SingleAccountant, DoubleAccountant.'
        ),
    ] = None
    field_odata_type: str


class WorkbookRangeFormat(Entity):
    column_width: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description="The width of all columns within the range. If the column widths aren't uniform, null will be returned."
        ),
    ] = None
    horizontal_alignment: Annotated[
        Optional[str],
        Field(
            description='The horizontal alignment for the specified object. Possible values are: General, Left, Center, Right, Fill, Justify, CenterAcrossSelection, Distributed.'
        ),
    ] = None
    row_height: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description="The height of all rows in the range. If the row heights aren't uniform null will be returned."
        ),
    ] = None
    vertical_alignment: Annotated[
        Optional[str],
        Field(
            description='The vertical alignment for the specified object. Possible values are: Top, Center, Bottom, Justify, Distributed.'
        ),
    ] = None
    wrap_text: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether Excel wraps the text in the object. A null value indicates that the entire range doesn't have a uniform wrap setting."
        ),
    ] = None
    borders: Annotated[
        Optional[List[WorkbookRangeBorder]],
        Field(
            description='Collection of border objects that apply to the overall range selected Read-only.'
        ),
    ] = None
    fill: Annotated[
        Optional[Union[WorkbookRangeFill, Dict[str, Any]]],
        Field(
            description='Returns the fill object defined on the overall range. Read-only.'
        ),
    ] = None
    font: Annotated[
        Optional[Union[WorkbookRangeFont, Dict[str, Any]]],
        Field(
            description='Returns the font object defined on the overall range selected Read-only.'
        ),
    ] = None
    protection: Annotated[
        Optional[Union[WorkbookFormatProtection, Dict[str, Any]]],
        Field(
            description='Returns the format protection object for a range. Read-only.'
        ),
    ] = None
    field_odata_type: str


class WorkbookTableSort(Entity):
    fields: Annotated[
        Optional[List[WorkbookSortField]],
        Field(
            description='The list of the current conditions last used to sort the table. Read-only.'
        ),
    ] = None
    match_case: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the casing impacted the last sort of the table. Read-only.'
        ),
    ] = None
    method: Annotated[
        Optional[str],
        Field(
            description='The Chinese character ordering method last used to sort the table. The possible values are: PinYin, StrokeCount. Read-only.'
        ),
    ] = None
    field_odata_type: str


class WorkbookWorksheetProtection(Entity):
    options: Annotated[
        Optional[Union[WorkbookWorksheetProtectionOptions, Dict[str, Any]]],
        Field(description='Worksheet protection options. Read-only.'),
    ] = None
    protected: Annotated[
        Optional[bool],
        Field(description='Indicates whether the worksheet is protected.  Read-only.'),
    ] = None
    field_odata_type: str


class X509CertificateCombinationConfiguration(AuthenticationCombinationConfiguration):
    allowed_issuer_skis: Annotated[
        Optional[List[str]],
        Field(description='A list of allowed subject key identifier values.'),
    ] = None
    allowed_policy_oi_ds: Annotated[
        Optional[List[str]], Field(description='A list of allowed policy OIDs.')
    ] = None
    field_odata_type: str


class AadUserNotificationRecipient(TeamworkNotificationRecipient):
    user_id: Annotated[
        Optional[str],
        Field(
            description='Microsoft Entra user identifier. Use the List users method to get this ID.'
        ),
    ] = None
    field_odata_type: str


class AcceptJoinResponse(ParticipantJoiningResponse):
    field_odata_type: str


class AccessPackageAnswer(BaseModel):
    display_value: Annotated[
        Optional[str],
        Field(
            description='The localized display value shown to the requestor and approvers.'
        ),
    ] = None
    answered_question: Optional[Union[AccessPackageQuestion, Dict[str, Any]]] = None
    field_odata_type: str


class AccessPackageAnswerChoice(BaseModel):
    actual_value: Annotated[
        Optional[str],
        Field(
            description='The actual value of the selected choice. This is typically a string value which is understandable by applications. Required.'
        ),
    ] = None
    localizations: Annotated[
        Optional[List[AccessPackageLocalizedText]],
        Field(
            description='The text of the answer choice represented in a format for a specific locale.'
        ),
    ] = None
    text: Annotated[
        Optional[str],
        Field(
            description='The string to display for this answer; if an Accept-Language header is provided, and there is a matching localization in localizations, this string will be the matching localized string; otherwise, this string remains as the default non-localized string. Required.'
        ),
    ] = None
    field_odata_type: str


class AccessPackageAnswerString(AccessPackageAnswer):
    value: Annotated[
        Optional[str],
        Field(
            description="The value stored on the requestor's user profile, if this answer is configured to be stored as a specific attribute."
        ),
    ] = None
    field_odata_type: str


class AccessPackageApprovalStage(BaseModel):
    duration_before_automatic_denial: Annotated[
        Optional[timedelta],
        Field(
            description='The number of days that a request can be pending a response before it is automatically denied.',
        ),
    ] = None
    duration_before_escalation: Annotated[
        Optional[timedelta],
        Field(
            description='If escalation is required, the time a request can be pending a response from a primary approver.',
        ),
    ] = None
    escalation_approvers: Annotated[
        Optional[List[SubjectSet]],
        Field(
            description='If escalation is enabled and the primary approvers do not respond before the escalation time, the escalationApprovers are the users who will be asked to approve requests.'
        ),
    ] = None
    fallback_escalation_approvers: Annotated[
        Optional[List[SubjectSet]],
        Field(
            description='The subjects, typically users, who are the fallback escalation approvers.'
        ),
    ] = None
    fallback_primary_approvers: Annotated[
        Optional[List[SubjectSet]],
        Field(
            description='The subjects, typically users, who are the fallback primary approvers.'
        ),
    ] = None
    is_approver_justification_required: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the approver is required to provide a justification for approving a request.'
        ),
    ] = None
    is_escalation_enabled: Annotated[
        Optional[bool],
        Field(
            description='If true, then one or more escalationApprovers are configured in this approval stage.'
        ),
    ] = None
    primary_approvers: Annotated[
        Optional[List[SubjectSet]],
        Field(
            description='The subjects, typically users, who will be asked to approve requests. A collection of singleUser, groupMembers, requestorManager, internalSponsors, externalSponsors, or targetUserSponsors.'
        ),
    ] = None
    field_odata_type: str


class AccessPackageAssignmentApprovalSettings(BaseModel):
    is_approval_required_for_add: Annotated[
        Optional[bool],
        Field(
            description="If false, then approval isn't required for new requests in this policy."
        ),
    ] = None
    is_approval_required_for_update: Annotated[
        Optional[bool],
        Field(
            description="If false, then approval isn't required for updates to requests in this policy."
        ),
    ] = None
    stages: Annotated[
        Optional[List[AccessPackageApprovalStage]],
        Field(
            description='If approval is required, the one, two or three elements of this collection define each of the stages of approval. An empty array is present if no approval is required.'
        ),
    ] = None
    field_odata_type: str


class AccessPackageAssignmentRequestCallbackData(CustomExtensionData):
    custom_extension_stage_instance_detail: Annotated[
        Optional[str], Field(description='Details for the callback.')
    ] = None
    custom_extension_stage_instance_id: Annotated[
        Optional[str],
        Field(description='Unique identifier of the callout to the custom extension.'),
    ] = None
    stage: Annotated[
        Optional[Union[AccessPackageCustomExtensionStage, Dict[str, Any]]],
        Field(
            description='Indicates the stage at which the custom callout extension is executed. The possible values are: assignmentRequestCreated, assignmentRequestApproved, assignmentRequestGranted, assignmentRequestRemoved, assignmentFourteenDaysBeforeExpiration, assignmentOneDayBeforeExpiration, unknownFutureValue.'
        ),
    ] = None
    state: Annotated[
        Optional[str],
        Field(
            description='Allow the extension to be able to deny or cancel the request submitted by the requestor. The supported values are Denied and Canceled. This property can only be set for an assignmentRequestCreated stage.'
        ),
    ] = None
    field_odata_type: str


class AccessPackageAssignmentRequestorSettings(BaseModel):
    allow_custom_assignment_schedule: Annotated[
        Optional[bool],
        Field(
            description="False indicates that the requestor isn't permitted to include a schedule in their request."
        ),
    ] = None
    enable_on_behalf_requestors_to_add_access: Annotated[
        Optional[bool],
        Field(
            description='True allows on-behalf-of requestors to create a request to add access for another principal.'
        ),
    ] = None
    enable_on_behalf_requestors_to_remove_access: Annotated[
        Optional[bool],
        Field(
            description='True allows on-behalf-of requestors to create a request to remove access for another principal.'
        ),
    ] = None
    enable_on_behalf_requestors_to_update_access: Annotated[
        Optional[bool],
        Field(
            description='True allows on-behalf-of requestors to create a request to update access for another principal.'
        ),
    ] = None
    enable_targets_to_self_add_access: Annotated[
        Optional[bool],
        Field(
            description='True allows requestors to create a request to add access for themselves.'
        ),
    ] = None
    enable_targets_to_self_remove_access: Annotated[
        Optional[bool],
        Field(
            description='True allows requestors to create a request to remove their access.'
        ),
    ] = None
    enable_targets_to_self_update_access: Annotated[
        Optional[bool],
        Field(
            description='True allows requestors to create a request to update their access.'
        ),
    ] = None
    on_behalf_requestors: Annotated[
        Optional[List[SubjectSet]],
        Field(description='The principals who can request on-behalf-of others.'),
    ] = None
    field_odata_type: str


class AccessPackageResourceAttribute(BaseModel):
    destination: Annotated[
        Optional[Union[AccessPackageResourceAttributeDestination, Dict[str, Any]]],
        Field(
            description='Information about how to set the attribute, currently a accessPackageUserDirectoryAttributeStore type.'
        ),
    ] = None
    is_editable: Optional[bool] = None
    is_persisted_on_assignment_removal: Optional[bool] = None
    name: Annotated[
        Optional[str],
        Field(
            description='The name of the attribute in the end system. If the destination is accessPackageUserDirectoryAttributeStore, then a user property such as jobTitle or a directory schema extension for the user object type, such as extension2b676109c7c74ae2b41549205f1947edpersonalTitle.'
        ),
    ] = None
    source: Annotated[
        Optional[Union[AccessPackageResourceAttributeSource, Dict[str, Any]]],
        Field(
            description='Information about how to populate the attribute value when an accessPackageAssignmentRequest is being fulfilled, currently a accessPackageResourceAttributeQuestion type.'
        ),
    ] = None
    field_odata_type: str


class AccessPackageResourceAttributeQuestion(AccessPackageResourceAttributeSource):
    question: Optional[Union[AccessPackageQuestion, Dict[str, Any]]] = None
    field_odata_type: str


class AccessReviewInstanceDecisionItemAccessPackageAssignmentPolicyResource(
    AccessReviewInstanceDecisionItemResource
):
    access_package_display_name: Annotated[
        Optional[str],
        Field(
            description='Display name of the access package to which access has been granted.'
        ),
    ] = None
    access_package_id: Annotated[
        Optional[str],
        Field(
            description='Identifier of the access package to which access has been granted.'
        ),
    ] = None
    field_odata_type: str


class AccessReviewInstanceDecisionItemAzureRoleResource(
    AccessReviewInstanceDecisionItemResource
):
    scope: Annotated[
        Optional[Union[AccessReviewInstanceDecisionItemResource, Dict[str, Any]]],
        Field(description='Details of the scope this role is associated with.'),
    ] = None
    field_odata_type: str


class AccessReviewNotificationRecipientItem(BaseModel):
    notification_recipient_scope: Annotated[
        Optional[Union[AccessReviewNotificationRecipientScope, Dict[str, Any]]],
        Field(description='Determines the recipient of the notification email.'),
    ] = None
    notification_template_type: Annotated[
        Optional[str],
        Field(
            description='Indicates the type of access review email to be sent. Supported template type is CompletedAdditionalRecipients, which sends review completion notifications to the recipients.'
        ),
    ] = None
    field_odata_type: str


class AccessReviewNotificationRecipientQueryScope(
    AccessReviewNotificationRecipientScope
):
    query: Annotated[
        Optional[str],
        Field(
            description='Represents the query for who the recipients are. For example, /groups/{group id}/members for group members and /users/{user id} for a specific user.'
        ),
    ] = None
    query_root: Annotated[
        Optional[str],
        Field(
            description='In the scenario where reviewers need to be specified dynamically, indicates the relative source of the query. This property is only required if a relative query (that is, ./manager) is specified.'
        ),
    ] = None
    query_type: Annotated[
        Optional[str],
        Field(
            description='Indicates the type of query. Allowed value is MicrosoftGraph.'
        ),
    ] = None
    field_odata_type: str


class AccessReviewQueryScope(AccessReviewScope):
    query: Annotated[
        Optional[str],
        Field(
            description='The query representing what will be reviewed in an access review.'
        ),
    ] = None
    query_root: Annotated[
        Optional[str],
        Field(
            description='In the scenario where reviewers need to be specified dynamically, this property is used to indicate the relative source of the query. This property is only required if a relative query is specified. For example, ./manager.'
        ),
    ] = None
    query_type: Annotated[
        Optional[str],
        Field(
            description='Indicates the type of query. Types include MicrosoftGraph and ARM.'
        ),
    ] = None
    field_odata_type: str


class AccountTargetContent(BaseModel):
    type: Annotated[
        Optional[Union[AccountTargetContentType, Dict[str, Any]]],
        Field(
            description='The type of account target content. Possible values are: unknown, includeAll, addressBook, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class AddIn(BaseModel):
    id: Annotated[
        Optional[UUID],
        Field(
            description='The unique identifier for the addIn object.',
        ),
    ] = None
    properties: Annotated[
        Optional[List[KeyValue]],
        Field(
            description='The collection of key-value pairs that define parameters that the consuming service can use or call. You must specify this property when performing a POST or a PATCH operation on the addIns collection. Required.'
        ),
    ] = None
    type: Annotated[
        Optional[str],
        Field(description='The unique name for the functionality exposed by the app.'),
    ] = None
    field_odata_type: str


class AddressBookAccountTargetContent(AccountTargetContent):
    account_target_emails: Annotated[
        Optional[List[str]],
        Field(
            description='List of user emails targeted for an attack simulation training campaign.'
        ),
    ] = None
    field_odata_type: str


class AlertHistoryState(BaseModel):
    app_id: Optional[str] = None
    assigned_to: Optional[str] = None
    comments: Optional[List[str]] = None
    feedback: Optional[Union[AlertFeedback, Dict[str, Any]]] = None
    status: Optional[Union[AlertStatus, Dict[str, Any]]] = None
    updated_date_time: Annotated[
        Optional[datetime],
        Field(
        ),
    ] = None
    user: Optional[str] = None
    field_odata_type: str


class AllDeviceRegistrationMembership(DeviceRegistrationMembership):
    field_odata_type: str


class AllDevicesAssignmentTarget(DeviceAndAppManagementAssignmentTarget):
    field_odata_type: str


class AllLicensedUsersAssignmentTarget(DeviceAndAppManagementAssignmentTarget):
    field_odata_type: str


class AlterationResponse(BaseModel):
    original_query_string: Annotated[
        Optional[str], Field(description='Defines the original user query string.')
    ] = None
    query_alteration: Annotated[
        Optional[Union[SearchAlteration, Dict[str, Any]]],
        Field(
            description='Defines the details of the alteration information for the spelling correction.'
        ),
    ] = None
    query_alteration_type: Annotated[
        Optional[Union[SearchAlterationType, Dict[str, Any]]],
        Field(
            description='Defines the type of the spelling correction. Possible values are: suggestion, modification.'
        ),
    ] = None
    field_odata_type: str


class AndroidMobileAppIdentifier(MobileAppIdentifier):
    package_id: Annotated[
        Optional[str],
        Field(description='The identifier for an app, as specified in the play store.'),
    ] = None
    field_odata_type: str


class ApiApplication(BaseModel):
    accept_mapped_claims: Annotated[
        Optional[bool],
        Field(
            description='When true, allows an application to use claims mapping without specifying a custom signing key.'
        ),
    ] = None
    known_client_applications: Annotated[
        Optional[List[KnownClientApplication]],
        Field(
            description='Used for bundling consent if you have a solution that contains two parts: a client app and a custom web API app. If you set the appID of the client app to this value, the user only consents once to the client app. Microsoft Entra ID knows that consenting to the client means implicitly consenting to the web API and automatically provisions service principals for both APIs at the same time. Both the client and the web API app must be registered in the same tenant.'
        ),
    ] = None
    oauth2_permission_scopes: Annotated[
        Optional[List[PermissionScope]],
        Field(
            description='The definition of the delegated permissions exposed by the web API represented by this application registration. These delegated permissions may be requested by a client application, and may be granted by users or administrators during consent. Delegated permissions are sometimes referred to as OAuth 2.0 scopes.'
        ),
    ] = None
    pre_authorized_applications: Annotated[
        Optional[List[PreAuthorizedApplication]],
        Field(
            description="Lists the client applications that are preauthorized with the specified delegated permissions to access this application's APIs. Users aren't required to consent to any preauthorized application (for the permissions specified). However, any other permissions not listed in preAuthorizedApplications (requested through incremental consent for example) will require user consent."
        ),
    ] = None
    requested_access_token_version: Annotated[
        Optional[float],
        Field(
            description='Specifies the access token version expected by this resource. This changes the version and format of the JWT produced independent of the endpoint or client used to request the access token.  The endpoint used, v1.0 or v2.0, is chosen by the client and only impacts the version of id_tokens. Resources need to explicitly configure requestedAccessTokenVersion to indicate the supported access token format.  Possible values for requestedAccessTokenVersion are 1, 2, or null. If the value is null, this defaults to 1, which corresponds to the v1.0 endpoint.  If signInAudience on the application is configured as AzureADandPersonalMicrosoftAccount or PersonalMicrosoftAccount, the value for this property must be 2.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class AppConfigurationSettingItem(BaseModel):
    app_config_key: Annotated[
        Optional[str], Field(description='app configuration key.')
    ] = None
    app_config_key_type: Optional[MdmAppConfigKeyType] = None
    app_config_key_value: Annotated[
        Optional[str], Field(description='app configuration key value.')
    ] = None
    field_odata_type: str


class AppHostedMediaConfig(MediaConfig):
    blob: Annotated[
        Optional[str],
        Field(
            description='The media configuration blob generated by smart media agent.'
        ),
    ] = None
    field_odata_type: str


class ApplicationEnforcedRestrictionsSessionControl(ConditionalAccessSessionControl):
    field_odata_type: str


class AppliedConditionalAccessPolicy(BaseModel):
    display_name: Annotated[
        Optional[str],
        Field(
            description="Refers to the name of the conditional access policy (example: 'Require MFA for Salesforce')."
        ),
    ] = None
    enforced_grant_controls: Annotated[
        Optional[List[str]],
        Field(
            description="Refers to the grant controls enforced by the conditional access policy (example: 'Require multifactor authentication')."
        ),
    ] = None
    enforced_session_controls: Annotated[
        Optional[List[str]],
        Field(
            description="Refers to the session controls enforced by the conditional access policy (example: 'Require app enforced controls')."
        ),
    ] = None
    id: Annotated[
        Optional[str],
        Field(
            description='An identifier of the conditional access policy. Supports $filter (eq).'
        ),
    ] = None
    result: Annotated[
        Optional[Union[AppliedConditionalAccessPolicyResult, Dict[str, Any]]],
        Field(
            description="Indicates the result of the CA policy that was triggered. Possible values are: success, failure, notApplied (policy isn't applied because policy conditions weren't met), notEnabled (This is due to the policy in a disabled state), unknown, unknownFutureValue, reportOnlySuccess, reportOnlyFailure, reportOnlyNotApplied, reportOnlyInterrupted. Use the Prefer: include-unknown-enum-members request header to get the following values in this evolvable enum: reportOnlySuccess, reportOnlyFailure, reportOnlyNotApplied, reportOnlyInterrupted."
        ),
    ] = None
    field_odata_type: str


class AppLogCollectionDownloadDetails(BaseModel):
    app_log_decryption_algorithm: Optional[AppLogDecryptionAlgorithm] = None
    decryption_key: Annotated[
        Optional[str], Field(description='Decryption key that used to decrypt the log.')
    ] = None
    download_url: Annotated[
        Optional[str],
        Field(
            description='Download SAS (Shared Access Signature) Url for completed app log request.'
        ),
    ] = None
    field_odata_type: str


class ApprovalSettings(BaseModel):
    approval_mode: Annotated[
        Optional[str],
        Field(
            description='One of SingleStage, Serial, Parallel, NoApproval (default). NoApproval is used when isApprovalRequired is false.'
        ),
    ] = None
    approval_stages: Annotated[
        Optional[List[UnifiedApprovalStage]],
        Field(
            description='If approval is required, the one or two elements of this collection define each of the stages of approval. An empty array if no approval is required.'
        ),
    ] = None
    is_approval_required: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether approval is required for requests in this policy.'
        ),
    ] = None
    is_approval_required_for_extension: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether approval is required for a user to extend their assignment.'
        ),
    ] = None
    is_requestor_justification_required: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the requestor is required to supply a justification in their request.'
        ),
    ] = None
    field_odata_type: str


class ArchivedPrintJob(BaseModel):
    acquired_by_printer: Annotated[
        Optional[bool],
        Field(
            description='True if the job was acquired by a printer; false otherwise. Read-only.'
        ),
    ] = None
    acquired_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The dateTimeOffset when the job was acquired by the printer, if any. Read-only.',
        ),
    ] = None
    completion_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The dateTimeOffset when the job was completed, canceled, or aborted. Read-only.',
        ),
    ] = None
    copies_printed: Annotated[
        Optional[float],
        Field(
            description='The number of copies that were printed. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    created_by: Annotated[
        Optional[Union[UserIdentity, Dict[str, Any]]],
        Field(description='The user who created the print job. Read-only.'),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The dateTimeOffset when the job was created. Read-only.',
        ),
    ] = None
    id: Annotated[
        Optional[str], Field(description="The archived print job's GUID. Read-only.")
    ] = None
    printer_id: Annotated[
        Optional[str],
        Field(description='The printer ID that the job was queued for. Read-only.'),
    ] = None
    printer_name: Annotated[
        Optional[str],
        Field(description='The printer name that the job was queued for. Read-only.'),
    ] = None
    processing_state: Optional[PrintJobProcessingState] = None
    field_odata_type: str


class ArtifactQuery(BaseModel):
    artifact_type: Annotated[
        Optional[Union[RestorableArtifact, Dict[str, Any]]],
        Field(
            description='The type of artifact to search. The possible values are: message, unknownFutureValue.'
        ),
    ] = None
    query_expression: Annotated[
        Optional[str], Field(description='Specifies criteria to retrieve artifacts.')
    ] = None
    field_odata_type: str


class AttachmentInfo(BaseModel):
    attachment_type: Annotated[
        Optional[Union[AttachmentType, Dict[str, Any]]],
        Field(
            description='The type of the attachment. The possible values are: file, item, reference. Required.'
        ),
    ] = None
    content_type: Annotated[
        Optional[str],
        Field(description='The nature of the data in the attachment. Optional.'),
    ] = None
    name: Annotated[
        Optional[str],
        Field(
            description="The display name of the attachment. This can be a descriptive string and doesn't have to be the actual file name. Required."
        ),
    ] = None
    size: Annotated[
        Optional[float],
        Field(description='The length of the attachment in bytes. Required.'),
    ] = None
    field_odata_type: str


class AttachmentItem(BaseModel):
    attachment_type: Annotated[
        Optional[Union[AttachmentType, Dict[str, Any]]],
        Field(
            description='The type of attachment. Possible values are: file, item, reference. Required.'
        ),
    ] = None
    content_id: Annotated[
        Optional[str],
        Field(
            description="The CID or Content-Id of the attachment for referencing for the in-line attachments using the <img src='cid:contentId'> tag in HTML messages. Optional."
        ),
    ] = None
    content_type: Annotated[
        Optional[str],
        Field(description='The nature of the data in the attachment. Optional.'),
    ] = None
    is_inline: Annotated[
        Optional[bool],
        Field(
            description='true if the attachment is an inline attachment; otherwise, false. Optional.'
        ),
    ] = None
    name: Annotated[
        Optional[str],
        Field(
            description="The display name of the attachment. This can be a descriptive string and doesn't have to be the actual file name. Required."
        ),
    ] = None
    size: Annotated[
        Optional[float],
        Field(description='The length of the attachment in bytes. Required.'),
    ] = None
    field_odata_type: str


class AttackSimulationRepeatOffender(BaseModel):
    attack_simulation_user: Annotated[
        Optional[Union[AttackSimulationUser, Dict[str, Any]]],
        Field(description='The user in an attack simulation and training campaign.'),
    ] = None
    repeat_offence_count: Annotated[
        Optional[float],
        Field(
            description='Number of repeat offences of the user in attack simulation and training campaigns.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class AttackSimulationSimulationUserCoverage(BaseModel):
    attack_simulation_user: Annotated[
        Optional[Union[AttackSimulationUser, Dict[str, Any]]],
        Field(description='User in an attack simulation and training campaign.'),
    ] = None
    click_count: Annotated[
        Optional[float],
        Field(
            description='Number of link clicks in the received payloads by the user in attack simulation and training campaigns.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    compromised_count: Annotated[
        Optional[float],
        Field(
            description='Number of compromising actions by the user in attack simulation and training campaigns.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    latest_simulation_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time of the latest attack simulation and training campaign that the user was included in.',
        ),
    ] = None
    simulation_count: Annotated[
        Optional[float],
        Field(
            description='Number of attack simulation and training campaigns that the user was included in.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class AttendeeBase(Recipient):
    type: Annotated[
        Optional[Union[AttendeeType, Dict[str, Any]]],
        Field(
            description='The type of attendee. The possible values are: required, optional, resource. Currently if the attendee is a person, findMeetingTimes always considers the person is of the Required type.'
        ),
    ] = None
    field_odata_type: str


class AttributeDefinitionMetadataEntry(BaseModel):
    key: Annotated[
        Optional[Union[AttributeDefinitionMetadata, Dict[str, Any]]],
        Field(
            description='Possible values are: BaseAttributeName, ComplexObjectDefinition, IsContainer, IsCustomerDefined, IsDomainQualified, LinkPropertyNames, LinkTypeName, MaximumLength, ReferencedProperty.'
        ),
    ] = None
    value: Annotated[
        Optional[str], Field(description='Value of the metadata property.')
    ] = None
    field_odata_type: str


class AttributeMappingParameterSchema(BaseModel):
    allow_multiple_occurrences: Annotated[
        Optional[bool],
        Field(
            description='The given parameter can be provided multiple times (for example, multiple input strings in the Concatenate(string,string,...) function).'
        ),
    ] = None
    name: Annotated[Optional[str], Field(description='Parameter name.')] = None
    required: Annotated[
        Optional[bool],
        Field(description='true if the parameter is required; otherwise false.'),
    ] = None
    type: Optional[AttributeType] = None
    field_odata_type: str


class AttributeRuleMembers(SubjectSet):
    description: Annotated[
        Optional[str], Field(description='A description of the membership rule.')
    ] = None
    membership_rule: Annotated[
        Optional[str],
        Field(
            description='Determines the allowed target users for this policy. For more information about the syntax of the membership rule, see Membership Rules syntax.'
        ),
    ] = None
    field_odata_type: str


class AuditActivityInitiator(BaseModel):
    app: Annotated[
        Optional[Union[AppIdentity, Dict[str, Any]]],
        Field(
            description='If the resource initiating the activity is an app, this property indicates all the app related information like appId, Name, servicePrincipalId, Name.'
        ),
    ] = None
    user: Annotated[
        Optional[Union[UserIdentity, Dict[str, Any]]],
        Field(
            description='If the resource initiating the activity is a user, this property Indicates all the user related information like userId, Name, UserPrinicpalName.'
        ),
    ] = None
    field_odata_type: str


class AuthenticationAttributeCollectionInputConfiguration(BaseModel):
    attribute: Annotated[
        Optional[str],
        Field(
            description='The built-in or custom attribute for which a value is being collected.'
        ),
    ] = None
    default_value: Annotated[
        Optional[str],
        Field(
            description="The default value of the attribute displayed to the end user. The capability to set the default value isn't available through the Microsoft Entra admin center."
        ),
    ] = None
    editable: Annotated[
        Optional[bool],
        Field(description='Defines whether the attribute is editable by the end user.'),
    ] = None
    hidden: Annotated[
        Optional[bool],
        Field(
            description="Defines whether the attribute is displayed to the end user. The capability to hide isn't available through the Microsoft Entra admin center."
        ),
    ] = None
    input_type: Optional[AuthenticationAttributeCollectionInputType] = None
    label: Annotated[
        Optional[str],
        Field(
            description="The label of the attribute field that's displayed to end user, unless overridden."
        ),
    ] = None
    options: Annotated[
        Optional[List[AuthenticationAttributeCollectionOptionConfiguration]],
        Field(description='The option values for certain multiple-option input types.'),
    ] = None
    required: Annotated[
        Optional[bool], Field(description='Defines whether the field is required.')
    ] = None
    validation_reg_ex: Annotated[
        Optional[str],
        Field(
            description='The regex for the value of the field. For more information about the supported regexes, see validationRegEx values for inputType objects. To understand how to specify regexes, see the Regular expressions cheat sheet.'
        ),
    ] = None
    write_to_directory: Annotated[
        Optional[bool],
        Field(
            description='Defines whether Microsoft Entra ID stores the value that it collects.'
        ),
    ] = None
    field_odata_type: str


class AuthenticationAttributeCollectionPageViewConfiguration(BaseModel):
    description: Annotated[
        Optional[str], Field(description='The description of the page.')
    ] = None
    inputs: Annotated[
        Optional[List[AuthenticationAttributeCollectionInputConfiguration]],
        Field(
            description="The display configuration of attributes being collected on the attribute collection page. You must specify all attributes that you want to retain, otherwise they're removed from the user flow."
        ),
    ] = None
    title: Annotated[
        Optional[str], Field(description='The title of the attribute collection page.')
    ] = None
    field_odata_type: str


class AuthenticationConditions(BaseModel):
    applications: Annotated[
        Optional[Union[AuthenticationConditionsApplications, Dict[str, Any]]],
        Field(
            description='Applications which trigger a custom authentication extension.'
        ),
    ] = None
    field_odata_type: str


class AuthenticationConfigurationValidation(BaseModel):
    errors: Annotated[
        Optional[List[GenericError]],
        Field(
            description='Errors in the validation result of a customAuthenticationExtension.'
        ),
    ] = None
    warnings: Annotated[
        Optional[List[GenericError]],
        Field(
            description='Warnings in the validation result of a customAuthenticationExtension.'
        ),
    ] = None
    field_odata_type: str


class AuthenticationMethodsRegistrationCampaignIncludeTarget(BaseModel):
    id: Annotated[
        Optional[str],
        Field(description='The object identifier of a Microsoft Entra user or group.'),
    ] = None
    targeted_authentication_method: Annotated[
        Optional[str],
        Field(
            description='The authentication method that the user is prompted to register. The value must be microsoftAuthenticator.'
        ),
    ] = None
    target_type: Optional[AuthenticationMethodTargetType] = None
    field_odata_type: str


class AutomaticRepliesMailTips(BaseModel):
    message: Annotated[
        Optional[str], Field(description='The automatic reply message.')
    ] = None
    message_language: Annotated[
        Optional[Union[LocaleInfo, Dict[str, Any]]],
        Field(description='The language that the automatic reply message is in.'),
    ] = None
    scheduled_end_time: Annotated[
        Optional[Union[DateTimeTimeZone, Dict[str, Any]]],
        Field(description='The date and time that automatic replies are set to end.'),
    ] = None
    scheduled_start_time: Annotated[
        Optional[Union[DateTimeTimeZone, Dict[str, Any]]],
        Field(description='The date and time that automatic replies are set to begin.'),
    ] = None
    field_odata_type: str


class AutomaticRepliesSetting(BaseModel):
    external_audience: Annotated[
        Optional[Union[ExternalAudienceScope, Dict[str, Any]]],
        Field(
            description="The set of audience external to the signed-in user's organization who will receive the ExternalReplyMessage, if Status is AlwaysEnabled or Scheduled. The possible values are: none, contactsOnly, all."
        ),
    ] = None
    external_reply_message: Annotated[
        Optional[str],
        Field(
            description='The automatic reply to send to the specified external audience, if Status is AlwaysEnabled or Scheduled.'
        ),
    ] = None
    internal_reply_message: Annotated[
        Optional[str],
        Field(
            description="The automatic reply to send to the audience internal to the signed-in user's organization, if Status is AlwaysEnabled or Scheduled."
        ),
    ] = None
    scheduled_end_date_time: Annotated[
        Optional[Union[DateTimeTimeZone, Dict[str, Any]]],
        Field(
            description='The date and time that automatic replies are set to end, if Status is set to Scheduled.'
        ),
    ] = None
    scheduled_start_date_time: Annotated[
        Optional[Union[DateTimeTimeZone, Dict[str, Any]]],
        Field(
            description='The date and time that automatic replies are set to begin, if Status is set to Scheduled.'
        ),
    ] = None
    status: Annotated[
        Optional[Union[AutomaticRepliesStatus, Dict[str, Any]]],
        Field(
            description='Configurations status for automatic replies. The possible values are: disabled, alwaysEnabled, scheduled.'
        ),
    ] = None
    field_odata_type: str


class AvailabilityItem(BaseModel):
    end_date_time: Optional[DateTimeTimeZone] = None
    service_id: Annotated[
        Optional[str],
        Field(
            description='Indicates the service ID for 1:n appointments. If the appointment is of type 1:n, this field is present, otherwise, null.'
        ),
    ] = None
    start_date_time: Optional[DateTimeTimeZone] = None
    status: Annotated[
        Optional[Union[BookingsAvailabilityStatus, Dict[str, Any]]],
        Field(
            description='The status of the staff member. Possible values are: available, busy, slotsAvailable, outOfOffice, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class AverageComparativeScore(BaseModel):
    average_score: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='Average score within specified basis.'),
    ] = None
    basis: Annotated[
        Optional[str],
        Field(
            description='Scope type. The possible values are: AllTenants, TotalSeats, IndustryTypes.'
        ),
    ] = None
    field_odata_type: str


class AzureActiveDirectoryTenant(IdentitySource):
    display_name: Annotated[
        Optional[str],
        Field(description='The name of the Microsoft Entra tenant. Read only.'),
    ] = None
    tenant_id: Annotated[
        Optional[str],
        Field(description='The ID of the Microsoft Entra tenant. Read only.'),
    ] = None
    field_odata_type: str


class AzureADJoinPolicy(BaseModel):
    allowed_to_join: Optional[Union[DeviceRegistrationMembership, Dict[str, Any]]] = (
        None
    )
    is_admin_configurable: Optional[bool] = None
    field_odata_type: str


class AzureAdPopTokenAuthentication(CustomExtensionAuthenticationConfiguration):
    field_odata_type: str


class AzureADRegistrationPolicy(BaseModel):
    allowed_to_register: Optional[
        Union[DeviceRegistrationMembership, Dict[str, Any]]
    ] = None
    is_admin_configurable: Optional[bool] = None
    field_odata_type: str


class AzureAdTokenAuthentication(CustomExtensionAuthenticationConfiguration):
    resource_id: Annotated[
        Optional[str],
        Field(
            description='The appID of the Microsoft Entra application to use to authenticate an app with a custom extension.'
        ),
    ] = None
    field_odata_type: str


class AzureCommunicationServicesUserIdentity(Identity):
    azure_communication_services_resource_id: Annotated[
        Optional[str],
        Field(
            description='The Azure Communication Services resource ID associated with the user.'
        ),
    ] = None
    field_odata_type: str


class BitLockerRemovableDrivePolicy(BaseModel):
    block_cross_organization_write_access: Annotated[
        Optional[bool],
        Field(
            description='This policy setting determines whether BitLocker protection is required for removable data drives to be writable on a computer.'
        ),
    ] = None
    encryption_method: Annotated[
        Optional[Union[BitLockerEncryptionMethod, Dict[str, Any]]],
        Field(
            description='Select the encryption method for removable  drives. Possible values are: aesCbc128, aesCbc256, xtsAes128, xtsAes256.'
        ),
    ] = None
    require_encryption_for_write_access: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether to block write access to devices configured in another organization.  If requireEncryptionForWriteAccess is false, this value does not affect.'
        ),
    ] = None
    field_odata_type: str


class BookingPageSettings(BaseModel):
    access_control: Optional[BookingPageAccessControl] = None
    booking_page_color_code: Annotated[
        Optional[str],
        Field(
            description='Custom color for the booking page. The value should be in Hex format. For example, #123456.'
        ),
    ] = None
    business_time_zone: Annotated[
        Optional[str],
        Field(
            description='The time zone of the customer. For a list of possible values, see dateTimeTimeZone.'
        ),
    ] = None
    customer_consent_message: Annotated[
        Optional[str],
        Field(
            description='The personal data collection and usage consent message in the booking page.'
        ),
    ] = None
    enforce_one_time_password: Annotated[
        Optional[bool],
        Field(
            description='Determines whether the one-time password is required to create an appointment. The default value is false.'
        ),
    ] = None
    is_business_logo_display_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the business logo is displayed on the booking page. The default value is false.'
        ),
    ] = None
    is_customer_consent_enabled: Annotated[
        Optional[bool],
        Field(
            description='Enables personal data collection and the usage consent toggle on the booking page. The default value is false.'
        ),
    ] = None
    is_search_engine_indexability_disabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether web crawlers index this page. The defaults value is false.'
        ),
    ] = None
    is_time_slot_time_zone_set_to_business_time_zone: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the time zone of the time slot is set to the time zone of the business. The default value is false.'
        ),
    ] = None
    privacy_policy_web_url: Annotated[
        Optional[str],
        Field(
            description="URL of a webpage that provides the terms and conditions of the business. If a privacy policy isn't included, the following text appears on the booking page as default: 'The policies and practices of {bookingbusinessname} apply to the use of your data.'"
        ),
    ] = None
    terms_and_conditions_web_url: Annotated[
        Optional[str],
        Field(
            description='URL of a webpage that provides the terms and conditions of the business.'
        ),
    ] = None
    field_odata_type: str


class BookingQuestionAnswer(BaseModel):
    answer: Annotated[
        Optional[str],
        Field(
            description='The answer given by the user in case the answerInputType is text.'
        ),
    ] = None
    answer_input_type: Annotated[
        Optional[Union[AnswerInputType, Dict[str, Any]]],
        Field(
            description='The expected answer type. The possible values are: text, radioButton, unknownFutureValue.'
        ),
    ] = None
    answer_options: Annotated[
        Optional[List[str]],
        Field(
            description='In case the answerInputType is radioButton, this will consists of a list of possible answer values.'
        ),
    ] = None
    is_required: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether it is mandatory to answer the custom question.'
        ),
    ] = None
    question: Annotated[Optional[str], Field(description='The question.')] = None
    question_id: Annotated[
        Optional[str], Field(description='The ID of the custom question.')
    ] = None
    selected_options: Annotated[
        Optional[List[str]], Field(description='The answers selected by the user.')
    ] = None
    field_odata_type: str


class BookingReminder(BaseModel):
    message: Annotated[
        Optional[str], Field(description='The message in the reminder.')
    ] = None
    offset: Annotated[
        Optional[timedelta],
        Field(
            description="The amount of time before the start of an appointment that the reminder should be sent. It's denoted in ISO 8601 format.",
        ),
    ] = None
    recipients: Optional[BookingReminderRecipients] = None
    field_odata_type: str


class BookingWorkHours(BaseModel):
    day: Optional[DayOfWeek] = None
    time_slots: Annotated[
        Optional[List[BookingWorkTimeSlot]],
        Field(description='A list of start/end times during a day.'),
    ] = None
    field_odata_type: str


class BroadcastMeetingSettings(BaseModel):
    allowed_audience: Annotated[
        Optional[Union[BroadcastMeetingAudience, Dict[str, Any]]],
        Field(
            description='Defines who can join the Teams live event. Possible values are listed in the following table.'
        ),
    ] = None
    captions: Annotated[
        Optional[Union[BroadcastMeetingCaptionSettings, Dict[str, Any]]],
        Field(description='Caption settings of a Teams live event.'),
    ] = None
    is_attendee_report_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether attendee report is enabled for this Teams live event. Default value is false.'
        ),
    ] = None
    is_question_and_answer_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether Q&A is enabled for this Teams live event. Default value is false.'
        ),
    ] = None
    is_recording_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether recording is enabled for this Teams live event. Default value is false.'
        ),
    ] = None
    is_video_on_demand_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether video on demand is enabled for this Teams live event. Default value is false.'
        ),
    ] = None
    field_odata_type: str


class BrowserSharedCookieHistory(BaseModel):
    comment: Annotated[
        Optional[str], Field(description='The comment for the shared cookie.')
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The name of the cookie.')
    ] = None
    host_only: Annotated[
        Optional[bool],
        Field(description='Controls whether a cookie is a host-only or domain cookie.'),
    ] = None
    host_or_domain: Annotated[
        Optional[str], Field(description='The URL of the cookie.')
    ] = None
    last_modified_by: Optional[IdentitySet] = None
    path: Annotated[Optional[str], Field(description='The path of the cookie.')] = None
    published_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the cookie was last published.',
        ),
    ] = None
    source_environment: Annotated[
        Optional[Union[BrowserSharedCookieSourceEnvironment, Dict[str, Any]]],
        Field(
            description='Specifies how the cookies are shared between Microsoft Edge and Internet Explorer. The possible values are: microsoftEdge, internetExplorer11, both, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class BrowserSiteHistory(BaseModel):
    allow_redirect: Annotated[
        Optional[bool],
        Field(
            description='Controls the behavior of redirected sites. If true, indicates that the site will open in Internet Explorer 11 or Microsoft Edge even if the site is navigated to as part of a HTTP or meta refresh redirection chain.'
        ),
    ] = None
    comment: Annotated[
        Optional[str], Field(description='The comment for the site.')
    ] = None
    compatibility_mode: Annotated[
        Optional[Union[BrowserSiteCompatibilityMode, Dict[str, Any]]],
        Field(
            description='Controls what compatibility setting is used for specific sites or domains. The possible values are: default, internetExplorer8Enterprise, internetExplorer7Enterprise, internetExplorer11, internetExplorer10, internetExplorer9, internetExplorer8, internetExplorer7, internetExplorer5, unknownFutureValue.'
        ),
    ] = None
    last_modified_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='The user who last modified the site.'),
    ] = None
    merge_type: Annotated[
        Optional[Union[BrowserSiteMergeType, Dict[str, Any]]],
        Field(
            description='The merge type of the site. The possible values are: noMerge, default, unknownFutureValue.'
        ),
    ] = None
    published_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the site was last published.',
        ),
    ] = None
    target_environment: Annotated[
        Optional[Union[BrowserSiteTargetEnvironment, Dict[str, Any]]],
        Field(
            description='The target environment that the site should open in. The possible values are: internetExplorerMode, internetExplorer11, microsoftEdge, configurable, none, unknownFutureValue.Prior to June 15, 2022, the internetExplorer11 option would allow opening a site in the Internet Explorer 11 (IE11) desktop application. Following the retirement of IE11 on June 15, 2022, the internetExplorer11 option will no longer open an IE11 window and will instead behave the same as the internetExplorerMode option.'
        ),
    ] = None
    field_odata_type: str


class BucketAggregationDefinition(BaseModel):
    is_descending: Annotated[
        Optional[bool],
        Field(
            description='True to specify the sort order as descending. The default is false, with the sort order as ascending. Optional.'
        ),
    ] = None
    minimum_count: Annotated[
        Optional[float],
        Field(
            description='The minimum number of items that should be present in the aggregation to be returned in a bucket. Optional.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    prefix_filter: Annotated[
        Optional[str],
        Field(
            description='A filter to define a matching criteria. The key should start with the specified prefix to be returned in the response. Optional.'
        ),
    ] = None
    ranges: Annotated[
        Optional[List[BucketAggregationRange]],
        Field(
            description='Specifies the manual ranges to compute the aggregations. This is only valid for nonstring refiners of date or numeric type. Optional.'
        ),
    ] = None
    sort_by: Optional[BucketAggregationSortProperty] = None
    field_odata_type: str


class CalendarSharingMessageAction(BaseModel):
    action: Optional[Union[CalendarSharingAction, Dict[str, Any]]] = None
    action_type: Optional[Union[CalendarSharingActionType, Dict[str, Any]]] = None
    importance: Optional[Union[CalendarSharingActionImportance, Dict[str, Any]]] = None
    field_odata_type: str


class CallMediaState(BaseModel):
    audio: Annotated[
        Optional[Union[MediaState, Dict[str, Any]]],
        Field(
            description='The audio media state. Possible values are: active, inactive, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class CallParticipantInfo(BaseModel):
    participant: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Identity of the call participant.'),
    ] = None
    field_odata_type: str


class CallRecordingEventMessageDetail(EventMessageDetail):
    call_id: Annotated[
        Optional[str], Field(description='Unique identifier of the call.')
    ] = None
    call_recording_display_name: Annotated[
        Optional[str], Field(description='Display name for the call recording.')
    ] = None
    call_recording_duration: Annotated[
        Optional[timedelta],
        Field(
            description='Duration of the call recording.',
        ),
    ] = None
    call_recording_status: Annotated[
        Optional[Union[CallRecordingStatus, Dict[str, Any]]],
        Field(
            description='Status of the call recording. Possible values are: success, failure, initial, chunkFinished, unknownFutureValue.'
        ),
    ] = None
    call_recording_url: Annotated[
        Optional[str], Field(description='Call recording URL.')
    ] = None
    initiator: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Initiator of the event.'),
    ] = None
    meeting_organizer: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Organizer of the meeting.'),
    ] = None
    field_odata_type: str


class CallRoute(BaseModel):
    final: Optional[IdentitySet] = None
    original: Optional[IdentitySet] = None
    routing_type: Optional[RoutingType] = None
    field_odata_type: str


class CallStartedEventMessageDetail(EventMessageDetail):
    call_event_type: Annotated[
        Optional[Union[TeamworkCallEventType, Dict[str, Any]]],
        Field(
            description='Represents the call event type. Possible values are: call, meeting, screenShare, unknownFutureValue.'
        ),
    ] = None
    call_id: Annotated[
        Optional[str], Field(description='Unique identifier of the call.')
    ] = None
    initiator: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Initiator of the event.'),
    ] = None
    field_odata_type: str


class CallTranscriptEventMessageDetail(EventMessageDetail):
    call_id: Annotated[
        Optional[str], Field(description='Unique identifier of the call.')
    ] = None
    call_transcript_i_cal_uid: Annotated[
        Optional[str], Field(description='Unique identifier for a call transcript.')
    ] = None
    meeting_organizer: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='The organizer of the meeting.'),
    ] = None
    field_odata_type: str


class CallTranscriptionInfo(BaseModel):
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The state modified time in UTC.',
        ),
    ] = None
    state: Optional[CallTranscriptionState] = None
    field_odata_type: str


class ChangeNotification(BaseModel):
    change_type: Optional[ChangeType] = None
    client_state: Annotated[
        Optional[str],
        Field(
            description='Value of the clientState property sent in the subscription request (if any). The maximum length is 255 characters. The client can check whether the change notification came from the service by comparing the values of the clientState property. The value of the clientState property sent with the subscription is compared with the value of the clientState property received with each change notification. Optional.'
        ),
    ] = None
    encrypted_content: Annotated[
        Optional[Union[ChangeNotificationEncryptedContent, Dict[str, Any]]],
        Field(
            description='(Preview) Encrypted content attached with the change notification. Only provided if encryptionCertificate and includeResourceData were defined during the subscription request and if the resource supports it. Optional.'
        ),
    ] = None
    id: Annotated[
        Optional[str], Field(description='Unique ID for the notification. Optional.')
    ] = None
    lifecycle_event: Annotated[
        Optional[Union[LifecycleEventType, Dict[str, Any]]],
        Field(
            description='The type of lifecycle notification if the current notification is a lifecycle notification. Optional. Supported values are missed, subscriptionRemoved, reauthorizationRequired. Optional.'
        ),
    ] = None
    resource: Annotated[
        Optional[str],
        Field(
            description='The URI of the resource that emitted the change notification relative to https://graph.microsoft.com. Required.'
        ),
    ] = None
    resource_data: Annotated[
        Optional[Union[ResourceData, Dict[str, Any]]],
        Field(
            description='The content of this property depends on the type of resource being subscribed to. Optional.'
        ),
    ] = None
    subscription_expiration_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The expiration time for the subscription. Required.',
        ),
    ] = None
    subscription_id: Annotated[
        Optional[UUID],
        Field(
            description='The unique identifier of the subscription that generated the notification.Required.',
        ),
    ] = None
    tenant_id: Annotated[
        Optional[UUID],
        Field(
            description='The unique identifier of the tenant from which the change notification originated. Required.',
        ),
    ] = None
    field_odata_type: str


class ChangeNotificationCollection(BaseModel):
    validation_tokens: Annotated[
        Optional[List[str]],
        Field(
            description='Contains an array of JSON web tokens (JWT) generated by Microsoft Graph for the application to validate the origin of the notifications. Microsoft Graph generates a single token for each distinct app and tenant pair for an item if it exists in the value array. Keep in mind that notifications can contain a mix of items for various apps and tenants that subscribed using the same notification URL. Only provided for change notifications with resource data. Optional.'
        ),
    ] = None
    value: Annotated[
        Optional[List[ChangeNotification]],
        Field(
            description='The set of notifications being sent to the notification URL. Required.'
        ),
    ] = None
    field_odata_type: str


class ChannelAddedEventMessageDetail(EventMessageDetail):
    channel_display_name: Annotated[
        Optional[str], Field(description='Display name of the channel.')
    ] = None
    channel_id: Annotated[
        Optional[str], Field(description='Unique identifier of the channel.')
    ] = None
    initiator: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Initiator of the event.'),
    ] = None
    field_odata_type: str


class ChannelDeletedEventMessageDetail(EventMessageDetail):
    channel_display_name: Annotated[
        Optional[str], Field(description='Display name of the channel.')
    ] = None
    channel_id: Annotated[
        Optional[str], Field(description='Unique identifier of the channel.')
    ] = None
    initiator: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Initiator of the event.'),
    ] = None
    field_odata_type: str


class ChannelDescriptionUpdatedEventMessageDetail(EventMessageDetail):
    channel_description: Annotated[
        Optional[str], Field(description='The updated description of the channel.')
    ] = None
    channel_id: Annotated[
        Optional[str], Field(description='Unique identifier of the channel.')
    ] = None
    initiator: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Initiator of the event.'),
    ] = None
    field_odata_type: str


class ChannelMembersNotificationRecipient(TeamworkNotificationRecipient):
    channel_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier for the channel whose members should receive the notification.'
        ),
    ] = None
    team_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier for the team under which the channel resides.'
        ),
    ] = None
    field_odata_type: str


class ChannelRenamedEventMessageDetail(EventMessageDetail):
    channel_display_name: Annotated[
        Optional[str], Field(description='The updated name of the channel.')
    ] = None
    channel_id: Annotated[
        Optional[str], Field(description='Unique identifier of the channel.')
    ] = None
    initiator: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Initiator of the event.'),
    ] = None
    field_odata_type: str


class ChannelSetAsFavoriteByDefaultEventMessageDetail(EventMessageDetail):
    channel_id: Annotated[
        Optional[str], Field(description='Unique identifier of the channel.')
    ] = None
    initiator: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Initiator of the event.'),
    ] = None
    field_odata_type: str


class ChannelUnsetAsFavoriteByDefaultEventMessageDetail(EventMessageDetail):
    channel_id: Annotated[
        Optional[str], Field(description='Unique identifier of the channel.')
    ] = None
    initiator: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Initiator of the event.'),
    ] = None
    field_odata_type: str


class ChatMembersNotificationRecipient(TeamworkNotificationRecipient):
    chat_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier for the chat whose members should receive the notifications.'
        ),
    ] = None
    field_odata_type: str


class ChatMessageFromIdentitySet(IdentitySet):
    field_odata_type: str


class ChatMessagePolicyViolation(BaseModel):
    dlp_action: Annotated[
        Optional[Union[ChatMessagePolicyViolationDlpActionTypes, Dict[str, Any]]],
        Field(
            description='The action taken by the DLP provider on the message with sensitive content. Supported values are: NoneNotifySender -- Inform the sender of the violation but allow readers to read the message.BlockAccess -- Block readers from reading the message.BlockAccessExternal -- Block users outside the organization from reading the message, while allowing users within the organization to read the message.'
        ),
    ] = None
    justification_text: Annotated[
        Optional[str],
        Field(
            description='Justification text provided by the sender of the message when overriding a policy violation.'
        ),
    ] = None
    policy_tip: Annotated[
        Optional[Union[ChatMessagePolicyViolationPolicyTip, Dict[str, Any]]],
        Field(
            description='Information to display to the message sender about why the message was flagged as a violation.'
        ),
    ] = None
    user_action: Annotated[
        Optional[Union[ChatMessagePolicyViolationUserActionTypes, Dict[str, Any]]],
        Field(
            description="Indicates the action taken by the user on a message blocked by the DLP provider. Supported values are: NoneOverrideReportFalsePositiveWhen the DLP provider is updating the message for blocking sensitive content, userAction isn't required."
        ),
    ] = None
    verdict_details: Annotated[
        Optional[Union[ChatMessagePolicyViolationVerdictDetailsTypes, Dict[str, Any]]],
        Field(
            description='Indicates what actions the sender may take in response to the policy violation. Supported values are: NoneAllowFalsePositiveOverride -- Allows the sender to declare the policyViolation to be an error in the DLP app and its rules, and allow readers to see the message again if the dlpAction hides it.AllowOverrideWithoutJustification -- Allows the sender to override the DLP violation and allow readers to see the message again if the dlpAction hides it, without needing to provide an explanation for doing so. AllowOverrideWithJustification -- Allows the sender to override the DLP violation and allow readers to see the message again if the dlpAction hides it, after providing an explanation for doing so.AllowOverrideWithoutJustification and AllowOverrideWithJustification are mutually exclusive.'
        ),
    ] = None
    field_odata_type: str


class ChatMessageReactionIdentitySet(IdentitySet):
    field_odata_type: str


class ChatRenamedEventMessageDetail(EventMessageDetail):
    chat_display_name: Annotated[
        Optional[str], Field(description='The updated name of the chat.')
    ] = None
    chat_id: Annotated[
        Optional[str], Field(description='Unique identifier of the chat.')
    ] = None
    initiator: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Initiator of the event.'),
    ] = None
    field_odata_type: str


class ClientCertificateAuthentication(ApiAuthenticationConfigurationBase):
    certificate_list: Annotated[
        Optional[List[Pkcs12CertificateInformation]],
        Field(description='The list of certificates uploaded for this API connector.'),
    ] = None
    field_odata_type: str


class CloudAppSecuritySessionControl(ConditionalAccessSessionControl):
    cloud_app_security_type: Annotated[
        Optional[Union[CloudAppSecuritySessionControlType, Dict[str, Any]]],
        Field(
            description='Possible values are: mcasConfigured, monitorOnly, blockDownloads, unknownFutureValue. For more information, see Deploy Conditional Access App Control for featured apps.'
        ),
    ] = None
    field_odata_type: str


class CloudPcAuditActor(BaseModel):
    application_display_name: Annotated[
        Optional[str], Field(description='Name of the application.')
    ] = None
    application_id: Annotated[
        Optional[str], Field(description='Microsoft Entra application ID.')
    ] = None
    ip_address: Annotated[Optional[str], Field(description='IP address.')] = None
    remote_tenant_id: Annotated[
        Optional[str], Field(description='The delegated partner tenant ID.')
    ] = None
    remote_user_id: Annotated[
        Optional[str], Field(description='The delegated partner user ID.')
    ] = None
    service_principal_name: Annotated[
        Optional[str], Field(description='Service Principal Name (SPN).')
    ] = None
    user_id: Annotated[Optional[str], Field(description='Microsoft Entra user ID.')] = (
        None
    )
    user_permissions: Annotated[
        Optional[List[str]],
        Field(
            description='List of user permissions and application permissions when the audit event was performed.'
        ),
    ] = None
    user_principal_name: Annotated[
        Optional[str], Field(description='User Principal Name (UPN).')
    ] = None
    user_role_scope_tags: Annotated[
        Optional[List[CloudPcUserRoleScopeTagInfo]],
        Field(description='List of role scope tags.'),
    ] = None
    field_odata_type: str


class CloudPcDomainJoinConfiguration(BaseModel):
    domain_join_type: Annotated[
        Optional[Union[CloudPcDomainJoinType, Dict[str, Any]]],
        Field(
            description='Specifies the method by which the provisioned Cloud PC joins Microsoft Entra ID. If you choose the hybridAzureADJoin type, only provide a value for the onPremisesConnectionId property and leave the regionName property empty. If you choose the azureADJoin type, provide a value for either the onPremisesConnectionId or the regionName property. Possible values are: azureADJoin, hybridAzureADJoin, unknownFutureValue.'
        ),
    ] = None
    on_premises_connection_id: Annotated[
        Optional[str],
        Field(
            description='The Azure network connection ID that matches the virtual network IT admins want the provisioning policy to use when they create Cloud PCs. You can use this property in both domain join types: Azure AD joined or Hybrid Microsoft Entra joined. If you enter an onPremisesConnectionId, leave the regionName property empty.'
        ),
    ] = None
    region_group: Annotated[
        Optional[Union[CloudPcRegionGroup, Dict[str, Any]]],
        Field(
            description='The logical geographic group this region belongs to. Multiple regions can belong to one region group. A customer can select a regionGroup when they provision a Cloud PC, and the Cloud PC is put in one of the regions in the group based on resource status. For example, the Europe region group contains the Northern Europe and Western Europe regions. Possible values are: default, australia, canada, usCentral, usEast, usWest, france, germany, europeUnion, unitedKingdom, japan, asia, india, southAmerica, euap, usGovernment, usGovernmentDOD, unknownFutureValue, norway, switzerland, southKorea. Use the Prefer: include-unknown-enum-members request header to get the following values in this evolvable enum: norway, switzerland, southKorea. Read-only.'
        ),
    ] = None
    region_name: Annotated[
        Optional[str],
        Field(
            description='The supported Azure region where the IT admin wants the provisioning policy to create Cloud PCs. Within this region, the Windows 365 service creates and manages the underlying virtual network. This option is available only when the IT admin selects Microsoft Entra joined as the domain join type. If you enter a regionName, leave the onPremisesConnectionId property empty.'
        ),
    ] = None
    field_odata_type: str


class CloudPcOnPremisesConnectionHealthCheck(BaseModel):
    additional_detail: Annotated[
        Optional[str],
        Field(
            description='Additional details about the health check or the recommended action. For exmaple, the string value can be download.microsoft.com:443;software-download.microsoft.com:443; Read-only.'
        ),
    ] = None
    correlation_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier of the health check item-related activities. This identifier can be useful in troubleshooting.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The display name for this health check item.')
    ] = None
    end_date_time: Annotated[
        Optional[datetime],
        Field(
            description="The value cannot be modified and is automatically populated when the health check ends. The Timestamp type represents date and time information using ISO 8601 format and is in Coordinated Universal Time (UTC). For example, midnight UTC on Jan 1, 2024 would look like this: '2024-01-01T00:00:00Z'. Returned by default. Read-only.",
        ),
    ] = None
    error_type: Annotated[
        Optional[
            Union[CloudPcOnPremisesConnectionHealthCheckErrorType, Dict[str, Any]]
        ],
        Field(
            description='The type of error that occurred during this health check. Possible values are: endpointConnectivityCheckCloudPcUrlNotAllowListed, endpointConnectivityCheckWVDUrlNotAllowListed, etc. (The all possible values can refer to cloudPcOnPremisesConnectionHealthCheckErrorType) Read-Only.'
        ),
    ] = None
    recommended_action: Annotated[
        Optional[str],
        Field(
            description='The recommended action to fix the corresponding error. For example, The Active Directory domain join check failed because the password of the domain join user has expired. Read-Only.'
        ),
    ] = None
    start_date_time: Annotated[
        Optional[datetime],
        Field(
            description="The value cannot be modified and is automatically populated when the health check starts. The Timestamp type represents date and time information using ISO 8601 format and is in  Coordinated Universal Time (UTC). For example, midnight UTC on Jan 1, 2024 would look like this: '2024-01-01T00:00:00Z'. Returned by default. Read-only.",
        ),
    ] = None
    status: Optional[CloudPcOnPremisesConnectionStatus] = None
    field_odata_type: str


class CloudPcOnPremisesConnectionStatusDetail(BaseModel):
    end_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The end time of the connection health check. The Timestamp  is shown in ISO 8601 format and Coordinated Universal Time (UTC). For example, midnight UTC on Jan 1, 2014 appears as 2014-01-01T00:00:00Z. Read-Only.',
        ),
    ] = None
    health_checks: Annotated[
        Optional[List[CloudPcOnPremisesConnectionHealthCheck]],
        Field(
            description='A list of all checks that have been run on the connection. Read-Only.'
        ),
    ] = None
    start_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The start time of the health check. The timestamp is shown in ISO 8601 format and Coordinated Universal Time (UTC). For example, midnight UTC on Jan 1, 2014 appear as 2014-01-01T00:00:00Z. Read-Only.',
        ),
    ] = None
    field_odata_type: str


class CloudPcRestorePointSetting(BaseModel):
    frequency_type: Annotated[
        Optional[Union[CloudPcRestorePointFrequencyType, Dict[str, Any]]],
        Field(
            description='The time interval in hours to take snapshots (restore points) of a Cloud PC automatically. Possible values are: default, fourHours, sixHours, twelveHours, sixteenHours, twentyFourHours, unknownFutureValue. The default value is default that indicates that the time interval for automatic capturing of restore point snapshots is set to 12 hours.'
        ),
    ] = None
    user_restore_enabled: Annotated[
        Optional[bool],
        Field(
            description="If true, the user has the ability to use snapshots to restore Cloud PCs. If false, non-admin users can't use snapshots to restore the Cloud PC."
        ),
    ] = None
    field_odata_type: str


class CoachmarkLocation(BaseModel):
    length: Annotated[
        Optional[float],
        Field(description='Length of coachmark.', ge=-2147483648.0, le=2147483647.0),
    ] = None
    offset: Annotated[
        Optional[float],
        Field(description='Offset of coachmark.', ge=-2147483648.0, le=2147483647.0),
    ] = None
    type: Annotated[
        Optional[Union[CoachmarkLocationType, Dict[str, Any]]],
        Field(
            description='Type of coachmark location. The possible values are: unknown, fromEmail, subject, externalTag, displayName, messageBody, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class ColumnValidation(BaseModel):
    default_language: Annotated[
        Optional[str],
        Field(description='Default BCP 47 language tag for the description.'),
    ] = None
    descriptions: Annotated[
        Optional[List[DisplayNameLocalization]],
        Field(
            description="Localized messages that explain what is needed for this column's value to be considered valid. User will be prompted with this message if validation fails."
        ),
    ] = None
    formula: Annotated[
        Optional[str],
        Field(
            description='The formula to validate column value. For examples, see Examples of common formulas in lists.'
        ),
    ] = None
    field_odata_type: str


class CommentAction(BaseModel):
    is_reply: Annotated[
        Optional[bool],
        Field(
            description='If true, this activity was a reply to an existing comment thread.'
        ),
    ] = None
    parent_author: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='The identity of the user who started the comment thread.'),
    ] = None
    participants: Annotated[
        Optional[List[IdentitySet]],
        Field(
            description='The identities of the users participating in this comment thread.'
        ),
    ] = None
    field_odata_type: str


class CommsNotification(BaseModel):
    change_type: Optional[ChangeType] = None
    resource_url: Annotated[
        Optional[str], Field(description='URI of the resource that was changed.')
    ] = None
    field_odata_type: str


class CommsNotifications(BaseModel):
    value: Annotated[
        Optional[List[CommsNotification]],
        Field(description='The notification of a change in the resource.'),
    ] = None
    field_odata_type: str


class CommunicationsApplicationIdentity(Identity):
    application_type: Annotated[
        Optional[str],
        Field(
            description='First-party Microsoft application that presents this identity.'
        ),
    ] = None
    hidden: Annotated[
        Optional[bool],
        Field(
            description="True if the participant shouldn't be shown in other participants' rosters."
        ),
    ] = None
    field_odata_type: str


class CommunicationsApplicationInstanceIdentity(Identity):
    hidden: Annotated[
        Optional[bool],
        Field(
            description="True if the participant shouldn't be shown in other participants' rosters."
        ),
    ] = None
    tenant_id: Annotated[
        Optional[str], Field(description='The tenant ID of the application.')
    ] = None
    field_odata_type: str


class CommunicationsEncryptedIdentity(Identity):
    field_odata_type: str


class CommunicationsGuestIdentity(Identity):
    field_odata_type: str


class CommunicationsIdentitySet(IdentitySet):
    application_instance: Annotated[
        Optional[Union[Identity, Dict[str, Any]]],
        Field(description='The application instance associated with this action.'),
    ] = None
    asserted_identity: Annotated[
        Optional[Union[Identity, Dict[str, Any]]],
        Field(
            description='An identity the participant would like to present itself as to the other participants in the call.'
        ),
    ] = None
    azure_communication_services_user: Annotated[
        Optional[Union[Identity, Dict[str, Any]]],
        Field(
            description='The Azure Communication Services user associated with this action.'
        ),
    ] = None
    encrypted: Annotated[
        Optional[Union[Identity, Dict[str, Any]]],
        Field(description='The encrypted user associated with this action.'),
    ] = None
    endpoint_type: Annotated[
        Optional[Union[EndpointType, Dict[str, Any]]],
        Field(
            description='Type of endpoint that the participant uses. Possible values are: default, voicemail, skypeForBusiness, skypeForBusinessVoipPhone, unknownFutureValue.'
        ),
    ] = None
    guest: Annotated[
        Optional[Union[Identity, Dict[str, Any]]],
        Field(description='The guest user associated with this action.'),
    ] = None
    on_premises: Annotated[
        Optional[Union[Identity, Dict[str, Any]]],
        Field(
            description='The Skype for Business on-premises user associated with this action.'
        ),
    ] = None
    phone: Annotated[
        Optional[Union[Identity, Dict[str, Any]]],
        Field(description='The phone user associated with this action.'),
    ] = None
    field_odata_type: str


class CommunicationsPhoneIdentity(Identity):
    field_odata_type: str


class CommunicationsUserIdentity(Identity):
    tenant_id: Annotated[Optional[str], Field(description="The user's tenant ID.")] = (
        None
    )
    field_odata_type: str


class ComplianceManagementPartnerAssignment(BaseModel):
    target: Annotated[
        Optional[Union[DeviceAndAppManagementAssignmentTarget, Dict[str, Any]]],
        Field(description='Group assignment target.'),
    ] = None
    field_odata_type: str


class ConditionalAccessAuthenticationFlows(BaseModel):
    transfer_methods: Optional[ConditionalAccessTransferMethods] = None
    field_odata_type: str


class ConditionalAccessExternalTenants(BaseModel):
    membership_kind: Annotated[
        Optional[Union[ConditionalAccessExternalTenantsMembershipKind, Dict[str, Any]]],
        Field(
            description='The membership kind. Possible values are: all, enumerated, unknownFutureValue. The enumerated member references an conditionalAccessEnumeratedExternalTenants object.'
        ),
    ] = None
    field_odata_type: str


class ConditionalAccessFilter(BaseModel):
    mode: Optional[FilterMode] = None
    rule: Annotated[
        Optional[str],
        Field(
            description='Rule syntax is similar to that used for membership rules for groups in Microsoft Entra ID. For details, see rules with multiple expressions'
        ),
    ] = None
    field_odata_type: str


class ConditionalAccessGrantControls(BaseModel):
    built_in_controls: Annotated[
        Optional[List[ConditionalAccessGrantControl]],
        Field(
            description='List of values of built-in controls required by the policy. Possible values: block, mfa, compliantDevice, domainJoinedDevice, approvedApplication, compliantApplication, passwordChange, unknownFutureValue.'
        ),
    ] = None
    custom_authentication_factors: Annotated[
        Optional[List[str]],
        Field(
            description='List of custom controls IDs required by the policy. For more information, see Custom controls.'
        ),
    ] = None
    operator: Annotated[
        Optional[str],
        Field(
            description='Defines the relationship of the grant controls. Possible values: AND, OR.'
        ),
    ] = None
    terms_of_use: Annotated[
        Optional[List[str]],
        Field(description='List of terms of use IDs required by the policy.'),
    ] = None
    authentication_strength: Optional[
        Union[AuthenticationStrengthPolicy, Dict[str, Any]]
    ] = None
    field_odata_type: str


class ConditionalAccessGuestsOrExternalUsers(BaseModel):
    external_tenants: Annotated[
        Optional[Union[ConditionalAccessExternalTenants, Dict[str, Any]]],
        Field(
            description="The tenant IDs of the selected types of external users. Either all B2B tenant or a collection of tenant IDs. External tenants can be specified only when the property guestOrExternalUserTypes isn't null or an empty String."
        ),
    ] = None
    guest_or_external_user_types: Optional[
        ConditionalAccessGuestOrExternalUserTypes
    ] = None
    field_odata_type: str


class ConditionalAccessPlatforms(BaseModel):
    exclude_platforms: Annotated[
        Optional[List[ConditionalAccessDevicePlatform]],
        Field(
            description='Possible values are: android, iOS, windows, windowsPhone, macOS, linux, all, unknownFutureValue.'
        ),
    ] = None
    include_platforms: Annotated[
        Optional[List[ConditionalAccessDevicePlatform]],
        Field(
            description='Possible values are: android, iOS, windows, windowsPhone, macOS, linux, all, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class ConditionalAccessUsers(BaseModel):
    exclude_groups: Annotated[
        Optional[List[str]],
        Field(description='Group IDs excluded from scope of policy.'),
    ] = None
    exclude_guests_or_external_users: Annotated[
        Optional[Union[ConditionalAccessGuestsOrExternalUsers, Dict[str, Any]]],
        Field(
            description='Internal guests or external users excluded from the policy scope. Optionally populated.'
        ),
    ] = None
    exclude_roles: Annotated[
        Optional[List[str]],
        Field(description='Role IDs excluded from scope of policy.'),
    ] = None
    exclude_users: Annotated[
        Optional[List[str]],
        Field(
            description='User IDs excluded from scope of policy and/or GuestsOrExternalUsers.'
        ),
    ] = None
    include_groups: Annotated[
        Optional[List[str]],
        Field(description='Group IDs in scope of policy unless explicitly excluded.'),
    ] = None
    include_guests_or_external_users: Annotated[
        Optional[Union[ConditionalAccessGuestsOrExternalUsers, Dict[str, Any]]],
        Field(
            description='Internal guests or external users included in the policy scope. Optionally populated.'
        ),
    ] = None
    include_roles: Annotated[
        Optional[List[str]],
        Field(description='Role IDs in scope of policy unless explicitly excluded.'),
    ] = None
    include_users: Annotated[
        Optional[List[str]],
        Field(
            description='User IDs in scope of policy unless explicitly excluded, None, All, or GuestsOrExternalUsers.'
        ),
    ] = None
    field_odata_type: str


class ConfigurationManagerCollectionAssignmentTarget(
    DeviceAndAppManagementAssignmentTarget
):
    collection_id: Annotated[
        Optional[str],
        Field(description='The collection Id that is the target of the assignment.'),
    ] = None
    field_odata_type: str


class ConnectedOrganizationMembers(SubjectSet):
    connected_organization_id: Annotated[
        Optional[str],
        Field(
            description='The ID of the connected organization in entitlement management.'
        ),
    ] = None
    description: Annotated[
        Optional[str], Field(description='The name of the connected organization.')
    ] = None
    field_odata_type: str


class ContentCustomization(BaseModel):
    attribute_collection: Annotated[
        Optional[List[KeyValue]],
        Field(
            description='Represents the content options of External Identities to be customized throughout the authentication flow for a tenant.'
        ),
    ] = None
    attribute_collection_relative_url: Annotated[
        Optional[str],
        Field(
            description='A relative URL for the content options of External Identities to be customized throughout the authentication flow for a tenant.'
        ),
    ] = None
    registration_campaign: Annotated[
        Optional[List[KeyValue]],
        Field(
            description='Represents content options to customize during MFA proofup interruptions.'
        ),
    ] = None
    registration_campaign_relative_url: Annotated[
        Optional[str],
        Field(
            description='The relative URL of the content options to customize during MFA proofup interruptions.'
        ),
    ] = None
    field_odata_type: str


class ControlScore(BaseModel):
    control_category: Annotated[
        Optional[str],
        Field(
            description='Control action category (Identity, Data, Device, Apps, Infrastructure).'
        ),
    ] = None
    control_name: Annotated[
        Optional[str], Field(description='Control unique name.')
    ] = None
    description: Annotated[
        Optional[str], Field(description='Description of the control.')
    ] = None
    score: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='Tenant achieved score for the control (it varies day by day depending on tenant operations on the control).'
        ),
    ] = None
    field_odata_type: str


class ConvertIdResult(BaseModel):
    error_details: Annotated[
        Optional[Union[GenericError, Dict[str, Any]]],
        Field(
            description="An error object indicating the reason for the conversion failure. This value isn't present if the conversion succeeded."
        ),
    ] = None
    source_id: Annotated[
        Optional[str],
        Field(
            description='The identifier that was converted. This value is the original, un-converted identifier.'
        ),
    ] = None
    target_id: Annotated[
        Optional[str],
        Field(
            description="The converted identifier. This value isn't present if the conversion failed."
        ),
    ] = None
    field_odata_type: str


class CopyNotebookModel(BaseModel):
    created_by: Optional[str] = None
    created_by_identity: Optional[Union[IdentitySet, Dict[str, Any]]] = None
    created_time: Annotated[
        Optional[datetime],
        Field(
        ),
    ] = None
    id: Optional[str] = None
    is_default: Optional[bool] = None
    is_shared: Optional[bool] = None
    last_modified_by: Optional[str] = None
    last_modified_by_identity: Optional[Union[IdentitySet, Dict[str, Any]]] = None
    last_modified_time: Annotated[
        Optional[datetime],
        Field(
        ),
    ] = None
    links: Optional[Union[NotebookLinks, Dict[str, Any]]] = None
    name: Optional[str] = None
    section_groups_url: Optional[str] = None
    sections_url: Optional[str] = None
    self: Optional[str] = None
    user_role: Optional[Union[OnenoteUserRole, Dict[str, Any]]] = None
    field_odata_type: str


class CrossCloudAzureActiveDirectoryTenant(IdentitySource):
    cloud_instance: Annotated[
        Optional[str],
        Field(
            description='The ID of the cloud where the tenant is located, one of microsoftonline.com, microsoftonline.us or partner.microsoftonline.cn. Read only.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(description='The name of the Microsoft Entra tenant. Read only.'),
    ] = None
    tenant_id: Annotated[
        Optional[str],
        Field(description='The ID of the Microsoft Entra tenant. Read only.'),
    ] = None
    field_odata_type: str


class CrossTenantAccessPolicyTarget(BaseModel):
    target: Annotated[
        Optional[str],
        Field(
            description='Defines the target for cross-tenant access policy settings and can have one of the following values:  The unique identifier of the user, group, or application  AllUsers  AllApplications - Refers to any Microsoft cloud application.  Office365 - Includes the applications mentioned as part of the Office 365 suite.'
        ),
    ] = None
    target_type: Annotated[
        Optional[Union[CrossTenantAccessPolicyTargetType, Dict[str, Any]]],
        Field(
            description='The type of resource that you want to target. The possible values are: user, group, application, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class CrossTenantAccessPolicyTargetConfiguration(BaseModel):
    access_type: Annotated[
        Optional[
            Union[CrossTenantAccessPolicyTargetConfigurationAccessType, Dict[str, Any]]
        ],
        Field(
            description='Defines whether access is allowed or blocked. The possible values are: allowed, blocked, unknownFutureValue.'
        ),
    ] = None
    targets: Annotated[
        Optional[List[CrossTenantAccessPolicyTarget]],
        Field(
            description='Specifies whether to target users, groups, or applications with this rule.'
        ),
    ] = None
    field_odata_type: str


class CustomExtensionCalloutInstance(BaseModel):
    custom_extension_id: Annotated[
        Optional[str],
        Field(
            description='Identification of the custom extension that was triggered at this instance.'
        ),
    ] = None
    detail: Annotated[
        Optional[str],
        Field(
            description='Details provided by the logic app during the callback of the request instance.'
        ),
    ] = None
    external_correlation_id: Annotated[
        Optional[str], Field(description='The unique run identifier for the logic app.')
    ] = None
    id: Annotated[
        Optional[str],
        Field(description='Unique identifier for the callout instance. Read-only.'),
    ] = None
    status: Annotated[
        Optional[Union[CustomExtensionCalloutInstanceStatus, Dict[str, Any]]],
        Field(
            description='The status of the request to the custom extension. The possible values are: calloutSent, callbackReceived, calloutFailed, callbackTimedOut, waitingForCallback, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class CustomExtensionCalloutRequest(BaseModel):
    data: Annotated[
        Optional[Union[CustomExtensionData, Dict[str, Any]]],
        Field(
            description='Contains the data that will be provided to the external system.'
        ),
    ] = None
    source: Annotated[
        Optional[str],
        Field(
            description='Identifies the source system or event context related to the callout request.'
        ),
    ] = None
    type: Annotated[
        Optional[str],
        Field(
            description='Describes the type of event related to the callout request.'
        ),
    ] = None
    field_odata_type: str


class CustomExtensionCalloutResponse(BaseModel):
    data: Annotated[
        Optional[Union[CustomExtensionData, Dict[str, Any]]],
        Field(
            description='Contains the data the external system provides to the custom extension endpoint.'
        ),
    ] = None
    source: Annotated[
        Optional[str],
        Field(
            description='Identifies the external system or event context related to the response.'
        ),
    ] = None
    type: Annotated[
        Optional[str],
        Field(description='Describes the type of event related to the response.'),
    ] = None
    field_odata_type: str


class DefenderDetectedMalwareActions(BaseModel):
    high_severity: Optional[DefenderThreatAction] = None
    low_severity: Optional[DefenderThreatAction] = None
    moderate_severity: Optional[DefenderThreatAction] = None
    severe_severity: Optional[DefenderThreatAction] = None
    field_odata_type: str


class DelegatedAdminAccessContainer(BaseModel):
    access_container_id: Annotated[
        Optional[str],
        Field(
            description="The identifier of the access container (for example, a security group). For 'securityGroup' access containers, this must be a valid ID of a Microsoft Entra security group in the Microsoft partner's tenant."
        ),
    ] = None
    access_container_type: Optional[DelegatedAdminAccessContainerType] = None
    field_odata_type: str


class DelegatedAdminAccessDetails(BaseModel):
    unified_roles: Annotated[
        Optional[List[UnifiedRole]],
        Field(
            description='The directory roles that the Microsoft partner is assigned in the customer tenant.'
        ),
    ] = None
    field_odata_type: str


class DeviceActionResult(BaseModel):
    action_name: Annotated[Optional[str], Field(description='Action name')] = None
    action_state: Optional[ActionState] = None
    last_updated_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Time the action state was last updated',
        ),
    ] = None
    start_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Time the action was initiated',
        ),
    ] = None
    field_odata_type: str


class DeviceGeoLocation(BaseModel):
    altitude: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='Altitude, given in meters above sea level'),
    ] = None
    heading: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='Heading in degrees from true north'),
    ] = None
    horizontal_accuracy: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='Accuracy of longitude and latitude in meters'),
    ] = None
    last_collected_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Time at which location was recorded, relative to UTC',
        ),
    ] = None
    latitude: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description="Latitude coordinate of the device's location"),
    ] = None
    longitude: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description="Longitude coordinate of the device's location"),
    ] = None
    speed: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='Speed the device is traveling in meters per second'),
    ] = None
    vertical_accuracy: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='Accuracy of altitude in meters'),
    ] = None
    field_odata_type: str


class DevicesFilter(BaseModel):
    mode: Annotated[
        Optional[
            Union[CrossTenantAccessPolicyTargetConfigurationAccessType, Dict[str, Any]]
        ],
        Field(
            description='Determines whether devices that satisfy the rule should be allowed or blocked. The possible values are: allowed, blocked, unknownFutureValue.'
        ),
    ] = None
    rule: Annotated[
        Optional[str],
        Field(
            description="Defines the rule to filter the devices. For example, device.deviceAttribute2 -eq 'PrivilegedAccessWorkstation'."
        ),
    ] = None
    field_odata_type: str


class DomainIdentitySource(IdentitySource):
    display_name: Annotated[
        Optional[str],
        Field(
            description='The name of the identity source, typically also the domain name. Read only.'
        ),
    ] = None
    domain_name: Annotated[
        Optional[str], Field(description='The domain name. Read only.')
    ] = None
    field_odata_type: str


class DriveItemSource(BaseModel):
    application: Annotated[
        Optional[Union[DriveItemSourceApplication, Dict[str, Any]]],
        Field(
            description='Enumeration value that indicates the source application where the file was created.'
        ),
    ] = None
    external_id: Annotated[
        Optional[str],
        Field(
            description='The external identifier for the drive item from the source.'
        ),
    ] = None
    field_odata_type: str


class EdgeSearchEngine(EdgeSearchEngineBase):
    edge_search_engine_type: Optional[EdgeSearchEngineType] = None
    field_odata_type: str


class EducationAssignmentClassRecipient(EducationAssignmentRecipient):
    field_odata_type: str


class EducationAssignmentGrade(BaseModel):
    graded_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='User who did the grading.'),
    ] = None
    graded_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Moment in time when the grade was applied to this submission object. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z',
        ),
    ] = None
    field_odata_type: str


class EducationAssignmentGroupRecipient(EducationAssignmentRecipient):
    field_odata_type: str


class EducationAssignmentIndividualRecipient(EducationAssignmentRecipient):
    recipients: Annotated[
        Optional[List[str]], Field(description='A collection of IDs of the recipients.')
    ] = None
    field_odata_type: str


class EducationAssignmentPointsGrade(EducationAssignmentGrade):
    points: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='Number of points a teacher is giving this submission object.'
        ),
    ] = None
    field_odata_type: str


class EducationAssignmentPointsGradeType(EducationAssignmentGradeType):
    max_points: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='Max points possible for this assignment.'),
    ] = None
    field_odata_type: str


class EducationItemBody(BaseModel):
    content: Optional[str] = None
    content_type: Optional[Union[BodyType, Dict[str, Any]]] = None
    field_odata_type: str


class EducationResource(BaseModel):
    created_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='The individual who created the resource.'),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Moment in time when the resource was created. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z',
        ),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='Display name of resource.')
    ] = None
    last_modified_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='The last user to modify the resource.'),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Moment in time when the resource was last modified.  The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    field_odata_type: str


class EducationStudent(BaseModel):
    birth_date: Annotated[
        Optional[date],
        Field(
            description='Birth date of the student.',
        ),
    ] = None
    external_id: Annotated[
        Optional[str], Field(description='ID of the student in the source system.')
    ] = None
    gender: Annotated[
        Optional[Union[EducationGender, Dict[str, Any]]],
        Field(
            description='The possible values are: female, male, other, unknownFutureValue.'
        ),
    ] = None
    grade: Annotated[
        Optional[str], Field(description='Current grade level of the student.')
    ] = None
    graduation_year: Annotated[
        Optional[str],
        Field(description='Year the student is graduating from the school.'),
    ] = None
    student_number: Annotated[Optional[str], Field(description='Student Number.')] = (
        None
    )
    field_odata_type: str


class EducationSubmissionIndividualRecipient(EducationSubmissionRecipient):
    user_id: Annotated[
        Optional[str],
        Field(description='User ID of the user to whom the submission is assigned.'),
    ] = None
    field_odata_type: str


class EducationTeamsAppResource(EducationResource):
    app_icon_web_url: Annotated[
        Optional[str], Field(description='URL that points to the icon of the app.')
    ] = None
    app_id: Annotated[
        Optional[str], Field(description='Teams app ID of the application.')
    ] = None
    teams_embedded_content_url: Annotated[
        Optional[str],
        Field(description='URL for the app resource that will be opened by Teams.'),
    ] = None
    web_url: Annotated[
        Optional[str],
        Field(
            description='URL for the app resource that can be opened in the browser.'
        ),
    ] = None
    field_odata_type: str


class EducationWordResource(EducationResource):
    file_url: Annotated[
        Optional[str], Field(description='Location of the file on disk.')
    ] = None
    field_odata_type: str


class EmailIdentity(Identity):
    email: Annotated[Optional[str], Field(description='Email address of the user.')] = (
        None
    )
    field_odata_type: str


class ExcludeTarget(BaseModel):
    id: Annotated[
        Optional[str],
        Field(description='The object identifier of a Microsoft Entra user or group.'),
    ] = None
    target_type: Optional[AuthenticationMethodTargetType] = None
    field_odata_type: str


class ExclusionGroupAssignmentTarget(GroupAssignmentTarget):
    field_odata_type: str


class ExpirationPattern(BaseModel):
    duration: Annotated[
        Optional[timedelta],
        Field(
            description="The requestor's desired duration of access represented in ISO 8601 format for durations. For example, PT3H refers to three hours.  If specified in a request, endDateTime should not be present and the type property should be set to afterDuration.",
        ),
    ] = None
    end_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Timestamp of date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    type: Annotated[
        Optional[Union[ExpirationPatternType, Dict[str, Any]]],
        Field(
            description="The requestor's desired expiration pattern type. The possible values are: notSpecified, noExpiration, afterDateTime, afterDuration."
        ),
    ] = None
    field_odata_type: str


class ExternalDomainFederation(IdentitySource):
    display_name: Annotated[
        Optional[str],
        Field(
            description='The name of the identity source, typically also the domain name. Read only.'
        ),
    ] = None
    domain_name: Annotated[
        Optional[str], Field(description='The domain name. Read only.')
    ] = None
    issuer_uri: Annotated[
        Optional[str],
        Field(description='The issuerURI of the incoming federation. Read only.'),
    ] = None
    field_odata_type: str


class ExternalSponsors(SubjectSet):
    field_odata_type: str


class FeatureTarget(BaseModel):
    id: Annotated[
        Optional[str],
        Field(
            description="The ID of the entity that's targeted in the include or exclude rule, or all_users to target all users."
        ),
    ] = None
    target_type: Annotated[
        Optional[Union[FeatureTargetType, Dict[str, Any]]],
        Field(
            description="The kind of entity that's targeted. The possible values are: group, administrativeUnit, role, unknownFutureValue."
        ),
    ] = None
    field_odata_type: str


class Fido2KeyRestrictions(BaseModel):
    aa_guids: Annotated[
        Optional[List[str]],
        Field(
            description='A collection of Authenticator Attestation GUIDs. AADGUIDs define key types and manufacturers.'
        ),
    ] = None
    enforcement_type: Annotated[
        Optional[Union[Fido2RestrictionEnforcementType, Dict[str, Any]]],
        Field(description='Enforcement type. Possible values are: allow, block.'),
    ] = None
    is_enforced: Annotated[
        Optional[bool],
        Field(description='Determines if the configured key enforcement is enabled.'),
    ] = None
    field_odata_type: str


class File(BaseModel):
    hashes: Annotated[
        Optional[Union[Hashes, Dict[str, Any]]],
        Field(
            description="Hashes of the file's binary content, if available. Read-only."
        ),
    ] = None
    mime_type: Annotated[
        Optional[str],
        Field(
            description='The MIME type for the file. This is determined by logic on the server and might not be the value provided when the file was uploaded. Read-only.'
        ),
    ] = None
    processing_metadata: Optional[bool] = None
    field_odata_type: str


class FileHash(BaseModel):
    hash_type: Annotated[
        Optional[Union[FileHashType, Dict[str, Any]]],
        Field(
            description='File hash type. Possible values are: unknown, sha1, sha256, md5, authenticodeHash256, lsHash, ctph, peSha1, peSha256.'
        ),
    ] = None
    hash_value: Annotated[
        Optional[str], Field(description='Value of the file hash.')
    ] = None
    field_odata_type: str


class FileSecurityState(BaseModel):
    file_hash: Annotated[
        Optional[Union[FileHash, Dict[str, Any]]],
        Field(
            description='Complex type containing file hashes (cryptographic and location-sensitive).'
        ),
    ] = None
    name: Annotated[Optional[str], Field(description='File name (without path).')] = (
        None
    )
    path: Annotated[
        Optional[str], Field(description='Full file path of the file/imageFile.')
    ] = None
    risk_score: Annotated[
        Optional[str],
        Field(
            description='Provider generated/calculated risk score of the alert file. Recommended value range of 0-1, which equates to a percentage.'
        ),
    ] = None
    field_odata_type: str


class FilterClause(BaseModel):
    operator_name: Annotated[
        Optional[str],
        Field(
            description='Name of the operator to be applied to the source and target operands. Must be one of the supported operators. Supported operators can be discovered.'
        ),
    ] = None
    source_operand_name: Annotated[
        Optional[str],
        Field(
            description='Name of source operand (the operand being tested). The source operand name must match one of the attribute names on the source object.'
        ),
    ] = None
    target_operand: Annotated[
        Optional[Union[FilterOperand, Dict[str, Any]]],
        Field(description='Values that the source operand will be tested against.'),
    ] = None
    field_odata_type: str


class FilterGroup(BaseModel):
    clauses: Annotated[
        Optional[List[FilterClause]],
        Field(
            description='Filter clauses (conditions) of this group. All clauses in a group must be satisfied in order for the filter group to evaluate to true.'
        ),
    ] = None
    name: Annotated[
        Optional[str], Field(description='Human-readable name of the filter group.')
    ] = None
    field_odata_type: str


class Folder(BaseModel):
    child_count: Annotated[
        Optional[float],
        Field(
            description='Number of children contained immediately within this container.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    view: Annotated[
        Optional[Union[FolderView, Dict[str, Any]]],
        Field(
            description='A collection of properties defining the recommended view for the folder.'
        ),
    ] = None
    field_odata_type: str


class FollowupFlag(BaseModel):
    completed_date_time: Annotated[
        Optional[Union[DateTimeTimeZone, Dict[str, Any]]],
        Field(description='The date and time that the follow-up was finished.'),
    ] = None
    due_date_time: Annotated[
        Optional[Union[DateTimeTimeZone, Dict[str, Any]]],
        Field(
            description='The date and time that the follow-up is to be finished. Note: To set the due date, you must also specify the startDateTime; otherwise, you get a 400 Bad Request response.'
        ),
    ] = None
    flag_status: Annotated[
        Optional[Union[FollowupFlagStatus, Dict[str, Any]]],
        Field(
            description='The status for follow-up for an item. Possible values are notFlagged, complete, and flagged.'
        ),
    ] = None
    start_date_time: Annotated[
        Optional[Union[DateTimeTimeZone, Dict[str, Any]]],
        Field(description='The date and time that the follow-up is to begin.'),
    ] = None
    field_odata_type: str


class GeoCoordinates(BaseModel):
    altitude: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='Optional. The altitude (height), in feet,  above sea level for the item. Read-only.'
        ),
    ] = None
    latitude: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='Optional. The latitude, in decimal, for the item. Read-only.'
        ),
    ] = None
    longitude: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='Optional. The longitude, in decimal, for the item. Read-only.'
        ),
    ] = None
    field_odata_type: str


class GroupMembers(SubjectSet):
    description: Annotated[
        Optional[str],
        Field(description='The name of the group in Microsoft Entra ID. Read only.'),
    ] = None
    group_id: Annotated[
        Optional[str], Field(description='The ID of the group in Microsoft Entra ID.')
    ] = None
    field_odata_type: str


class ImportedWindowsAutopilotDeviceIdentityState(BaseModel):
    device_error_code: Annotated[
        Optional[float],
        Field(
            description='Device error code reported by Device Directory Service(DDS).',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    device_error_name: Annotated[
        Optional[str],
        Field(
            description='Device error name reported by Device Directory Service(DDS).'
        ),
    ] = None
    device_import_status: Optional[
        ImportedWindowsAutopilotDeviceIdentityImportStatus
    ] = None
    device_registration_id: Annotated[
        Optional[str],
        Field(
            description='Device Registration ID for successfully added device reported by Device Directory Service(DDS).'
        ),
    ] = None
    field_odata_type: str


class IncludeAllAccountTargetContent(AccountTargetContent):
    field_odata_type: str


class Initiator(Identity):
    initiator_type: Annotated[
        Optional[Union[InitiatorType, Dict[str, Any]]],
        Field(
            description='Type of initiator. Possible values are: user, application, system, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class InsightValueDouble(UserExperienceAnalyticsInsightValue):
    value: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='The double value of the user experience analytics insight.'),
    ] = None
    field_odata_type: str


class InsightValueInt(UserExperienceAnalyticsInsightValue):
    value: Annotated[
        Optional[float],
        Field(
            description='The int value of the user experience analytics insight.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class InstanceResourceAccess(BaseModel):
    permissions: Optional[List[ResourcePermission]] = None
    resource_app_id: Optional[str] = None
    field_odata_type: str


class InternalSponsors(SubjectSet):
    field_odata_type: str


class IntuneBrand(BaseModel):
    contact_it_email_address: Annotated[
        Optional[str],
        Field(
            description='Email address of the person/organization responsible for IT support.'
        ),
    ] = None
    contact_it_name: Annotated[
        Optional[str],
        Field(
            description='Name of the person/organization responsible for IT support.'
        ),
    ] = None
    contact_it_notes: Annotated[
        Optional[str],
        Field(
            description='Text comments regarding the person/organization responsible for IT support.'
        ),
    ] = None
    contact_it_phone_number: Annotated[
        Optional[str],
        Field(
            description='Phone number of the person/organization responsible for IT support.'
        ),
    ] = None
    dark_background_logo: Annotated[
        Optional[Union[MimeContent, Dict[str, Any]]],
        Field(
            description='Logo image displayed in Company Portal apps which have a dark background behind the logo.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(description='Company/organization name that is displayed to end users.'),
    ] = None
    light_background_logo: Annotated[
        Optional[Union[MimeContent, Dict[str, Any]]],
        Field(
            description='Logo image displayed in Company Portal apps which have a light background behind the logo.'
        ),
    ] = None
    online_support_site_name: Annotated[
        Optional[str],
        Field(
            description='Display name of the company/organizations IT helpdesk site.'
        ),
    ] = None
    online_support_site_url: Annotated[
        Optional[str],
        Field(description='URL to the company/organizations IT helpdesk site.'),
    ] = None
    privacy_url: Annotated[
        Optional[str],
        Field(description='URL to the company/organizations privacy policy.'),
    ] = None
    show_display_name_next_to_logo: Annotated[
        Optional[bool],
        Field(
            description='Boolean that represents whether the administrator-supplied display name will be shown next to the logo image.'
        ),
    ] = None
    show_logo: Annotated[
        Optional[bool],
        Field(
            description='Boolean that represents whether the administrator-supplied logo images are shown or not shown.'
        ),
    ] = None
    show_name_next_to_logo: Annotated[
        Optional[bool],
        Field(
            description='Boolean that represents whether the administrator-supplied display name will be shown next to the logo image.'
        ),
    ] = None
    theme_color: Annotated[
        Optional[Union[RgbColor, Dict[str, Any]]],
        Field(
            description='Primary theme color used in the Company Portal applications and web portal.'
        ),
    ] = None
    field_odata_type: str


class InvitationRedemptionIdentityProviderConfiguration(BaseModel):
    fallback_identity_provider: Annotated[
        Optional[Union[B2bIdentityProvidersType, Dict[str, Any]]],
        Field(
            description='The fallback identity provider to be used in case no primary identity provider can be used for guest invitation redemption. Possible values are: defaultConfiguredIdp, emailOneTimePasscode, or microsoftAccount.'
        ),
    ] = None
    primary_identity_provider_precedence_order: Annotated[
        Optional[List[Union[B2bIdentityProvidersType, Dict[str, Any]]]],
        Field(
            description='Collection of identity providers in priority order of preference to be used for guest invitation redemption. Possible values are: azureActiveDirectory, externalFederation, or socialIdentityProviders.'
        ),
    ] = None
    field_odata_type: str


class InvitedUserMessageInfo(BaseModel):
    cc_recipients: Annotated[
        Optional[List[Recipient]],
        Field(
            description='Additional recipients the invitation message should be sent to. Currently only one additional recipient is supported.'
        ),
    ] = None
    customized_message_body: Annotated[
        Optional[str],
        Field(
            description="Customized message body you want to send if you don't want the default message. Only plain text is allowed."
        ),
    ] = None
    message_language: Annotated[
        Optional[str],
        Field(
            description='The language you want to send the default message in. If the customizedMessageBody is specified, this property is ignored, and the message is sent using the customizedMessageBody. The language format should be in ISO 639. The default is en-US.'
        ),
    ] = None
    field_odata_type: str


class InviteNewBotResponse(ParticipantJoiningResponse):
    invite_uri: Annotated[
        Optional[str],
        Field(description='URI to receive new incoming call notification.'),
    ] = None
    field_odata_type: str


class IosHomeScreenApp(IosHomeScreenItem):
    bundle_id: Annotated[
        Optional[str],
        Field(
            description='BundleID of the app if isWebClip is false or the URL of a web clip if isWebClip is true.'
        ),
    ] = None
    field_odata_type: str


class IosHomeScreenFolderPage(BaseModel):
    apps: Annotated[
        Optional[List[IosHomeScreenApp]],
        Field(
            description='A list of apps and web clips to appear on a page within a folder. This collection can contain a maximum of 500 elements.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='Name of the folder page')
    ] = None
    field_odata_type: str


class IosLobAppAssignmentSettings(MobileAppAssignmentSettings):
    is_removable: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates that the app can be uninstalled by the user. When FALSE, indicates that the app cannot be uninstalled by the user. By default, this property is set to null which internally is treated as TRUE.'
        ),
    ] = None
    uninstall_on_device_removal: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates that the app should be uninstalled when the device is removed from Intune. When FALSE, indicates that the app will not be uninstalled when the device is removed from Intune. By default, property is set to null which internally is treated as TRUE.'
        ),
    ] = None
    vpn_configuration_id: Annotated[
        Optional[str],
        Field(
            description='This is the unique identifier (Id) of the VPN Configuration to apply to the app.'
        ),
    ] = None
    field_odata_type: str


class IosMobileAppIdentifier(MobileAppIdentifier):
    bundle_id: Annotated[
        Optional[str],
        Field(description='The identifier for an app, as specified in the app store.'),
    ] = None
    field_odata_type: str


class IosNotificationSettings(BaseModel):
    alert_type: Optional[IosNotificationAlertType] = None
    app_name: Annotated[
        Optional[str],
        Field(description='Application name to be associated with the bundleID.'),
    ] = None
    badges_enabled: Annotated[
        Optional[bool],
        Field(description='Indicates whether badges are allowed for this app.'),
    ] = None
    bundle_id: Annotated[
        Optional[str],
        Field(
            description='Bundle id of app to which to apply these notification settings.'
        ),
    ] = None
    enabled: Annotated[
        Optional[bool],
        Field(description='Indicates whether notifications are allowed for this app.'),
    ] = None
    publisher: Annotated[
        Optional[str],
        Field(description='Publisher to be associated with the bundleID.'),
    ] = None
    show_in_notification_center: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether notifications can be shown in notification center.'
        ),
    ] = None
    show_on_lock_screen: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether notifications can be shown on the lock screen.'
        ),
    ] = None
    sounds_enabled: Annotated[
        Optional[bool],
        Field(description='Indicates whether sounds are allowed for this app.'),
    ] = None
    field_odata_type: str


class IosStoreAppAssignmentSettings(MobileAppAssignmentSettings):
    is_removable: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates that the app can be uninstalled by the user. When FALSE, indicates that the app cannot be uninstalled by the user. By default, this property is set to null which internally is treated as TRUE.'
        ),
    ] = None
    uninstall_on_device_removal: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates that the app should be uninstalled when the device is removed from Intune. When FALSE, indicates that the app will not be uninstalled when the device is removed from Intune. By default, property is set to null which internally is treated as TRUE.'
        ),
    ] = None
    vpn_configuration_id: Annotated[
        Optional[str],
        Field(
            description='This is the unique identifier (Id) of the VPN Configuration to apply to the app.'
        ),
    ] = None
    field_odata_type: str


class IosVppAppAssignmentSettings(MobileAppAssignmentSettings):
    use_device_licensing: Annotated[
        Optional[bool], Field(description='Whether or not to use device licensing.')
    ] = None
    vpn_configuration_id: Annotated[
        Optional[str],
        Field(description='The VPN Configuration Id to apply for this app.'),
    ] = None
    field_odata_type: str


class ItemBody(BaseModel):
    content: Annotated[Optional[str], Field(description='The content of the item.')] = (
        None
    )
    content_type: Annotated[
        Optional[Union[BodyType, Dict[str, Any]]],
        Field(
            description='The type of the content. Possible values are text and html.'
        ),
    ] = None
    field_odata_type: str


class ItemReference(BaseModel):
    drive_id: Annotated[
        Optional[str],
        Field(
            description='Unique identifier of the drive instance that contains the driveItem. Only returned if the item is located in a drive. Read-only.'
        ),
    ] = None
    drive_type: Annotated[
        Optional[str],
        Field(
            description='Identifies the type of drive. Only returned if the item is located in a drive. See drive resource for values.'
        ),
    ] = None
    id: Annotated[
        Optional[str],
        Field(
            description='Unique identifier of the driveItem in the drive or a listItem in a list. Read-only.'
        ),
    ] = None
    name: Annotated[
        Optional[str],
        Field(description='The name of the item being referenced. Read-only.'),
    ] = None
    path: Annotated[
        Optional[str],
        Field(
            description='Percent-encoded path that can be used to navigate to the item. Read-only.'
        ),
    ] = None
    share_id: Annotated[
        Optional[str],
        Field(
            description='A unique identifier for a shared resource that can be accessed via the Shares API.'
        ),
    ] = None
    sharepoint_ids: Annotated[
        Optional[Union[SharepointIds, Dict[str, Any]]],
        Field(
            description='Returns identifiers useful for SharePoint REST compatibility. Read-only.'
        ),
    ] = None
    site_id: Annotated[
        Optional[str],
        Field(
            description='For OneDrive for Business and SharePoint, this property represents the ID of the site that contains the parent document library of the driveItem resource or the parent list of the listItem resource. The value is the same as the id property of that site resource. It is an opaque string that consists of three identifiers of the site. For OneDrive, this property is not populated.'
        ),
    ] = None
    field_odata_type: str


class JoinMeetingIdMeetingInfo(MeetingInfo):
    join_meeting_id: Annotated[
        Optional[str], Field(description='The ID used to join the meeting.')
    ] = None
    passcode: Annotated[
        Optional[str],
        Field(description='The passcode used to join the meeting. Optional.'),
    ] = None
    field_odata_type: str


class KeyCredentialConfiguration(BaseModel):
    max_lifetime: Annotated[
        Optional[timedelta],
        Field(
            description='String value that indicates the maximum lifetime for key expiration, defined as an ISO 8601 duration. For example, P4DT12H30M5S represents four days, 12 hours, 30 minutes, and five seconds. This property is required when restrictionType is set to keyLifetime.',
        ),
    ] = None
    restrict_for_apps_created_after_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Specifies the date from which the policy restriction applies to newly created applications. For existing applications, the enforcement date can be retroactively applied.',
        ),
    ] = None
    restriction_type: Annotated[
        Optional[Union[AppKeyCredentialRestrictionType, Dict[str, Any]]],
        Field(
            description='The type of restriction being applied. Possible values are asymmetricKeyLifetime, and unknownFutureValue. Each value of restrictionType can be used only once per policy.'
        ),
    ] = None
    state: Optional[AppManagementRestrictionState] = None
    field_odata_type: str


class LobbyBypassSettings(BaseModel):
    is_dial_in_bypass_enabled: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether or not to always let dial-in callers bypass the lobby. Optional.'
        ),
    ] = None
    scope: Annotated[
        Optional[Union[LobbyBypassScope, Dict[str, Any]]],
        Field(
            description='Specifies the type of participants that are automatically admitted into a meeting, bypassing the lobby. Optional.'
        ),
    ] = None
    field_odata_type: str


class LocateDeviceActionResult(DeviceActionResult):
    device_location: Annotated[
        Optional[Union[DeviceGeoLocation, Dict[str, Any]]],
        Field(description='device location'),
    ] = None
    field_odata_type: str


class LoginPageLayoutConfiguration(BaseModel):
    is_footer_shown: Annotated[
        Optional[bool],
        Field(description='Option to show the footer on the sign-in page.'),
    ] = None
    is_header_shown: Annotated[
        Optional[bool],
        Field(description='Option to show the header on the sign-in page.'),
    ] = None
    layout_template_type: Annotated[
        Optional[Union[LayoutTemplateType, Dict[str, Any]]],
        Field(
            description="Represents the layout template to be displayed on the login page for a tenant. The possible values are  default - Represents the default Microsoft layout with a centered lightbox.  verticalSplit - Represents a layout with a background on the left side and a full-height lightbox to the right.  unknownFutureValue - Evolvable enumeration sentinel value. Don't use."
        ),
    ] = None
    field_odata_type: str


class MacOsLobAppAssignmentSettings(MobileAppAssignmentSettings):
    uninstall_on_device_removal: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates that the app should be uninstalled when the device is removed from Intune. When FALSE, indicates that the app will not be uninstalled when the device is removed from Intune.'
        ),
    ] = None
    field_odata_type: str


class MailTips(BaseModel):
    automatic_replies: Annotated[
        Optional[Union[AutomaticRepliesMailTips, Dict[str, Any]]],
        Field(
            description='Mail tips for automatic reply if it has been set up by the recipient.'
        ),
    ] = None
    custom_mail_tip: Annotated[
        Optional[str],
        Field(
            description="A custom mail tip that can be set on the recipient's mailbox."
        ),
    ] = None
    delivery_restricted: Annotated[
        Optional[bool],
        Field(
            description="Whether the recipient's mailbox is restricted, for example, accepting messages from only a predefined list of senders, rejecting messages from a predefined list of senders, or accepting messages from only authenticated senders."
        ),
    ] = None
    email_address: Annotated[
        Optional[Union[EmailAddress, Dict[str, Any]]],
        Field(description='The email address of the recipient to get mailtips for.'),
    ] = None
    error: Annotated[
        Optional[Union[MailTipsError, Dict[str, Any]]],
        Field(description='Errors that occur during the getMailTips action.'),
    ] = None
    external_member_count: Annotated[
        Optional[float],
        Field(
            description='The number of external members if the recipient is a distribution list.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    is_moderated: Annotated[
        Optional[bool],
        Field(
            description="Whether sending messages to the recipient requires approval. For example, if the recipient is a large distribution list and a moderator has been set up to approve messages sent to that distribution list, or if sending messages to a recipient requires approval of the recipient's manager."
        ),
    ] = None
    mailbox_full: Annotated[
        Optional[bool], Field(description='The mailbox full status of the recipient.')
    ] = None
    max_message_size: Annotated[
        Optional[float],
        Field(
            description="The maximum message size that has been configured for the recipient's organization or mailbox.",
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    recipient_scope: Annotated[
        Optional[Union[RecipientScopeType, Dict[str, Any]]],
        Field(
            description="The scope of the recipient. Possible values are: none, internal, external, externalPartner, externalNonParther. For example, an administrator can set another organization to be its 'partner'. The scope is useful if an administrator wants certain mailtips to be accessible to certain scopes. It's also useful to senders to inform them that their message may leave the organization, helping them make the correct decisions about wording, tone and content."
        ),
    ] = None
    recipient_suggestions: Annotated[
        Optional[List[Recipient]],
        Field(
            description='Recipients suggested based on previous contexts where they appear in the same message.'
        ),
    ] = None
    total_member_count: Annotated[
        Optional[float],
        Field(
            description='The number of members if the recipient is a distribution list.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class ManagedAppPolicyDeploymentSummaryPerApp(BaseModel):
    configuration_applied_user_count: Annotated[
        Optional[float],
        Field(
            description='Number of users the policy is applied.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    mobile_app_identifier: Annotated[
        Optional[Union[MobileAppIdentifier, Dict[str, Any]]],
        Field(description='Deployment of an app.'),
    ] = None
    field_odata_type: str


class MediaContentRatingAustralia(BaseModel):
    movie_rating: Optional[RatingAustraliaMoviesType] = None
    tv_rating: Optional[RatingAustraliaTelevisionType] = None
    field_odata_type: str


class MediaContentRatingCanada(BaseModel):
    movie_rating: Optional[RatingCanadaMoviesType] = None
    tv_rating: Optional[RatingCanadaTelevisionType] = None
    field_odata_type: str


class MediaContentRatingFrance(BaseModel):
    movie_rating: Optional[RatingFranceMoviesType] = None
    tv_rating: Optional[RatingFranceTelevisionType] = None
    field_odata_type: str


class MediaContentRatingGermany(BaseModel):
    movie_rating: Optional[RatingGermanyMoviesType] = None
    tv_rating: Optional[RatingGermanyTelevisionType] = None
    field_odata_type: str


class MediaContentRatingIreland(BaseModel):
    movie_rating: Optional[RatingIrelandMoviesType] = None
    tv_rating: Optional[RatingIrelandTelevisionType] = None
    field_odata_type: str


class MediaContentRatingJapan(BaseModel):
    movie_rating: Optional[RatingJapanMoviesType] = None
    tv_rating: Optional[RatingJapanTelevisionType] = None
    field_odata_type: str


class MediaContentRatingNewZealand(BaseModel):
    movie_rating: Optional[RatingNewZealandMoviesType] = None
    tv_rating: Optional[RatingNewZealandTelevisionType] = None
    field_odata_type: str


class MediaContentRatingUnitedKingdom(BaseModel):
    movie_rating: Optional[RatingUnitedKingdomMoviesType] = None
    tv_rating: Optional[RatingUnitedKingdomTelevisionType] = None
    field_odata_type: str


class MediaContentRatingUnitedStates(BaseModel):
    movie_rating: Optional[RatingUnitedStatesMoviesType] = None
    tv_rating: Optional[RatingUnitedStatesTelevisionType] = None
    field_odata_type: str


class MediaPrompt(Prompt):
    media_info: Optional[MediaInfo] = None
    field_odata_type: str


class MediaSource(BaseModel):
    content_category: Annotated[
        Optional[Union[MediaSourceContentCategory, Dict[str, Any]]],
        Field(
            description='Enumeration value that indicates the media content category.'
        ),
    ] = None
    field_odata_type: str


class MediaStream(BaseModel):
    direction: Optional[MediaDirection] = None
    label: Annotated[Optional[str], Field(description='The media stream label.')] = None
    media_type: Optional[Modality] = None
    server_muted: Annotated[
        Optional[bool], Field(description='If the media is muted by the server.')
    ] = None
    source_id: Annotated[Optional[str], Field(description='The source ID.')] = None
    field_odata_type: str


class MeetingParticipantInfo(BaseModel):
    identity: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Identity information of the participant.'),
    ] = None
    role: Annotated[
        Optional[Union[OnlineMeetingRole, Dict[str, Any]]],
        Field(description="Specifies the participant's role in the meeting."),
    ] = None
    upn: Annotated[
        Optional[str], Field(description='User principal name of the participant.')
    ] = None
    field_odata_type: str


class MeetingParticipants(BaseModel):
    attendees: Annotated[
        Optional[List[MeetingParticipantInfo]],
        Field(description='Information about the meeting attendees.'),
    ] = None
    organizer: Annotated[
        Optional[Union[MeetingParticipantInfo, Dict[str, Any]]],
        Field(description='Information about the meeting organizer.'),
    ] = None
    field_odata_type: str


class MessageRuleActions(BaseModel):
    assign_categories: Annotated[
        Optional[List[str]],
        Field(description='A list of categories to be assigned to a message.'),
    ] = None
    copy_to_folder: Annotated[
        Optional[str],
        Field(description='The ID of a folder that a message is to be copied to.'),
    ] = None
    delete: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether a message should be moved to the Deleted Items folder.'
        ),
    ] = None
    forward_as_attachment_to: Annotated[
        Optional[List[Recipient]],
        Field(
            description='The email addresses of the recipients to which a message should be forwarded as an attachment.'
        ),
    ] = None
    forward_to: Annotated[
        Optional[List[Recipient]],
        Field(
            description='The email addresses of the recipients to which a message should be forwarded.'
        ),
    ] = None
    mark_as_read: Annotated[
        Optional[bool],
        Field(description='Indicates whether a message should be marked as read.'),
    ] = None
    mark_importance: Annotated[
        Optional[Union[Importance, Dict[str, Any]]],
        Field(
            description='Sets the importance of the message, which can be: low, normal, high.'
        ),
    ] = None
    move_to_folder: Annotated[
        Optional[str],
        Field(description='The ID of the folder that a message will be moved to.'),
    ] = None
    permanent_delete: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether a message should be permanently deleted and not saved to the Deleted Items folder.'
        ),
    ] = None
    redirect_to: Annotated[
        Optional[List[Recipient]],
        Field(
            description='The email addresses to which a message should be redirected.'
        ),
    ] = None
    stop_processing_rules: Annotated[
        Optional[bool],
        Field(description='Indicates whether subsequent rules should be evaluated.'),
    ] = None
    field_odata_type: str


class MessageRulePredicates(BaseModel):
    body_contains: Annotated[
        Optional[List[str]],
        Field(
            description='Represents the strings that should appear in the body of an incoming message in order for the condition or exception to apply.'
        ),
    ] = None
    body_or_subject_contains: Annotated[
        Optional[List[str]],
        Field(
            description='Represents the strings that should appear in the body or subject of an incoming message in order for the condition or exception to apply.'
        ),
    ] = None
    categories: Annotated[
        Optional[List[str]],
        Field(
            description='Represents the categories that an incoming message should be labeled with in order for the condition or exception to apply.'
        ),
    ] = None
    from_addresses: Annotated[
        Optional[List[Recipient]],
        Field(
            description='Represents the specific sender email addresses of an incoming message in order for the condition or exception to apply.'
        ),
    ] = None
    has_attachments: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether an incoming message must have attachments in order for the condition or exception to apply.'
        ),
    ] = None
    header_contains: Annotated[
        Optional[List[str]],
        Field(
            description='Represents the strings that appear in the headers of an incoming message in order for the condition or exception to apply.'
        ),
    ] = None
    importance: Annotated[
        Optional[Union[Importance, Dict[str, Any]]],
        Field(
            description='The importance that is stamped on an incoming message in order for the condition or exception to apply: low, normal, high.'
        ),
    ] = None
    is_approval_request: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether an incoming message must be an approval request in order for the condition or exception to apply.'
        ),
    ] = None
    is_automatic_forward: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether an incoming message must be automatically forwarded in order for the condition or exception to apply.'
        ),
    ] = None
    is_automatic_reply: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether an incoming message must be an auto reply in order for the condition or exception to apply.'
        ),
    ] = None
    is_encrypted: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether an incoming message must be encrypted in order for the condition or exception to apply.'
        ),
    ] = None
    is_meeting_request: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether an incoming message must be a meeting request in order for the condition or exception to apply.'
        ),
    ] = None
    is_meeting_response: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether an incoming message must be a meeting response in order for the condition or exception to apply.'
        ),
    ] = None
    is_non_delivery_report: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether an incoming message must be a non-delivery report in order for the condition or exception to apply.'
        ),
    ] = None
    is_permission_controlled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether an incoming message must be permission controlled (RMS-protected) in order for the condition or exception to apply.'
        ),
    ] = None
    is_read_receipt: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether an incoming message must be a read receipt in order for the condition or exception to apply.'
        ),
    ] = None
    is_signed: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether an incoming message must be S/MIME-signed in order for the condition or exception to apply.'
        ),
    ] = None
    is_voicemail: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether an incoming message must be a voice mail in order for the condition or exception to apply.'
        ),
    ] = None
    message_action_flag: Annotated[
        Optional[Union[MessageActionFlag, Dict[str, Any]]],
        Field(
            description='Represents the flag-for-action value that appears on an incoming message in order for the condition or exception to apply. The possible values are: any, call, doNotForward, followUp, fyi, forward, noResponseNecessary, read, reply, replyToAll, review.'
        ),
    ] = None
    not_sent_to_me: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the owner of the mailbox must not be a recipient of an incoming message in order for the condition or exception to apply.'
        ),
    ] = None
    recipient_contains: Annotated[
        Optional[List[str]],
        Field(
            description='Represents the strings that appear in either the toRecipients or ccRecipients properties of an incoming message in order for the condition or exception to apply.'
        ),
    ] = None
    sender_contains: Annotated[
        Optional[List[str]],
        Field(
            description='Represents the strings that appear in the from property of an incoming message in order for the condition or exception to apply.'
        ),
    ] = None
    sensitivity: Annotated[
        Optional[Union[Sensitivity, Dict[str, Any]]],
        Field(
            description='Represents the sensitivity level that must be stamped on an incoming message in order for the condition or exception to apply. The possible values are: normal, personal, private, confidential.'
        ),
    ] = None
    sent_cc_me: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the owner of the mailbox must be in the ccRecipients property of an incoming message in order for the condition or exception to apply.'
        ),
    ] = None
    sent_only_to_me: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the owner of the mailbox must be the only recipient in an incoming message in order for the condition or exception to apply.'
        ),
    ] = None
    sent_to_addresses: Annotated[
        Optional[List[Recipient]],
        Field(
            description='Represents the email addresses that an incoming message must have been sent to in order for the condition or exception to apply.'
        ),
    ] = None
    sent_to_me: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the owner of the mailbox must be in the toRecipients property of an incoming message in order for the condition or exception to apply.'
        ),
    ] = None
    sent_to_or_cc_me: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the owner of the mailbox must be in either a toRecipients or ccRecipients property of an incoming message in order for the condition or exception to apply.'
        ),
    ] = None
    subject_contains: Annotated[
        Optional[List[str]],
        Field(
            description='Represents the strings that appear in the subject of an incoming message in order for the condition or exception to apply.'
        ),
    ] = None
    within_size_range: Annotated[
        Optional[Union[SizeRange, Dict[str, Any]]],
        Field(
            description='Represents the minimum and maximum sizes (in kilobytes) that an incoming message must fall in between in order for the condition or exception to apply.'
        ),
    ] = None
    field_odata_type: str


class MicrosoftManagedDesktop(BaseModel):
    managed_type: Annotated[
        Optional[Union[MicrosoftManagedDesktopType, Dict[str, Any]]],
        Field(
            description='Indicates the provisioning policy associated with Microsoft Managed Desktop settings. Possible values are: notManaged, premiumManaged, standardManaged, starterManaged, unknownFutureValue. The default is notManaged.'
        ),
    ] = None
    profile: Annotated[
        Optional[str],
        Field(
            description='The name of the Microsoft Managed Desktop profile that the Windows 365 Cloud PC is associated with.'
        ),
    ] = None
    field_odata_type: str


class MicrosoftStoreForBusinessAppAssignmentSettings(MobileAppAssignmentSettings):
    use_device_context: Annotated[
        Optional[bool],
        Field(
            description='Whether or not to use device execution context for Microsoft Store for Business mobile app.'
        ),
    ] = None
    field_odata_type: str


class MultiTenantOrganizationJoinRequestTransitionDetails(BaseModel):
    desired_member_state: Annotated[
        Optional[Union[MultiTenantOrganizationMemberState, Dict[str, Any]]],
        Field(
            description='State of the tenant in the multitenant organization currently being processed. The possible values are: pending, active, removed, unknownFutureValue. Read-only.'
        ),
    ] = None
    details: Annotated[
        Optional[str],
        Field(
            description='Details that explain the processing status if any. Read-only.'
        ),
    ] = None
    status: Annotated[
        Optional[Union[MultiTenantOrganizationMemberProcessingStatus, Dict[str, Any]]],
        Field(
            description='Processing state of the asynchronous job. The possible values are: notStarted, running, succeeded, failed, unknownFutureValue. Read-only.'
        ),
    ] = None
    field_odata_type: str


class MultiTenantOrganizationMemberTransitionDetails(BaseModel):
    desired_role: Annotated[
        Optional[Union[MultiTenantOrganizationMemberRole, Dict[str, Any]]],
        Field(
            description='Role of the tenant in the multitenant organization. The possible values are: owner, member, unknownFutureValue.'
        ),
    ] = None
    desired_state: Annotated[
        Optional[Union[MultiTenantOrganizationMemberState, Dict[str, Any]]],
        Field(
            description='State of the tenant in the multitenant organization currently being processed. The possible values are: pending, active, removed, unknownFutureValue. Read-only.'
        ),
    ] = None
    details: Annotated[
        Optional[str],
        Field(
            description='Details that explain the processing status if any. Read-only.'
        ),
    ] = None
    status: Annotated[
        Optional[Union[MultiTenantOrganizationMemberProcessingStatus, Dict[str, Any]]],
        Field(
            description='Processing state of the asynchronous job. The possible values are: notStarted, running, succeeded, failed, unknownFutureValue. Read-only.'
        ),
    ] = None
    field_odata_type: str


class NetworkConnection(BaseModel):
    application_name: Annotated[
        Optional[str],
        Field(
            description='Name of the application managing the network connection (for example, Facebook or SMTP).'
        ),
    ] = None
    destination_address: Annotated[
        Optional[str],
        Field(description='Destination IP address (of the network connection).'),
    ] = None
    destination_domain: Annotated[
        Optional[str],
        Field(
            description="Destination domain portion of the destination URL. (for example 'www.contoso.com')."
        ),
    ] = None
    destination_location: Annotated[
        Optional[str],
        Field(
            description='Location (by IP address mapping) associated with the destination of a network connection.'
        ),
    ] = None
    destination_port: Annotated[
        Optional[str],
        Field(description='Destination port (of the network connection).'),
    ] = None
    destination_url: Annotated[
        Optional[str],
        Field(
            description="Network connection URL/URI string - excluding parameters. (for example 'www.contoso.com/products/default.html')"
        ),
    ] = None
    direction: Annotated[
        Optional[Union[ConnectionDirection, Dict[str, Any]]],
        Field(
            description='Network connection direction. Possible values are: unknown, inbound, outbound.'
        ),
    ] = None
    domain_registered_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date when the destination domain was registered. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z',
        ),
    ] = None
    local_dns_name: Annotated[
        Optional[str],
        Field(
            description="The local DNS name resolution as it appears in the host's local DNS cache (for example, in case the 'hosts' file was tampered with)."
        ),
    ] = None
    nat_destination_address: Annotated[
        Optional[str],
        Field(description='Network Address Translation destination IP address.'),
    ] = None
    nat_destination_port: Annotated[
        Optional[str],
        Field(description='Network Address Translation destination port.'),
    ] = None
    nat_source_address: Annotated[
        Optional[str],
        Field(description='Network Address Translation source IP address.'),
    ] = None
    nat_source_port: Annotated[
        Optional[str], Field(description='Network Address Translation source port.')
    ] = None
    protocol: Annotated[
        Optional[Union[SecurityNetworkProtocol, Dict[str, Any]]],
        Field(
            description='Network protocol. Possible values are: unknown, ip, icmp, igmp, ggp, ipv4, tcp, pup, udp, idp, ipv6, ipv6RoutingHeader, ipv6FragmentHeader, ipSecEncapsulatingSecurityPayload, ipSecAuthenticationHeader, icmpV6, ipv6NoNextHeader, ipv6DestinationOptions, nd, raw, ipx, spx, spxII.'
        ),
    ] = None
    risk_score: Annotated[
        Optional[str],
        Field(
            description='Provider generated/calculated risk score of the network connection. Recommended value range of 0-1, which equates to a percentage.'
        ),
    ] = None
    source_address: Annotated[
        Optional[str],
        Field(
            description='Source (i.e. origin) IP address (of the network connection).'
        ),
    ] = None
    source_location: Annotated[
        Optional[str],
        Field(
            description='Location (by IP address mapping) associated with the source of a network connection.'
        ),
    ] = None
    source_port: Annotated[
        Optional[str],
        Field(description='Source (i.e. origin) IP port (of the network connection).'),
    ] = None
    status: Annotated[
        Optional[Union[ConnectionStatus, Dict[str, Any]]],
        Field(
            description='Network connection status. Possible values are: unknown, attempted, succeeded, blocked, failed.'
        ),
    ] = None
    url_parameters: Annotated[
        Optional[str], Field(description='Parameters (suffix) of the destination URL.')
    ] = None
    field_odata_type: str


class NumberColumn(BaseModel):
    decimal_places: Annotated[
        Optional[str],
        Field(
            description='How many decimal places to display. See below for information about the possible values.'
        ),
    ] = None
    display_as: Annotated[
        Optional[str],
        Field(
            description='How the value should be presented in the UX. Must be one of number or percentage. If unspecified, treated as number.'
        ),
    ] = None
    maximum: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='The maximum permitted value.'),
    ] = None
    minimum: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='The minimum permitted value.'),
    ] = None
    field_odata_type: str


class OAuthConsentAppDetail(BaseModel):
    app_scope: Annotated[
        Optional[Union[OAuthAppScope, Dict[str, Any]]],
        Field(
            description='App scope. Possible values are: unknown, readCalendar, readContact, readMail, readAllChat, readAllFile, readAndWriteMail, sendMail, unknownFutureValue.'
        ),
    ] = None
    display_logo: Annotated[Optional[str], Field(description='App display logo.')] = (
        None
    )
    display_name: Annotated[Optional[str], Field(description='App name.')] = None
    field_odata_type: str


class ObjectDefinitionMetadataEntry(BaseModel):
    key: Annotated[
        Optional[Union[ObjectDefinitionMetadata, Dict[str, Any]]],
        Field(
            description='Possible values are: PropertyNameAccountEnabled, PropertyNameSoftDeleted, IsSoftDeletionSupported, IsSynchronizeAllSupported, ConnectorDataStorageRequired, Extensions, LinkTypeName.'
        ),
    ] = None
    value: Annotated[
        Optional[str], Field(description='Value of the metadata property.')
    ] = None
    field_odata_type: str


class ObjectMappingMetadataEntry(BaseModel):
    key: Annotated[
        Optional[Union[ObjectMappingMetadata, Dict[str, Any]]],
        Field(
            description='Possible values are: EscrowBehavior, DisableMonitoringForChanges, OriginalJoiningProperty, Disposition, IsCustomerDefined, ExcludeFromReporting, Unsynchronized.'
        ),
    ] = None
    value: Annotated[
        Optional[str], Field(description='Value of the metadata property.')
    ] = None
    field_odata_type: str


class OmaSettingFloatingPoint(OmaSetting):
    value: Annotated[
        Optional[Union[float, str, ReferenceNumeric]], Field(description='Value.')
    ] = None
    field_odata_type: str


class OnAuthenticationMethodLoadStartExternalUsersSelfServiceSignUp(
    OnAuthenticationMethodLoadStartHandler
):
    identity_providers: Optional[List[IdentityProviderBase]] = None
    field_odata_type: str


class OnenotePagePreview(BaseModel):
    links: Optional[Union[OnenotePagePreviewLinks, Dict[str, Any]]] = None
    preview_text: Optional[str] = None
    field_odata_type: str


class OnenotePatchContentCommand(BaseModel):
    action: Optional[OnenotePatchActionType] = None
    content: Annotated[
        Optional[str],
        Field(
            description="A string of well-formed HTML to add to the page, and any image or file binary data. If the content contains binary data, the request must be sent using the multipart/form-data content type with a 'Commands' part."
        ),
    ] = None
    position: Annotated[
        Optional[Union[OnenotePatchInsertPosition, Dict[str, Any]]],
        Field(
            description='The location to add the supplied content, relative to the target element. The possible values are: after (default) or before.'
        ),
    ] = None
    target: Annotated[
        Optional[str],
        Field(
            description='The element to update. Must be the #<data-id> or the generated <id> of the element, or the body or title keyword.'
        ),
    ] = None
    field_odata_type: str


class OnInteractiveAuthFlowStartExternalUsersSelfServiceSignUp(
    OnInteractiveAuthFlowStartHandler
):
    is_sign_up_allowed: Annotated[
        Optional[bool],
        Field(
            description='Optional. Specifies whether the authentication flow includes an option to sign up (create account) and sign in. Default value is false meaning only sign in is enabled.'
        ),
    ] = None
    field_odata_type: str


class OnlineMeetingRestricted(BaseModel):
    content_sharing_disabled: Annotated[
        Optional[Union[OnlineMeetingContentSharingDisabledReason, Dict[str, Any]]],
        Field(
            description='Specifies the reason shared content from this participant is disabled. Possible values are: watermarkProtection, unknownFutureValue.'
        ),
    ] = None
    video_disabled: Annotated[
        Optional[Union[OnlineMeetingVideoDisabledReason, Dict[str, Any]]],
        Field(
            description='Specifies the reason video from this participant is disabled. Possible values are: watermarkProtection, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class OnPremisesAccidentalDeletionPrevention(BaseModel):
    alert_threshold: Annotated[
        Optional[float],
        Field(
            description='Threshold value which triggers accidental deletion prevention. The threshold is either an absolute number of objects or a percentage number of objects.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    synchronization_prevention_type: Annotated[
        Optional[
            Union[
                OnPremisesDirectorySynchronizationDeletionPreventionType, Dict[str, Any]
            ]
        ],
        Field(
            description='The status of the accidental deletion prevention feature. The possible values are: disabled, enabledForCount, enabledForPercentage, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class OnPremisesDirectorySynchronizationConfiguration(BaseModel):
    accidental_deletion_prevention: Annotated[
        Optional[Union[OnPremisesAccidentalDeletionPrevention, Dict[str, Any]]],
        Field(
            description='Contains the accidental deletion prevention configuration for a tenant.'
        ),
    ] = None
    field_odata_type: str


class OnUserCreateStartExternalUsersSelfServiceSignUp(OnUserCreateStartHandler):
    user_type_to_create: Annotated[
        Optional[Union[UserType, Dict[str, Any]]],
        Field(
            description='The type of user to create. Maps to userType property of user object. The possible values are: member, guest, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class OutlookGeoCoordinates(BaseModel):
    accuracy: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='The accuracy of the latitude and longitude. As an example, the accuracy can be measured in meters, such as the latitude and longitude are accurate to within 50 meters.'
        ),
    ] = None
    altitude: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='The altitude of the location.'),
    ] = None
    altitude_accuracy: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='The accuracy of the altitude.'),
    ] = None
    latitude: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='The latitude of the location.'),
    ] = None
    longitude: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='The longitude of the location.'),
    ] = None
    field_odata_type: str


class OutOfBoxExperienceSetting(BaseModel):
    device_usage_type: Optional[WindowsDeviceUsageType] = None
    escape_link_hidden: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, the link that allows user to start over with a different account on company sign-in is hidden. When false, the link that allows user to start over with a different account on company sign-in is available. Default value is FALSE.'
        ),
    ] = None
    eula_hidden: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, EULA is hidden to the end user during OOBE. When FALSE, EULA is shown to the end user during OOBE. Default value is FALSE.'
        ),
    ] = None
    keyboard_selection_page_skipped: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, the keyboard selection page is hidden to the end user during OOBE if Language and Region are set. When FALSE, the keyboard selection page is skipped during OOBE.'
        ),
    ] = None
    privacy_settings_hidden: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, privacy settings is hidden to the end user during OOBE. When FALSE, privacy settings is shown to the end user during OOBE. Default value is FALSE.'
        ),
    ] = None
    user_type: Optional[WindowsUserType] = None
    field_odata_type: str


class ParticipantInfo(BaseModel):
    country_code: Annotated[
        Optional[str],
        Field(
            description="The ISO 3166-1 Alpha-2 country code of the participant's best estimated physical location at the start of the call. Read-only."
        ),
    ] = None
    endpoint_type: Annotated[
        Optional[Union[EndpointType, Dict[str, Any]]],
        Field(
            description='The type of endpoint the participant is using. Possible values are: default, skypeForBusiness, or skypeForBusinessVoipPhone. Read-only.'
        ),
    ] = None
    identity: Optional[IdentitySet] = None
    language_id: Annotated[
        Optional[str], Field(description='The language culture string. Read-only.')
    ] = None
    participant_id: Annotated[
        Optional[str],
        Field(description='The participant ID of the participant. Read-only.'),
    ] = None
    region: Annotated[
        Optional[str],
        Field(
            description="The home region of the participant. This can be a country, a continent, or a larger geographic region. This doesn't change based on the participant's current physical location. Read-only."
        ),
    ] = None
    field_odata_type: str


class PasswordCredentialConfiguration(BaseModel):
    max_lifetime: Annotated[
        Optional[timedelta],
        Field(
            description='String value that indicates the maximum lifetime for password expiration, defined as an ISO 8601 duration. For example, P4DT12H30M5S represents four days, 12 hours, 30 minutes, and five seconds. This property is required when restrictionType is set to passwordLifetime.',
        ),
    ] = None
    restrict_for_apps_created_after_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Specifies the date from which the policy restriction applies to newly created applications. For existing applications, the enforcement date can be retroactively applied.',
        ),
    ] = None
    restriction_type: Annotated[
        Optional[Union[AppCredentialRestrictionType, Dict[str, Any]]],
        Field(
            description='The type of restriction being applied. The possible values are: passwordAddition, passwordLifetime, symmetricKeyAddition, symmetricKeyLifetime, customPasswordAddition, and unknownFutureValue. Each value of restrictionType can be used only once per policy.'
        ),
    ] = None
    state: Optional[AppManagementRestrictionState] = None
    field_odata_type: str


class PayloadCoachmark(BaseModel):
    coachmark_location: Annotated[
        Optional[Union[CoachmarkLocation, Dict[str, Any]]],
        Field(description='The coachmark location.'),
    ] = None
    description: Annotated[
        Optional[str], Field(description='The description about the coachmark.')
    ] = None
    indicator: Annotated[
        Optional[str], Field(description='The coachmark indicator.')
    ] = None
    is_valid: Annotated[
        Optional[bool],
        Field(description='Indicates whether the coachmark is valid or not.'),
    ] = None
    language: Annotated[Optional[str], Field(description='The coachmark language.')] = (
        None
    )
    order: Annotated[Optional[str], Field(description='The coachmark order.')] = None
    field_odata_type: str


class PayloadDetail(BaseModel):
    coachmarks: Optional[List[PayloadCoachmark]] = None
    content: Annotated[Optional[str], Field(description='Payload content details.')] = (
        None
    )
    phishing_url: Annotated[
        Optional[str], Field(description='The phishing URL used to target a user.')
    ] = None
    field_odata_type: str


class PersistentBrowserSessionControl(ConditionalAccessSessionControl):
    mode: Annotated[
        Optional[Union[PersistentBrowserSessionMode, Dict[str, Any]]],
        Field(description='Possible values are: always, never.'),
    ] = None
    field_odata_type: str


class Phone(BaseModel):
    language: Optional[str] = None
    number: Annotated[Optional[str], Field(description='The phone number.')] = None
    region: Optional[str] = None
    type: Annotated[
        Optional[Union[PhoneType, Dict[str, Any]]],
        Field(
            description='The type of phone number. The possible values are: home, business, mobile, other, assistant, homeFax, businessFax, otherFax, pager, radio.'
        ),
    ] = None
    field_odata_type: str


class Photo(BaseModel):
    camera_make: Annotated[
        Optional[str], Field(description='Camera manufacturer. Read-only.')
    ] = None
    camera_model: Annotated[
        Optional[str], Field(description='Camera model. Read-only.')
    ] = None
    exposure_denominator: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='The denominator for the exposure time fraction from the camera. Read-only.'
        ),
    ] = None
    exposure_numerator: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='The numerator for the exposure time fraction from the camera. Read-only.'
        ),
    ] = None
    f_number: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='The F-stop value from the camera. Read-only.'),
    ] = None
    focal_length: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='The focal length from the camera. Read-only.'),
    ] = None
    iso: Annotated[
        Optional[float],
        Field(
            description='The ISO value from the camera. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    orientation: Annotated[
        Optional[float],
        Field(
            description='The orientation value from the camera. Writable on OneDrive Personal.',
            ge=-32768.0,
            le=32767.0,
        ),
    ] = None
    taken_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Represents the date and time the photo was taken. Read-only.',
        ),
    ] = None
    field_odata_type: str


class PlannerPlanContainer(BaseModel):
    container_id: Annotated[
        Optional[str],
        Field(
            description='The identifier of the resource that contains the plan. Optional.'
        ),
    ] = None
    type: Annotated[
        Optional[Union[PlannerContainerType, Dict[str, Any]]],
        Field(
            description='The type of the resource that contains the plan. For supported types, see the previous table. Possible values are: group, unknownFutureValue, roster. Use the Prefer: include-unknown-enum-members request header to get the following value in this evolvable enum: roster. Optional.'
        ),
    ] = None
    url: Annotated[
        Optional[str],
        Field(description='The full canonical URL of the container. Optional.'),
    ] = None
    field_odata_type: str


class PresenceStatusMessage(BaseModel):
    expiry_date_time: Annotated[
        Optional[Union[DateTimeTimeZone, Dict[str, Any]]],
        Field(
            description="Time in which the status message expires.If not provided, the status message doesn't expire.expiryDateTime.dateTime shouldn't include time zone.expiryDateTime isn't available when you request the presence of another user."
        ),
    ] = None
    message: Annotated[
        Optional[Union[ItemBody, Dict[str, Any]]],
        Field(
            description="Status message item. The only supported format currently is message.contentType = 'text'."
        ),
    ] = None
    published_date_time: Annotated[
        Optional[datetime],
        Field(
            description="Time in which the status message was published.Read-only.publishedDateTime isn't available when you request the presence of another user.",
        ),
    ] = None
    field_odata_type: str


class PrinterCapabilities(BaseModel):
    bottom_margins: Annotated[
        Optional[List[BottomMargin]],
        Field(
            description='A list of supported bottom margins(in microns) for the printer.'
        ),
    ] = None
    collation: Annotated[
        Optional[bool],
        Field(
            description='True if the printer supports collating when printing muliple copies of a multi-page document; false otherwise.'
        ),
    ] = None
    color_modes: Annotated[
        Optional[List[Union[PrintColorMode, Dict[str, Any]]]],
        Field(
            description='The color modes supported by the printer. Valid values are described in the following table.'
        ),
    ] = None
    content_types: Annotated[
        Optional[List[str]],
        Field(
            description='A list of supported content (MIME) types that the printer supports. It is not guaranteed that the Universal Print service supports printing all of these MIME types.'
        ),
    ] = None
    copies_per_job: Annotated[
        Optional[Union[IntegerRange, Dict[str, Any]]],
        Field(description='The range of copies per job supported by the printer.'),
    ] = None
    dpis: Annotated[
        Optional[List[Dpi]],
        Field(
            description='The list of print resolutions in DPI that are supported by the printer.'
        ),
    ] = None
    duplex_modes: Annotated[
        Optional[List[Union[PrintDuplexMode, Dict[str, Any]]]],
        Field(
            description='The list of duplex modes that are supported by the printer. Valid values are described in the following table.'
        ),
    ] = None
    feed_orientations: Annotated[
        Optional[List[Union[PrinterFeedOrientation, Dict[str, Any]]]],
        Field(
            description='The list of feed orientations that are supported by the printer.'
        ),
    ] = None
    finishings: Annotated[
        Optional[List[Union[PrintFinishing, Dict[str, Any]]]],
        Field(
            description='Finishing processes the printer supports for a printed document.'
        ),
    ] = None
    input_bins: Annotated[
        Optional[List[str]], Field(description='Supported input bins for the printer.')
    ] = None
    is_color_printing_supported: Annotated[
        Optional[bool],
        Field(
            description='True if color printing is supported by the printer; false otherwise. Read-only.'
        ),
    ] = None
    is_page_range_supported: Annotated[
        Optional[bool],
        Field(
            description='True if the printer supports printing by page ranges; false otherwise.'
        ),
    ] = None
    left_margins: Annotated[
        Optional[List[LeftMargin]],
        Field(
            description='A list of supported left margins(in microns) for the printer.'
        ),
    ] = None
    media_colors: Annotated[
        Optional[List[str]],
        Field(description='The media (i.e., paper) colors supported by the printer.'),
    ] = None
    media_sizes: Annotated[
        Optional[List[str]],
        Field(
            description='The media sizes supported by the printer. Supports standard size names for ISO and ANSI media sizes. Valid values are in the following table.'
        ),
    ] = None
    media_types: Annotated[
        Optional[List[str]],
        Field(description='The media types supported by the printer.'),
    ] = None
    multipage_layouts: Annotated[
        Optional[List[Union[PrintMultipageLayout, Dict[str, Any]]]],
        Field(
            description='The presentation directions supported by the printer. Supported values are described in the following table.'
        ),
    ] = None
    orientations: Annotated[
        Optional[List[Union[PrintOrientation, Dict[str, Any]]]],
        Field(
            description='The print orientations supported by the printer. Valid values are described in the following table.'
        ),
    ] = None
    output_bins: Annotated[
        Optional[List[str]],
        Field(description="The printer's supported output bins (trays)."),
    ] = None
    pages_per_sheet: Annotated[
        Optional[List[PagesPerSheetItem]],
        Field(
            description='Supported number of Input Pages to impose upon a single Impression.'
        ),
    ] = None
    qualities: Annotated[
        Optional[List[Union[PrintQuality, Dict[str, Any]]]],
        Field(description='The print qualities supported by the printer.'),
    ] = None
    right_margins: Annotated[
        Optional[List[RightMargin]],
        Field(
            description='A list of supported right margins(in microns) for the printer.'
        ),
    ] = None
    scalings: Annotated[
        Optional[List[Union[PrintScaling, Dict[str, Any]]]],
        Field(description='Supported print scalings.'),
    ] = None
    supports_fit_pdf_to_page: Annotated[
        Optional[bool],
        Field(
            description='True if the printer supports scaling PDF pages to match the print media size; false otherwise.'
        ),
    ] = None
    top_margins: Annotated[
        Optional[List[TopMargin]],
        Field(
            description='A list of supported top margins(in microns) for the printer.'
        ),
    ] = None
    field_odata_type: str


class PrinterDefaults(BaseModel):
    color_mode: Annotated[
        Optional[Union[PrintColorMode, Dict[str, Any]]],
        Field(
            description='The default color mode to use when printing the document. Valid values are described in the following table.'
        ),
    ] = None
    content_type: Annotated[
        Optional[str],
        Field(
            description='The default content (MIME) type to use when processing documents.'
        ),
    ] = None
    copies_per_job: Annotated[
        Optional[float],
        Field(
            description='The default number of copies printed per job.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    dpi: Annotated[
        Optional[float],
        Field(
            description='The default resolution in DPI to use when printing the job.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    duplex_mode: Annotated[
        Optional[Union[PrintDuplexMode, Dict[str, Any]]],
        Field(
            description='The default duplex (double-sided) configuration to use when printing a document. Valid values are described in the following table.'
        ),
    ] = None
    finishings: Annotated[
        Optional[List[Union[PrintFinishing, Dict[str, Any]]]],
        Field(
            description='The default set of finishings to apply to print jobs. Valid values are described in the following table.'
        ),
    ] = None
    fit_pdf_to_page: Annotated[
        Optional[bool],
        Field(
            description='The default fitPdfToPage setting. True to fit each page of a PDF document to a physical sheet of media; false to let the printer decide how to lay out impressions.'
        ),
    ] = None
    input_bin: Annotated[
        Optional[str],
        Field(description='The default input bin that serves as the paper source.'),
    ] = None
    media_color: Annotated[
        Optional[str],
        Field(
            description='The default media (such as paper) color to print the document on.'
        ),
    ] = None
    media_size: Annotated[
        Optional[str],
        Field(
            description='The default media size to use. Supports standard size names for ISO and ANSI media sizes. Valid values are listed in the printerCapabilities topic.'
        ),
    ] = None
    media_type: Annotated[
        Optional[str],
        Field(
            description='The default media (such as paper) type to print the document on.'
        ),
    ] = None
    multipage_layout: Annotated[
        Optional[Union[PrintMultipageLayout, Dict[str, Any]]],
        Field(
            description='The default direction to lay out pages when multiple pages are being printed per sheet. Valid values are described in the following table.'
        ),
    ] = None
    orientation: Annotated[
        Optional[Union[PrintOrientation, Dict[str, Any]]],
        Field(
            description='The default orientation to use when printing the document. Valid values are described in the following table.'
        ),
    ] = None
    output_bin: Annotated[
        Optional[str],
        Field(
            description="The default output bin to place completed prints into. See the printer's capabilities for a list of supported output bins."
        ),
    ] = None
    pages_per_sheet: Annotated[
        Optional[float],
        Field(
            description='The default number of document pages to print on each sheet.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    quality: Annotated[
        Optional[Union[PrintQuality, Dict[str, Any]]],
        Field(
            description='The default quality to use when printing the document. Valid values are described in the following table.'
        ),
    ] = None
    scaling: Annotated[
        Optional[Union[PrintScaling, Dict[str, Any]]],
        Field(
            description='Specifies how the printer scales the document data to fit the requested media. Valid values are described in the following table.'
        ),
    ] = None
    field_odata_type: str


class PrinterLocation(BaseModel):
    altitude_in_meters: Annotated[
        Optional[float],
        Field(
            description='The altitude, in meters, that the printer is located at.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    building: Annotated[
        Optional[str], Field(description='The building that the printer is located in.')
    ] = None
    city: Annotated[
        Optional[str], Field(description='The city that the printer is located in.')
    ] = None
    country_or_region: Annotated[
        Optional[str],
        Field(description='The country or region that the printer is located in.'),
    ] = None
    floor: Annotated[
        Optional[str],
        Field(
            description='The floor that the printer is located on. Only numerical values are supported right now.'
        ),
    ] = None
    floor_description: Annotated[
        Optional[str],
        Field(
            description='The description of the floor that the printer is located on.'
        ),
    ] = None
    latitude: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='The latitude that the printer is located at.'),
    ] = None
    longitude: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='The longitude that the printer is located at.'),
    ] = None
    organization: Annotated[
        Optional[List[str]],
        Field(
            description='The organizational hierarchy that the printer belongs to. The elements should be in hierarchical order.'
        ),
    ] = None
    postal_code: Annotated[
        Optional[str],
        Field(description='The postal code that the printer is located in.'),
    ] = None
    room_description: Annotated[
        Optional[str],
        Field(
            description='The description of the room that the printer is located in.'
        ),
    ] = None
    room_name: Annotated[
        Optional[str],
        Field(
            description='The room that the printer is located in. Only numerical values are supported right now.'
        ),
    ] = None
    site: Annotated[
        Optional[str], Field(description='The site that the printer is located in.')
    ] = None
    state_or_province: Annotated[
        Optional[str],
        Field(description='The state or province that the printer is located in.'),
    ] = None
    street_address: Annotated[
        Optional[str],
        Field(description='The street address where the printer is located.'),
    ] = None
    subdivision: Annotated[
        Optional[List[str]],
        Field(
            description='The subdivision that the printer is located in. The elements should be in hierarchical order.'
        ),
    ] = None
    subunit: Optional[List[str]] = None
    field_odata_type: str


class PrinterStatus(BaseModel):
    description: Annotated[
        Optional[str],
        Field(
            description="A human-readable description of the printer's current processing state. Read-only."
        ),
    ] = None
    details: Annotated[
        Optional[List[PrinterProcessingStateDetail]],
        Field(
            description='The list of details describing why the printer is in the current state. Valid values are described in the following table. Read-only.'
        ),
    ] = None
    state: Optional[PrinterProcessingState] = None
    field_odata_type: str


class PrintJobConfiguration(BaseModel):
    collate: Annotated[
        Optional[bool],
        Field(
            description='Whether the printer should collate pages wehen printing multiple copies of a multi-page document.'
        ),
    ] = None
    color_mode: Annotated[
        Optional[Union[PrintColorMode, Dict[str, Any]]],
        Field(
            description='The color mode the printer should use to print the job. Valid values are described in the table below. Read-only.'
        ),
    ] = None
    copies: Annotated[
        Optional[float],
        Field(
            description='The number of copies that should be printed. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    dpi: Annotated[
        Optional[float],
        Field(
            description='The resolution to use when printing the job, expressed in dots per inch (DPI). Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    duplex_mode: Annotated[
        Optional[Union[PrintDuplexMode, Dict[str, Any]]],
        Field(
            description='The duplex mode the printer should use when printing the job. Valid values are described in the table below. Read-only.'
        ),
    ] = None
    feed_orientation: Annotated[
        Optional[Union[PrinterFeedOrientation, Dict[str, Any]]],
        Field(
            description='The orientation to use when feeding media into the printer. Valid values are described in the following table. Read-only.'
        ),
    ] = None
    finishings: Annotated[
        Optional[List[Union[PrintFinishing, Dict[str, Any]]]],
        Field(description='Finishing processes to use when printing.'),
    ] = None
    fit_pdf_to_page: Annotated[
        Optional[bool],
        Field(
            description='True to fit each page of a PDF document to a physical sheet of media; false to let the printer decide how to lay out impressions.'
        ),
    ] = None
    input_bin: Annotated[
        Optional[str],
        Field(
            description="The input bin (tray) to use when printing. See the printer's capabilities for a list of supported input bins."
        ),
    ] = None
    margin: Annotated[
        Optional[Union[PrintMargin, Dict[str, Any]]],
        Field(description='The margin settings to use when printing.'),
    ] = None
    media_size: Annotated[
        Optional[str],
        Field(
            description='The media size to use when printing. Supports standard size names for ISO and ANSI media sizes. Valid values listed in the printerCapabilities topic.'
        ),
    ] = None
    media_type: Annotated[
        Optional[str],
        Field(
            description='The default media (such as paper) type to print the document on.'
        ),
    ] = None
    multipage_layout: Annotated[
        Optional[Union[PrintMultipageLayout, Dict[str, Any]]],
        Field(
            description='The direction to lay out pages when multiple pages are being printed per sheet. Valid values are described in the following table.'
        ),
    ] = None
    orientation: Annotated[
        Optional[Union[PrintOrientation, Dict[str, Any]]],
        Field(
            description='The orientation setting the printer should use when printing the job. Valid values are described in the following table.'
        ),
    ] = None
    output_bin: Annotated[
        Optional[str],
        Field(
            description="The output bin to place completed prints into. See the printer's capabilities for a list of supported output bins."
        ),
    ] = None
    page_ranges: Annotated[
        Optional[List[IntegerRange]],
        Field(description='The page ranges to print. Read-only.'),
    ] = None
    pages_per_sheet: Annotated[
        Optional[float],
        Field(
            description='The number of document pages to print on each sheet.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    quality: Annotated[
        Optional[Union[PrintQuality, Dict[str, Any]]],
        Field(
            description='The print quality to use when printing the job. Valid values are described in the table below. Read-only.'
        ),
    ] = None
    scaling: Annotated[
        Optional[Union[PrintScaling, Dict[str, Any]]],
        Field(
            description='Specifies how the printer should scale the document data to fit the requested media. Valid values are described in the following table.'
        ),
    ] = None
    field_odata_type: str


class PrintJobStatus(BaseModel):
    description: Annotated[
        Optional[str],
        Field(
            description="A human-readable description of the print job's current processing state. Read-only."
        ),
    ] = None
    details: Annotated[
        Optional[List[PrintJobStateDetail]],
        Field(
            description='Additional details for print job state. Valid values are described in the following table. Read-only.'
        ),
    ] = None
    is_acquired_by_printer: Annotated[
        Optional[bool],
        Field(
            description='True if the job was acknowledged by a printer; false otherwise. Read-only.'
        ),
    ] = None
    state: Optional[PrintJobProcessingState] = None
    field_odata_type: str


class PrintOperationStatus(BaseModel):
    description: Annotated[
        Optional[str],
        Field(
            description="A human-readable description of the printOperation's current processing state. Read-only."
        ),
    ] = None
    state: Optional[PrintOperationProcessingState] = None
    field_odata_type: str


class PrintTaskStatus(BaseModel):
    description: Annotated[
        Optional[str],
        Field(
            description='A human-readable description of the current processing state of the printTask.'
        ),
    ] = None
    state: Optional[PrintTaskProcessingState] = None
    field_odata_type: str


class Process(BaseModel):
    account_name: Annotated[
        Optional[str],
        Field(
            description='User account identifier (user account context the process ran under) for example, AccountName, SID, and so on.'
        ),
    ] = None
    command_line: Annotated[
        Optional[str],
        Field(
            description='The full process invocation commandline including all parameters.'
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Time at which the process was started. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    file_hash: Annotated[
        Optional[Union[FileHash, Dict[str, Any]]],
        Field(
            description='Complex type containing file hashes (cryptographic and location-sensitive).'
        ),
    ] = None
    integrity_level: Annotated[
        Optional[Union[ProcessIntegrityLevel, Dict[str, Any]]],
        Field(
            description='The integrity level of the process. Possible values are: unknown, untrusted, low, medium, high, system.'
        ),
    ] = None
    is_elevated: Annotated[
        Optional[bool], Field(description='True if the process is elevated.')
    ] = None
    name: Annotated[
        Optional[str], Field(description="The name of the process' Image file.")
    ] = None
    parent_process_created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='DateTime at which the parent process was started. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    parent_process_id: Annotated[
        Optional[float],
        Field(
            description='The Process ID (PID) of the parent process.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    parent_process_name: Annotated[
        Optional[str],
        Field(description='The name of the image file of the parent process.'),
    ] = None
    path: Annotated[
        Optional[str], Field(description='Full path, including filename.')
    ] = None
    process_id: Annotated[
        Optional[float],
        Field(
            description='The Process ID (PID) of the process.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class ProvisioningErrorInfo(BaseModel):
    additional_details: Annotated[
        Optional[str], Field(description="Additional details if there's error.")
    ] = None
    error_category: Annotated[
        Optional[Union[ProvisioningStatusErrorCategory, Dict[str, Any]]],
        Field(
            description='Categorizes the error code. Possible values are failure, nonServiceFailure, success, unknownFutureValue'
        ),
    ] = None
    error_code: Annotated[
        Optional[str],
        Field(description='Unique error code if any occurred. Learn more'),
    ] = None
    reason: Annotated[
        Optional[str],
        Field(
            description='Summarizes the status and describes why the status happened.'
        ),
    ] = None
    recommended_action: Annotated[
        Optional[str],
        Field(description='Provides the resolution for the corresponding error.'),
    ] = None
    field_odata_type: str


class ProvisioningStatusInfo(BaseModel):
    error_information: Annotated[
        Optional[Union[ProvisioningErrorInfo, Dict[str, Any]]],
        Field(
            description="If status isn't success/ skipped details for the error are contained in this."
        ),
    ] = None
    status: Annotated[
        Optional[Union[ProvisioningResult, Dict[str, Any]]],
        Field(
            description='Possible values are: success, warning, failure, skipped, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class ProvisioningStep(BaseModel):
    description: Annotated[
        Optional[str], Field(description='Summary of what occurred during the step.')
    ] = None
    details: Annotated[
        Optional[Union[DetailsInfo, Dict[str, Any]]],
        Field(description='Details of what occurred during the step.'),
    ] = None
    name: Annotated[Optional[str], Field(description='Name of the step.')] = None
    provisioning_step_type: Annotated[
        Optional[Union[ProvisioningStepType, Dict[str, Any]]],
        Field(
            description='Type of step. Possible values are: import, scoping, matching, processing, referenceResolution, export, unknownFutureValue.'
        ),
    ] = None
    status: Annotated[
        Optional[Union[ProvisioningResult, Dict[str, Any]]],
        Field(
            description='Status of the step. Possible values are: success, warning,  failure, skipped, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class PublicError(BaseModel):
    code: Annotated[Optional[str], Field(description='Represents the error code.')] = (
        None
    )
    details: Annotated[
        Optional[List[PublicErrorDetail]], Field(description='Details of the error.')
    ] = None
    inner_error: Annotated[
        Optional[Union[PublicInnerError, Dict[str, Any]]],
        Field(description='Details of the inner error.'),
    ] = None
    message: Annotated[
        Optional[str], Field(description='A non-localized message for the developer.')
    ] = None
    target: Annotated[Optional[str], Field(description='The target of the error.')] = (
        None
    )
    field_odata_type: str


class PublicErrorResponse(BaseModel):
    error: Optional[Union[PublicError, Dict[str, Any]]] = None
    field_odata_type: str


class Quota(BaseModel):
    deleted: Annotated[
        Optional[float],
        Field(
            description='Total space consumed by files in the recycle bin, in bytes. Read-only.'
        ),
    ] = None
    remaining: Annotated[
        Optional[float],
        Field(
            description='Total space remaining before reaching the capacity limit, in bytes. Read-only.'
        ),
    ] = None
    state: Annotated[
        Optional[str],
        Field(
            description='Enumeration value that indicates the state of the storage space. Read-only.'
        ),
    ] = None
    storage_plan_information: Annotated[
        Optional[Union[StoragePlanInformation, Dict[str, Any]]],
        Field(
            description="Information about the drive's storage quota plans. Only in Personal OneDrive."
        ),
    ] = None
    total: Annotated[
        Optional[float],
        Field(description='Total allowed storage space, in bytes. Read-only.'),
    ] = None
    used: Annotated[
        Optional[float], Field(description='Total space used, in bytes. Read-only.')
    ] = None
    field_odata_type: str


class RecentNotebook(BaseModel):
    display_name: Annotated[
        Optional[str], Field(description='The name of the notebook.')
    ] = None
    last_accessed_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the notebook was last modified. The timestamp represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.',
        ),
    ] = None
    links: Annotated[
        Optional[Union[RecentNotebookLinks, Dict[str, Any]]],
        Field(
            description="Links for opening the notebook. The oneNoteClientURL link opens the notebook in the OneNote client, if it's installed. The oneNoteWebURL link opens the notebook in OneNote on the web."
        ),
    ] = None
    source_service: Annotated[
        Optional[Union[OnenoteSourceService, Dict[str, Any]]],
        Field(
            description='The backend store where the Notebook resides, either OneDriveForBusiness or OneDrive.'
        ),
    ] = None
    field_odata_type: str


class RecommendedAction(BaseModel):
    action_web_url: Annotated[
        Optional[str], Field(description='Web URL to the recommended action.')
    ] = None
    potential_score_impact: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='Potential improvement in the tenant security score from the recommended action.'
        ),
    ] = None
    title: Annotated[
        Optional[str], Field(description='Title of the recommended action.')
    ] = None
    field_odata_type: str


class RecordingInfo(BaseModel):
    initiator: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='The identities of the recording initiator.'),
    ] = None
    recording_status: Optional[RecordingStatus] = None
    field_odata_type: str


class RecurrencePattern(BaseModel):
    day_of_month: Annotated[
        Optional[float],
        Field(
            description='The day of the month on which the event occurs. Required if type is absoluteMonthly or absoluteYearly.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    days_of_week: Annotated[
        Optional[List[Union[DayOfWeek, Dict[str, Any]]]],
        Field(
            description='A collection of the days of the week on which the event occurs. The possible values are: sunday, monday, tuesday, wednesday, thursday, friday, saturday. If type is relativeMonthly or relativeYearly, and daysOfWeek specifies more than one day, the event falls on the first day that satisfies the pattern.  Required if type is weekly, relativeMonthly, or relativeYearly.'
        ),
    ] = None
    first_day_of_week: Annotated[
        Optional[Union[DayOfWeek, Dict[str, Any]]],
        Field(
            description='The first day of the week. The possible values are: sunday, monday, tuesday, wednesday, thursday, friday, saturday. Default is sunday. Required if type is weekly.'
        ),
    ] = None
    index: Annotated[
        Optional[Union[WeekIndex, Dict[str, Any]]],
        Field(
            description='Specifies on which instance of the allowed days specified in daysOfWeek the event occurs, counted from the first instance in the month. The possible values are: first, second, third, fourth, last. Default is first. Optional and used if type is relativeMonthly or relativeYearly.'
        ),
    ] = None
    interval: Annotated[
        Optional[float],
        Field(
            description='The number of units between occurrences, where units can be in days, weeks, months, or years, depending on the type. Required.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    month: Annotated[
        Optional[float],
        Field(
            description='The month in which the event occurs.  This is a number from 1 to 12.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    type: Annotated[
        Optional[Union[RecurrencePatternType, Dict[str, Any]]],
        Field(
            description='The recurrence pattern type: daily, weekly, absoluteMonthly, relativeMonthly, absoluteYearly, relativeYearly. Required. For more information, see values of type property.'
        ),
    ] = None
    field_odata_type: str


class RecurrenceRange(BaseModel):
    end_date: Annotated[
        Optional[date],
        Field(
            description='The date to stop applying the recurrence pattern. Depending on the recurrence pattern of the event, the last occurrence of the meeting may not be this date. Required if type is endDate.',
        ),
    ] = None
    number_of_occurrences: Annotated[
        Optional[float],
        Field(
            description='The number of times to repeat the event. Required and must be positive if type is numbered.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    recurrence_time_zone: Annotated[
        Optional[str],
        Field(
            description='Time zone for the startDate and endDate properties. Optional. If not specified, the time zone of the event is used.'
        ),
    ] = None
    start_date: Annotated[
        Optional[date],
        Field(
            description='The date to start applying the recurrence pattern. The first occurrence of the meeting may be this date or later, depending on the recurrence pattern of the event. Must be the same value as the start property of the recurring event. Required.',
        ),
    ] = None
    type: Annotated[
        Optional[Union[RecurrenceRangeType, Dict[str, Any]]],
        Field(
            description='The recurrence range. The possible values are: endDate, noEnd, numbered. Required.'
        ),
    ] = None
    field_odata_type: str


class RegistryKeyState(BaseModel):
    hive: Annotated[
        Optional[Union[RegistryHive, Dict[str, Any]]],
        Field(
            description='A Windows registry hive : HKEYCURRENTCONFIG HKEYCURRENTUSER HKEYLOCALMACHINE/SAM HKEYLOCALMACHINE/Security HKEYLOCALMACHINE/Software HKEYLOCALMACHINE/System HKEY_USERS/.Default. Possible values are: unknown, currentConfig, currentUser, localMachineSam, localMachineSecurity, localMachineSoftware, localMachineSystem, usersDefault.'
        ),
    ] = None
    key: Annotated[
        Optional[str],
        Field(description='Current (i.e. changed) registry key (excludes HIVE).'),
    ] = None
    old_key: Annotated[
        Optional[str],
        Field(
            description='Previous (i.e. before changed) registry key (excludes HIVE).'
        ),
    ] = None
    old_value_data: Annotated[
        Optional[str],
        Field(
            description='Previous (i.e. before changed) registry key value data (contents).'
        ),
    ] = None
    old_value_name: Annotated[
        Optional[str],
        Field(description='Previous (i.e. before changed) registry key value name.'),
    ] = None
    operation: Annotated[
        Optional[Union[RegistryOperation, Dict[str, Any]]],
        Field(
            description='Operation that changed the registry key name and/or value. Possible values are: unknown, create, modify, delete.'
        ),
    ] = None
    process_id: Annotated[
        Optional[float],
        Field(
            description="Process ID (PID) of the process that modified the registry key (process details will appear in the alert 'processes' collection).",
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    value_data: Annotated[
        Optional[str],
        Field(description='Current (i.e. changed) registry key value data (contents).'),
    ] = None
    value_name: Annotated[
        Optional[str],
        Field(description='Current (i.e. changed) registry key value name'),
    ] = None
    value_type: Annotated[
        Optional[Union[RegistryValueType, Dict[str, Any]]],
        Field(
            description='Registry key value type REGBINARY REGDWORD REGDWORDLITTLEENDIAN REGDWORDBIGENDIANREGEXPANDSZ REGLINK REGMULTISZ REGNONE REGQWORD REGQWORDLITTLEENDIAN REG_SZ Possible values are: unknown, binary, dword, dwordLittleEndian, dwordBigEndian, expandSz, link, multiSz, none, qword, qwordlittleEndian, sz.'
        ),
    ] = None
    field_odata_type: str


class RejectJoinResponse(ParticipantJoiningResponse):
    reason: Optional[RejectReason] = None
    field_odata_type: str


class RelatedContact(BaseModel):
    access_consent: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the user has been consented to access student data.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='Name of the contact. Required.')
    ] = None
    email_address: Annotated[
        Optional[str],
        Field(description='Primary email address of the contact. Required.'),
    ] = None
    mobile_phone: Annotated[
        Optional[str], Field(description='Mobile phone number of the contact.')
    ] = None
    relationship: Optional[ContactRelationship] = None
    field_odata_type: str


class RemoteLockActionResult(DeviceActionResult):
    unlock_pin: Annotated[
        Optional[str], Field(description='Pin to unlock the client')
    ] = None
    field_odata_type: str


class RequestorManager(SubjectSet):
    manager_level: Annotated[
        Optional[float],
        Field(
            description="The hierarchical level of the manager with respect to the requestor. For example, the direct manager of a requestor would have a managerLevel of 1, while the manager of the requestor's manager would have a managerLevel of 2. Default value for managerLevel is 1. Possible values for this property range from 1 to 2.",
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class RequestSignatureVerification(BaseModel):
    allowed_weak_algorithms: Annotated[
        Optional[Union[WeakAlgorithms, Dict[str, Any]]],
        Field(
            description='Specifies which weak algorithms are allowed.  The possible values are: rsaSha1, unknownFutureValue.'
        ),
    ] = None
    is_signed_request_required: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether signed authentication requests for this application should be required.'
        ),
    ] = None
    field_odata_type: str


class RequiredResourceAccess(BaseModel):
    resource_access: Annotated[
        Optional[List[ResourceAccess]],
        Field(
            description='The list of OAuth2.0 permission scopes and app roles that the application requires from the specified resource.'
        ),
    ] = None
    resource_app_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier for the resource that the application requires access to. This should be equal to the appId declared on the target resource application.'
        ),
    ] = None
    field_odata_type: str


class ResetPasscodeActionResult(DeviceActionResult):
    error_code: Annotated[
        Optional[float],
        Field(
            description='RotateBitLockerKeys action error code. Valid values 0 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    passcode: Annotated[
        Optional[str], Field(description='Newly generated passcode for the device')
    ] = None
    field_odata_type: str


class ResponseStatus(BaseModel):
    response: Annotated[
        Optional[Union[ResponseType, Dict[str, Any]]],
        Field(
            description="The response type. Possible values are: none, organizer, tentativelyAccepted, accepted, declined, notResponded.To differentiate between none and notResponded:  none  from organizer's perspective. This value is used when the status of an attendee/participant is reported to the organizer of a meeting.  notResponded  from attendee's perspective. Indicates the attendee has not responded to the meeting request.  Clients can treat notResponded == none.  As an example, if attendee Alex hasn't responded to a meeting request, getting Alex' response status for that event in Alex' calendar returns notResponded. Getting Alex' response from the calendar of any other attendee or the organizer's returns none. Getting the organizer's response for the event in anybody's calendar also returns none."
        ),
    ] = None
    time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the response was returned. It uses ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z',
        ),
    ] = None
    field_odata_type: str


class RetentionLabelSettings(BaseModel):
    behavior_during_retention_period: Annotated[
        Optional[Union[security.BehaviorDuringRetentionPeriod, Dict[str, Any]]],
        Field(
            description='Describes the item behavior during retention period. Possible values are: doNotRetain, retain, retainAsRecord, retainAsRegulatoryRecord, unknownFutureValue. Read-only.'
        ),
    ] = None
    is_content_update_allowed: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether updates to document content are allowed. Read-only.'
        ),
    ] = None
    is_delete_allowed: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether the document deletion is allowed. Read-only.'
        ),
    ] = None
    is_label_update_allowed: Annotated[
        Optional[bool],
        Field(
            description="Specifies whether you're allowed to change the retention label on the document. Read-only."
        ),
    ] = None
    is_metadata_update_allowed: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether updates to the item metadata (for example, the Title field) are blocked. Read-only.'
        ),
    ] = None
    is_record_locked: Annotated[
        Optional[bool],
        Field(description='Specifies whether the item is locked. Read-write.'),
    ] = None
    field_odata_type: str


class RiskServicePrincipalActivity(BaseModel):
    detail: Annotated[
        Optional[Union[RiskDetail, Dict[str, Any]]],
        Field(
            description='Details of the detected risk. Note: Details for this property are only available for Workload Identities Premium customers. Events in tenants without this license will be returned hidden. The possible values are: none, hidden, adminConfirmedServicePrincipalCompromised, adminDismissedAllRiskForServicePrincipal. Use the Prefer: include-unknown-enum-members request header to get the following value(s) in this evolvable enum: adminConfirmedServicePrincipalCompromised , adminDismissedAllRiskForServicePrincipal.'
        ),
    ] = None
    risk_event_types: Annotated[
        Optional[List[str]],
        Field(
            description='The type of risk event detected. The possible values are: investigationsThreatIntelligence, generic, adminConfirmedServicePrincipalCompromised, suspiciousSignins, leakedCredentials, anomalousServicePrincipalActivity, maliciousApplication, suspiciousApplication.'
        ),
    ] = None
    field_odata_type: str


class RiskUserActivity(BaseModel):
    detail: Annotated[
        Optional[Union[RiskDetail, Dict[str, Any]]],
        Field(
            description='Details of the detected risk. Possible values are: none, adminGeneratedTemporaryPassword, userPerformedSecuredPasswordChange, userPerformedSecuredPasswordReset, adminConfirmedSigninSafe, aiConfirmedSigninSafe, userPassedMFADrivenByRiskBasedPolicy, adminDismissedAllRiskForUser, adminConfirmedSigninCompromised, hidden, adminConfirmedUserCompromised, unknownFutureValue. For more information about each value, see Risk types and detection.'
        ),
    ] = None
    risk_event_types: Annotated[
        Optional[List[str]], Field(description='The type of risk event detected.')
    ] = None
    field_odata_type: str


class RotateBitLockerKeysDeviceActionResult(DeviceActionResult):
    error_code: Annotated[
        Optional[float],
        Field(
            description='RotateBitLockerKeys action error code',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class RubricCriterion(BaseModel):
    description: Annotated[
        Optional[Union[EducationItemBody, Dict[str, Any]]],
        Field(description='The description of this criterion.'),
    ] = None
    field_odata_type: str


class RubricLevel(BaseModel):
    description: Annotated[
        Optional[Union[EducationItemBody, Dict[str, Any]]],
        Field(description='The description of this rubric level.'),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The name of this rubric level.')
    ] = None
    grading: Annotated[
        Optional[Union[EducationAssignmentGradeType, Dict[str, Any]]],
        Field(
            description="Null if this is a no-points rubric; educationAssignmentPointsGradeType if it's a points rubric."
        ),
    ] = None
    level_id: Annotated[
        Optional[str], Field(description='The ID of this resource.')
    ] = None
    field_odata_type: str


class RubricQuality(BaseModel):
    criteria: Annotated[
        Optional[List[RubricCriterion]],
        Field(description='The collection of criteria for this rubric quality.'),
    ] = None
    description: Annotated[
        Optional[Union[EducationItemBody, Dict[str, Any]]],
        Field(description='The description of this rubric quality.'),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The name of this rubric quality.')
    ] = None
    quality_id: Annotated[
        Optional[str], Field(description='The ID of this resource.')
    ] = None
    weight: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='If present, a numerical weight for this quality.  Weights must add up to 100.'
        ),
    ] = None
    field_odata_type: str


class RubricQualityFeedbackModel(BaseModel):
    feedback: Annotated[
        Optional[Union[EducationItemBody, Dict[str, Any]]],
        Field(description='Specific feedback for one quality of this rubric.'),
    ] = None
    quality_id: Annotated[
        Optional[str],
        Field(
            description='The ID of the rubricQuality that this feedback is related to.'
        ),
    ] = None
    field_odata_type: str


class ScheduleEntity(BaseModel):
    end_date_time: Annotated[
        Optional[datetime],
        Field(
        ),
    ] = None
    start_date_time: Annotated[
        Optional[datetime],
        Field(
        ),
    ] = None
    theme: Optional[ScheduleEntityTheme] = None
    field_odata_type: str


class ScheduleItem(BaseModel):
    end: Annotated[
        Optional[Union[DateTimeTimeZone, Dict[str, Any]]],
        Field(
            description='The date, time, and time zone that the corresponding event ends.'
        ),
    ] = None
    is_private: Annotated[
        Optional[bool],
        Field(
            description='The sensitivity of the corresponding event. True if the event is marked private, false otherwise. Optional.'
        ),
    ] = None
    location: Annotated[
        Optional[str],
        Field(
            description='The location where the corresponding event is held or attended from. Optional.'
        ),
    ] = None
    start: Annotated[
        Optional[Union[DateTimeTimeZone, Dict[str, Any]]],
        Field(
            description='The date, time, and time zone that the corresponding event starts.'
        ),
    ] = None
    status: Annotated[
        Optional[Union[FreeBusyStatus, Dict[str, Any]]],
        Field(
            description='The availability status of the user or resource during the corresponding event. The possible values are: free, tentative, busy, oof, workingElsewhere, unknown.'
        ),
    ] = None
    subject: Annotated[
        Optional[str],
        Field(description="The corresponding event's subject line. Optional."),
    ] = None
    field_odata_type: str


class ScoredEmailAddress(BaseModel):
    address: Annotated[Optional[str], Field(description='The email address.')] = None
    item_id: Optional[str] = None
    relevance_score: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='The relevance score of the email address. A relevance score is used as a sort key, in relation to the other returned results. A higher relevance score value corresponds to a more relevant result. Relevance is determined by the users communication and collaboration patterns and business relationships.'
        ),
    ] = None
    selection_likelihood: Optional[Union[SelectionLikelihoodInfo, Dict[str, Any]]] = (
        None
    )
    field_odata_type: str


class SearchAggregation(BaseModel):
    buckets: Optional[List[SearchBucket]] = None
    field: Optional[str] = None
    field_odata_type: str


class SearchHitsContainer(BaseModel):
    aggregations: Optional[List[SearchAggregation]] = None
    hits: Annotated[
        Optional[List[SearchHit]],
        Field(description='A collection of the search results.'),
    ] = None
    more_results_available: Annotated[
        Optional[bool],
        Field(
            description='Provides information if more results are available. Based on this information, you can adjust the from and size properties of the searchRequest accordingly.'
        ),
    ] = None
    total: Annotated[
        Optional[float],
        Field(
            description="The total number of results. Note this isn't the number of results on the page, but the total number of results satisfying the query.",
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class SearchResponse(BaseModel):
    hits_containers: Annotated[
        Optional[List[SearchHitsContainer]],
        Field(description='A collection of search results.'),
    ] = None
    query_alteration_response: Annotated[
        Optional[Union[AlterationResponse, Dict[str, Any]]],
        Field(
            description='Provides information related to spelling corrections in the alteration response.'
        ),
    ] = None
    result_templates: Annotated[
        Optional[Union[ResultTemplateDictionary, Dict[str, Any]]],
        Field(
            description='A dictionary of resultTemplateIds and associated values, which include the name and JSON schema of the result templates.'
        ),
    ] = None
    search_terms: Annotated[
        Optional[List[str]],
        Field(
            description='Contains the search terms sent in the initial search query.'
        ),
    ] = None
    field_odata_type: str


class SecurityResource(BaseModel):
    resource: Annotated[
        Optional[str],
        Field(
            description='Name of the resource that is related to current alert. Required.'
        ),
    ] = None
    resource_type: Annotated[
        Optional[Union[SecurityResourceType, Dict[str, Any]]],
        Field(
            description='Represents type of security resources related to an alert. Possible values are: attacked, related.'
        ),
    ] = None
    field_odata_type: str


class SensitivityLabelAssignment(BaseModel):
    assignment_method: Optional[SensitivityLabelAssignmentMethod] = None
    sensitivity_label_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier for the sensitivity label assigned to the file.'
        ),
    ] = None
    tenant_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier for the tenant that hosts the file when this label is applied.'
        ),
    ] = None
    field_odata_type: str


class ServiceHealthIssuePost(BaseModel):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The published time of the post.',
        ),
    ] = None
    description: Annotated[
        Optional[Union[ItemBody, Dict[str, Any]]],
        Field(
            description='The content of the service issue post. The supported value for the contentType property is html.'
        ),
    ] = None
    post_type: Annotated[
        Optional[Union[PostType, Dict[str, Any]]],
        Field(
            description='The post type of the service issue historical post. Possible values are: regular, quick, strategic, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class ServiceStatus(BaseModel):
    backup_service_consumer: Annotated[
        Optional[Union[BackupServiceConsumer, Dict[str, Any]]],
        Field(
            description='The type of consumer. The possible values are: unknown, firstparty, thirdparty, unknownFutureValue.'
        ),
    ] = None
    disable_reason: Annotated[
        Optional[Union[DisableReason, Dict[str, Any]]],
        Field(
            description='The reason the service is disabled. The possible values are: none, controllerServiceAppDeleted, invalidBillingProfile, userRequested, unknownFutureValue.'
        ),
    ] = None
    grace_period_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The expiration time of the grace period.',
        ),
    ] = None
    last_modified_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Identity of the person who last modified the entity.'),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Timestamp of the last modification of the entity.',
        ),
    ] = None
    restore_allowed_till_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The expiration time of the restoration allowed period.',
        ),
    ] = None
    status: Annotated[
        Optional[Union[BackupServiceStatus, Dict[str, Any]]],
        Field(
            description='Status of the service. This value indicates what capabilities can be used. The possible values are: disabled, enabled, protectionChangeLocked, restoreLocked, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class SettingSource(BaseModel):
    display_name: Annotated[Optional[str], Field(description='Not yet documented')] = (
        None
    )
    id: Annotated[Optional[str], Field(description='Not yet documented')] = None
    source_type: Optional[SettingSourceType] = None
    field_odata_type: str


class SharedPCAccountManagerPolicy(BaseModel):
    account_deletion_policy: Optional[SharedPCAccountDeletionPolicyType] = None
    cache_accounts_above_disk_free_percentage: Annotated[
        Optional[float],
        Field(
            description='Sets the percentage of available disk space a PC should have before it stops deleting cached shared PC accounts. Only applies when AccountDeletionPolicy is DiskSpaceThreshold or DiskSpaceThresholdOrInactiveThreshold. Valid values 0 to 100',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    inactive_threshold_days: Annotated[
        Optional[float],
        Field(
            description='Specifies when the accounts will start being deleted when they have not been logged on during the specified period, given as number of days. Only applies when AccountDeletionPolicy is DiskSpaceThreshold or DiskSpaceThresholdOrInactiveThreshold.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    remove_accounts_below_disk_free_percentage: Annotated[
        Optional[float],
        Field(
            description='Sets the percentage of disk space remaining on a PC before cached accounts will be deleted to free disk space. Accounts that have been inactive the longest will be deleted first. Only applies when AccountDeletionPolicy is DiskSpaceThresholdOrInactiveThreshold. Valid values 0 to 100',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class SharePointOneDriveOptions(BaseModel):
    include_content: Annotated[
        Optional[Union[SearchContent, Dict[str, Any]]],
        Field(
            description='The type of search content. The possible values are: sharedContent, privateContent, unknownFutureValue. Read-only.'
        ),
    ] = None
    field_odata_type: str


class ShiftActivity(BaseModel):
    code: Annotated[
        Optional[str],
        Field(description='Customer defined code for the shiftActivity. Required.'),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The name of the shiftActivity. Required.')
    ] = None
    end_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The end date and time for the shiftActivity. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Required.',
        ),
    ] = None
    is_paid: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the microsoft.graph.user should be paid for the activity during their shift. Required.'
        ),
    ] = None
    start_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The start date and time for the shiftActivity. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Required.',
        ),
    ] = None
    theme: Optional[ScheduleEntityTheme] = None
    field_odata_type: str


class ShiftItem(ScheduleEntity):
    activities: Annotated[
        Optional[List[ShiftActivity]],
        Field(
            description='An incremental part of a shift which can cover details of when and where an employee is during their shift. For example, an assignment or a scheduled break or lunch. Required.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The shift label of the shiftItem.')
    ] = None
    notes: Annotated[
        Optional[str], Field(description='The shift notes for the shiftItem.')
    ] = None
    field_odata_type: str


class SignInFrequencySessionControl(ConditionalAccessSessionControl):
    authentication_type: Annotated[
        Optional[Union[SignInFrequencyAuthenticationType, Dict[str, Any]]],
        Field(
            description="The possible values are primaryAndSecondaryAuthentication, secondaryAuthentication, unknownFutureValue. This property isn't required when using frequencyInterval with the value of timeBased."
        ),
    ] = None
    frequency_interval: Annotated[
        Optional[Union[SignInFrequencyInterval, Dict[str, Any]]],
        Field(
            description='The possible values are timeBased, everyTime, unknownFutureValue. Sign-in frequency of everyTime is available for risky users, risky sign-ins, and Intune device enrollment. For more information, see Require reauthentication every time.'
        ),
    ] = None
    type: Annotated[
        Optional[Union[SigninFrequencyType, Dict[str, Any]]],
        Field(description='Possible values are: days, hours.'),
    ] = None
    value: Annotated[
        Optional[float],
        Field(
            description='The number of days or hours.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class SignInLocation(BaseModel):
    city: Annotated[
        Optional[str],
        Field(
            description='Provides the city where the sign-in originated and is determined using latitude/longitude information from the sign-in activity.'
        ),
    ] = None
    country_or_region: Annotated[
        Optional[str],
        Field(
            description='Provides the country code info (two letter code) where the sign-in originated.  This is calculated using latitude/longitude information from the sign-in activity.'
        ),
    ] = None
    geo_coordinates: Annotated[
        Optional[Union[GeoCoordinates, Dict[str, Any]]],
        Field(
            description='Provides the latitude, longitude and altitude where the sign-in originated.'
        ),
    ] = None
    state: Annotated[
        Optional[str],
        Field(
            description='Provides the State where the sign-in originated. This is calculated using latitude/longitude information from the sign-in activity.'
        ),
    ] = None
    field_odata_type: str


class SimulationEventsContent(BaseModel):
    compromised_rate: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='Actual percentage of users who fell for the simulated attack in an attack simulation and training campaign.'
        ),
    ] = None
    events: Annotated[
        Optional[List[SimulationEvent]],
        Field(
            description='List of simulation events in an attack simulation and training campaign.'
        ),
    ] = None
    field_odata_type: str


class SimulationReportOverview(BaseModel):
    recommended_actions: Annotated[
        Optional[List[RecommendedAction]],
        Field(
            description='List of recommended actions for a tenant to improve its security posture based on the attack simulation and training campaign attack type.'
        ),
    ] = None
    resolved_targets_count: Annotated[
        Optional[float],
        Field(
            description='Number of valid users in the attack simulation and training campaign.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    simulation_events_content: Annotated[
        Optional[Union[SimulationEventsContent, Dict[str, Any]]],
        Field(
            description='Summary of simulation events in the attack simulation and training campaign.'
        ),
    ] = None
    training_events_content: Annotated[
        Optional[Union[TrainingEventsContent, Dict[str, Any]]],
        Field(
            description='Summary of assigned trainings in the attack simulation and training campaign.'
        ),
    ] = None
    field_odata_type: str


class SingleServicePrincipal(SubjectSet):
    description: Annotated[
        Optional[str], Field(description='Description of this service principal.')
    ] = None
    service_principal_id: Annotated[
        Optional[str], Field(description='ID of the servicePrincipal.')
    ] = None
    field_odata_type: str


class SingleUser(SubjectSet):
    description: Annotated[
        Optional[str],
        Field(description='The name of the user in Microsoft Entra ID. Read only.'),
    ] = None
    user_id: Annotated[
        Optional[str], Field(description='The ID of the user in Microsoft Entra ID.')
    ] = None
    field_odata_type: str


class SiteArchivalDetails(BaseModel):
    archive_status: Annotated[
        Optional[Union[SiteArchiveStatus, Dict[str, Any]]],
        Field(
            description='Represents the current archive status of the site collection. Returned only on $select. The possible values are: recentlyArchived, fullyArchived, reactivating, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class SiteCollection(BaseModel):
    archival_details: Annotated[
        Optional[Union[SiteArchivalDetails, Dict[str, Any]]],
        Field(
            description='Represents whether the site collection is recently archived, fully archived, or reactivating. Possible values are: recentlyArchived, fullyArchived, reactivating, unknownFutureValue.'
        ),
    ] = None
    data_location_code: Annotated[
        Optional[str],
        Field(
            description='The geographic region code for where this site collection resides. Only present for multi-geo tenants. Read-only.'
        ),
    ] = None
    hostname: Annotated[
        Optional[str],
        Field(description='The hostname for the site collection. Read-only.'),
    ] = None
    root: Annotated[
        Optional[Union[Root, Dict[str, Any]]],
        Field(
            description='If present, indicates that this is a root site collection in SharePoint. Read-only.'
        ),
    ] = None
    field_odata_type: str


class SocialIdentitySource(IdentitySource):
    display_name: Optional[str] = None
    social_identity_source_type: Optional[SocialIdentitySourceType] = None
    field_odata_type: str


class StaffAvailabilityItem(BaseModel):
    availability_items: Annotated[
        Optional[List[AvailabilityItem]],
        Field(
            description='Each item in this collection indicates a slot and the status of the staff member.'
        ),
    ] = None
    staff_id: Annotated[
        Optional[str], Field(description='The ID of the staff member.')
    ] = None
    field_odata_type: str


class StandardTimeZoneOffset(BaseModel):
    day_occurrence: Annotated[
        Optional[float],
        Field(
            description='Represents the nth occurrence of the day of week that the transition from daylight saving time to standard time occurs.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    day_of_week: Annotated[
        Optional[Union[DayOfWeek, Dict[str, Any]]],
        Field(
            description='Represents the day of the week when the transition from daylight saving time to standard time.'
        ),
    ] = None
    month: Annotated[
        Optional[float],
        Field(
            description='Represents the month of the year when the transition from daylight saving time to standard time occurs.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    time: Annotated[
        Optional[time],
        Field(
            description='Represents the time of day when the transition from daylight saving time to standard time occurs.',
        ),
    ] = None
    year: Annotated[
        Optional[float],
        Field(
            description='Represents how frequently in terms of years the change from daylight saving time to standard time occurs. For example, a value of 0 means every year.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class SubjectRightsRequestAllMailboxLocation(SubjectRightsRequestMailboxLocation):
    field_odata_type: str


class SubjectRightsRequestAllSiteLocation(SubjectRightsRequestSiteLocation):
    field_odata_type: str


class SubjectRightsRequestEnumeratedMailboxLocation(
    SubjectRightsRequestMailboxLocation
):
    user_principal_names: Annotated[
        Optional[List[str]],
        Field(
            description='Collection of mailboxes that should be included in the search. Includes the user principal name (UPN) of each mailbox, for example, Monica.Thompson@contoso.com.'
        ),
    ] = None
    field_odata_type: str


class SubjectRightsRequestEnumeratedSiteLocation(SubjectRightsRequestSiteLocation):
    urls: Annotated[
        Optional[List[str]],
        Field(
            description='Collection of site URLs that should be included. Includes the URL of each site, for example, https://www.contoso.com/site1.'
        ),
    ] = None
    field_odata_type: str


class SubjectRightsRequestHistory(BaseModel):
    changed_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(
            description='Identity of the user who changed the  subject rights request.'
        ),
    ] = None
    event_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Data and time when the entity was changed.',
        ),
    ] = None
    stage: Annotated[
        Optional[Union[SubjectRightsRequestStage, Dict[str, Any]]],
        Field(
            description='The stage when the entity was changed. Possible values are: contentRetrieval, contentReview, generateReport, contentDeletion, caseResolved, unknownFutureValue, approval. Use the Prefer: include-unknown-enum-members request header to get the following value(s) in this evolvable enum: approval.'
        ),
    ] = None
    stage_status: Annotated[
        Optional[Union[SubjectRightsRequestStageStatus, Dict[str, Any]]],
        Field(
            description='The status of the stage when the entity was changed. Possible values are: notStarted, current, completed, failed, unknownFutureValue.'
        ),
    ] = None
    type: Annotated[Optional[str], Field(description='Type of history.')] = None
    field_odata_type: str


class SubjectRightsRequestStageDetail(BaseModel):
    error: Annotated[
        Optional[Union[PublicError, Dict[str, Any]]],
        Field(description='Describes the error, if any, for the current stage.'),
    ] = None
    stage: Annotated[
        Optional[Union[SubjectRightsRequestStage, Dict[str, Any]]],
        Field(
            description='The stage of the subject rights request. Possible values are: contentRetrieval, contentReview, generateReport, contentDeletion, caseResolved, unknownFutureValue, approval. Use the Prefer: include-unknown-enum-members request header to get the following value in this evolvable enum: approval.'
        ),
    ] = None
    status: Annotated[
        Optional[Union[SubjectRightsRequestStageStatus, Dict[str, Any]]],
        Field(
            description='Status of the current stage. Possible values are: notStarted, current, completed, failed, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class SynchronizationJobRestartCriteria(BaseModel):
    reset_scope: Annotated[
        Optional[Union[SynchronizationJobRestartScope, Dict[str, Any]]],
        Field(
            description='Comma-separated combination of the following values: None, ConnectorDataStore, Escrows, Watermark, QuarantineState, Full, ForceDeletes. The property can also be empty.   None: Starts a paused or quarantined provisioning job. DO NOT USE. Use the Start synchronizationJob API instead.ConnectorDataStore - Clears the underlying cache for all users. DO NOT USE. Contact Microsoft Support for guidance.Escrows - Provisioning failures are marked as escrows and retried. Clearing escrows will stop the service from retrying failures.Watermark - Removing the watermark causes the service to reevaluate all the users again, rather than just processing changes.QuarantineState - Temporarily lifts the quarantine.Use Full if you want all of the options.ForceDeletes - Forces the system to delete the pending deleted users when using the accidental deletions prevention feature and the deletion threshold is exceeded. Leaving this property empty emulates the Restart provisioning option in the Microsoft Entra admin center. It is similar to setting the resetScope to include QuarantineState, Watermark, and Escrows. This option meets most customer needs.'
        ),
    ] = None
    field_odata_type: str


class SynchronizationMetadataEntry(BaseModel):
    key: Annotated[
        Optional[Union[SynchronizationMetadata, Dict[str, Any]]],
        Field(
            description='Possible values are: GalleryApplicationIdentifier, GalleryApplicationKey, IsOAuthEnabled, IsSynchronizationAgentAssignmentRequired, IsSynchronizationAgentRequired, IsSynchronizationInPreview, OAuthSettings, SynchronizationLearnMoreIbizaFwLink, ConfigurationFields.'
        ),
    ] = None
    value: Annotated[
        Optional[str], Field(description='Value of the metadata property.')
    ] = None
    field_odata_type: str


class SynchronizationQuarantine(BaseModel):
    current_began: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when the quarantine was last evaluated and imposed. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    error: Annotated[
        Optional[Union[SynchronizationError, Dict[str, Any]]],
        Field(
            description='Describes the error(s) that occurred when putting the synchronization job into quarantine.'
        ),
    ] = None
    next_attempt: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when the next attempt to re-evaluate the quarantine will be made. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    reason: Optional[QuarantineReason] = None
    series_began: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when the quarantine was first imposed in this series (a series starts when a quarantine is first imposed, and is reset as soon as the quarantine is lifted). The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    series_count: Annotated[
        Optional[float],
        Field(
            description='Number of times in this series the quarantine was re-evaluated and left in effect (a series starts when quarantine is first imposed, and is reset as soon as quarantine is lifted).'
        ),
    ] = None
    field_odata_type: str


class SynchronizationSchedule(BaseModel):
    expiration: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when this job expires. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    interval: Annotated[
        Optional[timedelta],
        Field(
            description='The interval between synchronization iterations. The value is represented in ISO 8601  format for durations. For example, P1M represents a period of one month and PT1M represents a period of one minute.',
        ),
    ] = None
    state: Optional[SynchronizationScheduleState] = None
    field_odata_type: str


class SynchronizationSecretKeyStringValuePair(BaseModel):
    key: Optional[SynchronizationSecret] = None
    value: Annotated[Optional[str], Field(description='The value of the secret.')] = (
        None
    )
    field_odata_type: str


class SynchronizationTaskExecution(BaseModel):
    activity_identifier: Annotated[
        Optional[str], Field(description='Identifier of the job run.')
    ] = None
    count_entitled: Annotated[
        Optional[float],
        Field(
            description='Count of processed entries that were assigned for this application.'
        ),
    ] = None
    count_entitled_for_provisioning: Annotated[
        Optional[float],
        Field(
            description='Count of processed entries that were assigned for provisioning.'
        ),
    ] = None
    count_escrowed: Annotated[
        Optional[float],
        Field(description='Count of entries that were escrowed (errors).'),
    ] = None
    count_escrowed_raw: Annotated[
        Optional[float],
        Field(
            description='Count of entries that were escrowed, including system-generated escrows.'
        ),
    ] = None
    count_exported: Annotated[
        Optional[float], Field(description='Count of exported entries.')
    ] = None
    count_exports: Annotated[
        Optional[float],
        Field(description='Count of entries that were expected to be exported.'),
    ] = None
    count_imported: Annotated[
        Optional[float], Field(description='Count of imported entries.')
    ] = None
    count_imported_deltas: Annotated[
        Optional[float], Field(description='Count of imported delta-changes.')
    ] = None
    count_imported_reference_deltas: Annotated[
        Optional[float],
        Field(
            description='Count of imported delta-changes pertaining to reference changes.'
        ),
    ] = None
    error: Annotated[
        Optional[Union[SynchronizationError, Dict[str, Any]]],
        Field(
            description='If an error was encountered, contains a synchronizationError object with details.'
        ),
    ] = None
    state: Optional[SynchronizationTaskExecutionResult] = None
    time_began: Annotated[
        Optional[datetime],
        Field(
            description='Time when this job run began. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    time_ended: Annotated[
        Optional[datetime],
        Field(
            description='Time when this job run ended. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    field_odata_type: str


class TargetResource(BaseModel):
    display_name: Annotated[
        Optional[str],
        Field(
            description='Indicates the visible name defined for the resource. Typically specified when the resource is created.'
        ),
    ] = None
    group_type: Annotated[
        Optional[Union[GroupType, Dict[str, Any]]],
        Field(
            description='When type is set to Group, this indicates the group type. Possible values are: unifiedGroups, azureAD, and unknownFutureValue'
        ),
    ] = None
    id: Annotated[
        Optional[str], Field(description='Indicates the unique ID of the resource.')
    ] = None
    modified_properties: Annotated[
        Optional[List[ModifiedProperty]],
        Field(
            description='Indicates name, old value and new value of each attribute that changed. Property values depend on the operation type.'
        ),
    ] = None
    type: Annotated[
        Optional[str],
        Field(
            description='Describes the resource type.  Example values include Application, Group, ServicePrincipal, and User.'
        ),
    ] = None
    user_principal_name: Annotated[
        Optional[str],
        Field(
            description='When type is set to User, this includes the user name that initiated the action; null for other types.'
        ),
    ] = None
    field_odata_type: str


class TeamFunSettings(BaseModel):
    allow_custom_memes: Annotated[
        Optional[bool],
        Field(description='If set to true, enables users to include custom memes.'),
    ] = None
    allow_giphy: Annotated[
        Optional[bool], Field(description='If set to true, enables Giphy use.')
    ] = None
    allow_stickers_and_memes: Annotated[
        Optional[bool],
        Field(
            description='If set to true, enables users to include stickers and memes.'
        ),
    ] = None
    giphy_content_rating: Annotated[
        Optional[Union[GiphyRatingType, Dict[str, Any]]],
        Field(
            description='Giphy content rating. Possible values are: moderate, strict.'
        ),
    ] = None
    field_odata_type: str


class TeamMembersNotificationRecipient(TeamworkNotificationRecipient):
    team_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier for the team whose members should receive the notification.'
        ),
    ] = None
    field_odata_type: str


class TeamsAppResourceSpecificPermission(BaseModel):
    permission_type: Annotated[
        Optional[Union[TeamsAppResourceSpecificPermissionType, Dict[str, Any]]],
        Field(description='The type of resource-specific permission.'),
    ] = None
    permission_value: Annotated[
        Optional[str],
        Field(description='The name of the resource-specific permission.'),
    ] = None
    field_odata_type: str


class TeamworkActivityTopic(BaseModel):
    source: Annotated[
        Optional[Union[TeamworkActivityTopicSource, Dict[str, Any]]],
        Field(
            description='Type of source. Possible values are: entityUrl, text. For supported Microsoft Graph URLs, use entityUrl. For custom text, use text.'
        ),
    ] = None
    value: Annotated[
        Optional[str],
        Field(
            description='The topic value. If the value of the source property is entityUrl, this must be a Microsoft Graph URL. If the value is text, this must be a plain text value.'
        ),
    ] = None
    web_url: Annotated[
        Optional[str],
        Field(
            description='The link the user clicks when they select the notification. Optional when source is entityUrl; required when source is text.'
        ),
    ] = None
    field_odata_type: str


class TeamworkApplicationIdentity(Identity):
    application_identity_type: Annotated[
        Optional[Union[TeamworkApplicationIdentityType, Dict[str, Any]]],
        Field(
            description='Type of application that is referenced. Possible values are: aadApplication, bot, tenantBot, office365Connector, outgoingWebhook, and unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class TeamworkConversationIdentity(Identity):
    conversation_identity_type: Annotated[
        Optional[Union[TeamworkConversationIdentityType, Dict[str, Any]]],
        Field(
            description='Type of conversation. Possible values are: team, channel, chat, and unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class TeamworkUserIdentity(Identity):
    user_identity_type: Annotated[
        Optional[Union[TeamworkUserIdentityType, Dict[str, Any]]],
        Field(
            description='Type of user. Possible values are: aadUser, onPremiseAadUser, anonymousGuest, federatedUser, personalMicrosoftAccountUser, skypeUser, phoneUser, unknownFutureValue and emailUser.'
        ),
    ] = None
    field_odata_type: str


class TeleconferenceDeviceMediaQuality(BaseModel):
    average_inbound_jitter: Annotated[
        Optional[timedelta],
        Field(
            description='The average inbound stream network jitter.',
        ),
    ] = None
    average_inbound_packet_loss_rate_in_percentage: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='The average inbound stream packet loss rate in percentage (0-100). For example, 0.01 means 0.01%.'
        ),
    ] = None
    average_inbound_round_trip_delay: Annotated[
        Optional[timedelta],
        Field(
            description='The average inbound stream network round trip delay.',
        ),
    ] = None
    average_outbound_jitter: Annotated[
        Optional[timedelta],
        Field(
            description='The average outbound stream network jitter.',
        ),
    ] = None
    average_outbound_packet_loss_rate_in_percentage: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='The average outbound stream packet loss rate in percentage (0-100). For example, 0.01 means 0.01%.'
        ),
    ] = None
    average_outbound_round_trip_delay: Annotated[
        Optional[timedelta],
        Field(
            description='The average outbound stream network round trip delay.',
        ),
    ] = None
    channel_index: Annotated[
        Optional[float],
        Field(
            description='The channel index of media. Indexing begins with 1.  If a media session contains 3 video modalities, channel indexes will be 1, 2, and 3.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    inbound_packets: Annotated[
        Optional[float], Field(description='The total number of the inbound packets.')
    ] = None
    local_ip_address: Annotated[
        Optional[str], Field(description='the local IP address for the media session.')
    ] = None
    local_port: Annotated[
        Optional[float],
        Field(description='The local media port.', ge=-2147483648.0, le=2147483647.0),
    ] = None
    maximum_inbound_jitter: Annotated[
        Optional[timedelta],
        Field(
            description='The maximum inbound stream network jitter.',
        ),
    ] = None
    maximum_inbound_packet_loss_rate_in_percentage: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='The maximum inbound stream packet loss rate in percentage (0-100). For example, 0.01 means 0.01%.'
        ),
    ] = None
    maximum_inbound_round_trip_delay: Annotated[
        Optional[timedelta],
        Field(
            description='The maximum inbound stream network round trip delay.',
        ),
    ] = None
    maximum_outbound_jitter: Annotated[
        Optional[timedelta],
        Field(
            description='The maximum outbound stream network jitter.',
        ),
    ] = None
    maximum_outbound_packet_loss_rate_in_percentage: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='The maximum outbound stream packet loss rate in percentage (0-100). For example, 0.01 means 0.01%.'
        ),
    ] = None
    maximum_outbound_round_trip_delay: Annotated[
        Optional[timedelta],
        Field(
            description='The maximum outbound stream network round trip delay.',
        ),
    ] = None
    media_duration: Annotated[
        Optional[timedelta],
        Field(
            description='The total modality duration. If the media enabled and disabled multiple times, MediaDuration will the summation of all of the durations.',
        ),
    ] = None
    network_link_speed_in_bytes: Annotated[
        Optional[float], Field(description='The network link speed in bytes')
    ] = None
    outbound_packets: Annotated[
        Optional[float], Field(description='The total number of the outbound packets.')
    ] = None
    remote_ip_address: Annotated[
        Optional[str], Field(description='The remote IP address for the media session.')
    ] = None
    remote_port: Annotated[
        Optional[float],
        Field(description='The remote media port.', ge=-2147483648.0, le=2147483647.0),
    ] = None
    field_odata_type: str


class TeleconferenceDeviceQuality(BaseModel):
    call_chain_id: Annotated[
        Optional[UUID],
        Field(
            description='A unique identifier for all  the participant calls in a conference or a unique identifier for two participant calls in P2P call. This needs to be copied over from Microsoft.Graph.Call.CallChainId.',
        ),
    ] = None
    cloud_service_deployment_environment: Annotated[
        Optional[str],
        Field(
            description='A geo-region where the service is deployed, such as ProdNoam.'
        ),
    ] = None
    cloud_service_deployment_id: Annotated[
        Optional[str],
        Field(description='A unique deployment identifier assigned by Azure.'),
    ] = None
    cloud_service_instance_name: Annotated[
        Optional[str],
        Field(
            description='The Azure deployed cloud service instance name, such as FrontEndIN3.'
        ),
    ] = None
    cloud_service_name: Annotated[
        Optional[str],
        Field(
            description='The Azure deployed cloud service name, such as contoso.cloudapp.net.'
        ),
    ] = None
    device_description: Annotated[
        Optional[str],
        Field(description='Any additional description, such as VTC Bldg 30/21.'),
    ] = None
    device_name: Annotated[
        Optional[str],
        Field(description='The user media agent name, such as Cisco SX80.'),
    ] = None
    media_leg_id: Annotated[
        Optional[UUID],
        Field(
            description='A unique identifier for a specific media leg of a participant in a conference.  One participant can have multiple media leg identifiers if retargeting happens. CVI partner assigns this value.',
        ),
    ] = None
    media_quality_list: Annotated[
        Optional[List[TeleconferenceDeviceMediaQuality]],
        Field(
            description='The list of media qualities in a media session (call), such as audio quality, video quality, and/or screen sharing quality.'
        ),
    ] = None
    participant_id: Annotated[
        Optional[UUID],
        Field(
            description='A unique identifier for a specific participant in a conference. The CVI partner needs to copy over Call.MyParticipantId to this property.',
        ),
    ] = None
    field_odata_type: str


class TeleconferenceDeviceVideoQuality(TeleconferenceDeviceMediaQuality):
    average_inbound_bit_rate: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='The average inbound stream video bit rate per second.'),
    ] = None
    average_inbound_frame_rate: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='The average inbound stream video frame rate per second.'),
    ] = None
    average_outbound_bit_rate: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='The average outbound stream video bit rate per second.'),
    ] = None
    average_outbound_frame_rate: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='The average outbound stream video frame rate per second.'),
    ] = None
    field_odata_type: str


class TimeConstraint(BaseModel):
    activity_domain: Annotated[
        Optional[Union[ActivityDomain, Dict[str, Any]]],
        Field(
            description='The nature of the activity, optional. The possible values are: work, personal, unrestricted, or unknown.'
        ),
    ] = None
    time_slots: Optional[List[TimeSlot]] = None
    field_odata_type: str


class TimeOffItem(ScheduleEntity):
    time_off_reason_id: Annotated[
        Optional[str],
        Field(description='ID of the timeOffReason for this timeOffItem. Required.'),
    ] = None
    field_odata_type: str


class TitleArea(BaseModel):
    alternative_text: Annotated[
        Optional[str], Field(description='Alternative text on the title area.')
    ] = None
    enable_gradient_effect: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the title area has a gradient effect enabled.'
        ),
    ] = None
    image_web_url: Annotated[
        Optional[str], Field(description='URL of the image in the title area.')
    ] = None
    layout: Annotated[
        Optional[Union[TitleAreaLayoutType, Dict[str, Any]]],
        Field(
            description='Enumeration value that indicates the layout of the title area. The possible values are: imageAndTitle, plain, colorBlock, overlap, unknownFutureValue.'
        ),
    ] = None
    server_processed_content: Annotated[
        Optional[Union[ServerProcessedContent, Dict[str, Any]]],
        Field(
            description='Contains collections of data that can be processed by server side services like search index and link fixup.'
        ),
    ] = None
    show_author: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the author should be shown in title area.'
        ),
    ] = None
    show_published_date: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the published date should be shown in title area.'
        ),
    ] = None
    show_text_block_above_title: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the text block above title should be shown in title area.'
        ),
    ] = None
    text_above_title: Annotated[
        Optional[str], Field(description='The text above title line.')
    ] = None
    text_alignment: Annotated[
        Optional[Union[TitleAreaTextAlignmentType, Dict[str, Any]]],
        Field(
            description='Enumeration value that indicates the text alignment of the title area. The possible values are: left, center, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class ToneInfo(BaseModel):
    sequence_id: Annotated[
        Optional[float],
        Field(description='An incremental identifier used for ordering DTMF events.'),
    ] = None
    tone: Optional[Tone] = None
    field_odata_type: str


class TrainingSetting(BaseModel):
    setting_type: Annotated[
        Optional[Union[TrainingSettingType, Dict[str, Any]]],
        Field(
            description='Type of setting. Possible values are: microsoftCustom, microsoftManaged, noTraining, custom, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class UnifiedRoleManagementPolicyRuleTarget(BaseModel):
    caller: Annotated[
        Optional[str],
        Field(
            description="The type of caller that's the target of the policy rule. Allowed values are: None, Admin, EndUser."
        ),
    ] = None
    enforced_settings: Annotated[
        Optional[List[str]],
        Field(
            description='The list of role settings that are enforced and cannot be overridden by child scopes. Use All for all settings.'
        ),
    ] = None
    inheritable_settings: Annotated[
        Optional[List[str]],
        Field(
            description='The list of role settings that can be inherited by child scopes. Use All for all settings.'
        ),
    ] = None
    level: Annotated[
        Optional[str],
        Field(
            description="The role assignment type that's the target of policy rule. Allowed values are: Eligibility, Assignment."
        ),
    ] = None
    operations: Annotated[
        Optional[
            List[Union[UnifiedRoleManagementPolicyRuleTargetOperations, Dict[str, Any]]]
        ],
        Field(
            description='The role management operations that are the target of the policy rule. Allowed values are: All, Activate, Deactivate, Assign, Update, Remove, Extend, Renew.'
        ),
    ] = None
    target_objects: Optional[List[DirectoryObject]] = None
    field_odata_type: str


class UpdateAllowedCombinationsResult(BaseModel):
    additional_information: Annotated[
        Optional[str],
        Field(
            description='Information about why the updateAllowedCombinations action was successful or failed.'
        ),
    ] = None
    conditional_access_references: Annotated[
        Optional[List[str]],
        Field(
            description='References to existing Conditional Access policies that use this authentication strength.'
        ),
    ] = None
    current_combinations: Annotated[
        Optional[List[AuthenticationMethodModes]],
        Field(
            description='The list of current authentication method combinations allowed by the authentication strength.'
        ),
    ] = None
    previous_combinations: Annotated[
        Optional[List[AuthenticationMethodModes]],
        Field(
            description='The list of former authentication method combinations allowed by the authentication strength before they were updated through the updateAllowedCombinations action.'
        ),
    ] = None
    field_odata_type: str


class UpdateWindowsDeviceAccountActionParameter(BaseModel):
    calendar_sync_enabled: Annotated[
        Optional[bool], Field(description='Not yet documented')
    ] = None
    device_account: Annotated[
        Optional[Union[WindowsDeviceAccount, Dict[str, Any]]],
        Field(description='Not yet documented'),
    ] = None
    device_account_email: Annotated[
        Optional[str], Field(description='Not yet documented')
    ] = None
    exchange_server: Annotated[
        Optional[str], Field(description='Not yet documented')
    ] = None
    password_rotation_enabled: Annotated[
        Optional[bool], Field(description='Not yet documented')
    ] = None
    session_initiation_protocal_address: Annotated[
        Optional[str], Field(description='Not yet documented')
    ] = None
    field_odata_type: str


class UserExperienceAnalyticsInsight(BaseModel):
    insight_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier of the user experience analytics insight.'
        ),
    ] = None
    severity: Optional[UserExperienceAnalyticsInsightSeverity] = None
    user_experience_analytics_metric_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier of the user experience analytics metric.'
        ),
    ] = None
    values: Annotated[
        Optional[List[UserExperienceAnalyticsInsightValue]],
        Field(description='The value of the user experience analytics insight.'),
    ] = None
    field_odata_type: str


class UserFlowApiConnectorConfiguration(BaseModel):
    post_attribute_collection: Optional[Union[IdentityApiConnector, Dict[str, Any]]] = (
        None
    )
    post_federation_signup: Optional[Union[IdentityApiConnector, Dict[str, Any]]] = None
    field_odata_type: str


class UserLastSignInRecommendationInsightSetting(
    AccessReviewRecommendationInsightSetting
):
    recommendation_look_back_duration: Annotated[
        Optional[timedelta],
        Field(
            description='Optional. Indicates the time period of inactivity (with respect to the start date of the review instance) that recommendations will be configured from. The recommendation will be to deny if the user is inactive during the look-back duration. For reviews of groups and Microsoft Entra roles, any duration is accepted. For reviews of applications, 30 days is the maximum duration. If not specified, the duration is 30 days.',
        ),
    ] = None
    sign_in_scope: Annotated[
        Optional[Union[UserSignInRecommendationScope, Dict[str, Any]]],
        Field(
            description="Indicates whether inactivity is calculated based on the user's inactivity in the tenant or in the application. The possible values are tenant, application, unknownFutureValue. application is only relevant when the access review is a review of an assignment to an application."
        ),
    ] = None
    field_odata_type: str


class UserRegistrationFeatureCount(BaseModel):
    feature: Optional[AuthenticationMethodFeature] = None
    user_count: Annotated[Optional[float], Field(description='Number of users.')] = None
    field_odata_type: str


class UserRegistrationFeatureSummary(BaseModel):
    total_user_count: Annotated[
        Optional[float],
        Field(
            description='Total number of users accounts, excluding those that are blocked.'
        ),
    ] = None
    user_registration_feature_counts: Annotated[
        Optional[List[UserRegistrationFeatureCount]],
        Field(
            description='Number of users registered or capable for multi-factor authentication, self-service password reset, and passwordless authentication.'
        ),
    ] = None
    user_roles: Annotated[
        Optional[Union[IncludedUserRoles, Dict[str, Any]]],
        Field(
            description='The role type of the user. Possible values are: all, privilegedAdmin, admin, user, unknownFutureValue.'
        ),
    ] = None
    user_types: Annotated[
        Optional[Union[IncludedUserTypes, Dict[str, Any]]],
        Field(
            description='User type. Possible values are: all, member, guest, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class UserRegistrationMethodSummary(BaseModel):
    total_user_count: Annotated[
        Optional[float], Field(description='Total number of users in the tenant.')
    ] = None
    user_registration_method_counts: Annotated[
        Optional[List[UserRegistrationMethodCount]],
        Field(description='Number of users registered for each authentication method.'),
    ] = None
    user_roles: Annotated[
        Optional[Union[IncludedUserRoles, Dict[str, Any]]],
        Field(
            description='The role type of the user. Possible values are: all, privilegedAdmin, admin, user, unknownFutureValue.'
        ),
    ] = None
    user_types: Annotated[
        Optional[Union[IncludedUserTypes, Dict[str, Any]]],
        Field(
            description='User type. Possible values are: all, member, guest, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class UserSecurityState(BaseModel):
    aad_user_id: Annotated[
        Optional[str],
        Field(
            description='AAD User object identifier (GUID) - represents the physical/multi-account user entity.'
        ),
    ] = None
    account_name: Annotated[
        Optional[str],
        Field(
            description='Account name of user account (without Active Directory domain or DNS domain) - (also called mailNickName).'
        ),
    ] = None
    domain_name: Annotated[
        Optional[str],
        Field(
            description='NetBIOS/Active Directory domain of user account (that is, domain/account format).'
        ),
    ] = None
    email_role: Annotated[
        Optional[Union[EmailRole, Dict[str, Any]]],
        Field(
            description="For email-related alerts - user account's email 'role'. Possible values are: unknown, sender, recipient."
        ),
    ] = None
    is_vpn: Annotated[
        Optional[bool],
        Field(description='Indicates whether the user logged on through a VPN.'),
    ] = None
    logon_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Time at which the sign-in occurred. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    logon_id: Annotated[Optional[str], Field(description='User sign-in ID.')] = None
    logon_ip: Annotated[
        Optional[str],
        Field(description='IP Address the sign-in request originated from.'),
    ] = None
    logon_location: Annotated[
        Optional[str],
        Field(
            description='Location (by IP address mapping) associated with a user sign-in event by this user.'
        ),
    ] = None
    logon_type: Annotated[
        Optional[Union[LogonType, Dict[str, Any]]],
        Field(
            description='Method of user sign in. Possible values are: unknown, interactive, remoteInteractive, network, batch, service.'
        ),
    ] = None
    on_premises_security_identifier: Annotated[
        Optional[str],
        Field(
            description='Active Directory (on-premises) Security Identifier (SID) of the user.'
        ),
    ] = None
    risk_score: Annotated[
        Optional[str],
        Field(
            description='Provider-generated/calculated risk score of the user account. Recommended value range of 0-1, which equates to a percentage.'
        ),
    ] = None
    user_account_type: Annotated[
        Optional[Union[UserAccountSecurityType, Dict[str, Any]]],
        Field(
            description='User account type (group membership), per Windows definition. Possible values are: unknown, standard, power, administrator.'
        ),
    ] = None
    user_principal_name: Annotated[
        Optional[str],
        Field(
            description='User sign-in name - internet format: (user account name)@(user account DNS domain name).'
        ),
    ] = None
    field_odata_type: str


class UserSimulationEventInfo(BaseModel):
    browser: Annotated[
        Optional[str],
        Field(
            description='Browser information from where the simulation event was initiated by a user in an attack simulation and training campaign.'
        ),
    ] = None
    click_source: Optional[Union[ClickSource, Dict[str, Any]]] = None
    event_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time of the simulation event by a user in an attack simulation and training campaign.',
        ),
    ] = None
    event_name: Annotated[
        Optional[str],
        Field(
            description='Name of the simulation event by a user in an attack simulation and training campaign.'
        ),
    ] = None
    ip_address: Annotated[
        Optional[str],
        Field(
            description='IP address from where the simulation event was initiated by a user in an attack simulation and training campaign.'
        ),
    ] = None
    os_platform_device_details: Annotated[
        Optional[str],
        Field(
            description='The operating system, platform, and device details from where the simulation event was initiated by a user in an attack simulation and training campaign.'
        ),
    ] = None
    field_odata_type: str


class UserTrainingContentEventInfo(BaseModel):
    browser: Annotated[
        Optional[str],
        Field(
            description='Browser of the user from where the training event was generated.'
        ),
    ] = None
    content_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time of the training content playback by the user.',
        ),
    ] = None
    ip_address: Annotated[
        Optional[str],
        Field(description='IP address of the user for the training event.'),
    ] = None
    os_platform_device_details: Annotated[
        Optional[str],
        Field(
            description='The operating system, platform, and device details of the user for the training event.'
        ),
    ] = None
    potential_score_impact: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='Potential improvement in the tenant security posture after completion of the training by the user.'
        ),
    ] = None
    field_odata_type: str


class UserTrainingEventInfo(BaseModel):
    display_name: Annotated[
        Optional[str], Field(description='Display name of the training.')
    ] = None
    latest_training_status: Annotated[
        Optional[Union[TrainingStatus, Dict[str, Any]]],
        Field(
            description='Latest status of the training assigned to the user. Possible values are: unknown, assigned, inProgress, completed, overdue, unknownFutureValue.'
        ),
    ] = None
    training_assigned_properties: Annotated[
        Optional[Union[UserTrainingContentEventInfo, Dict[str, Any]]],
        Field(
            description='Event details of the training when it was assigned to the user.'
        ),
    ] = None
    training_completed_properties: Annotated[
        Optional[Union[UserTrainingContentEventInfo, Dict[str, Any]]],
        Field(
            description='Event details of the training when it was completed by the user.'
        ),
    ] = None
    training_updated_properties: Annotated[
        Optional[Union[UserTrainingContentEventInfo, Dict[str, Any]]],
        Field(
            description='Event details of the training when it was updated/in-progress by the user.'
        ),
    ] = None
    field_odata_type: str


class UserTrainingStatusInfo(BaseModel):
    assigned_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time of assignment of the training to the user.',
        ),
    ] = None
    completion_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time of completion of the training by the user.',
        ),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='Display name of the assigned training.')
    ] = None
    training_status: Annotated[
        Optional[Union[TrainingStatus, Dict[str, Any]]],
        Field(
            description='The status of the training assigned to the user. Possible values are: unknown, assigned, inProgress, completed, overdue, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class Video(BaseModel):
    audio_bits_per_sample: Annotated[
        Optional[float],
        Field(
            description='Number of audio bits per sample.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    audio_channels: Annotated[
        Optional[float],
        Field(
            description='Number of audio channels.', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    audio_format: Annotated[
        Optional[str], Field(description='Name of the audio format (AAC, MP3, etc.).')
    ] = None
    audio_samples_per_second: Annotated[
        Optional[float],
        Field(
            description='Number of audio samples per second.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    bitrate: Annotated[
        Optional[float],
        Field(
            description='Bit rate of the video in bits per second.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    duration: Annotated[
        Optional[float], Field(description='Duration of the file in milliseconds.')
    ] = None
    four_cc: Annotated[
        Optional[str],
        Field(description="'Four character code' name of the video format."),
    ] = None
    frame_rate: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='Frame rate of the video.'),
    ] = None
    height: Annotated[
        Optional[float],
        Field(
            description='Height of the video, in pixels.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    width: Annotated[
        Optional[float],
        Field(
            description='Width of the video, in pixels.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class VirtualEventPresenterDetails(BaseModel):
    bio: Annotated[
        Optional[Union[ItemBody, Dict[str, Any]]],
        Field(description='Bio of the presenter.'),
    ] = None
    company: Annotated[
        Optional[str], Field(description="The presenter's company name.")
    ] = None
    job_title: Annotated[
        Optional[str], Field(description="The presenter's job title.")
    ] = None
    linked_in_profile_web_url: Annotated[
        Optional[str], Field(description="The presenter's LinkedIn profile URL.")
    ] = None
    personal_site_web_url: Annotated[
        Optional[str], Field(description="The presenter's personal website URL.")
    ] = None
    photo: Annotated[
        Optional[str], Field(description="The content stream of the presenter's photo.")
    ] = None
    twitter_profile_web_url: Annotated[
        Optional[str], Field(description="The presenter's Twitter profile URL.")
    ] = None
    field_odata_type: str


class VirtualEventPresenterInfo(MeetingParticipantInfo):
    presenter_details: Optional[Union[VirtualEventPresenterDetails, Dict[str, Any]]] = (
        None
    )
    field_odata_type: str


class WebPartPosition(BaseModel):
    column_id: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='Indicates the identifier of the column where the web part is located.'
        ),
    ] = None
    horizontal_section_id: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='Indicates the horizontal section where the web part is located.'
        ),
    ] = None
    is_in_vertical_section: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the web part is located in the vertical section.'
        ),
    ] = None
    web_part_index: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='Index of the current web part. Represents the order of the web part in this column or section.'
        ),
    ] = None
    field_odata_type: str


class Website(BaseModel):
    address: Annotated[Optional[str], Field(description='The URL of the website.')] = (
        None
    )
    display_name: Annotated[
        Optional[str], Field(description='The display name of the web site.')
    ] = None
    type: Annotated[
        Optional[Union[WebsiteType, Dict[str, Any]]],
        Field(description='The possible values are: other, home, work, blog, profile.'),
    ] = None
    field_odata_type: str


class Win32LobAppAutoUpdateSettings(BaseModel):
    auto_update_superseded_apps_state: Optional[
        Win32LobAutoUpdateSupersededAppsState
    ] = None
    field_odata_type: str


class Win32LobAppInstallExperience(BaseModel):
    device_restart_behavior: Optional[Win32LobAppRestartBehavior] = None
    run_as_account: Optional[RunAsAccountType] = None
    field_odata_type: str


class Win32LobAppMsiInformation(BaseModel):
    package_type: Optional[Win32LobAppMsiPackageType] = None
    product_code: Annotated[
        Optional[str], Field(description='The MSI product code.')
    ] = None
    product_name: Annotated[
        Optional[str], Field(description='The MSI product name.')
    ] = None
    product_version: Annotated[
        Optional[str], Field(description='The MSI product version.')
    ] = None
    publisher: Annotated[Optional[str], Field(description='The MSI publisher.')] = None
    requires_reboot: Annotated[
        Optional[bool],
        Field(
            description='Whether the MSI app requires the machine to reboot to complete installation.'
        ),
    ] = None
    upgrade_code: Annotated[
        Optional[str], Field(description='The MSI upgrade code.')
    ] = None
    field_odata_type: str


class Win32LobAppReturnCode(BaseModel):
    return_code: Annotated[
        Optional[float],
        Field(description='Return code.', ge=-2147483648.0, le=2147483647.0),
    ] = None
    type: Optional[Win32LobAppReturnCodeType] = None
    field_odata_type: str


class Win32LobAppRule(BaseModel):
    rule_type: Optional[Win32LobAppRuleType] = None
    field_odata_type: str


class WindowsDefenderScanActionResult(DeviceActionResult):
    scan_type: Annotated[
        Optional[str], Field(description='Scan type either full scan or quick scan')
    ] = None
    field_odata_type: str


class WindowsFirewallNetworkProfile(BaseModel):
    authorized_application_rules_from_group_policy_merged: Annotated[
        Optional[bool],
        Field(
            description='Configures the firewall to merge authorized application rules from group policy with those from local store instead of ignoring the local store rules. When AuthorizedApplicationRulesFromGroupPolicyNotMerged and AuthorizedApplicationRulesFromGroupPolicyMerged are both true, AuthorizedApplicationRulesFromGroupPolicyMerged takes priority.'
        ),
    ] = None
    connection_security_rules_from_group_policy_merged: Annotated[
        Optional[bool],
        Field(
            description='Configures the firewall to merge connection security rules from group policy with those from local store instead of ignoring the local store rules. When ConnectionSecurityRulesFromGroupPolicyNotMerged and ConnectionSecurityRulesFromGroupPolicyMerged are both true, ConnectionSecurityRulesFromGroupPolicyMerged takes priority.'
        ),
    ] = None
    firewall_enabled: Optional[StateManagementSetting] = None
    global_port_rules_from_group_policy_merged: Annotated[
        Optional[bool],
        Field(
            description='Configures the firewall to merge global port rules from group policy with those from local store instead of ignoring the local store rules. When GlobalPortRulesFromGroupPolicyNotMerged and GlobalPortRulesFromGroupPolicyMerged are both true, GlobalPortRulesFromGroupPolicyMerged takes priority.'
        ),
    ] = None
    inbound_connections_blocked: Annotated[
        Optional[bool],
        Field(
            description='Configures the firewall to block all incoming connections by default. When InboundConnectionsRequired and InboundConnectionsBlocked are both true, InboundConnectionsBlocked takes priority.'
        ),
    ] = None
    inbound_notifications_blocked: Annotated[
        Optional[bool],
        Field(
            description='Prevents the firewall from displaying notifications when an application is blocked from listening on a port. When InboundNotificationsRequired and InboundNotificationsBlocked are both true, InboundNotificationsBlocked takes priority.'
        ),
    ] = None
    incoming_traffic_blocked: Annotated[
        Optional[bool],
        Field(
            description='Configures the firewall to block all incoming traffic regardless of other policy settings. When IncomingTrafficRequired and IncomingTrafficBlocked are both true, IncomingTrafficBlocked takes priority.'
        ),
    ] = None
    outbound_connections_blocked: Annotated[
        Optional[bool],
        Field(
            description='Configures the firewall to block all outgoing connections by default. When OutboundConnectionsRequired and OutboundConnectionsBlocked are both true, OutboundConnectionsBlocked takes priority. This setting will get applied to Windows releases version 1809 and above.'
        ),
    ] = None
    policy_rules_from_group_policy_merged: Annotated[
        Optional[bool],
        Field(
            description='Configures the firewall to merge Firewall Rule policies from group policy with those from local store instead of ignoring the local store rules. When PolicyRulesFromGroupPolicyNotMerged and PolicyRulesFromGroupPolicyMerged are both true, PolicyRulesFromGroupPolicyMerged takes priority.'
        ),
    ] = None
    secured_packet_exemption_allowed: Annotated[
        Optional[bool],
        Field(
            description='Configures the firewall to allow the host computer to respond to unsolicited network traffic of that traffic is secured by IPSec even when stealthModeBlocked is set to true. When SecuredPacketExemptionBlocked and SecuredPacketExemptionAllowed are both true, SecuredPacketExemptionAllowed takes priority.'
        ),
    ] = None
    stealth_mode_blocked: Annotated[
        Optional[bool],
        Field(
            description='Prevent the server from operating in stealth mode. When StealthModeRequired and StealthModeBlocked are both true, StealthModeBlocked takes priority.'
        ),
    ] = None
    unicast_responses_to_multicast_broadcasts_blocked: Annotated[
        Optional[bool],
        Field(
            description='Configures the firewall to block unicast responses to multicast broadcast traffic. When UnicastResponsesToMulticastBroadcastsRequired and UnicastResponsesToMulticastBroadcastsBlocked are both true, UnicastResponsesToMulticastBroadcastsBlocked takes priority.'
        ),
    ] = None
    field_odata_type: str


class WindowsMalwareCategoryCount(BaseModel):
    active_malware_detection_count: Annotated[
        Optional[float],
        Field(
            description='Count of active malware detections for this malware category. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    category: Optional[WindowsMalwareCategory] = None
    device_count: Annotated[
        Optional[float],
        Field(
            description='Count of devices with malware detections for this malware category',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    distinct_active_malware_count: Annotated[
        Optional[float],
        Field(
            description='Count of distinct active malwares for this malware category. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    last_update_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp of the last update for the device count in UTC',
        ),
    ] = None
    field_odata_type: str


class WindowsMalwareExecutionStateCount(BaseModel):
    device_count: Annotated[
        Optional[float],
        Field(
            description='Count of devices with malware detections for this malware execution state',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    execution_state: Optional[WindowsMalwareExecutionState] = None
    last_update_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp of the last update for the device count in UTC',
        ),
    ] = None
    field_odata_type: str


class WindowsMalwareSeverityCount(BaseModel):
    distinct_malware_count: Annotated[
        Optional[float],
        Field(
            description='Count of distinct malwares for this malware State. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    last_update_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp of the last update for the WindowsMalwareSeverityCount in UTC',
        ),
    ] = None
    malware_detection_count: Annotated[
        Optional[float],
        Field(
            description='Count of threats detections for this malware severity. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    severity: Optional[WindowsMalwareSeverity] = None
    field_odata_type: str


class WindowsMalwareStateCount(BaseModel):
    device_count: Annotated[
        Optional[float],
        Field(
            description='Count of devices with malware detections for this malware State',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    distinct_malware_count: Annotated[
        Optional[float],
        Field(
            description='Count of distinct malwares for this malware State. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    last_update_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp of the last update for the device count in UTC',
        ),
    ] = None
    malware_detection_count: Annotated[
        Optional[float],
        Field(
            description='Count of total malware detections for this malware State. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    state: Optional[WindowsMalwareThreatState] = None
    field_odata_type: str


class WindowsUpdateActiveHoursInstall(WindowsUpdateInstallScheduleType):
    active_hours_end: Annotated[
        Optional[time],
        Field(
            description='Active Hours End',
        ),
    ] = None
    active_hours_start: Annotated[
        Optional[time],
        Field(
            description='Active Hours Start',
        ),
    ] = None
    field_odata_type: str


class WindowsUpdateScheduledInstall(WindowsUpdateInstallScheduleType):
    scheduled_install_day: Optional[WeeklySchedule] = None
    scheduled_install_time: Annotated[
        Optional[time],
        Field(
            description='Scheduled Install Time during day',
        ),
    ] = None
    field_odata_type: str


class WorkbookFilterCriteria(BaseModel):
    color: Annotated[
        Optional[str], Field(description='The color applied to the cell.')
    ] = None
    criterion1: Annotated[Optional[str], Field(description='A custom criterion.')] = (
        None
    )
    criterion2: Annotated[Optional[str], Field(description='A custom criterion.')] = (
        None
    )
    dynamic_criteria: Annotated[
        Optional[str],
        Field(description='A dynamic formula specified in a custom filter.'),
    ] = None
    filter_on: Annotated[
        Optional[str],
        Field(description='Indicates whether a filter is applied to a column.'),
    ] = None
    icon: Annotated[
        Optional[Union[WorkbookIcon, Dict[str, Any]]],
        Field(description='An icon applied to a cell via conditional formatting.'),
    ] = None
    operator: Annotated[
        Optional[str],
        Field(description='An operator in a cell; for example, =, >, <, <=, or <>.'),
    ] = None
    values: Annotated[
        Optional[Any], Field(description='The values that appear in the cell.')
    ] = None
    field_odata_type: str


class WorkforceIntegrationEncryption(BaseModel):
    protocol: Annotated[
        Optional[Union[WorkforceIntegrationEncryptionProtocol, Dict[str, Any]]],
        Field(description='Possible values are: sharedSecret, unknownFutureValue.'),
    ] = None
    secret: Annotated[Optional[str], Field(description='Encryption shared secret.')] = (
        None
    )
    field_odata_type: str


class WorkingHours(BaseModel):
    days_of_week: Annotated[
        Optional[List[Union[DayOfWeek, Dict[str, Any]]]],
        Field(description='The days of the week on which the user works.'),
    ] = None
    end_time: Annotated[
        Optional[time],
        Field(
            description='The time of the day that the user stops working.',
        ),
    ] = None
    start_time: Annotated[
        Optional[time],
        Field(
            description='The time of the day that the user starts working.',
        ),
    ] = None
    time_zone: Annotated[
        Optional[Union[TimeZoneBase, Dict[str, Any]]],
        Field(description='The time zone to which the working hours apply.'),
    ] = None
    field_odata_type: str


class X509CertificateCRLValidationConfiguration(BaseModel):
    exempted_certificate_authorities_subject_key_identifiers: Optional[List[str]] = None
    state: Optional[X509CertificateCRLValidationConfigurationState] = None
    field_odata_type: str


class X509CertificateRule(BaseModel):
    identifier: Annotated[
        Optional[str],
        Field(description='The identifier of the X.509 certificate. Required.'),
    ] = None
    issuer_subject_identifier: Optional[str] = None
    policy_oid_identifier: Optional[str] = None
    x509_certificate_authentication_mode: Annotated[
        Optional[Union[X509CertificateAuthenticationMode, Dict[str, Any]]],
        Field(
            description='The type of strong authentication mode. The possible values are: x509CertificateSingleFactor, x509CertificateMultiFactor, unknownFutureValue. Required.'
        ),
    ] = None
    x509_certificate_required_affinity_level: Optional[
        Union[X509CertificateAffinityLevel, Dict[str, Any]]
    ] = None
    x509_certificate_rule_type: Annotated[
        Optional[Union[X509CertificateRuleType, Dict[str, Any]]],
        Field(
            description='The type of the X.509 certificate mode configuration rule. The possible values are: issuerSubject, policyOID, unknownFutureValue. Required.'
        ),
    ] = None
    field_odata_type: str


class X509CertificateUserBinding(BaseModel):
    priority: Annotated[
        Optional[float],
        Field(
            description='The priority of the binding. Microsoft Entra ID uses the binding with the highest priority. This value must be a non-negative integer and unique in the collection of objects in the certificateUserBindings property of an x509CertificateAuthenticationMethodConfiguration object. Required',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    trust_affinity_level: Optional[
        Union[X509CertificateAffinityLevel, Dict[str, Any]]
    ] = None
    user_property: Annotated[
        Optional[str],
        Field(
            description='Defines the Microsoft Entra user property of the user object to use for the binding. The possible values are: userPrincipalName, onPremisesUserPrincipalName, certificateUserIds. Required.'
        ),
    ] = None
    x509_certificate_field: Annotated[
        Optional[str],
        Field(
            description='The field on the X.509 certificate to use for the binding. The possible values are: PrincipalName, RFC822Name, SubjectKeyIdentifier, SHA1PublicKey.'
        ),
    ] = None
    field_odata_type: str


class AgreementAcceptanceCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AgreementAcceptance]] = None


class ApplicationTemplateCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ApplicationTemplate]] = None


class CertificateBasedAuthConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[CertificateBasedAuthConfiguration]] = None


class DataPolicyOperationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[DataPolicyOperation]] = None


class DirectoryObjectCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[DirectoryObject]] = None


class DirectoryRoleTemplateCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[DirectoryRoleTemplate]] = None


class DomainDnsRecordCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[DomainDnsRecord]] = None


class FilterOperatorSchemaCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[FilterOperatorSchema]] = None


class GroupLifecyclePolicyCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[GroupLifecyclePolicy]] = None


class GroupSettingCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[GroupSetting]] = None


class GroupSettingTemplateCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[GroupSettingTemplate]] = None


class IdentityProviderCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[IdentityProvider]] = None


class OAuth2PermissionGrantCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[OAuth2PermissionGrant]] = None


class ResourceSpecificPermissionGrantCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[ResourceSpecificPermissionGrant]] = None


class SchemaExtensionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SchemaExtension]] = None


class ScopedRoleMembershipCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ScopedRoleMembership]] = None


class SubscribedSkuCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SubscribedSku]] = None


class SubscriptionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Subscription]] = None


class TeamsTemplateCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[TeamsTemplate]] = None


class CustomExtensionStageSettingCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[CustomExtensionStageSetting]] = None


class AccessPackageQuestionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AccessPackageQuestion]] = None


class CustomCalloutExtensionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[CustomCalloutExtension]] = None


class AccessReviewHistoryInstanceCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AccessReviewHistoryInstance]] = None


class AccessReviewReviewerCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AccessReviewReviewer]] = None


class AccessReviewInstanceDecisionItemCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AccessReviewInstanceDecisionItem]] = None


class AccessReviewStageCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AccessReviewStage]] = None


class GovernanceInsightCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[GovernanceInsight]] = None


class ExtensionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Extension]] = None


class AgreementFileVersionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AgreementFileVersion]] = None


class DeviceCompliancePolicyAssignmentCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DeviceCompliancePolicyAssignment]] = None


class SettingStateDeviceSummaryCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[SettingStateDeviceSummary]] = None


class DeviceComplianceDeviceStatusCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DeviceComplianceDeviceStatus]] = None


class DeviceComplianceScheduledActionForRuleCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DeviceComplianceScheduledActionForRule]] = None


class DeviceComplianceUserStatusCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DeviceComplianceUserStatus]] = None


class DeviceConfigurationAssignmentCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DeviceConfigurationAssignment]] = None


class DeviceConfigurationDeviceStatusCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DeviceConfigurationDeviceStatus]] = None


class DeviceConfigurationUserStatusCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DeviceConfigurationUserStatus]] = None


class MobileAppAssignmentCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[MobileAppAssignment]] = None


class MobileAppCategoryCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[MobileAppCategory]] = None


class TargetedManagedAppPolicyAssignmentCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[TargetedManagedAppPolicyAssignment]] = None


class ManagedMobileAppCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ManagedMobileApp]] = None


class ManagedAppPolicyCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ManagedAppPolicy]] = None


class ManagedAppOperationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ManagedAppOperation]] = None


class ExtensionPropertyCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ExtensionProperty]] = None


class FederatedIdentityCredentialCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[FederatedIdentityCredential]] = None


class TokenIssuancePolicyCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[TokenIssuancePolicy]] = None


class TokenLifetimePolicyCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[TokenLifetimePolicy]] = None


class ApprovalStageCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ApprovalStage]] = None


class EmailAuthenticationMethodCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[EmailAuthenticationMethod]] = None


class Fido2AuthenticationMethodCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[Fido2AuthenticationMethod]] = None


class AuthenticationMethodCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AuthenticationMethod]] = None


class LongRunningOperationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[LongRunningOperation]] = None


class PasswordAuthenticationMethodCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[PasswordAuthenticationMethod]] = None


class PhoneAuthenticationMethodCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[PhoneAuthenticationMethod]] = None


class SoftwareOathAuthenticationMethodCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[SoftwareOathAuthenticationMethod]] = None


class TemporaryAccessPassAuthenticationMethodCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[TemporaryAccessPassAuthenticationMethod]] = None


class UserRegistrationDetailsCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[UserRegistrationDetails]] = None


class AuthenticationCombinationConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AuthenticationCombinationConfiguration]] = None


class AuthenticationMethodModeDetailCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AuthenticationMethodModeDetail]] = None


class AuthenticationStrengthPolicyCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AuthenticationStrengthPolicy]] = None


class UserFlowLanguageConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UserFlowLanguageConfiguration]] = None


class IdentityUserFlowAttributeAssignmentCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[IdentityUserFlowAttributeAssignment]] = None


class IdentityProviderBaseCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[IdentityProviderBase]] = None


class ProtectionPolicyBaseCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ProtectionPolicyBase]] = None


class ServiceAppCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ServiceApp]] = None


class BitlockerRecoveryKeyCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[BitlockerRecoveryKey]] = None


class BookingCustomerBaseCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[BookingCustomerBase]] = None


class BookingCustomQuestionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[BookingCustomQuestion]] = None


class BookingStaffMemberBaseCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[BookingStaffMemberBase]] = None


class CalendarPermissionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[CalendarPermission]] = None


class MultiValueLegacyExtendedPropertyCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[MultiValueLegacyExtendedProperty]] = None


class SingleValueLegacyExtendedPropertyCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[SingleValueLegacyExtendedProperty]] = None


class AttachmentCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Attachment]] = None


class AudioRoutingGroupCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AudioRoutingGroup]] = None


class ContentSharingSessionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ContentSharingSession]] = None


class CommsOperationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[CommsOperation]] = None


class ConversationMemberCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ConversationMember]] = None


class ChatMessageHostedContentCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ChatMessageHostedContent]] = None


class CloudClipboardItemCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[CloudClipboardItem]] = None


class CloudPcUserSettingAssignmentCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[CloudPcUserSettingAssignment]] = None


class AuthenticationContextClassReferenceCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AuthenticationContextClassReference]] = None


class NamedLocationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[NamedLocation]] = None


class ContactFolderCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ContactFolder]] = None


class ContactCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Contact]] = None


class ColumnLinkCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ColumnLink]] = None


class AllowedValueCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AllowedValue]] = None


class DelegatedAdminServiceManagementDetailCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DelegatedAdminServiceManagementDetail]] = None


class DelegatedAdminRelationshipOperationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DelegatedAdminRelationshipOperation]] = None


class DelegatedAdminRelationshipRequestCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DelegatedAdminRelationshipRequest]] = None


class ManagedAppRegistrationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ManagedAppRegistration]] = None


class ManagedAppStatusCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ManagedAppStatus]] = None


class VppTokenCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[VppToken]] = None


class WindowsInformationProtectionPolicyCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[WindowsInformationProtectionPolicy]] = None


class DeviceComplianceSettingStateCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DeviceComplianceSettingState]] = None


class DeviceComplianceActionItemCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DeviceComplianceActionItem]] = None


class EnrollmentConfigurationAssignmentCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[EnrollmentConfigurationAssignment]] = None


class AuditEventCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AuditEvent]] = None


class DeviceCategoryCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[DeviceCategory]] = None


class DeviceManagementPartnerCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[DeviceManagementPartner]] = None


class DeviceManagementExchangeConnectorCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DeviceManagementExchangeConnector]] = None


class IosUpdateDeviceStatusCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[IosUpdateDeviceStatus]] = None


class MobileAppTroubleshootingEventCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[MobileAppTroubleshootingEvent]] = None


class MobileThreatDefenseConnectorCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[MobileThreatDefenseConnector]] = None


class NotificationMessageTemplateCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[NotificationMessageTemplate]] = None


class RemoteAssistancePartnerCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[RemoteAssistancePartner]] = None


class ResourceOperationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ResourceOperation]] = None


class TelecomExpenseManagementPartnerCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[TelecomExpenseManagementPartner]] = None


class DeviceManagementTroubleshootingEventCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DeviceManagementTroubleshootingEvent]] = None


class UserExperienceAnalyticsAppHealthApplicationPerformanceCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UserExperienceAnalyticsAppHealthApplicationPerformance]] = None


class UserExperienceAnalyticsAppHealthAppPerformanceByAppVersionDetailsCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[
        List[UserExperienceAnalyticsAppHealthAppPerformanceByAppVersionDetails]
    ] = None


class UserExperienceAnalyticsAppHealthAppPerformanceByAppVersionDeviceIdCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[
        List[UserExperienceAnalyticsAppHealthAppPerformanceByAppVersionDeviceId]
    ] = None


class UserExperienceAnalyticsAppHealthAppPerformanceByOSVersionCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UserExperienceAnalyticsAppHealthAppPerformanceByOSVersion]] = (
        None
    )


class UserExperienceAnalyticsAppHealthDeviceModelPerformanceCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UserExperienceAnalyticsAppHealthDeviceModelPerformance]] = None


class UserExperienceAnalyticsAppHealthDevicePerformanceCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UserExperienceAnalyticsAppHealthDevicePerformance]] = None


class UserExperienceAnalyticsAppHealthDevicePerformanceDetailsCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UserExperienceAnalyticsAppHealthDevicePerformanceDetails]] = (
        None
    )


class UserExperienceAnalyticsAppHealthOSVersionPerformanceCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UserExperienceAnalyticsAppHealthOSVersionPerformance]] = None


class UserExperienceAnalyticsDevicePerformanceCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UserExperienceAnalyticsDevicePerformance]] = None


class UserExperienceAnalyticsDeviceScoresCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UserExperienceAnalyticsDeviceScores]] = None


class UserExperienceAnalyticsDeviceStartupHistoryCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UserExperienceAnalyticsDeviceStartupHistory]] = None


class UserExperienceAnalyticsDeviceStartupProcessCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UserExperienceAnalyticsDeviceStartupProcess]] = None


class UserExperienceAnalyticsDeviceStartupProcessPerformanceCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UserExperienceAnalyticsDeviceStartupProcessPerformance]] = None


class UserExperienceAnalyticsMetricHistoryCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UserExperienceAnalyticsMetricHistory]] = None


class UserExperienceAnalyticsModelScoresCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UserExperienceAnalyticsModelScores]] = None


class UserExperienceAnalyticsScoreHistoryCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UserExperienceAnalyticsScoreHistory]] = None


class UserExperienceAnalyticsWorkFromAnywhereMetricCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UserExperienceAnalyticsWorkFromAnywhereMetric]] = None


class UserExperienceAnalyticsWorkFromAnywhereModelPerformanceCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UserExperienceAnalyticsWorkFromAnywhereModelPerformance]] = (
        None
    )


class WindowsAutopilotDeviceIdentityCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[WindowsAutopilotDeviceIdentity]] = None


class WindowsInformationProtectionAppLearningSummaryCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[WindowsInformationProtectionAppLearningSummary]] = None


class WindowsInformationProtectionNetworkLearningSummaryCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[WindowsInformationProtectionNetworkLearningSummary]] = None


class WindowsMalwareInformationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[WindowsMalwareInformation]] = None


class DeviceManagementExportJobCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DeviceManagementExportJob]] = None


class AttributeSetCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AttributeSet]] = None


class CustomSecurityAttributeDefinitionCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[CustomSecurityAttributeDefinition]] = None


class DeviceLocalCredentialInfoCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DeviceLocalCredentialInfo]] = None


class CompanySubscriptionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[CompanySubscription]] = None


class ThumbnailSetCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ThumbnailSet]] = None


class DriveItemVersionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[DriveItemVersion]] = None


class EducationCategoryCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[EducationCategory]] = None


class EducationGradingCategoryCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[EducationGradingCategory]] = None


class EducationOutcomeCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[EducationOutcome]] = None


class AuthenticationMethodTargetCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AuthenticationMethodTarget]] = None


class ThreatAssessmentResultCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ThreatAssessmentResult]] = None


class LearningCourseActivityCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[LearningCourseActivity]] = None


class LearningProviderCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[LearningProvider]] = None


class ProfilePhotoCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ProfilePhoto]] = None


class HorizontalSectionColumnCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[HorizontalSectionColumn]] = None


class WebPartCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[WebPart]] = None


class IdentityApiConnectorCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[IdentityApiConnector]] = None


class IdentityUserFlowAttributeCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[IdentityUserFlowAttribute]] = None


class InferenceClassificationOverrideCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[InferenceClassificationOverride]] = None


class ManagedDeviceMobileAppConfigurationAssignmentCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[ManagedDeviceMobileAppConfigurationAssignment]] = None


class ManagedDeviceMobileAppConfigurationDeviceStatusCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[ManagedDeviceMobileAppConfigurationDeviceStatus]] = None


class ManagedDeviceMobileAppConfigurationUserStatusCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[ManagedDeviceMobileAppConfigurationUserStatus]] = None


class ManagedEBookAssignmentCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ManagedEBookAssignment]] = None


class DeviceInstallStateCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[DeviceInstallState]] = None


class UserInstallStateSummaryCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[UserInstallStateSummary]] = None


class SharedInsightCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SharedInsight]] = None


class TrendingCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Trending]] = None


class UsedInsightCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[UsedInsight]] = None


class LandingPageDetailCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[LandingPageDetail]] = None


class LearningContentCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[LearningContent]] = None


class ListItemVersionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ListItemVersion]] = None


class DeviceLogCollectionResponseCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DeviceLogCollectionResponse]] = None


class WindowsInformationProtectionAppLockerFileCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[WindowsInformationProtectionAppLockerFile]] = None


class AttendanceRecordCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AttendanceRecord]] = None


class MicrosoftAuthenticatorAuthenticationMethodTargetCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[MicrosoftAuthenticatorAuthenticationMethodTarget]] = None


class MobileContainedAppCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[MobileContainedApp]] = None


class MobileAppContentFileCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[MobileAppContentFile]] = None


class AppLogCollectionRequestCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AppLogCollectionRequest]] = None


class LocalizedNotificationMessageCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[LocalizedNotificationMessage]] = None


class OnenoteResourceCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[OnenoteResource]] = None


class MeetingAttendanceReportCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[MeetingAttendanceReport]] = None


class CallRecordingCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[CallRecording]] = None


class CallTranscriptCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[CallTranscript]] = None


class OutlookCategoryCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[OutlookCategory]] = None


class ProfileCardPropertyCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ProfileCardProperty]] = None


class PermissionGrantConditionSetCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[PermissionGrantConditionSet]] = None


class FeatureRolloutPolicyCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[FeatureRolloutPolicy]] = None


class PrintServiceCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[PrintService]] = None


class PrintDocumentCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[PrintDocument]] = None


class PrintServiceEndpointCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[PrintServiceEndpoint]] = None


class UnifiedRbacResourceNamespaceCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UnifiedRbacResourceNamespace]] = None


class UnifiedRoleDefinitionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[UnifiedRoleDefinition]] = None


class TargetDeviceGroupCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[TargetDeviceGroup]] = None


class PrintUsageByPrinterCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[PrintUsageByPrinter]] = None


class PrintUsageByUserCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[PrintUsageByUser]] = None


class ExternalDomainNameCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ExternalDomainName]] = None


class SchedulingGroupCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SchedulingGroup]] = None


class TimeOffReasonCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[TimeOffReason]] = None


class TimeOffRequestCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[TimeOffRequest]] = None


class SecureScoreControlProfileCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[SecureScoreControlProfile]] = None


class DelegatedPermissionClassificationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DelegatedPermissionClassification]] = None


class EndpointCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Endpoint]] = None


class ServiceAnnouncementAttachmentCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[ServiceAnnouncementAttachment]] = None


class SimulationAutomationRunCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SimulationAutomationRun]] = None


class SmsAuthenticationMethodTargetCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[SmsAuthenticationMethodTarget]] = None


class BookingCurrencyCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[BookingCurrency]] = None


class TeamsAsyncOperationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[TeamsAsyncOperation]] = None


class TeamworkTagCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[TeamworkTag]] = None


class DeletedChatCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[DeletedChat]] = None


class TeamworkTagMemberCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[TeamworkTagMember]] = None


class TermsAndConditionsAssignmentCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[TermsAndConditionsAssignment]] = None


class AttachmentBaseCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AttachmentBase]] = None


class AttachmentSessionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AttachmentSession]] = None


class ChecklistItemCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ChecklistItem]] = None


class LinkedResourceCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[LinkedResource]] = None


class UnifiedRbacResourceActionCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UnifiedRbacResourceAction]] = None


class ServiceStorageQuotaBreakdownCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[ServiceStorageQuotaBreakdown]] = None


class LicenseDetailsCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[LicenseDetails]] = None


class UserExperienceAnalyticsMetricCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UserExperienceAnalyticsMetric]] = None


class UserExperienceAnalyticsWorkFromAnywhereDeviceCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UserExperienceAnalyticsWorkFromAnywhereDevice]] = None


class UserFlowLanguagePageCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[UserFlowLanguagePage]] = None


class WindowsSettingCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[WindowsSetting]] = None


class CloudPCCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[CloudPC]] = None


class CloudPcDeviceImageCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[CloudPcDeviceImage]] = None


class CloudPcGalleryImageCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[CloudPcGalleryImage]] = None


class VirtualEventRegistrationQuestionBaseCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[VirtualEventRegistrationQuestionBase]] = None


class MalwareStateForWindowsDeviceCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[MalwareStateForWindowsDevice]] = None


class WindowsDeviceMalwareStateCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[WindowsDeviceMalwareState]] = None


class WindowsSettingInstanceCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[WindowsSettingInstance]] = None


class WorkbookCommentCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[WorkbookComment]] = None


class WorkbookOperationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[WorkbookOperation]] = None


class WorkbookChartSeriesCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[WorkbookChartSeries]] = None


class WorkbookChartPointCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[WorkbookChartPoint]] = None


class WorkbookCommentReplyCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[WorkbookCommentReply]] = None


class WorkbookRangeBorderCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[WorkbookRangeBorder]] = None


class WorkbookRangeViewCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[WorkbookRangeView]] = None


class WorkbookTableRowCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[WorkbookTableRow]] = None


class AuthenticationConditionApplicationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AuthenticationConditionApplication]] = None


class DirectoryObjectPartnerReferenceCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DirectoryObjectPartnerReference]] = None


class PolicyBaseCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[PolicyBase]] = None


class StsPolicyCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[StsPolicy]] = None


class DomainDnsSrvRecordCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[DomainDnsSrvRecord]] = None


class DomainDnsTxtRecordCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[DomainDnsTxtRecord]] = None


class DomainDnsUnavailableRecordCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DomainDnsUnavailableRecord]] = None


class AccessPackageTextInputQuestionCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AccessPackageTextInputQuestion]] = None


class UserSignInInsightCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[UserSignInInsight]] = None


class OpenTypeExtensionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[OpenTypeExtension]] = None


class ManagedAppConfigurationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ManagedAppConfiguration]] = None


class ManagedAppProtectionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ManagedAppProtection]] = None


class TargetedManagedAppProtectionCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[TargetedManagedAppProtection]] = None


class WindowsInformationProtectionCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[WindowsInformationProtection]] = None


class Fido2CombinationConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[Fido2CombinationConfiguration]] = None


class X509CertificateCombinationConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[X509CertificateCombinationConfiguration]] = None


class AppleManagedIdentityProviderCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AppleManagedIdentityProvider]] = None


class BuiltInIdentityProviderCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[BuiltInIdentityProvider]] = None


class SamlOrWsFedProviderCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SamlOrWsFedProvider]] = None


class SocialIdentityProviderCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SocialIdentityProvider]] = None


class FileAttachmentCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[FileAttachment]] = None


class ItemAttachmentCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ItemAttachment]] = None


class ReferenceAttachmentCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ReferenceAttachment]] = None


class InviteParticipantsOperationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[InviteParticipantsOperation]] = None


class MuteParticipantOperationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[MuteParticipantOperation]] = None


class PlayPromptOperationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[PlayPromptOperation]] = None


class RecordOperationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[RecordOperation]] = None


class SendDtmfTonesOperationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SendDtmfTonesOperation]] = None


class StartHoldMusicOperationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[StartHoldMusicOperation]] = None


class StopHoldMusicOperationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[StopHoldMusicOperation]] = None


class SubscribeToToneOperationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SubscribeToToneOperation]] = None


class UnmuteParticipantOperationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UnmuteParticipantOperation]] = None


class UpdateRecordingStatusOperationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UpdateRecordingStatusOperation]] = None


class MicrosoftAccountUserConversationMemberCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[MicrosoftAccountUserConversationMember]] = None


class SkypeForBusinessUserConversationMemberCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[SkypeForBusinessUserConversationMember]] = None


class SkypeUserConversationMemberCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[SkypeUserConversationMember]] = None


class CountryNamedLocationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[CountryNamedLocation]] = None


class IpNamedLocationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[IpNamedLocation]] = None


class ManagedAppStatusRawCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ManagedAppStatusRaw]] = None


class EnrollmentTroubleshootingEventCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[EnrollmentTroubleshootingEvent]] = None


class LearningSelfInitiatedCourseCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[LearningSelfInitiatedCourse]] = None


class StandardWebPartCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[StandardWebPart]] = None


class TextWebPartCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[TextWebPart]] = None


class WindowsUniversalAppXContainedAppCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[WindowsUniversalAppXContainedApp]] = None


class TaskFileAttachmentCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[TaskFileAttachment]] = None


class VirtualEventRegistrationCustomQuestionCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[VirtualEventRegistrationCustomQuestion]] = None


class VirtualEventRegistrationPredefinedQuestionCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[VirtualEventRegistrationPredefinedQuestion]] = None


class CustomExtensionCalloutInstanceCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[CustomExtensionCalloutInstance]] = None


class SubjectSetCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SubjectSet]] = None


class AccessPackageAnswerCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AccessPackageAnswer]] = None


class AccessPackageLocalizedTextCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AccessPackageLocalizedText]] = None


class AccessPackageAnswerChoiceCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AccessPackageAnswerChoice]] = None


class AccessPackageResourceAttributeCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AccessPackageResourceAttribute]] = None


class AccessReviewScopeCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AccessReviewScope]] = None


class AccessReviewReviewerScopeCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AccessReviewReviewerScope]] = None


class AccessReviewNotificationRecipientItemCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AccessReviewNotificationRecipientItem]] = None


class AccessReviewStageSettingsCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AccessReviewStageSettings]] = None


class AlertDetectionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AlertDetection]] = None


class CloudAppSecurityStateCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[CloudAppSecurityState]] = None


class FileSecurityStateCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[FileSecurityState]] = None


class AlertHistoryStateCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AlertHistoryState]] = None


class HostSecurityStateCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[HostSecurityState]] = None


class InvestigationSecurityStateCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[InvestigationSecurityState]] = None


class MalwareStateCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[MalwareState]] = None


class MessageSecurityStateCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[MessageSecurityState]] = None


class NetworkConnectionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[NetworkConnection]] = None


class ProcessCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Process]] = None


class RegistryKeyStateCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[RegistryKeyState]] = None


class SecurityResourceCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SecurityResource]] = None


class AlertTriggerCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AlertTrigger]] = None


class UriClickSecurityStateCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[UriClickSecurityState]] = None


class UserSecurityStateCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[UserSecurityState]] = None


class VulnerabilityStateCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[VulnerabilityState]] = None


class OmaSettingCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[OmaSetting]] = None


class AppListItemCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AppListItem]] = None


class AppConsentRequestScopeCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AppConsentRequestScope]] = None


class AddInCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AddIn]] = None


class AppRoleCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AppRole]] = None


class KeyCredentialCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[KeyCredential]] = None


class PasswordCredentialCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[PasswordCredential]] = None


class RequiredResourceAccessCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[RequiredResourceAccess]] = None


class AttendanceIntervalCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AttendanceInterval]] = None


class AttributeMappingParameterSchemaCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AttributeMappingParameterSchema]] = None


class AuditResourceCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AuditResource]] = None


class ExcludeTargetCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ExcludeTarget]] = None


class BookingCustomerInformationBaseCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[BookingCustomerInformationBase]] = None


class BookingReminderCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[BookingReminder]] = None


class BookingWorkHoursCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[BookingWorkHours]] = None


class PhysicalAddressCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[PhysicalAddress]] = None


class PhoneCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Phone]] = None


class BookingQuestionAssignmentCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[BookingQuestionAssignment]] = None


class BrowserSharedCookieHistoryCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[BrowserSharedCookieHistory]] = None


class BrowserSiteHistoryCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[BrowserSiteHistory]] = None


class RecipientCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Recipient]] = None


class InternetMessageHeaderCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[InternetMessageHeader]] = None


class CalendarSharingMessageActionCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[CalendarSharingMessageAction]] = None


class CallRouteCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[CallRoute]] = None


class InvitationParticipantInfoCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[InvitationParticipantInfo]] = None


class CertificateAuthorityCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[CertificateAuthority]] = None


class ChatMessageAttachmentCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ChatMessageAttachment]] = None


class CloudClipboardItemPayloadCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[CloudClipboardItemPayload]] = None


class CloudPcAuditResourceCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[CloudPcAuditResource]] = None


class CloudPcDomainJoinConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[CloudPcDomainJoinConfiguration]] = None


class ServicePlanInfoCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ServicePlanInfo]] = None


class ComplianceManagementPartnerAssignmentCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[ComplianceManagementPartnerAssignment]] = None


class IdentitySourceCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[IdentitySource]] = None


class EmailAddressCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[EmailAddress]] = None


class KeyValuePairCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[KeyValuePair]] = None


class AlternativeSecurityIdCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AlternativeSecurityId]] = None


class RolePermissionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[RolePermission]] = None


class DeviceLocalCredentialCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[DeviceLocalCredential]] = None


class DeviceManagementPartnerAssignmentCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DeviceManagementPartnerAssignment]] = None


class KeyValueCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[KeyValue]] = None


class TargetResourceCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[TargetResource]] = None


class DocumentSetVersionItemCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[DocumentSetVersionItem]] = None


class RubricLevelCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[RubricLevel]] = None


class RubricQualityCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[RubricQuality]] = None


class RubricQualityFeedbackModelCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[RubricQualityFeedbackModel]] = None


class RubricQualitySelectedColumnModelCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[RubricQualitySelectedColumnModel]] = None


class AssignedLicenseCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AssignedLicense]] = None


class AssignedPlanCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AssignedPlan]] = None


class ProvisionedPlanCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ProvisionedPlan]] = None


class RelatedContactCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[RelatedContact]] = None


class RetentionSettingCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[RetentionSetting]] = None


class AssignedLabelCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AssignedLabel]] = None


class OnPremisesProvisioningErrorCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[OnPremisesProvisioningError]] = None


class ServiceProvisioningErrorCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ServiceProvisioningError]] = None


class SettingValueCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SettingValue]] = None


class SettingTemplateValueCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SettingTemplateValue]] = None


class UserAttributeValuesItemCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[UserAttributeValuesItem]] = None


class IosHomeScreenItemCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[IosHomeScreenItem]] = None


class IosHomeScreenPageCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[IosHomeScreenPage]] = None


class IosNotificationSettingsCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[IosNotificationSettings]] = None


class IosNetworkUsageRuleCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[IosNetworkUsageRule]] = None


class AppConfigurationSettingItemCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AppConfigurationSettingItem]] = None


class IpRangeCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[IpRange]] = None


class MacOSIncludedAppCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[MacOSIncludedApp]] = None


class MacOSLobChildAppCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[MacOSLobChildApp]] = None


class ManagedAppPolicyDeploymentSummaryPerAppCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[ManagedAppPolicyDeploymentSummaryPerApp]] = None


class DeviceActionResultCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[DeviceActionResult]] = None


class WindowsInformationProtectionResourceCollectionCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[WindowsInformationProtectionResourceCollection]] = None


class WindowsInformationProtectionIPRangeCollectionCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[WindowsInformationProtectionIPRangeCollection]] = None


class WindowsInformationProtectionProxiedDomainCollectionCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[WindowsInformationProtectionProxiedDomainCollection]] = None


class WindowsInformationProtectionAppCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[WindowsInformationProtectionApp]] = None


class OnTokenIssuanceStartReturnClaimCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[OnTokenIssuanceStartReturnClaim]] = None


class VerifiedDomainCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[VerifiedDomain]] = None


class PhysicalOfficeAddressCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[PhysicalOfficeAddress]] = None


class MediaStreamCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[MediaStream]] = None


class IdentitySetCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[IdentitySet]] = None


class SharePointIdentitySetCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SharePointIdentitySet]] = None


class ScoredEmailAddressCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ScoredEmailAddress]] = None


class WebsiteCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Website]] = None


class ProfileCardAnnotationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ProfileCardAnnotation]] = None


class ModifiedPropertyCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ModifiedProperty]] = None


class ProvisioningStepCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ProvisioningStep]] = None


class ExtensionSchemaPropertyCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ExtensionSchemaProperty]] = None


class AverageComparativeScoreCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AverageComparativeScore]] = None


class ControlScoreCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ControlScore]] = None


class ComplianceInformationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ComplianceInformation]] = None


class SecureScoreControlStateUpdateCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[SecureScoreControlStateUpdate]] = None


class ServiceHealthIssuePostCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ServiceHealthIssuePost]] = None


class PermissionScopeCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[PermissionScope]] = None


class ResourceSpecificPermissionCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[ResourceSpecificPermission]] = None


class SharingDetailCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SharingDetail]] = None


class AppliedConditionalAccessPolicyCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AppliedConditionalAccessPolicy]] = None


class SubjectRightsRequestHistoryCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[SubjectRightsRequestHistory]] = None


class SubjectRightsRequestStageDetailCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[SubjectRightsRequestStageDetail]] = None


class SynchronizationSecretKeyStringValuePairCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[SynchronizationSecretKeyStringValuePair]] = None


class SynchronizationMetadataEntryCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[SynchronizationMetadataEntry]] = None


class UnifiedRolePermissionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[UnifiedRolePermission]] = None


class ObjectIdentityCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ObjectIdentity]] = None


class LicenseAssignmentStateCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[LicenseAssignmentState]] = None


class UserExperienceAnalyticsInsightCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UserExperienceAnalyticsInsight]] = None


class VirtualEventExternalInformationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[VirtualEventExternalInformation]] = None


class VirtualEventRegistrationQuestionAnswerCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[VirtualEventRegistrationQuestionAnswer]] = None


class CommunicationsUserIdentityCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[CommunicationsUserIdentity]] = None


class IdentityCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Identity]] = None


class Win32LobAppReturnCodeCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Win32LobAppReturnCode]] = None


class Win32LobAppRuleCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Win32LobAppRule]] = None


class WorkbookSortFieldCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[WorkbookSortField]] = None


class X509CertificateUserBindingCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[X509CertificateUserBinding]] = None


class AccessPackageApprovalStageCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AccessPackageApprovalStage]] = None


class AccessReviewApplyActionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AccessReviewApplyAction]] = None


class AccessReviewRecommendationInsightSettingCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AccessReviewRecommendationInsightSetting]] = None


class PreAuthorizedApplicationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[PreAuthorizedApplication]] = None


class KeyCredentialConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[KeyCredentialConfiguration]] = None


class PasswordCredentialConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[PasswordCredentialConfiguration]] = None


class UnifiedApprovalStageCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[UnifiedApprovalStage]] = None


class UserTrainingStatusInfoCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[UserTrainingStatusInfo]] = None


class StringKeyStringValuePairCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[StringKeyStringValuePair]] = None


class AttributeDefinitionMetadataEntryCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AttributeDefinitionMetadataEntry]] = None


class ReferencedObjectCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ReferencedObject]] = None


class AuditPropertyCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AuditProperty]] = None


class AuthenticationAttributeCollectionOptionConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AuthenticationAttributeCollectionOptionConfiguration]] = None


class AuthenticationAttributeCollectionPageViewConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AuthenticationAttributeCollectionPageViewConfiguration]] = None


class AuthenticationAttributeCollectionInputConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AuthenticationAttributeCollectionInputConfiguration]] = None


class GenericErrorCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[GenericError]] = None


class AuthenticationMethodsRegistrationCampaignIncludeTargetCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AuthenticationMethodsRegistrationCampaignIncludeTarget]] = None


class BookingQuestionAnswerCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[BookingQuestionAnswer]] = None


class BookingWorkTimeSlotCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[BookingWorkTimeSlot]] = None


class BucketAggregationRangeCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[BucketAggregationRange]] = None


class CallParticipantInfoCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[CallParticipantInfo]] = None


class ChangeNotificationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ChangeNotification]] = None


class Pkcs12CertificateInformationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[Pkcs12CertificateInformation]] = None


class CloudPcUserRoleScopeTagInfoCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[CloudPcUserRoleScopeTagInfo]] = None


class CloudPcAuditPropertyCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[CloudPcAuditProperty]] = None


class CloudPcOnPremisesConnectionHealthCheckCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[CloudPcOnPremisesConnectionHealthCheck]] = None


class DisplayNameLocalizationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[DisplayNameLocalization]] = None


class CommsNotificationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[CommsNotification]] = None


class CertificationControlCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[CertificationControl]] = None


class CrossTenantAccessPolicyTargetCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[CrossTenantAccessPolicyTarget]] = None


class UnifiedRoleCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[UnifiedRole]] = None


class SettingSourceCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SettingSource]] = None


class ContentTypeInfoCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ContentTypeInfo]] = None


class DocumentSetContentCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[DocumentSetContent]] = None


class PayloadCoachmarkCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[PayloadCoachmark]] = None


class StringKeyObjectValuePairCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[StringKeyObjectValuePair]] = None


class SensitivityLabelAssignmentCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[SensitivityLabelAssignment]] = None


class FilterGroupCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[FilterGroup]] = None


class FilterClauseCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[FilterClause]] = None


class ResourcePermissionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ResourcePermission]] = None


class IosHomeScreenFolderPageCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[IosHomeScreenFolderPage]] = None


class IosHomeScreenAppCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[IosHomeScreenApp]] = None


class MeetingParticipantInfoCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[MeetingParticipantInfo]] = None


class TeamworkUserIdentityCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[TeamworkUserIdentity]] = None


class ObjectDefinitionMetadataEntryCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[ObjectDefinitionMetadataEntry]] = None


class ObjectMappingMetadataEntryCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[ObjectMappingMetadataEntry]] = None


class ShiftActivityCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ShiftActivity]] = None


class OptionalClaimCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[OptionalClaim]] = None


class IntegerRangeCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[IntegerRange]] = None


class PublicErrorDetailCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[PublicErrorDetail]] = None


class ResourceAccessCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ResourceAccess]] = None


class ResourceActionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ResourceAction]] = None


class RubricCriterionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[RubricCriterion]] = None


class ScheduleItemCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ScheduleItem]] = None


class SearchBucketCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SearchBucket]] = None


class AlteredQueryTokenCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AlteredQueryToken]] = None


class SearchAggregationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SearchAggregation]] = None


class SearchHitCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SearchHit]] = None


class CollapsePropertyCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[CollapseProperty]] = None


class SortPropertyCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SortProperty]] = None


class SearchHitsContainerCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SearchHitsContainer]] = None


class MetaDataKeyStringPairCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[MetaDataKeyStringPair]] = None


class MediaInfoCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[MediaInfo]] = None


class TimeRangeCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[TimeRange]] = None


class SimulationEventCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SimulationEvent]] = None


class RecommendedActionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[RecommendedAction]] = None


class AvailabilityItemCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AvailabilityItem]] = None


class SynchronizationProgressCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SynchronizationProgress]] = None


class StringKeyLongValuePairCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[StringKeyLongValuePair]] = None


class TeamsAppResourceSpecificPermissionCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[TeamsAppResourceSpecificPermission]] = None


class TeleconferenceDeviceMediaQualityCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[TeleconferenceDeviceMediaQuality]] = None


class TimeSlotCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[TimeSlot]] = None


class AssignedTrainingInfoCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AssignedTrainingInfo]] = None


class UserExperienceAnalyticsInsightValueCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UserExperienceAnalyticsInsightValue]] = None


class UserRegistrationFeatureCountCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UserRegistrationFeatureCount]] = None


class UserRegistrationMethodCountCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UserRegistrationMethodCount]] = None


class UserSimulationEventInfoCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[UserSimulationEventInfo]] = None


class UserTrainingEventInfoCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[UserTrainingEventInfo]] = None


class RedirectUriSettingsCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[RedirectUriSettings]] = None


class ProxiedDomainCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ProxiedDomain]] = None


class WindowsMalwareCategoryCountCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[WindowsMalwareCategoryCount]] = None


class WindowsMalwareExecutionStateCountCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[WindowsMalwareExecutionStateCount]] = None


class WindowsMalwareNameCountCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[WindowsMalwareNameCount]] = None


class WindowsMalwareSeverityCountCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[WindowsMalwareSeverityCount]] = None


class WindowsMalwareStateCountCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[WindowsMalwareStateCount]] = None


class OsVersionCountCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[OsVersionCount]] = None


class X509CertificateRuleCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[X509CertificateRule]] = None


class AccessPackageAssignmentRequestWorkflowExtension(CustomCalloutExtension):
    callback_configuration: Annotated[
        Optional[Union[CustomExtensionCallbackConfiguration, Dict[str, Any]]],
        Field(description='The callback configuration for a custom extension.'),
    ] = None
    created_by: Annotated[
        Optional[str],
        Field(
            description='The userPrincipalName of the user or identity of the subject that created this resource. Read-only.'
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='When the object was created.',
        ),
    ] = None
    last_modified_by: Annotated[
        Optional[str],
        Field(
            description='The userPrincipalName of the identity that last modified the object.'
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='When the object was last modified.',
        ),
    ] = None
    field_odata_type: str


class AccessPackageAssignmentWorkflowExtension(CustomCalloutExtension):
    callback_configuration: Annotated[
        Optional[Union[CustomExtensionCallbackConfiguration, Dict[str, Any]]],
        Field(description='The callback configuration for a custom extension.'),
    ] = None
    created_by: Annotated[
        Optional[str],
        Field(
            description='The userPrincipalName of the user or identity of the subject that created this resource. Read-only.'
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='When the entity was created.',
        ),
    ] = None
    last_modified_by: Annotated[
        Optional[str],
        Field(
            description='The userPrincipalName of the identity that last modified the entity.'
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='When the entity was last modified.',
        ),
    ] = None
    field_odata_type: str


class AccessPackageMultipleChoiceQuestion(AccessPackageQuestion):
    choices: Annotated[
        Optional[List[AccessPackageAnswerChoice]],
        Field(description='List of answer choices.'),
    ] = None
    is_multiple_selection_allowed: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether requestor can select multiple choices as their answer.'
        ),
    ] = None
    field_odata_type: str


class AccessReviewInstance(Entity):
    end_date_time: Annotated[
        Optional[datetime],
        Field(
            description='DateTime when review instance is scheduled to end.The DatetimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Supports $select. Read-only.',
        ),
    ] = None
    fallback_reviewers: Annotated[
        Optional[List[AccessReviewReviewerScope]],
        Field(
            description="This collection of reviewer scopes is used to define the list of fallback reviewers. These fallback reviewers will be notified to take action if no users are found from the list of reviewers specified. This could occur when either the group owner is specified as the reviewer but the group owner does not exist, or manager is specified as reviewer but a user's manager does not exist. Supports $select."
        ),
    ] = None
    reviewers: Annotated[
        Optional[List[AccessReviewReviewerScope]],
        Field(
            description='This collection of access review scopes is used to define who the reviewers are. Supports $select. For examples of options for assigning reviewers, see Assign reviewers to your access review definition using the Microsoft Graph API.'
        ),
    ] = None
    scope: Annotated[
        Optional[Union[AccessReviewScope, Dict[str, Any]]],
        Field(
            description='Created based on scope and instanceEnumerationScope at the accessReviewScheduleDefinition level. Defines the scope of users reviewed in a group. Supports $select and $filter (contains only). Read-only.'
        ),
    ] = None
    start_date_time: Annotated[
        Optional[datetime],
        Field(
            description='DateTime when review instance is scheduled to start. May be in the future. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Supports $select. Read-only.',
        ),
    ] = None
    status: Annotated[
        Optional[str],
        Field(
            description='Specifies the status of an accessReview. Possible values: Initializing, NotStarted, Starting, InProgress, Completing, Completed, AutoReviewing, and AutoReviewed. Supports $select, $orderby, and $filter (eq only). Read-only.'
        ),
    ] = None
    contacted_reviewers: Annotated[
        Optional[List[AccessReviewReviewer]],
        Field(
            description='Returns the collection of reviewers who were contacted to complete this review. While the reviewers and fallbackReviewers properties of the accessReviewScheduleDefinition might specify group owners or managers as reviewers, contactedReviewers returns their individual identities. Supports $select. Read-only.'
        ),
    ] = None
    decisions: Annotated[
        Optional[List[AccessReviewInstanceDecisionItem]],
        Field(
            description='Each user reviewed in an accessReviewInstance has a decision item representing if they were approved, denied, or not yet reviewed.'
        ),
    ] = None
    stages: Annotated[
        Optional[List[AccessReviewStage]],
        Field(
            description='If the instance has multiple stages, this returns the collection of stages. A new stage will only be created when the previous stage ends. The existence, number, and settings of stages on a review instance are created based on the accessReviewStageSettings on the parent accessReviewScheduleDefinition.'
        ),
    ] = None
    field_odata_type: str


class ActivityBasedTimeoutPolicy(StsPolicy):
    field_odata_type: str


class AddLargeGalleryViewOperation(CommsOperation):
    field_odata_type: str


class AdministrativeUnit(DirectoryObject):
    description: Annotated[
        Optional[str],
        Field(
            description='An optional description for the administrative unit. Supports $filter (eq, ne, in, startsWith), $search.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='Display name for the administrative unit. Maximum length is 256 characters. Supports $filter (eq, ne, not, ge, le, in, startsWith, and eq on null values), $search, and $orderby.'
        ),
    ] = None
    is_member_management_restricted: Optional[bool] = None
    membership_rule: Annotated[
        Optional[str],
        Field(
            description='The dynamic membership rule for the administrative unit. For more information about the rules you can use for dynamic administrative units and dynamic groups, see Manage rules for dynamic membership groups in Microsoft Entra ID.'
        ),
    ] = None
    membership_rule_processing_state: Annotated[
        Optional[str],
        Field(
            description='Controls whether the dynamic membership rule is actively processed. Set to On to activate the dynamic membership rule, or Paused to stop updating membership dynamically.'
        ),
    ] = None
    membership_type: Annotated[
        Optional[str],
        Field(
            description='Indicates the membership type for the administrative unit. The possible values are: dynamic, assigned. If not set, the default value is null and the default behavior is assigned.'
        ),
    ] = None
    visibility: Annotated[
        Optional[str],
        Field(
            description='Controls whether the administrative unit and its members are hidden or public. Can be set to HiddenMembership. If not set, the default value is null and the default behavior is public. When set to HiddenMembership, only members of the administrative unit can list other members of the administrative unit.'
        ),
    ] = None
    extensions: Annotated[
        Optional[List[Extension]],
        Field(
            description='The collection of open extensions defined for this administrative unit. Nullable.'
        ),
    ] = None
    members: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description='Users and groups that are members of this administrative unit. Supports $expand.'
        ),
    ] = None
    scoped_role_members: Annotated[
        Optional[List[ScopedRoleMembership]],
        Field(description='Scoped-role members of this administrative unit.'),
    ] = None
    field_odata_type: str


class AdminMicrosoft365Apps(Entity):
    installation_options: Annotated[
        Optional[Union[M365AppsInstallationOptions, Dict[str, Any]]],
        Field(
            description='A container for tenant-level settings for Microsoft 365 applications.'
        ),
    ] = None
    field_odata_type: str


class AgreementFileLocalization(AgreementFileProperties):
    versions: Annotated[
        Optional[List[AgreementFileVersion]],
        Field(
            description='Read-only. Customized versions of the terms of use agreement in the Microsoft Entra tenant.'
        ),
    ] = None
    field_odata_type: str


class Alert(Entity):
    activity_group_name: Annotated[
        Optional[str],
        Field(
            description='Name or alias of the activity group (attacker) this alert is attributed to.'
        ),
    ] = None
    alert_detections: Optional[List[AlertDetection]] = None
    assigned_to: Annotated[
        Optional[str],
        Field(
            description='Name of the analyst the alert is assigned to for triage, investigation, or remediation (supports update).'
        ),
    ] = None
    azure_subscription_id: Annotated[
        Optional[str],
        Field(
            description='Azure subscription ID, present if this alert is related to an Azure resource.'
        ),
    ] = None
    azure_tenant_id: Annotated[
        Optional[str], Field(description='Microsoft Entra tenant ID. Required.')
    ] = None
    category: Annotated[
        Optional[str],
        Field(
            description='Category of the alert (for example, credentialTheft, ransomware).'
        ),
    ] = None
    closed_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Time at which the alert was closed. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z (supports update).',
        ),
    ] = None
    cloud_app_states: Annotated[
        Optional[List[CloudAppSecurityState]],
        Field(
            description='Security-related stateful information generated by the provider about the cloud application/s related to this alert.'
        ),
    ] = None
    comments: Annotated[
        Optional[List[str]],
        Field(
            description='Customer-provided comments on alert (for customer alert management) (supports update).'
        ),
    ] = None
    confidence: Annotated[
        Optional[float],
        Field(
            description='Confidence of the detection logic (percentage between 1-100).',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Time at which the alert was created by the alert provider. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Required.',
        ),
    ] = None
    description: Annotated[Optional[str], Field(description='Alert description.')] = (
        None
    )
    detection_ids: Annotated[
        Optional[List[str]],
        Field(
            description='Set of alerts related to this alert entity (each alert is pushed to the SIEM as a separate record).'
        ),
    ] = None
    event_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Time at which the event or events that served as the trigger to generate the alert occurred. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Required.',
        ),
    ] = None
    feedback: Annotated[
        Optional[Union[AlertFeedback, Dict[str, Any]]],
        Field(
            description='Analyst feedback on the alert. Possible values are: unknown, truePositive, falsePositive, benignPositive. Supports update.'
        ),
    ] = None
    file_states: Annotated[
        Optional[List[FileSecurityState]],
        Field(
            description='Security-related stateful information generated by the provider about the file(s) related to this alert.'
        ),
    ] = None
    history_states: Optional[List[AlertHistoryState]] = None
    host_states: Annotated[
        Optional[List[HostSecurityState]],
        Field(
            description='Security-related stateful information generated by the provider about the host(s) related to this alert.'
        ),
    ] = None
    incident_ids: Annotated[
        Optional[List[str]],
        Field(description='IDs of incidents related to current alert.'),
    ] = None
    investigation_security_states: Optional[List[InvestigationSecurityState]] = None
    last_event_date_time: Annotated[
        Optional[datetime],
        Field(
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Time at which the alert entity was last modified. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    malware_states: Annotated[
        Optional[List[MalwareState]],
        Field(
            description='Threat Intelligence pertaining to malware related to this alert.'
        ),
    ] = None
    message_security_states: Optional[List[MessageSecurityState]] = None
    network_connections: Annotated[
        Optional[List[NetworkConnection]],
        Field(
            description='Security-related stateful information generated by the provider about the network connection(s) related to this alert.'
        ),
    ] = None
    processes: Annotated[
        Optional[List[Process]],
        Field(
            description='Security-related stateful information generated by the provider about the process or processes related to this alert.'
        ),
    ] = None
    recommended_actions: Annotated[
        Optional[List[str]],
        Field(
            description='Vendor/provider recommended action(s) to take as a result of the alert (for example, isolate machine, enforce2FA, reimage host).'
        ),
    ] = None
    registry_key_states: Annotated[
        Optional[List[RegistryKeyState]],
        Field(
            description='Security-related stateful information generated by the provider about the registry keys related to this alert.'
        ),
    ] = None
    security_resources: Annotated[
        Optional[List[SecurityResource]],
        Field(
            description='Resources related to current alert. For example, for some alerts this can have the Azure Resource value.'
        ),
    ] = None
    severity: Optional[AlertSeverity] = None
    source_materials: Annotated[
        Optional[List[str]],
        Field(
            description="Hyperlinks (URIs) to the source material related to the alert, for example, provider's user interface for alerts or log search."
        ),
    ] = None
    status: Optional[AlertStatus] = None
    tags: Annotated[
        Optional[List[str]],
        Field(
            description="User-definable labels that can be applied to an alert and can serve as filter conditions (for example 'HVA', 'SAW') (supports update)."
        ),
    ] = None
    title: Annotated[Optional[str], Field(description='Alert title. Required.')] = None
    triggers: Annotated[
        Optional[List[AlertTrigger]],
        Field(
            description='Security-related information about the specific properties that triggered the alert (properties appearing in the alert). Alerts might contain information about multiple users, hosts, files, ip addresses. This field indicates which properties triggered the alert generation.'
        ),
    ] = None
    uri_click_security_states: Optional[List[UriClickSecurityState]] = None
    user_states: Annotated[
        Optional[List[UserSecurityState]],
        Field(
            description='Security-related stateful information generated by the provider about the user accounts related to this alert.'
        ),
    ] = None
    vendor_information: Annotated[
        Optional[Union[SecurityVendorInformation, Dict[str, Any]]],
        Field(
            description='Complex type containing details about the security product/service vendor, provider, and subprovider (for example, vendor=Microsoft; provider=Windows Defender ATP; subProvider=AppLocker). Required.'
        ),
    ] = None
    vulnerability_states: Annotated[
        Optional[List[VulnerabilityState]],
        Field(
            description='Threat intelligence pertaining to one or more vulnerabilities related to this alert.'
        ),
    ] = None
    field_odata_type: str


class AndroidManagedAppRegistration(ManagedAppRegistration):
    field_odata_type: str


class AnonymousGuestConversationMember(ConversationMember):
    anonymous_guest_id: Annotated[
        Optional[str],
        Field(
            description='Unique ID that represents the user. Note: This ID can change if the user leaves and rejoins the meeting, or joins from a different device.'
        ),
    ] = None
    field_odata_type: str


class AppRoleAssignment(DirectoryObject):
    app_role_id: Annotated[
        Optional[UUID],
        Field(
            description="The identifier (id) for the app role that's assigned to the principal. This app role must be exposed in the appRoles property on the resource application's service principal (resourceId). If the resource application hasn't declared any app roles, a default app role ID of 00000000-0000-0000-0000-000000000000 can be specified to signal that the principal is assigned to the resource app without any specific app roles. Required on create.",
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The time when the app role assignment was created. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.',
        ),
    ] = None
    principal_display_name: Annotated[
        Optional[str],
        Field(
            description='The display name of the user, group, or service principal that was granted the app role assignment. Maximum length is 256 characters. Read-only. Supports $filter (eq and startswith).'
        ),
    ] = None
    principal_id: Annotated[
        Optional[UUID],
        Field(
            description='The unique identifier (id) for the user, security group, or service principal being granted the app role. Security groups with dynamic memberships are supported. Required on create.',
        ),
    ] = None
    principal_type: Annotated[
        Optional[str],
        Field(
            description='The type of the assigned principal. This can either be User, Group, or ServicePrincipal. Read-only.'
        ),
    ] = None
    resource_display_name: Annotated[
        Optional[str],
        Field(
            description="The display name of the resource app's service principal to which the assignment is made. Maximum length is 256 characters."
        ),
    ] = None
    resource_id: Annotated[
        Optional[UUID],
        Field(
            description='The unique identifier (id) for the resource service principal for which the assignment is made. Required on create. Supports $filter (eq only).',
        ),
    ] = None
    field_odata_type: str


class Approval(Entity):
    stages: Annotated[
        Optional[List[ApprovalStage]],
        Field(description='A collection of stages in the approval decision.'),
    ] = None
    field_odata_type: str


class AttackSimulationOperation(LongRunningOperation):
    percentage_completed: Annotated[
        Optional[float],
        Field(
            description='Percentage of completion of the respective operation.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    tenant_id: Annotated[Optional[str], Field(description='Tenant identifier.')] = None
    type: Annotated[
        Optional[Union[AttackSimulationOperationType, Dict[str, Any]]],
        Field(
            description='The attack simulation operation type. Possible values are: createSimulation, updateSimulation, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class AttributeMappingFunctionSchema(Entity):
    parameters: Annotated[
        Optional[List[AttributeMappingParameterSchema]],
        Field(description='Collection of function parameters.'),
    ] = None
    field_odata_type: str


class AuthenticationEventListener(Entity):
    authentication_events_flow_id: Annotated[
        Optional[str],
        Field(
            description='Indicates the authenticationEventListener is associated with an authenticationEventsFlow. Read-only.'
        ),
    ] = None
    conditions: Annotated[
        Optional[Union[AuthenticationConditions, Dict[str, Any]]],
        Field(
            description='The conditions on which this authenticationEventListener should trigger.'
        ),
    ] = None
    field_odata_type: str


class AuthenticationEventsFlow(Entity):
    conditions: Annotated[
        Optional[Union[AuthenticationConditions, Dict[str, Any]]],
        Field(
            description="The conditions representing the context of the authentication request that's used to decide whether the events policy is invoked.  Supports $filter (eq). See support for filtering on user flows for syntax information."
        ),
    ] = None
    description: Annotated[
        Optional[str], Field(description='The description of the events policy.')
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(description='Required. The display name for the events policy.'),
    ] = None
    field_odata_type: str


class AuthenticationMethodConfiguration(Entity):
    exclude_targets: Annotated[
        Optional[List[ExcludeTarget]],
        Field(description='Groups of users that are excluded from a policy.'),
    ] = None
    state: Annotated[
        Optional[Union[AuthenticationMethodState, Dict[str, Any]]],
        Field(
            description='The state of the policy. Possible values are: enabled, disabled.'
        ),
    ] = None
    field_odata_type: str


class AuthenticationMethodsRoot(Entity):
    user_registration_details: Annotated[
        Optional[List[UserRegistrationDetails]],
        Field(
            description="Represents the state of a user's authentication methods, including which methods are registered and which features the user is registered and capable of (such as multifactor authentication, self-service password reset, and passwordless authentication)."
        ),
    ] = None
    field_odata_type: str


class AuthoredNote(Entity):
    author: Annotated[
        Optional[Union[Identity, Dict[str, Any]]],
        Field(description="Identity information about the note's author."),
    ] = None
    content: Annotated[
        Optional[Union[ItemBody, Dict[str, Any]]],
        Field(description='The content of the note.'),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the entity was created. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    field_odata_type: str


class AuthorizationPolicy(PolicyBase):
    allowed_to_sign_up_email_based_subscriptions: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether users can sign up for email based subscriptions.'
        ),
    ] = None
    allowed_to_use_sspr: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether administrators of the tenant can use the Self-Service Password Reset (SSPR). For more information, see Self-service password reset for administrators.'
        ),
    ] = None
    allow_email_verified_users_to_join_organization: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether a user can join the tenant by email validation.'
        ),
    ] = None
    allow_invites_from: Annotated[
        Optional[Union[AllowInvitesFrom, Dict[str, Any]]],
        Field(
            description='Indicates who can invite guests to the organization. Possible values are: none, adminsAndGuestInviters, adminsGuestInvitersAndAllMembers, everyone.  everyone is the default setting for all cloud environments except US Government. For more information, see allowInvitesFrom values.'
        ),
    ] = None
    allow_user_consent_for_risky_apps: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether user consent for risky apps is allowed. We recommend keeping allowUserConsentForRiskyApps as false. Default value is false.'
        ),
    ] = None
    block_msol_power_shell: Annotated[
        Optional[bool],
        Field(
            description="To disable the use of MSOL PowerShell, set this property to true. This also disables user-based access to the legacy service endpoint used by MSOL PowerShell. This doesn't affect Microsoft Entra Connect or Microsoft Graph."
        ),
    ] = None
    default_user_role_permissions: Optional[DefaultUserRolePermissions] = None
    guest_user_role_id: Annotated[
        Optional[UUID],
        Field(
            description='Represents role templateId for the role that should be granted to guests. Currently following roles are supported:  User (a0b1b346-4d3e-4e8b-98f8-753987be4970), Guest User (10dae51f-b6af-4016-8d66-8c2a99b929b3), and Restricted Guest User (2af84b1e-32c8-42b7-82bc-daa82404023b).',
        ),
    ] = None
    field_odata_type: str


class AzureCommunicationServicesUserConversationMember(ConversationMember):
    azure_communication_services_id: Annotated[
        Optional[str], Field(description='Azure Communication Services ID of the user.')
    ] = None
    field_odata_type: str


class B2xIdentityUserFlow(IdentityUserFlow):
    api_connector_configuration: Annotated[
        Optional[Union[UserFlowApiConnectorConfiguration, Dict[str, Any]]],
        Field(
            description='Configuration for enabling an API connector for use as part of the self-service sign-up user flow. You can only obtain the value of this object using Get userFlowApiConnectorConfiguration.'
        ),
    ] = None
    identity_providers: Annotated[
        Optional[List[IdentityProvider]],
        Field(description='The identity providers included in the user flow.'),
    ] = None
    languages: Annotated[
        Optional[List[UserFlowLanguageConfiguration]],
        Field(
            description="The languages supported for customization within the user flow. Language customization is enabled by default in self-service sign-up user flow. You can't create custom languages in self-service sign-up user flows."
        ),
    ] = None
    user_attribute_assignments: Annotated[
        Optional[List[IdentityUserFlowAttributeAssignment]],
        Field(description='The user attribute assignments included in the user flow.'),
    ] = None
    user_flow_identity_providers: Optional[List[IdentityProviderBase]] = None
    field_odata_type: str


class Bitlocker(Entity):
    recovery_keys: Annotated[
        Optional[List[BitlockerRecoveryKey]],
        Field(description='The recovery keys associated with the bitlocker entity.'),
    ] = None
    field_odata_type: str


class BookingCustomer(BookingCustomerBase):
    addresses: Annotated[
        Optional[List[PhysicalAddress]],
        Field(
            description="Addresses associated with the customer. The attribute type of physicalAddress isn't supported in v1.0. Internally we map the addresses to the type others."
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date, time, and time zone when the customer was created. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The name of the customer.')
    ] = None
    email_address: Annotated[
        Optional[str], Field(description='The SMTP address of the customer.')
    ] = None
    last_updated_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date, time, and time zone when the customer was last updated. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    phones: Annotated[
        Optional[List[Phone]],
        Field(
            description='Phone numbers associated with the customer, including home, business, and mobile numbers.'
        ),
    ] = None
    field_odata_type: str


class BookingStaffMember(BookingStaffMemberBase):
    availability_is_affected_by_personal_calendar: Annotated[
        Optional[bool],
        Field(
            description="True means that if the staff member is a Microsoft 365 user, the Bookings API would verify the staff member's availability in their personal calendar in Microsoft 365, before making a booking."
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date, time, and time zone when the staff member was created. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='The name of the staff member, as displayed to customers. Required.'
        ),
    ] = None
    email_address: Annotated[
        Optional[str],
        Field(
            description='The email address of the staff member. This email address can be in the same Microsoft 365 tenant as the business, or in a different email domain. This email address can be used if the sendConfirmationsToOwner property is set to true in the scheduling policy of the business. Required.'
        ),
    ] = None
    is_email_notification_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates that a staff member is notified via email when a booking assigned to them is created or changed. The default value is true.'
        ),
    ] = None
    last_updated_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date, time, and time zone when the staff member was last updated. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    membership_status: Optional[BookingStaffMembershipStatus] = None
    role: Optional[BookingStaffRole] = None
    time_zone: Annotated[
        Optional[str],
        Field(
            description='The time zone of the staff member. For a list of possible values, see dateTimeTimeZone.'
        ),
    ] = None
    use_business_hours: Annotated[
        Optional[bool],
        Field(
            description="True means the staff member's availability is as specified in the businessHours property of the business. False means the availability is determined by the staff member's workingHours property setting."
        ),
    ] = None
    working_hours: Annotated[
        Optional[List[BookingWorkHours]],
        Field(
            description="The range of hours each day of the week that the staff member is available for booking. By default, they're initialized to be the same as the businessHours property of the business."
        ),
    ] = None
    field_odata_type: str


class BrowserSharedCookie(Entity):
    comment: Annotated[
        Optional[str], Field(description='The comment for the shared cookie.')
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the shared cookie was created.',
        ),
    ] = None
    deleted_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the shared cookie was deleted.',
        ),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The name of the cookie.')
    ] = None
    history: Annotated[
        Optional[List[BrowserSharedCookieHistory]],
        Field(description='The history of modifications applied to the cookie.'),
    ] = None
    host_only: Annotated[
        Optional[bool],
        Field(description='Controls whether a cookie is a host-only or domain cookie.'),
    ] = None
    host_or_domain: Annotated[
        Optional[str], Field(description='The URL of the cookie.')
    ] = None
    last_modified_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='The user who last modified the cookie.'),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the cookie was last modified.',
        ),
    ] = None
    path: Annotated[Optional[str], Field(description='The path of the cookie.')] = None
    source_environment: Optional[BrowserSharedCookieSourceEnvironment] = None
    status: Optional[BrowserSharedCookieStatus] = None
    field_odata_type: str


class BrowserSite(Entity):
    allow_redirect: Annotated[
        Optional[bool],
        Field(
            description='Controls the behavior of redirected sites. If true, indicates that the site will open in Internet Explorer 11 or Microsoft Edge even if the site is navigated to as part of a HTTP or meta refresh redirection chain.'
        ),
    ] = None
    comment: Annotated[
        Optional[str], Field(description='The comment for the site.')
    ] = None
    compatibility_mode: Optional[BrowserSiteCompatibilityMode] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the site was created.',
        ),
    ] = None
    deleted_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the site was deleted.',
        ),
    ] = None
    history: Annotated[
        Optional[List[BrowserSiteHistory]],
        Field(description='The history of modifications applied to the site.'),
    ] = None
    last_modified_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='The user who last modified the site.'),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the site was last modified.',
        ),
    ] = None
    merge_type: Optional[BrowserSiteMergeType] = None
    status: Optional[BrowserSiteStatus] = None
    target_environment: Optional[BrowserSiteTargetEnvironment] = None
    web_url: Annotated[Optional[str], Field(description='The URL of the site.')] = None
    field_odata_type: str


class BrowserSiteList(Entity):
    description: Annotated[
        Optional[str], Field(description='The description of the site list.')
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The name of the site list.')
    ] = None
    last_modified_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='The user who last modified the site list.'),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the site list was last modified.',
        ),
    ] = None
    published_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='The user who published the site list.'),
    ] = None
    published_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the site list was published.',
        ),
    ] = None
    revision: Annotated[
        Optional[str], Field(description='The current revision of the site list.')
    ] = None
    status: Optional[BrowserSiteListStatus] = None
    shared_cookies: Annotated[
        Optional[List[BrowserSharedCookie]],
        Field(description='A collection of shared cookies defined for the site list.'),
    ] = None
    sites: Annotated[
        Optional[List[BrowserSite]],
        Field(description='A collection of sites defined for the site list.'),
    ] = None
    field_odata_type: str


class CancelMediaProcessingOperation(CommsOperation):
    field_odata_type: str


class ChatMessageInfo(Entity):
    body: Annotated[
        Optional[Union[ItemBody, Dict[str, Any]]],
        Field(
            description="Body of the chatMessage. This will still contain markers for @mentions and attachments even though the object doesn't return @mentions and attachments."
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date time object representing the time at which message was created.',
        ),
    ] = None
    event_detail: Annotated[
        Optional[Union[EventMessageDetail, Dict[str, Any]]],
        Field(
            description='Read-only.  If present, represents details of an event that happened in a chat, a channel, or a team, for example, members were added, and so on. For event messages, the messageType property is set to systemEventMessage.'
        ),
    ] = None
    from_: Annotated[
        Optional[Union[ChatMessageFromIdentitySet, Dict[str, Any]]],
        Field(description='Information about the sender of the message.'),
    ] = None
    is_deleted: Annotated[
        Optional[bool],
        Field(description='If set to true, the original message has been deleted.'),
    ] = None
    message_type: Optional[ChatMessageType] = None
    field_odata_type: str


class ClaimsMappingPolicy(StsPolicy):
    field_odata_type: str


class CloudPcAuditEvent(Entity):
    activity: Annotated[
        Optional[str], Field(description='The friendly name of the audit activity.')
    ] = None
    activity_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date time in UTC when the activity was performed.\u202fRead-only.',
        ),
    ] = None
    activity_operation_type: Optional[CloudPcAuditActivityOperationType] = None
    activity_result: Optional[CloudPcAuditActivityResult] = None
    activity_type: Annotated[
        Optional[str],
        Field(description='The type of activity that was performed.\u202fRead-only.'),
    ] = None
    actor: Optional[CloudPcAuditActor] = None
    category: Optional[CloudPcAuditCategory] = None
    component_name: Annotated[
        Optional[str],
        Field(description='The component name for the audit event. Read-only.'),
    ] = None
    correlation_id: Annotated[
        Optional[str],
        Field(
            description='The client request ID that is used to correlate activity within the system.\u202fRead-only.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(description='The display name for the audit event. Read-only.'),
    ] = None
    resources: Annotated[
        Optional[List[CloudPcAuditResource]],
        Field(description='The list of cloudPcAuditResource objects.\u202fRead-only.'),
    ] = None
    field_odata_type: str


class CloudPcOnPremisesConnection(Entity):
    ad_domain_name: Annotated[
        Optional[str],
        Field(
            description='The fully qualified domain name (FQDN) of the Active Directory domain you want to join. Maximum length is 255. Optional.'
        ),
    ] = None
    ad_domain_password: Annotated[
        Optional[str],
        Field(
            description='The password associated with the username of an Active Directory account (adDomainUsername).'
        ),
    ] = None
    ad_domain_username: Annotated[
        Optional[str],
        Field(
            description='The username of an Active Directory account (user or service account) that has permission to create computer objects in Active Directory. Required format: admin@contoso.com. Optional.'
        ),
    ] = None
    alternate_resource_url: Annotated[
        Optional[str],
        Field(
            description="The interface URL of the partner service's resource that links to this Azure network connection. Returned only on $select."
        ),
    ] = None
    connection_type: Annotated[
        Optional[Union[CloudPcOnPremisesConnectionType, Dict[str, Any]]],
        Field(
            description="Specifies how the provisioned Cloud PC joins to Microsoft Entra. It includes different types, one is Microsoft Entra ID join, which means there's no on-premises Active Directory (AD) in the current tenant, and the Cloud PC device is joined by Microsoft Entra. Another one is hybridAzureADJoin, which means there's also an on-premises Active Directory (AD) in the current tenant and the Cloud PC device joins to on-premises Active Directory (AD) and Microsoft Entra. The type also determines which types of users can be assigned and can sign into a Cloud PC. The azureADJoin type indicates that cloud-only and hybrid users can be assigned and signed into the Cloud PC. hybridAzureADJoin indicates only hybrid users can be assigned and signed into the Cloud PC. The default value is hybridAzureADJoin."
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(description='The display name for the Azure network connection.'),
    ] = None
    health_check_status: Optional[CloudPcOnPremisesConnectionStatus] = None
    health_check_status_detail: Annotated[
        Optional[Union[CloudPcOnPremisesConnectionStatusDetail, Dict[str, Any]]],
        Field(
            description='Indicates the results of health checks performed on the on-premises connection. Read-only. Returned only on $select. For an example that shows how to get the inUse property, see Example 2: Get the selected properties of an Azure network connection, including healthCheckStatusDetail. Read-only.'
        ),
    ] = None
    in_use: Annotated[
        Optional[bool],
        Field(
            description="When true, the Azure network connection is in use. When false, the connection isn't in use. You can't delete a connection thats in use. Returned only on $select. For an example that shows how to get the inUse property, see Example 2: Get the selected properties of an Azure network connection, including healthCheckStatusDetail. Read-only."
        ),
    ] = None
    organizational_unit: Annotated[
        Optional[str],
        Field(
            description="The organizational unit (OU) in which the computer account is created. If left null, the OU configured as the default (a well-known computer object container) in the tenant's Active Directory domain (OU) is used. Optional."
        ),
    ] = None
    resource_group_id: Annotated[
        Optional[str],
        Field(
            description="The unique identifier of the target resource group used associated with the on-premises network connectivity for Cloud PCs. Required format: '/subscriptions/{subscription-id}/resourceGroups/{resourceGroupName}'"
        ),
    ] = None
    subnet_id: Annotated[
        Optional[str],
        Field(
            description="The unique identifier of the target subnet used associated with the on-premises network connectivity for Cloud PCs. Required format: '/subscriptions/{subscription-id}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkId}/subnets/{subnetName}'"
        ),
    ] = None
    subscription_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier of the Azure subscription associated with the tenant.'
        ),
    ] = None
    subscription_name: Annotated[
        Optional[str],
        Field(
            description='The name of the Azure subscription is used to create an Azure network connection. Read-only.'
        ),
    ] = None
    virtual_network_id: Annotated[
        Optional[str],
        Field(
            description="The unique identifier of the target virtual network used associated with the on-premises network connectivity for Cloud PCs. Required format: '/subscriptions/{subscription-id}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}'"
        ),
    ] = None
    virtual_network_location: Annotated[
        Optional[str],
        Field(
            description='Indicates the resource location of the target virtual network. For example, the location can be eastus2, westeurope, etc. Read-only (computed value).'
        ),
    ] = None
    field_odata_type: str


class CloudPcUserSetting(Entity):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the setting was created. The timestamp type represents the date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(description='The setting name displayed in the user interface.'),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the setting was last modified. The timestamp type represents the date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    local_admin_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the local admin option is enabled. The default value is false. To enable the local admin option, change the setting to true. If the local admin option is enabled, the end user can be an admin of the Cloud PC device.'
        ),
    ] = None
    reset_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether an end user is allowed to reset their Cloud PC. When true, the user is allowed to reset their Cloud PC. When false, end-user initiated reset is not allowed. The default value is false.'
        ),
    ] = None
    restore_point_setting: Annotated[
        Optional[Union[CloudPcRestorePointSetting, Dict[str, Any]]],
        Field(
            description="Defines how frequently a restore point is created that is, a snapshot is taken) for users' provisioned Cloud PCs (default is 12 hours), and whether the user is allowed to restore their own Cloud PCs to a backup made at a specific point in time."
        ),
    ] = None
    assignments: Annotated[
        Optional[List[CloudPcUserSettingAssignment]],
        Field(
            description='Represents the set of Microsoft 365 groups and security groups in Microsoft Entra ID that have cloudPCUserSetting assigned. Returned only on $expand. For an example, see Get cloudPcUserSetting.'
        ),
    ] = None
    field_odata_type: str


class ComplianceManagementPartner(Entity):
    android_enrollment_assignments: Annotated[
        Optional[List[ComplianceManagementPartnerAssignment]],
        Field(description='User groups which enroll Android devices through partner.'),
    ] = None
    android_onboarded: Annotated[
        Optional[bool], Field(description='Partner onboarded for Android devices.')
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='Partner display name')
    ] = None
    ios_enrollment_assignments: Annotated[
        Optional[List[ComplianceManagementPartnerAssignment]],
        Field(description='User groups which enroll ios devices through partner.'),
    ] = None
    ios_onboarded: Annotated[
        Optional[bool], Field(description='Partner onboarded for ios devices.')
    ] = None
    last_heartbeat_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Timestamp of last heartbeat after admin onboarded to the compliance management partner',
        ),
    ] = None
    mac_os_enrollment_assignments: Annotated[
        Optional[List[ComplianceManagementPartnerAssignment]],
        Field(description='User groups which enroll Mac devices through partner.'),
    ] = None
    mac_os_onboarded: Annotated[
        Optional[bool], Field(description='Partner onboarded for Mac devices.')
    ] = None
    partner_state: Optional[DeviceManagementPartnerTenantState] = None
    field_odata_type: str


class ConnectedOrganization(Entity):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(description='The description of the connected organization.'),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='The display name of the connected organization. Supports $filter (eq).'
        ),
    ] = None
    identity_sources: Annotated[
        Optional[List[IdentitySource]],
        Field(
            description='The identity sources in this connected organization, one of azureActiveDirectoryTenant, crossCloudAzureActiveDirectoryTenant, domainIdentitySource, externalDomainFederation, or socialIdentitySource. Nullable.'
        ),
    ] = None
    modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.',
        ),
    ] = None
    state: Annotated[
        Optional[Union[ConnectedOrganizationState, Dict[str, Any]]],
        Field(
            description='The state of a connected organization defines whether assignment policies with requestor scope type AllConfiguredConnectedOrganizationSubjects are applicable or not.  The possible values are: configured, proposed, unknownFutureValue.'
        ),
    ] = None
    external_sponsors: Optional[List[DirectoryObject]] = None
    internal_sponsors: Optional[List[DirectoryObject]] = None
    field_odata_type: str


class Contract(DirectoryObject):
    contract_type: Annotated[
        Optional[str],
        Field(
            description='Type of contract. Possible values are:  SyndicationPartner, BreadthPartner, ResellerPartner. See more in the table below.'
        ),
    ] = None
    customer_id: Annotated[
        Optional[UUID],
        Field(
            description="The unique identifier for the customer tenant referenced by this partnership. Corresponds to the id property of the customer tenant's organization resource.",
        ),
    ] = None
    default_domain_name: Annotated[
        Optional[str],
        Field(
            description="A copy of the customer tenant's default domain name. The copy is made when the partnership with the customer is established. It isn't automatically updated if the customer tenant's default domain name changes."
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description="A copy of the customer tenant's display name. The copy is made when the partnership with the customer is established. It is not automatically updated if the customer tenant's display name changes."
        ),
    ] = None
    field_odata_type: str


class CustomAuthenticationExtension(CustomCalloutExtension):
    field_odata_type: str


class DelegatedAdminAccessAssignment(Entity):
    access_container: Optional[DelegatedAdminAccessContainer] = None
    access_details: Optional[DelegatedAdminAccessDetails] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time in ISO 8601 format and in UTC time when the access assignment was created. Read-only.',
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time in ISO 8601 and in UTC time when this access assignment was last modified. Read-only.',
        ),
    ] = None
    status: Annotated[
        Optional[Union[DelegatedAdminAccessAssignmentStatus, Dict[str, Any]]],
        Field(
            description='The status of the access assignment. Read-only. The possible values are: pending, active, deleting, deleted, error, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class DelegatedAdminCustomer(Entity):
    display_name: Annotated[
        Optional[str],
        Field(
            description='The Microsoft Entra ID display name of the customer tenant. Read-only. Supports $orderby.'
        ),
    ] = None
    tenant_id: Annotated[
        Optional[str],
        Field(
            description='The Microsoft Entra ID-assigned tenant ID of the customer. Read-only.'
        ),
    ] = None
    service_management_details: Annotated[
        Optional[List[DelegatedAdminServiceManagementDetail]],
        Field(
            description="Contains the management details of a service in the customer tenant that's managed by delegated administration."
        ),
    ] = None
    field_odata_type: str


class DelegatedAdminRelationship(Entity):
    access_details: Optional[DelegatedAdminAccessDetails] = None
    activated_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time in ISO 8601 format and in UTC time when the relationship became active. Read-only.',
        ),
    ] = None
    auto_extend_duration: Annotated[
        Optional[timedelta],
        Field(
            description="The duration by which the validity of the relationship is automatically extended, denoted in ISO 8601 format. Supported values are: P0D, PT0S, P180D. The default value is PT0S. PT0S indicates that the relationship expires when the endDateTime is reached and it isn't automatically extended.",
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time in ISO 8601 format and in UTC time when the relationship was created. Read-only.',
        ),
    ] = None
    customer: Annotated[
        Optional[Union[DelegatedAdminRelationshipCustomerParticipant, Dict[str, Any]]],
        Field(
            description="The display name and unique identifier of the customer of the relationship. This is configured either by the partner at the time the relationship is created or by the system after the customer approves the relationship. Can't be changed by the customer."
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description="The display name of the relationship used for ease of identification. Must be unique across all delegated admin relationships of the partner and is set by the partner only when the relationship is in the created status and can't be changed by the customer. Maximum length is 50 characters."
        ),
    ] = None
    duration: Annotated[
        Optional[timedelta],
        Field(
            description="The duration of the relationship in ISO 8601 format. Must be a value between P1D and P2Y inclusive. This is set by the partner only when the relationship is in the created status and can't be changed by the customer.",
        ),
    ] = None
    end_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time in ISO 8601 format and in UTC time when the status of relationship changes to either terminated or expired. Calculated as endDateTime = activatedDateTime + duration. Read-only.',
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time in ISO 8601 format and in UTC time when the relationship was last modified. Read-only.',
        ),
    ] = None
    status: Annotated[
        Optional[Union[DelegatedAdminRelationshipStatus, Dict[str, Any]]],
        Field(
            description='The status of the relationship. Read Only. The possible values are: activating, active, approvalPending, approved, created, expired, expiring, terminated, terminating, terminationRequested, unknownFutureValue. Supports $orderby.'
        ),
    ] = None
    access_assignments: Annotated[
        Optional[List[DelegatedAdminAccessAssignment]],
        Field(
            description='The access assignments associated with the delegated admin relationship.'
        ),
    ] = None
    operations: Annotated[
        Optional[List[DelegatedAdminRelationshipOperation]],
        Field(
            description='The long running operations associated with the delegated admin relationship.'
        ),
    ] = None
    requests: Annotated[
        Optional[List[DelegatedAdminRelationshipRequest]],
        Field(
            description='The requests associated with the delegated admin relationship.'
        ),
    ] = None
    field_odata_type: str


class Device(DirectoryObject):
    account_enabled: Annotated[
        Optional[bool],
        Field(
            description='true if the account is enabled; otherwise, false. Required. Default is true.  Supports $filter (eq, ne, not, in). Only callers with at least the Cloud Device Administrator role can set this property.'
        ),
    ] = None
    alternative_security_ids: Annotated[
        Optional[List[AlternativeSecurityId]],
        Field(
            description='For internal use only. Not nullable. Supports $filter (eq, not, ge, le).'
        ),
    ] = None
    approximate_last_sign_in_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only. Supports $filter (eq, ne, not, ge, le, and eq on null values) and $orderby.',
        ),
    ] = None
    compliance_expiration_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The timestamp when the device is no longer deemed compliant. The timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.',
        ),
    ] = None
    device_category: Annotated[
        Optional[str],
        Field(
            description='User-defined property set by Intune to automatically add devices to groups and simplify managing devices.'
        ),
    ] = None
    device_id: Annotated[
        Optional[str],
        Field(
            description='Unique identifier set by Azure Device Registration Service at the time of registration. This alternate key can be used to reference the device object. Supports $filter (eq, ne, not, startsWith).'
        ),
    ] = None
    device_metadata: Annotated[
        Optional[str], Field(description='For internal use only. Set to null.')
    ] = None
    device_ownership: Annotated[
        Optional[str],
        Field(
            description='Ownership of the device. Intune sets this property. Possible values are: unknown, company, personal.'
        ),
    ] = None
    device_version: Annotated[
        Optional[float],
        Field(description='For internal use only.', ge=-2147483648.0, le=2147483647.0),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='The display name for the device. Maximum length is 256 characters. Required. Supports $filter (eq, ne, not, ge, le, in, startsWith, and eq on null values), $search, and $orderby.'
        ),
    ] = None
    enrollment_profile_name: Annotated[
        Optional[str],
        Field(
            description='Enrollment profile applied to the device. For example, Apple Device Enrollment Profile, Device enrollment - Corporate device identifiers, or Windows Autopilot profile name. This property is set by Intune.'
        ),
    ] = None
    enrollment_type: Annotated[
        Optional[str],
        Field(
            description='Enrollment type of the device. Intune sets this property. Possible values are: unknown, userEnrollment, deviceEnrollmentManager, appleBulkWithUser, appleBulkWithoutUser, windowsAzureADJoin, windowsBulkUserless, windowsAutoEnrollment, windowsBulkAzureDomainJoin, windowsCoManagement, windowsAzureADJoinUsingDeviceAuth,appleUserEnrollment, appleUserEnrollmentWithServiceAccount. NOTE: This property might return other values apart from those listed.'
        ),
    ] = None
    is_compliant: Annotated[
        Optional[bool],
        Field(
            description='true if the device complies with Mobile Device Management (MDM) policies; otherwise, false. Read-only. This can only be updated by Intune for any device OS type or by an approved MDM app for Windows OS devices. Supports $filter (eq, ne, not).'
        ),
    ] = None
    is_managed: Annotated[
        Optional[bool],
        Field(
            description='true if the device is managed by a Mobile Device Management (MDM) app; otherwise, false. This can only be updated by Intune for any device OS type or by an approved MDM app for Windows OS devices. Supports $filter (eq, ne, not).'
        ),
    ] = None
    is_management_restricted: Optional[bool] = None
    is_rooted: Annotated[
        Optional[bool],
        Field(
            description='true if the device is rooted or jail-broken. This property can only be updated by Intune.'
        ),
    ] = None
    management_type: Annotated[
        Optional[str],
        Field(
            description='The management channel of the device. This property is set by Intune. Possible values are: eas, mdm, easMdm, intuneClient, easIntuneClient, configurationManagerClient, configurationManagerClientMdm, configurationManagerClientMdmEas, unknown, jamf, googleCloudDevicePolicyController.'
        ),
    ] = None
    manufacturer: Annotated[
        Optional[str], Field(description='Manufacturer of the device. Read-only.')
    ] = None
    mdm_app_id: Annotated[
        Optional[str],
        Field(
            description='Application identifier used to register device into MDM. Read-only. Supports $filter (eq, ne, not, startsWith).'
        ),
    ] = None
    model: Annotated[
        Optional[str], Field(description='Model of the device. Read-only.')
    ] = None
    on_premises_last_sync_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The last time at which the object was synced with the on-premises directory. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z Read-only. Supports $filter (eq, ne, not, ge, le, in).',
        ),
    ] = None
    on_premises_security_identifier: Annotated[
        Optional[str],
        Field(
            description='The on-premises security identifier (SID) for the user who was synchronized from on-premises to the cloud. Read-only. Returned only on $select. Supports $filter (eq).'
        ),
    ] = None
    on_premises_sync_enabled: Annotated[
        Optional[bool],
        Field(
            description='true if this object is synced from an on-premises directory; false if this object was originally synced from an on-premises directory but is no longer synced; null if this object has never been synced from an on-premises directory (default). Read-only. Supports $filter (eq, ne, not, in, and eq on null values).'
        ),
    ] = None
    operating_system: Annotated[
        Optional[str],
        Field(
            description='The type of operating system on the device. Required. Supports $filter (eq, ne, not, ge, le, startsWith, and eq on null values).'
        ),
    ] = None
    operating_system_version: Annotated[
        Optional[str],
        Field(
            description='The version of the operating system on the device. Required. Supports $filter (eq, ne, not, ge, le, startsWith, and eq on null values).'
        ),
    ] = None
    physical_ids: Annotated[
        Optional[List[str]],
        Field(
            description='For internal use only. Not nullable. Supports $filter (eq, not, ge, le, startsWith,/$count eq 0, /$count ne 0).'
        ),
    ] = None
    profile_type: Annotated[
        Optional[str],
        Field(
            description='The profile type of the device. Possible values: RegisteredDevice (default), SecureVM, Printer, Shared, IoT.'
        ),
    ] = None
    registration_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time of when the device was registered. The timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.',
        ),
    ] = None
    system_labels: Annotated[
        Optional[List[str]],
        Field(
            description='List of labels applied to the device by the system. Supports $filter (/$count eq 0, /$count ne 0).'
        ),
    ] = None
    trust_type: Annotated[
        Optional[str],
        Field(
            description='Type of trust for the joined device. Read-only. Possible values:  Workplace (indicates bring your own personal devices), AzureAd (Cloud-only joined devices), ServerAd (on-premises domain joined devices joined to Microsoft Entra ID). For more information, see Introduction to device management in Microsoft Entra ID.'
        ),
    ] = None
    extensions: Annotated[
        Optional[List[Extension]],
        Field(
            description='The collection of open extensions defined for the device. Read-only. Nullable.'
        ),
    ] = None
    member_of: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description='Groups and administrative units that this device is a member of. Read-only. Nullable. Supports $expand.'
        ),
    ] = None
    registered_owners: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description='The user that cloud joined the device or registered their personal device. The registered owner is set at the time of registration. Read-only. Nullable. Supports $expand.'
        ),
    ] = None
    registered_users: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description='Collection of registered users of the device. For cloud joined devices and registered personal devices, registered users are set to the same value as registered owners at the time of registration. Read-only. Nullable. Supports $expand.'
        ),
    ] = None
    transitive_member_of: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description='Groups and administrative units that the device is a member of. This operation is transitive. Supports $expand.'
        ),
    ] = None
    field_odata_type: str


class DeviceCompliancePolicy(Entity):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='DateTime the object was created.',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(description='Admin provided description of the Device Configuration.'),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(description='Admin provided name of the device configuration.'),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='DateTime the object was last modified.',
        ),
    ] = None
    version: Annotated[
        Optional[float],
        Field(
            description='Version of the device configuration.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    assignments: Annotated[
        Optional[List[DeviceCompliancePolicyAssignment]],
        Field(description='The collection of assignments for this compliance policy.'),
    ] = None
    device_setting_state_summaries: Annotated[
        Optional[List[SettingStateDeviceSummary]],
        Field(description='Compliance Setting State Device Summary'),
    ] = None
    device_statuses: Annotated[
        Optional[List[DeviceComplianceDeviceStatus]],
        Field(description='List of DeviceComplianceDeviceStatus.'),
    ] = None
    device_status_overview: Annotated[
        Optional[Union[DeviceComplianceDeviceOverview, Dict[str, Any]]],
        Field(description='Device compliance devices status overview'),
    ] = None
    scheduled_actions_for_rule: Annotated[
        Optional[List[DeviceComplianceScheduledActionForRule]],
        Field(
            description='The list of scheduled action per rule for this compliance policy. This is a required property when creating any individual per-platform compliance policies.'
        ),
    ] = None
    user_statuses: Annotated[
        Optional[List[DeviceComplianceUserStatus]],
        Field(description='List of DeviceComplianceUserStatus.'),
    ] = None
    user_status_overview: Annotated[
        Optional[Union[DeviceComplianceUserOverview, Dict[str, Any]]],
        Field(description='Device compliance users status overview'),
    ] = None
    field_odata_type: str


class DeviceCompliancePolicySettingStateSummary(Entity):
    compliant_device_count: Annotated[
        Optional[float],
        Field(
            description='Number of compliant devices', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    conflict_device_count: Annotated[
        Optional[float],
        Field(
            description='Number of conflict devices', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    error_device_count: Annotated[
        Optional[float],
        Field(description='Number of error devices', ge=-2147483648.0, le=2147483647.0),
    ] = None
    non_compliant_device_count: Annotated[
        Optional[float],
        Field(
            description='Number of NonCompliant devices',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    not_applicable_device_count: Annotated[
        Optional[float],
        Field(
            description='Number of not applicable devices',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    platform_type: Optional[PolicyPlatformType] = None
    remediated_device_count: Annotated[
        Optional[float],
        Field(
            description='Number of remediated devices',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    setting: Annotated[
        Optional[str], Field(description='The setting class name and property name.')
    ] = None
    setting_name: Annotated[
        Optional[str], Field(description='Name of the setting.')
    ] = None
    unknown_device_count: Annotated[
        Optional[float],
        Field(
            description='Number of unknown devices', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    device_compliance_setting_states: Annotated[
        Optional[List[DeviceComplianceSettingState]],
        Field(description='Not yet documented'),
    ] = None
    field_odata_type: str


class DeviceConfiguration(Entity):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='DateTime the object was created.',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(description='Admin provided description of the Device Configuration.'),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(description='Admin provided name of the device configuration.'),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='DateTime the object was last modified.',
        ),
    ] = None
    version: Annotated[
        Optional[float],
        Field(
            description='Version of the device configuration.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    assignments: Annotated[
        Optional[List[DeviceConfigurationAssignment]],
        Field(
            description='The list of assignments for the device configuration profile.'
        ),
    ] = None
    device_setting_state_summaries: Annotated[
        Optional[List[SettingStateDeviceSummary]],
        Field(description='Device Configuration Setting State Device Summary'),
    ] = None
    device_statuses: Annotated[
        Optional[List[DeviceConfigurationDeviceStatus]],
        Field(description='Device configuration installation status by device.'),
    ] = None
    device_status_overview: Annotated[
        Optional[Union[DeviceConfigurationDeviceOverview, Dict[str, Any]]],
        Field(description='Device Configuration devices status overview'),
    ] = None
    user_statuses: Annotated[
        Optional[List[DeviceConfigurationUserStatus]],
        Field(description='Device configuration installation status by user.'),
    ] = None
    user_status_overview: Annotated[
        Optional[Union[DeviceConfigurationUserOverview, Dict[str, Any]]],
        Field(description='Device Configuration users status overview'),
    ] = None
    field_odata_type: str


class DeviceEnrollmentConfiguration(Entity):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Created date time in UTC of the device enrollment configuration',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(description='The description of the device enrollment configuration'),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(description='The display name of the device enrollment configuration'),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Last modified date time in UTC of the device enrollment configuration',
        ),
    ] = None
    priority: Annotated[
        Optional[float],
        Field(
            description='Priority is used when a user exists in multiple groups that are assigned enrollment configuration. Users are subject only to the configuration with the lowest priority value.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    version: Annotated[
        Optional[float],
        Field(
            description='The version of the device enrollment configuration',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    assignments: Annotated[
        Optional[List[EnrollmentConfigurationAssignment]],
        Field(
            description='The list of group assignments for the device configuration profile'
        ),
    ] = None
    field_odata_type: str


class DeviceEnrollmentLimitConfiguration(DeviceEnrollmentConfiguration):
    limit: Annotated[
        Optional[float],
        Field(
            description='The maximum number of devices that a user can enroll',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class DeviceEnrollmentPlatformRestrictionsConfiguration(DeviceEnrollmentConfiguration):
    android_restriction: Annotated[
        Optional[Union[DeviceEnrollmentPlatformRestriction, Dict[str, Any]]],
        Field(
            description='Android restrictions based on platform, platform operating system version, and device ownership'
        ),
    ] = None
    ios_restriction: Annotated[
        Optional[Union[DeviceEnrollmentPlatformRestriction, Dict[str, Any]]],
        Field(
            description='Ios restrictions based on platform, platform operating system version, and device ownership'
        ),
    ] = None
    mac_os_restriction: Annotated[
        Optional[Union[DeviceEnrollmentPlatformRestriction, Dict[str, Any]]],
        Field(
            description='Mac restrictions based on platform, platform operating system version, and device ownership'
        ),
    ] = None
    windows_mobile_restriction: Annotated[
        Optional[Union[DeviceEnrollmentPlatformRestriction, Dict[str, Any]]],
        Field(
            description='Windows mobile restrictions based on platform, platform operating system version, and device ownership'
        ),
    ] = None
    windows_restriction: Annotated[
        Optional[Union[DeviceEnrollmentPlatformRestriction, Dict[str, Any]]],
        Field(
            description='Windows restrictions based on platform, platform operating system version, and device ownership'
        ),
    ] = None
    field_odata_type: str


class DeviceEnrollmentWindowsHelloForBusinessConfiguration(
    DeviceEnrollmentConfiguration
):
    enhanced_biometrics_state: Optional[Enablement] = None
    pin_expiration_in_days: Annotated[
        Optional[float],
        Field(
            description="Controls the period of time (in days) that a PIN can be used before the system requires the user to change it. This must be set between 0 and 730, inclusive. If set to 0, the user's PIN will never expire",
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    pin_lowercase_characters_usage: Optional[WindowsHelloForBusinessPinUsage] = None
    pin_maximum_length: Annotated[
        Optional[float],
        Field(
            description='Controls the maximum number of characters allowed for the Windows Hello for Business PIN. This value must be between 4 and 127, inclusive. This value must be greater than or equal to the value set for the minimum PIN.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    pin_minimum_length: Annotated[
        Optional[float],
        Field(
            description='Controls the minimum number of characters required for the Windows Hello for Business PIN.  This value must be between 4 and 127, inclusive, and less than or equal to the value set for the maximum PIN.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    pin_previous_block_count: Annotated[
        Optional[float],
        Field(
            description='Controls the ability to prevent users from using past PINs. This must be set between 0 and 50, inclusive, and the current PIN of the user is included in that count. If set to 0, previous PINs are not stored. PIN history is not preserved through a PIN reset.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    pin_special_characters_usage: Optional[WindowsHelloForBusinessPinUsage] = None
    pin_uppercase_characters_usage: Optional[WindowsHelloForBusinessPinUsage] = None
    remote_passport_enabled: Annotated[
        Optional[bool],
        Field(
            description='Controls the use of Remote Windows Hello for Business. Remote Windows Hello for Business provides the ability for a portable, registered device to be usable as a companion for desktop authentication. The desktop must be Azure AD joined and the companion device must have a Windows Hello for Business PIN.'
        ),
    ] = None
    security_device_required: Annotated[
        Optional[bool],
        Field(
            description='Controls whether to require a Trusted Platform Module (TPM) for provisioning Windows Hello for Business. A TPM provides an additional security benefit in that data stored on it cannot be used on other devices. If set to False, all devices can provision Windows Hello for Business even if there is not a usable TPM.'
        ),
    ] = None
    state: Optional[Enablement] = None
    unlock_with_biometrics_enabled: Annotated[
        Optional[bool],
        Field(
            description='Controls the use of biometric gestures, such as face and fingerprint, as an alternative to the Windows Hello for Business PIN.  If set to False, biometric gestures are not allowed. Users must still configure a PIN as a backup in case of failures.'
        ),
    ] = None
    field_odata_type: str


class DeviceRegistrationPolicy(Entity):
    azure_ad_join: Optional[Union[AzureADJoinPolicy, Dict[str, Any]]] = None
    azure_ad_registration: Optional[
        Union[AzureADRegistrationPolicy, Dict[str, Any]]
    ] = None
    description: Optional[str] = None
    display_name: Optional[str] = None
    local_admin_password: Optional[
        Union[LocalAdminPasswordSettings, Dict[str, Any]]
    ] = None
    multi_factor_auth_configuration: Optional[MultiFactorAuthConfiguration] = None
    user_device_quota: Annotated[
        Optional[float], Field(ge=-2147483648.0, le=2147483647.0)
    ] = None
    field_odata_type: str


class DirectoryAudit(Entity):
    activity_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Indicates the date and time the activity was performed. The Timestamp type is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Supports $filter (eq, ge, le) and $orderby.',
        ),
    ] = None
    activity_display_name: Annotated[
        Optional[str],
        Field(
            description="Indicates the activity name or the operation name (examples: 'Create User' and 'Add member to group'). For a list of activities logged, refer to Microsoft Entra audit log categories and activities. Supports $filter (eq, startswith)."
        ),
    ] = None
    additional_details: Annotated[
        Optional[List[KeyValue]],
        Field(description='Indicates additional details on the activity.'),
    ] = None
    category: Annotated[
        Optional[str],
        Field(
            description="Indicates which resource category that's targeted by the activity. For example: UserManagement, GroupManagement, ApplicationManagement, RoleManagement. For a list of categories for activities logged, refer to Microsoft Entra audit log categories and activities."
        ),
    ] = None
    correlation_id: Annotated[
        Optional[str],
        Field(
            description='Indicates a unique ID that helps correlate activities that span across various services. Can be used to trace logs across services. Supports $filter (eq).'
        ),
    ] = None
    initiated_by: Optional[AuditActivityInitiator] = None
    logged_by_service: Annotated[
        Optional[str],
        Field(
            description='Indicates information on which service initiated the activity (For example: Self-service Password Management, Core Directory, B2C, Invited Users, Microsoft Identity Manager, Privileged Identity Management. Supports $filter (eq).'
        ),
    ] = None
    operation_type: Annotated[
        Optional[str],
        Field(
            description='Indicates the type of operation that was performed. The possible values include but are not limited to the following: Add, Assign, Update, Unassign, and Delete.'
        ),
    ] = None
    result: Annotated[
        Optional[Union[OperationResult, Dict[str, Any]]],
        Field(
            description='Indicates the result of the activity. Possible values are: success, failure, timeout, unknownFutureValue.'
        ),
    ] = None
    result_reason: Annotated[
        Optional[str],
        Field(
            description='Indicates the reason for failure if the result is failure or timeout.'
        ),
    ] = None
    target_resources: Annotated[
        Optional[List[TargetResource]],
        Field(
            description='Indicates information on which resource was changed due to the activity. Target Resource Type can be User, Device, Directory, App, Role, Group, Policy or Other. Supports $filter (eq) for id and displayName; and $filter (startswith) for displayName.'
        ),
    ] = None
    field_odata_type: str


class DirectoryRole(DirectoryObject):
    description: Annotated[
        Optional[str],
        Field(
            description='The description for the directory role. Read-only. Supports $filter (eq), $search, $select.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='The display name for the directory role. Read-only. Supports $filter (eq), $search, $select.'
        ),
    ] = None
    role_template_id: Annotated[
        Optional[str],
        Field(
            description='The id of the directoryRoleTemplate that this role is based on. The property must be specified when activating a directory role in a tenant with a POST operation. After the directory role has been activated, the property is read only. Supports $filter (eq), $select.'
        ),
    ] = None
    members: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description='Users that are members of this directory role. HTTP Methods: GET, POST, DELETE. Read-only. Nullable. Supports $expand.'
        ),
    ] = None
    scoped_members: Annotated[
        Optional[List[ScopedRoleMembership]],
        Field(
            description='Members of this directory role that are scoped to administrative units. Read-only. Nullable.'
        ),
    ] = None
    field_odata_type: str


class DocumentSetVersion(ListItemVersion):
    comment: Annotated[
        Optional[str], Field(description='Comment about the captured version.')
    ] = None
    created_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='User who captured the version.'),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when this version was created.',
        ),
    ] = None
    items: Annotated[
        Optional[List[DocumentSetVersionItem]],
        Field(
            description='Items within the document set that are captured as part of this version.'
        ),
    ] = None
    should_capture_minor_version: Annotated[
        Optional[bool],
        Field(
            description='If true, minor versions of items are also captured; otherwise, only major versions are captured. The default value is false.'
        ),
    ] = None
    field_odata_type: str


class DomainDnsCnameRecord(DomainDnsRecord):
    canonical_name: Annotated[
        Optional[str],
        Field(
            description='The canonical name of the CNAME record. Used to configure the CNAME record at the DNS host.'
        ),
    ] = None
    field_odata_type: str


class DomainDnsMxRecord(DomainDnsRecord):
    mail_exchange: Annotated[
        Optional[str],
        Field(
            description='Value used when configuring the answer/destination/value of the MX record at the DNS host.'
        ),
    ] = None
    preference: Annotated[
        Optional[float],
        Field(
            description='Value used when configuring the Preference/Priority property of the MX record at the DNS host.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class EditionUpgradeConfiguration(DeviceConfiguration):
    license: Annotated[
        Optional[str], Field(description='Edition Upgrade License File Content.')
    ] = None
    license_type: Optional[EditionUpgradeLicenseType] = None
    product_key: Annotated[
        Optional[str], Field(description='Edition Upgrade Product Key.')
    ] = None
    target_edition: Optional[Windows10EditionType] = None
    field_odata_type: str


class EducationAssignmentResource(Entity):
    distribute_for_student_work: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether this resource should be copied to each student submission for modification and submission. Required'
        ),
    ] = None
    resource: Annotated[
        Optional[Union[EducationResource, Dict[str, Any]]],
        Field(
            description='Resource object that has been associated with this assignment.'
        ),
    ] = None
    field_odata_type: str


class EducationAssignmentSettings(Entity):
    submission_animation_disabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether to show the turn-in celebration animation. If true, indicates to skip the animation. The default value is false.'
        ),
    ] = None
    grading_categories: Annotated[
        Optional[List[EducationGradingCategory]],
        Field(
            description='When set, enables users to weight assignments differently when computing a class average grade.'
        ),
    ] = None
    field_odata_type: str


class EducationFeedbackResourceOutcome(EducationOutcome):
    feedback_resource: Annotated[
        Optional[Union[EducationResource, Dict[str, Any]]],
        Field(description='The actual feedback resource.'),
    ] = None
    resource_status: Annotated[
        Optional[Union[EducationFeedbackResourceOutcomeStatus, Dict[str, Any]]],
        Field(
            description='The status of the feedback resource. The possible values are: notPublished, pendingPublish, published, failedPublish, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class EducationModuleResource(Entity):
    resource: Annotated[
        Optional[Union[EducationResource, Dict[str, Any]]],
        Field(description='Resource object that is with this module.'),
    ] = None
    field_odata_type: str


class EducationPointsOutcome(EducationOutcome):
    points: Annotated[
        Optional[Union[EducationAssignmentPointsGrade, Dict[str, Any]]],
        Field(
            description='The numeric grade the teacher has given the student for this assignment.'
        ),
    ] = None
    published_points: Annotated[
        Optional[Union[EducationAssignmentPointsGrade, Dict[str, Any]]],
        Field(
            description='A copy of the points property that is made when the grade is released to the student.'
        ),
    ] = None
    field_odata_type: str


class EducationRubric(Entity):
    created_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='The user who created this resource.'),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    description: Annotated[
        Optional[Union[EducationItemBody, Dict[str, Any]]],
        Field(description='The description of this rubric.'),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The name of this rubric.')
    ] = None
    grading: Annotated[
        Optional[Union[EducationAssignmentGradeType, Dict[str, Any]]],
        Field(
            description='The grading type of this rubric. You can use null for a no-points rubric or educationAssignmentPointsGradeType for a points rubric.'
        ),
    ] = None
    last_modified_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='The last user to modify the resource.'),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Moment in time when the resource was last modified. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    levels: Annotated[
        Optional[List[RubricLevel]],
        Field(description='The collection of levels making up this rubric.'),
    ] = None
    qualities: Annotated[
        Optional[List[RubricQuality]],
        Field(description='The collection of qualities making up this rubric.'),
    ] = None
    field_odata_type: str


class EducationRubricOutcome(EducationOutcome):
    published_rubric_quality_feedback: Annotated[
        Optional[List[RubricQualityFeedbackModel]],
        Field(
            description='A copy of the rubricQualityFeedback property that is made when the grade is released to the student.'
        ),
    ] = None
    published_rubric_quality_selected_levels: Annotated[
        Optional[List[RubricQualitySelectedColumnModel]],
        Field(
            description='A copy of the rubricQualitySelectedLevels property that is made when the grade is released to the student.'
        ),
    ] = None
    rubric_quality_feedback: Annotated[
        Optional[List[RubricQualityFeedbackModel]],
        Field(
            description='A collection of specific feedback for each quality of this rubric.'
        ),
    ] = None
    rubric_quality_selected_levels: Annotated[
        Optional[List[RubricQualitySelectedColumnModel]],
        Field(
            description='The level that the teacher has selected for each quality while grading this assignment.'
        ),
    ] = None
    field_odata_type: str


class EducationSubmissionResource(Entity):
    assignment_resource_url: Annotated[
        Optional[str],
        Field(
            description='Pointer to the assignment from which the resource was copied, and if null, the student uploaded the resource.'
        ),
    ] = None
    resource: Annotated[
        Optional[Union[EducationResource, Dict[str, Any]]],
        Field(description='Resource object.'),
    ] = None
    field_odata_type: str


class EmailAuthenticationMethodConfiguration(AuthenticationMethodConfiguration):
    allow_external_id_to_use_email_otp: Annotated[
        Optional[Union[ExternalEmailOtpState, Dict[str, Any]]],
        Field(
            description="Determines whether email OTP is usable by external users for authentication. Possible values are: default, enabled, disabled, unknownFutureValue. Tenants in the default state who didn't use public preview have email OTP enabled beginning in October 2021."
        ),
    ] = None
    include_targets: Annotated[
        Optional[List[AuthenticationMethodTarget]],
        Field(
            description='A collection of groups that are enabled to use the authentication method.'
        ),
    ] = None
    field_odata_type: str


class EmployeeExperienceUser(Entity):
    learning_course_activities: Optional[List[LearningCourseActivity]] = None
    field_odata_type: str


class EndUserNotificationDetail(Entity):
    email_content: Annotated[
        Optional[str], Field(description='Email HTML content.')
    ] = None
    is_default_langauge: Annotated[
        Optional[bool], Field(description='Indicates whether this language is default.')
    ] = None
    language: Annotated[Optional[str], Field(description='Notification language.')] = (
        None
    )
    locale: Annotated[Optional[str], Field(description='Notification locale.')] = None
    sent_from: Optional[EmailIdentity] = None
    subject: Annotated[Optional[str], Field(description='Mail subject.')] = None
    field_odata_type: str


class EngagementAsyncOperation(LongRunningOperation):
    operation_type: Annotated[
        Optional[Union[EngagementAsyncOperationType, Dict[str, Any]]],
        Field(
            description='The type of the long-running operation. The possible values are: createCommunity, unknownFutureValue.'
        ),
    ] = None
    resource_id: Annotated[
        Optional[str],
        Field(
            description='The ID of the object created or modified as a result of this async operation.'
        ),
    ] = None
    field_odata_type: str


class ExternalUsersSelfServiceSignUpEventsFlow(AuthenticationEventsFlow):
    on_attribute_collection: Annotated[
        Optional[Union[OnAttributeCollectionHandler, Dict[str, Any]]],
        Field(
            description='The configuration for what to invoke when attributes are ready to be collected from the user.'
        ),
    ] = None
    on_authentication_method_load_start: Annotated[
        Optional[Union[OnAuthenticationMethodLoadStartHandler, Dict[str, Any]]],
        Field(
            description='Required. The configuration for what to invoke when authentication methods are ready to be presented to the user. Must have at least one identity provider linked.  Supports $filter (eq). See support for filtering on user flows for syntax information.'
        ),
    ] = None
    on_interactive_auth_flow_start: Annotated[
        Optional[Union[OnInteractiveAuthFlowStartHandler, Dict[str, Any]]],
        Field(
            description='Required. The configuration for what to invoke when an authentication flow is ready to be initiated.'
        ),
    ] = None
    on_user_create_start: Annotated[
        Optional[Union[OnUserCreateStartHandler, Dict[str, Any]]],
        Field(description='The configuration for what to invoke during user creation.'),
    ] = None
    field_odata_type: str


class Fido2AuthenticationMethodConfiguration(AuthenticationMethodConfiguration):
    is_attestation_enforced: Annotated[
        Optional[bool],
        Field(
            description='Determines whether attestation must be enforced for FIDO2 security key registration.'
        ),
    ] = None
    is_self_service_registration_allowed: Annotated[
        Optional[bool],
        Field(description='Determines if users can register new FIDO2 security keys.'),
    ] = None
    key_restrictions: Annotated[
        Optional[Union[Fido2KeyRestrictions, Dict[str, Any]]],
        Field(
            description='Controls whether key restrictions are enforced on FIDO2 security keys, either allowing or disallowing certain key types as defined by Authenticator Attestation GUID (AAGUID), an identifier that indicates the type (e.g. make and model) of the authenticator.'
        ),
    ] = None
    include_targets: Annotated[
        Optional[List[AuthenticationMethodTarget]],
        Field(
            description='A collection of groups that are enabled to use the authentication method.'
        ),
    ] = None
    field_odata_type: str


class HomeRealmDiscoveryPolicy(StsPolicy):
    field_odata_type: str


class HorizontalSection(Entity):
    emphasis: Annotated[
        Optional[Union[SectionEmphasisType, Dict[str, Any]]],
        Field(
            description='Enumeration value that indicates the emphasis of the section background. The possible values are: none, netural, soft, strong, unknownFutureValue.'
        ),
    ] = None
    layout: Annotated[
        Optional[Union[HorizontalSectionLayoutType, Dict[str, Any]]],
        Field(
            description='Layout type of the section. The possible values are: none, oneColumn, twoColumns, threeColumns, oneThirdLeftColumn, oneThirdRightColumn, fullWidth, unknownFutureValue.'
        ),
    ] = None
    columns: Annotated[
        Optional[List[HorizontalSectionColumn]],
        Field(description='The set of vertical columns in this section.'),
    ] = None
    field_odata_type: str


class IdentityBuiltInUserFlowAttribute(IdentityUserFlowAttribute):
    field_odata_type: str


class IdentityCustomUserFlowAttribute(IdentityUserFlowAttribute):
    field_odata_type: str


class IdentitySecurityDefaultsEnforcementPolicy(PolicyBase):
    is_enabled: Annotated[
        Optional[bool],
        Field(
            description='If set to true, Microsoft Entra security defaults are enabled for the tenant.'
        ),
    ] = None
    field_odata_type: str


class ImportedWindowsAutopilotDeviceIdentity(Entity):
    assigned_user_principal_name: Annotated[
        Optional[str], Field(description='UPN of the user the device will be assigned')
    ] = None
    group_tag: Annotated[
        Optional[str], Field(description='Group Tag of the Windows autopilot device.')
    ] = None
    hardware_identifier: Annotated[
        Optional[str],
        Field(description='Hardware Blob of the Windows autopilot device.'),
    ] = None
    import_id: Annotated[
        Optional[str],
        Field(description='The Import Id of the Windows autopilot device.'),
    ] = None
    product_key: Annotated[
        Optional[str], Field(description='Product Key of the Windows autopilot device.')
    ] = None
    serial_number: Annotated[
        Optional[str],
        Field(description='Serial number of the Windows autopilot device.'),
    ] = None
    state: Annotated[
        Optional[Union[ImportedWindowsAutopilotDeviceIdentityState, Dict[str, Any]]],
        Field(description='Current state of the imported device.'),
    ] = None
    field_odata_type: str


class ImportedWindowsAutopilotDeviceIdentityUpload(Entity):
    created_date_time_utc: Annotated[
        Optional[datetime],
        Field(
            description='DateTime when the entity is created.',
        ),
    ] = None
    status: Optional[ImportedWindowsAutopilotDeviceIdentityUploadStatus] = None
    device_identities: Annotated[
        Optional[List[ImportedWindowsAutopilotDeviceIdentity]],
        Field(
            description='Collection of all Autopilot devices as a part of this upload.'
        ),
    ] = None
    field_odata_type: str


class InferenceClassification(Entity):
    overrides: Annotated[
        Optional[List[InferenceClassificationOverride]],
        Field(
            description='A set of overrides for a user to always classify messages from specific senders in certain ways: focused, or other. Read-only. Nullable.'
        ),
    ] = None
    field_odata_type: str


class InternalDomainFederation(SamlOrWsFedProvider):
    active_sign_in_uri: Annotated[
        Optional[str],
        Field(
            description='URL of the endpoint used by active clients when authenticating with federated domains set up for single sign-on in Microsoft Entra ID. Corresponds to the ActiveLogOnUri property of the Set-MsolDomainFederationSettings MSOnline v1 PowerShell cmdlet.'
        ),
    ] = None
    federated_idp_mfa_behavior: Annotated[
        Optional[Union[FederatedIdpMfaBehavior, Dict[str, Any]]],
        Field(
            description='Determines whether Microsoft Entra ID accepts the MFA performed by the federated IdP when a federated user accesses an application that is governed by a conditional access policy that requires MFA. The possible values are: acceptIfMfaDoneByFederatedIdp, enforceMfaByFederatedIdp, rejectMfaByFederatedIdp, unknownFutureValue. For more information, see federatedIdpMfaBehavior values.'
        ),
    ] = None
    is_signed_authentication_request_required: Annotated[
        Optional[bool],
        Field(
            description="If true, when SAML authentication requests are sent to the federated SAML IdP, Microsoft Entra ID will sign those requests using the OrgID signing key. If false (default), the SAML authentication requests sent to the federated IdP aren't signed."
        ),
    ] = None
    next_signing_certificate: Annotated[
        Optional[str],
        Field(
            description="Fallback token signing certificate that can also be used to sign tokens, for example when the primary signing certificate expires. Formatted as Base64 encoded strings of the public portion of the federated IdP's token signing certificate. Needs to be compatible with the X509Certificate2 class. Much like the signingCertificate, the nextSigningCertificate property is used if a rollover is required outside of the auto-rollover update, a new federation service is being set up, or if the new token signing certificate isn't present in the federation properties after the federation service certificate has been updated."
        ),
    ] = None
    password_reset_uri: Optional[str] = None
    prompt_login_behavior: Annotated[
        Optional[Union[PromptLoginBehavior, Dict[str, Any]]],
        Field(
            description='Sets the preferred behavior for the sign-in prompt. The possible values are: translateToFreshPasswordAuthentication, nativeSupport, disabled, unknownFutureValue.'
        ),
    ] = None
    signing_certificate_update_status: Annotated[
        Optional[Union[SigningCertificateUpdateStatus, Dict[str, Any]]],
        Field(
            description='Provides status and timestamp of the last update of the signing certificate.'
        ),
    ] = None
    sign_out_uri: Annotated[
        Optional[str],
        Field(
            description='URI that clients are redirected to when they sign out of Microsoft Entra services. Corresponds to the LogOffUri property of the Set-MsolDomainFederationSettings MSOnline v1 PowerShell cmdlet.'
        ),
    ] = None
    field_odata_type: str


class InternetExplorerMode(Entity):
    site_lists: Annotated[
        Optional[List[BrowserSiteList]],
        Field(
            description='A collection of site lists to support Internet Explorer mode.'
        ),
    ] = None
    field_odata_type: str


class IosCertificateProfile(DeviceConfiguration):
    field_odata_type: str


class IosCompliancePolicy(DeviceCompliancePolicy):
    device_threat_protection_enabled: Annotated[
        Optional[bool],
        Field(
            description='Require that devices have enabled device threat protection .'
        ),
    ] = None
    device_threat_protection_required_security_level: Optional[
        DeviceThreatProtectionLevel
    ] = None
    managed_email_profile_required: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to require a managed email profile.'
        ),
    ] = None
    os_maximum_version: Annotated[
        Optional[str], Field(description='Maximum IOS version.')
    ] = None
    os_minimum_version: Annotated[
        Optional[str], Field(description='Minimum IOS version.')
    ] = None
    passcode_block_simple: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block simple passcodes.'),
    ] = None
    passcode_expiration_days: Annotated[
        Optional[float],
        Field(
            description='Number of days before the passcode expires. Valid values 1 to 65535',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    passcode_minimum_character_set_count: Annotated[
        Optional[float],
        Field(
            description='The number of character sets required in the password.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    passcode_minimum_length: Annotated[
        Optional[float],
        Field(
            description='Minimum length of passcode. Valid values 4 to 14',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    passcode_minutes_of_inactivity_before_lock: Annotated[
        Optional[float],
        Field(
            description='Minutes of inactivity before a passcode is required.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    passcode_previous_passcode_block_count: Annotated[
        Optional[float],
        Field(
            description='Number of previous passcodes to block. Valid values 1 to 24',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    passcode_required: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to require a passcode.'),
    ] = None
    passcode_required_type: Optional[RequiredPasswordType] = None
    security_block_jailbroken_devices: Annotated[
        Optional[bool], Field(description='Devices must not be jailbroken or rooted.')
    ] = None
    field_odata_type: str


class IosCustomConfiguration(DeviceConfiguration):
    payload: Annotated[
        Optional[str], Field(description='Payload. (UTF8 encoded byte array)')
    ] = None
    payload_file_name: Annotated[
        Optional[str], Field(description='Payload file name (.mobileconfig')
    ] = None
    payload_name: Annotated[
        Optional[str], Field(description='Name that is displayed to the user.')
    ] = None
    field_odata_type: str


class IosGeneralDeviceConfiguration(DeviceConfiguration):
    account_block_modification: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to allow account modification when the device is in supervised mode.'
        ),
    ] = None
    activation_lock_allow_when_supervised: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to allow activation lock when the device is in the supervised mode.'
        ),
    ] = None
    air_drop_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to allow AirDrop when the device is in supervised mode.'
        ),
    ] = None
    air_drop_force_unmanaged_drop_target: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to cause AirDrop to be considered an unmanaged drop target (iOS 9.0 and later).'
        ),
    ] = None
    air_play_force_pairing_password_for_outgoing_requests: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to enforce all devices receiving AirPlay requests from this device to use a pairing password.'
        ),
    ] = None
    apple_news_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from using News when the device is in supervised mode (iOS 9.0 and later).'
        ),
    ] = None
    apple_watch_block_pairing: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to allow Apple Watch pairing when the device is in supervised mode (iOS 9.0 and later).'
        ),
    ] = None
    apple_watch_force_wrist_detection: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to force a paired Apple Watch to use Wrist Detection (iOS 8.2 and later).'
        ),
    ] = None
    apps_single_app_mode_list: Annotated[
        Optional[List[AppListItem]],
        Field(
            description='Gets or sets the list of iOS apps allowed to autonomously enter Single App Mode. Supervised only. iOS 7.0 and later. This collection can contain a maximum of 500 elements.'
        ),
    ] = None
    app_store_block_automatic_downloads: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the automatic downloading of apps purchased on other devices when the device is in supervised mode (iOS 9.0 and later).'
        ),
    ] = None
    app_store_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from using the App Store. Requires a supervised device for iOS 13 and later.'
        ),
    ] = None
    app_store_block_in_app_purchases: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from making in app purchases.'
        ),
    ] = None
    app_store_block_ui_app_installation: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the App Store app, not restricting installation through Host apps. Applies to supervised mode only (iOS 9.0 and later).'
        ),
    ] = None
    app_store_require_password: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to require a password when using the app store.'
        ),
    ] = None
    apps_visibility_list: Annotated[
        Optional[List[AppListItem]],
        Field(
            description='List of apps in the visibility list (either visible/launchable apps list or hidden/unlaunchable apps list, controlled by AppsVisibilityListType) (iOS 9.3 and later). This collection can contain a maximum of 10000 elements.'
        ),
    ] = None
    apps_visibility_list_type: Optional[AppListType] = None
    bluetooth_block_modification: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to allow modification of Bluetooth settings when the device is in supervised mode (iOS 10.0 and later).'
        ),
    ] = None
    camera_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from accessing the camera of the device. Requires a supervised device for iOS 13 and later.'
        ),
    ] = None
    cellular_block_data_roaming: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block data roaming.'),
    ] = None
    cellular_block_global_background_fetch_while_roaming: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block global background fetch while roaming.'
        ),
    ] = None
    cellular_block_per_app_data_modification: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to allow changes to cellular app data usage settings when the device is in supervised mode.'
        ),
    ] = None
    cellular_block_personal_hotspot: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block Personal Hotspot.'),
    ] = None
    cellular_block_voice_roaming: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block voice roaming.'),
    ] = None
    certificates_block_untrusted_tls_certificates: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block untrusted TLS certificates.'
        ),
    ] = None
    classroom_app_block_remote_screen_observation: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to allow remote screen observation by Classroom app when the device is in supervised mode (iOS 9.3 and later).'
        ),
    ] = None
    classroom_app_force_unprompted_screen_observation: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether or not to automatically give permission to the teacher of a managed course on the Classroom app to view a student's screen without prompting when the device is in supervised mode."
        ),
    ] = None
    compliant_app_list_type: Optional[AppListType] = None
    compliant_apps_list: Annotated[
        Optional[List[AppListItem]],
        Field(
            description='List of apps in the compliance (either allow list or block list, controlled by CompliantAppListType). This collection can contain a maximum of 10000 elements.'
        ),
    ] = None
    configuration_profile_block_changes: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from installing configuration profiles and certificates interactively when the device is in supervised mode.'
        ),
    ] = None
    definition_lookup_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block definition lookup when the device is in supervised mode (iOS 8.1.3 and later ).'
        ),
    ] = None
    device_block_enable_restrictions: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to allow the user to enables restrictions in the device settings when the device is in supervised mode.'
        ),
    ] = None
    device_block_erase_content_and_settings: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether or not to allow the use of the 'Erase all content and settings' option on the device when the device is in supervised mode."
        ),
    ] = None
    device_block_name_modification: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to allow device name modification when the device is in supervised mode (iOS 9.0 and later).'
        ),
    ] = None
    diagnostic_data_block_submission: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block diagnostic data submission.'
        ),
    ] = None
    diagnostic_data_block_submission_modification: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to allow diagnostics submission settings modification when the device is in supervised mode (iOS 9.3.2 and later).'
        ),
    ] = None
    documents_block_managed_documents_in_unmanaged_apps: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from viewing managed documents in unmanaged apps.'
        ),
    ] = None
    documents_block_unmanaged_documents_in_managed_apps: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from viewing unmanaged documents in managed apps.'
        ),
    ] = None
    email_in_domain_suffixes: Annotated[
        Optional[List[str]],
        Field(
            description='An email address lacking a suffix that matches any of these strings will be considered out-of-domain.'
        ),
    ] = None
    enterprise_app_block_trust: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from trusting an enterprise app.'
        ),
    ] = None
    enterprise_app_block_trust_modification: Annotated[
        Optional[bool],
        Field(
            description="[Deprecated] Configuring this setting and setting the value to 'true' has no effect on the device."
        ),
    ] = None
    face_time_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from using FaceTime. Requires a supervised device for iOS 13 and later.'
        ),
    ] = None
    find_my_friends_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block changes to Find My Friends when the device is in supervised mode.'
        ),
    ] = None
    game_center_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from using Game Center when the device is in supervised mode.'
        ),
    ] = None
    gaming_block_game_center_friends: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from having friends in Game Center. Requires a supervised device for iOS 13 and later.'
        ),
    ] = None
    gaming_block_multiplayer: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from using multiplayer gaming. Requires a supervised device for iOS 13 and later.'
        ),
    ] = None
    host_pairing_blocked: Annotated[
        Optional[bool],
        Field(
            description='indicates whether or not to allow host pairing to control the devices an iOS device can pair with when the iOS device is in supervised mode.'
        ),
    ] = None
    i_books_store_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from using the iBooks Store when the device is in supervised mode.'
        ),
    ] = None
    i_books_store_block_erotica: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from downloading media from the iBookstore that has been tagged as erotica.'
        ),
    ] = None
    i_cloud_block_activity_continuation: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from continuing work they started on iOS device to another iOS or macOS device.'
        ),
    ] = None
    i_cloud_block_backup: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block iCloud backup. Requires a supervised device for iOS 13 and later.'
        ),
    ] = None
    i_cloud_block_document_sync: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block iCloud document sync. Requires a supervised device for iOS 13 and later.'
        ),
    ] = None
    i_cloud_block_managed_apps_sync: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block Managed Apps Cloud Sync.'),
    ] = None
    i_cloud_block_photo_library: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block iCloud Photo Library.'),
    ] = None
    i_cloud_block_photo_stream_sync: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block iCloud Photo Stream Sync.'
        ),
    ] = None
    i_cloud_block_shared_photo_stream: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block Shared Photo Stream.'),
    ] = None
    i_cloud_require_encrypted_backup: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to require backups to iCloud be encrypted.'
        ),
    ] = None
    i_tunes_block_explicit_content: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from accessing explicit content in iTunes and the App Store. Requires a supervised device for iOS 13 and later.'
        ),
    ] = None
    i_tunes_block_music_service: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block Music service and revert Music app to classic mode when the device is in supervised mode (iOS 9.3 and later and macOS 10.12 and later).'
        ),
    ] = None
    i_tunes_block_radio: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from using iTunes Radio when the device is in supervised mode (iOS 9.3 and later).'
        ),
    ] = None
    keyboard_block_auto_correct: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block keyboard auto-correction when the device is in supervised mode (iOS 8.1.3 and later).'
        ),
    ] = None
    keyboard_block_dictation: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from using dictation input when the device is in supervised mode.'
        ),
    ] = None
    keyboard_block_predictive: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block predictive keyboards when device is in supervised mode (iOS 8.1.3 and later).'
        ),
    ] = None
    keyboard_block_shortcuts: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block keyboard shortcuts when the device is in supervised mode (iOS 9.0 and later).'
        ),
    ] = None
    keyboard_block_spell_check: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block keyboard spell-checking when the device is in supervised mode (iOS 8.1.3 and later).'
        ),
    ] = None
    kiosk_mode_allow_assistive_speak: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to allow assistive speak while in kiosk mode.'
        ),
    ] = None
    kiosk_mode_allow_assistive_touch_settings: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to allow access to the Assistive Touch Settings while in kiosk mode.'
        ),
    ] = None
    kiosk_mode_allow_auto_lock: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether or not to allow device auto lock while in kiosk mode. This property's functionality is redundant with the OS default and is deprecated. Use KioskModeBlockAutoLock instead."
        ),
    ] = None
    kiosk_mode_allow_color_inversion_settings: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to allow access to the Color Inversion Settings while in kiosk mode.'
        ),
    ] = None
    kiosk_mode_allow_ringer_switch: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether or not to allow use of the ringer switch while in kiosk mode. This property's functionality is redundant with the OS default and is deprecated. Use KioskModeBlockRingerSwitch instead."
        ),
    ] = None
    kiosk_mode_allow_screen_rotation: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether or not to allow screen rotation while in kiosk mode. This property's functionality is redundant with the OS default and is deprecated. Use KioskModeBlockScreenRotation instead."
        ),
    ] = None
    kiosk_mode_allow_sleep_button: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether or not to allow use of the sleep button while in kiosk mode. This property's functionality is redundant with the OS default and is deprecated. Use KioskModeBlockSleepButton instead."
        ),
    ] = None
    kiosk_mode_allow_touchscreen: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether or not to allow use of the touchscreen while in kiosk mode. This property's functionality is redundant with the OS default and is deprecated. Use KioskModeBlockTouchscreen instead."
        ),
    ] = None
    kiosk_mode_allow_voice_over_settings: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to allow access to the voice over settings while in kiosk mode.'
        ),
    ] = None
    kiosk_mode_allow_volume_buttons: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether or not to allow use of the volume buttons while in kiosk mode. This property's functionality is redundant with the OS default and is deprecated. Use KioskModeBlockVolumeButtons instead."
        ),
    ] = None
    kiosk_mode_allow_zoom_settings: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to allow access to the zoom settings while in kiosk mode.'
        ),
    ] = None
    kiosk_mode_app_store_url: Annotated[
        Optional[str],
        Field(
            description='URL in the app store to the app to use for kiosk mode. Use if KioskModeManagedAppId is not known.'
        ),
    ] = None
    kiosk_mode_built_in_app_id: Annotated[
        Optional[str],
        Field(
            description='ID for built-in apps to use for kiosk mode. Used when KioskModeManagedAppId and KioskModeAppStoreUrl are not set.'
        ),
    ] = None
    kiosk_mode_managed_app_id: Annotated[
        Optional[str],
        Field(
            description='Managed app id of the app to use for kiosk mode. If KioskModeManagedAppId is specified then KioskModeAppStoreUrl will be ignored.'
        ),
    ] = None
    kiosk_mode_require_assistive_touch: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to require assistive touch while in kiosk mode.'
        ),
    ] = None
    kiosk_mode_require_color_inversion: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to require color inversion while in kiosk mode.'
        ),
    ] = None
    kiosk_mode_require_mono_audio: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to require mono audio while in kiosk mode.'
        ),
    ] = None
    kiosk_mode_require_voice_over: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to require voice over while in kiosk mode.'
        ),
    ] = None
    kiosk_mode_require_zoom: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to require zoom while in kiosk mode.'
        ),
    ] = None
    lock_screen_block_control_center: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from using control center on the lock screen.'
        ),
    ] = None
    lock_screen_block_notification_view: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from using the notification view on the lock screen.'
        ),
    ] = None
    lock_screen_block_passbook: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from using passbook when the device is locked.'
        ),
    ] = None
    lock_screen_block_today_view: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from using the Today View on the lock screen.'
        ),
    ] = None
    media_content_rating_apps: Optional[RatingAppsType] = None
    media_content_rating_australia: Annotated[
        Optional[Union[MediaContentRatingAustralia, Dict[str, Any]]],
        Field(description='Media content rating settings for Australia'),
    ] = None
    media_content_rating_canada: Annotated[
        Optional[Union[MediaContentRatingCanada, Dict[str, Any]]],
        Field(description='Media content rating settings for Canada'),
    ] = None
    media_content_rating_france: Annotated[
        Optional[Union[MediaContentRatingFrance, Dict[str, Any]]],
        Field(description='Media content rating settings for France'),
    ] = None
    media_content_rating_germany: Annotated[
        Optional[Union[MediaContentRatingGermany, Dict[str, Any]]],
        Field(description='Media content rating settings for Germany'),
    ] = None
    media_content_rating_ireland: Annotated[
        Optional[Union[MediaContentRatingIreland, Dict[str, Any]]],
        Field(description='Media content rating settings for Ireland'),
    ] = None
    media_content_rating_japan: Annotated[
        Optional[Union[MediaContentRatingJapan, Dict[str, Any]]],
        Field(description='Media content rating settings for Japan'),
    ] = None
    media_content_rating_new_zealand: Annotated[
        Optional[Union[MediaContentRatingNewZealand, Dict[str, Any]]],
        Field(description='Media content rating settings for New Zealand'),
    ] = None
    media_content_rating_united_kingdom: Annotated[
        Optional[Union[MediaContentRatingUnitedKingdom, Dict[str, Any]]],
        Field(description='Media content rating settings for United Kingdom'),
    ] = None
    media_content_rating_united_states: Annotated[
        Optional[Union[MediaContentRatingUnitedStates, Dict[str, Any]]],
        Field(description='Media content rating settings for United States'),
    ] = None
    messages_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from using the Messages app on the supervised device.'
        ),
    ] = None
    network_usage_rules: Annotated[
        Optional[List[IosNetworkUsageRule]],
        Field(
            description='List of managed apps and the network rules that applies to them. This collection can contain a maximum of 1000 elements.'
        ),
    ] = None
    notifications_block_settings_modification: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to allow notifications settings modification (iOS 9.3 and later).'
        ),
    ] = None
    passcode_block_fingerprint_modification: Annotated[
        Optional[bool],
        Field(
            description='Block modification of registered Touch ID fingerprints when in supervised mode.'
        ),
    ] = None
    passcode_block_fingerprint_unlock: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block fingerprint unlock.'),
    ] = None
    passcode_block_modification: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to allow passcode modification on the supervised device (iOS 9.0 and later).'
        ),
    ] = None
    passcode_block_simple: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block simple passcodes.'),
    ] = None
    passcode_expiration_days: Annotated[
        Optional[float],
        Field(
            description='Number of days before the passcode expires. Valid values 1 to 65535',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    passcode_minimum_character_set_count: Annotated[
        Optional[float],
        Field(
            description='Number of character sets a passcode must contain. Valid values 0 to 4',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    passcode_minimum_length: Annotated[
        Optional[float],
        Field(
            description='Minimum length of passcode. Valid values 4 to 14',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    passcode_minutes_of_inactivity_before_lock: Annotated[
        Optional[float],
        Field(
            description='Minutes of inactivity before a passcode is required.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    passcode_minutes_of_inactivity_before_screen_timeout: Annotated[
        Optional[float],
        Field(
            description='Minutes of inactivity before the screen times out.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    passcode_previous_passcode_block_count: Annotated[
        Optional[float],
        Field(
            description='Number of previous passcodes to block. Valid values 1 to 24',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    passcode_required: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to require a passcode.'),
    ] = None
    passcode_required_type: Optional[RequiredPasswordType] = None
    passcode_sign_in_failure_count_before_wipe: Annotated[
        Optional[float],
        Field(
            description='Number of sign in failures allowed before wiping the device. Valid values 2 to 11',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    podcasts_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from using podcasts on the supervised device (iOS 8.0 and later).'
        ),
    ] = None
    safari_block_autofill: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from using Auto fill in Safari. Requires a supervised device for iOS 13 and later.'
        ),
    ] = None
    safari_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from using Safari. Requires a supervised device for iOS 13 and later.'
        ),
    ] = None
    safari_block_java_script: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block JavaScript in Safari.'),
    ] = None
    safari_block_popups: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block popups in Safari.'),
    ] = None
    safari_cookie_settings: Optional[WebBrowserCookieSettings] = None
    safari_managed_domains: Annotated[
        Optional[List[str]],
        Field(
            description='URLs matching the patterns listed here will be considered managed.'
        ),
    ] = None
    safari_password_auto_fill_domains: Annotated[
        Optional[List[str]],
        Field(
            description='Users can save passwords in Safari only from URLs matching the patterns listed here. Applies to devices in supervised mode (iOS 9.3 and later).'
        ),
    ] = None
    safari_require_fraud_warning: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to require fraud warning in Safari.'
        ),
    ] = None
    screen_capture_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from taking Screenshots.'
        ),
    ] = None
    siri_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from using Siri.'
        ),
    ] = None
    siri_blocked_when_locked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from using Siri when locked.'
        ),
    ] = None
    siri_block_user_generated_content: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block Siri from querying user-generated content when used on a supervised device.'
        ),
    ] = None
    siri_require_profanity_filter: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to prevent Siri from dictating, or speaking profane language on supervised device.'
        ),
    ] = None
    spotlight_block_internet_results: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block Spotlight search from returning internet results on supervised device.'
        ),
    ] = None
    voice_dialing_blocked: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block voice dialing.'),
    ] = None
    wallpaper_block_modification: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to allow wallpaper modification on supervised device (iOS 9.0 and later) .'
        ),
    ] = None
    wi_fi_connect_only_to_configured_networks: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether or not to force the device to use only Wi-Fi networks from configuration profiles when the device is in supervised mode. Available for devices running iOS and iPadOS versions 14.4 and earlier. Devices running 14.5+ should use the setting, 'WiFiConnectToAllowedNetworksOnlyForced."
        ),
    ] = None
    field_odata_type: str


class IosManagedAppRegistration(ManagedAppRegistration):
    field_odata_type: str


class IosUpdateConfiguration(DeviceConfiguration):
    active_hours_end: Annotated[
        Optional[time],
        Field(
            description='Active Hours End (active hours mean the time window when updates install should not happen)',
        ),
    ] = None
    active_hours_start: Annotated[
        Optional[time],
        Field(
            description='Active Hours Start (active hours mean the time window when updates install should not happen)',
        ),
    ] = None
    scheduled_install_days: Annotated[
        Optional[List[DayOfWeek]],
        Field(
            description='Days in week for which active hours are configured. This collection can contain a maximum of 7 elements.'
        ),
    ] = None
    utc_time_offset_in_minutes: Annotated[
        Optional[float],
        Field(
            description='UTC Time Offset indicated in minutes',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class IosVppEBookAssignment(ManagedEBookAssignment):
    field_odata_type: str


class ItemRetentionLabel(Entity):
    is_label_applied_explicitly: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether the label is applied explicitly on the item. True indicates that the label is applied explicitly; otherwise, the label is inherited from its parent. Read-only.'
        ),
    ] = None
    label_applied_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Identity of the user who applied the label. Read-only.'),
    ] = None
    label_applied_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the label was applied on the item. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.',
        ),
    ] = None
    name: Annotated[
        Optional[str],
        Field(description='The retention label on the document. Read-write.'),
    ] = None
    retention_settings: Annotated[
        Optional[Union[RetentionLabelSettings, Dict[str, Any]]],
        Field(description='The retention settings enforced on the item. Read-write.'),
    ] = None
    field_odata_type: str


class LandingPage(Entity):
    created_by: Annotated[
        Optional[Union[EmailIdentity, Dict[str, Any]]],
        Field(description='Identity of the user who created the landing page.'),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when the landing page was created. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(description='Description of the landing page as defined by the user.'),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The display name of the landing page.')
    ] = None
    last_modified_by: Annotated[
        Optional[Union[EmailIdentity, Dict[str, Any]]],
        Field(
            description='Email identity of the user who last modified the landing page.'
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when the landing page was last modified. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    locale: Annotated[Optional[str], Field(description='Content locale.')] = None
    source: Annotated[
        Optional[Union[SimulationContentSource, Dict[str, Any]]],
        Field(
            description='The source of the content. Possible values are: unknown, global, tenant, unknownFutureValue.'
        ),
    ] = None
    status: Annotated[
        Optional[Union[SimulationContentStatus, Dict[str, Any]]],
        Field(
            description='The status of the simulation. Possible values are: unknown, draft, ready, archive, delete, unknownFutureValue.'
        ),
    ] = None
    supported_locales: Annotated[
        Optional[List[str]], Field(description='Supported locales.')
    ] = None
    details: Annotated[
        Optional[List[LandingPageDetail]],
        Field(
            description='The detail information for a landing page associated with a simulation during its creation.'
        ),
    ] = None
    field_odata_type: str


class LearningAssignment(LearningCourseActivity):
    assigned_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Assigned date for the course activity. Optional.',
        ),
    ] = None
    assigner_user_id: Annotated[
        Optional[str], Field(description='The user ID of the assigner. Optional.')
    ] = None
    assignment_type: Optional[AssignmentType] = None
    due_date_time: Annotated[
        Optional[Union[DateTimeTimeZone, Dict[str, Any]]],
        Field(description='Due date for the course activity. Optional.'),
    ] = None
    notes: Annotated[
        Optional[Union[ItemBody, Dict[str, Any]]],
        Field(description='Notes for the course activity. Optional.'),
    ] = None
    field_odata_type: str


class LoginPage(Entity):
    content: Annotated[
        Optional[str], Field(description='The HTML content of the login page.')
    ] = None
    created_by: Annotated[
        Optional[Union[EmailIdentity, Dict[str, Any]]],
        Field(description='Identity of the user who created the login page.'),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when the login page was created. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    description: Annotated[
        Optional[str], Field(description='Description about the login page.')
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='Display name of the login page.')
    ] = None
    language: Annotated[
        Optional[str], Field(description='The content language of the login page.')
    ] = None
    last_modified_by: Annotated[
        Optional[Union[EmailIdentity, Dict[str, Any]]],
        Field(description='Identity of the user who last modified the login page.'),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when the login page was last modified. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    source: Annotated[
        Optional[Union[SimulationContentSource, Dict[str, Any]]],
        Field(
            description='The source of the content. Possible values are: unknown, global, tenant, unknownFutureValue.'
        ),
    ] = None
    status: Annotated[
        Optional[Union[SimulationContentStatus, Dict[str, Any]]],
        Field(
            description='The login page status. Possible values are: unknown, draft, ready, archive, delete, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class MacOSCompliancePolicy(DeviceCompliancePolicy):
    device_threat_protection_enabled: Annotated[
        Optional[bool],
        Field(
            description='Require that devices have enabled device threat protection.'
        ),
    ] = None
    device_threat_protection_required_security_level: Optional[
        DeviceThreatProtectionLevel
    ] = None
    firewall_block_all_incoming: Annotated[
        Optional[bool],
        Field(
            description="Corresponds to the 'Block all incoming connections' option."
        ),
    ] = None
    firewall_enabled: Annotated[
        Optional[bool],
        Field(description='Whether the firewall should be enabled or not.'),
    ] = None
    firewall_enable_stealth_mode: Annotated[
        Optional[bool], Field(description="Corresponds to 'Enable stealth mode.'")
    ] = None
    os_maximum_version: Annotated[
        Optional[str], Field(description='Maximum MacOS version.')
    ] = None
    os_minimum_version: Annotated[
        Optional[str], Field(description='Minimum MacOS version.')
    ] = None
    password_block_simple: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block simple passwords.'),
    ] = None
    password_expiration_days: Annotated[
        Optional[float],
        Field(
            description='Number of days before the password expires. Valid values 1 to 65535',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minimum_character_set_count: Annotated[
        Optional[float],
        Field(
            description='The number of character sets required in the password.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minimum_length: Annotated[
        Optional[float],
        Field(
            description='Minimum length of password. Valid values 4 to 14',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minutes_of_inactivity_before_lock: Annotated[
        Optional[float],
        Field(
            description='Minutes of inactivity before a password is required.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_previous_password_block_count: Annotated[
        Optional[float],
        Field(
            description='Number of previous passwords to block. Valid values 1 to 24',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_required: Annotated[
        Optional[bool], Field(description='Whether or not to require a password.')
    ] = None
    password_required_type: Optional[RequiredPasswordType] = None
    storage_require_encryption: Annotated[
        Optional[bool], Field(description='Require encryption on Mac OS devices.')
    ] = None
    system_integrity_protection_enabled: Annotated[
        Optional[bool],
        Field(
            description='Require that devices have enabled system integrity protection.'
        ),
    ] = None
    field_odata_type: str


class MacOSCustomConfiguration(DeviceConfiguration):
    payload: Annotated[
        Optional[str], Field(description='Payload. (UTF8 encoded byte array)')
    ] = None
    payload_file_name: Annotated[
        Optional[str], Field(description='Payload file name (.mobileconfig')
    ] = None
    payload_name: Annotated[
        Optional[str], Field(description='Name that is displayed to the user.')
    ] = None
    field_odata_type: str


class MacOSGeneralDeviceConfiguration(DeviceConfiguration):
    compliant_app_list_type: Optional[AppListType] = None
    compliant_apps_list: Annotated[
        Optional[List[AppListItem]],
        Field(
            description='List of apps in the compliance (either allow list or block list, controlled by CompliantAppListType). This collection can contain a maximum of 10000 elements.'
        ),
    ] = None
    email_in_domain_suffixes: Annotated[
        Optional[List[str]],
        Field(
            description='An email address lacking a suffix that matches any of these strings will be considered out-of-domain.'
        ),
    ] = None
    password_block_simple: Annotated[
        Optional[bool], Field(description='Block simple passwords.')
    ] = None
    password_expiration_days: Annotated[
        Optional[float],
        Field(
            description='Number of days before the password expires.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minimum_character_set_count: Annotated[
        Optional[float],
        Field(
            description='Number of character sets a password must contain. Valid values 0 to 4',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minimum_length: Annotated[
        Optional[float],
        Field(
            description='Minimum length of passwords.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minutes_of_inactivity_before_lock: Annotated[
        Optional[float],
        Field(
            description='Minutes of inactivity required before a password is required.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minutes_of_inactivity_before_screen_timeout: Annotated[
        Optional[float],
        Field(
            description='Minutes of inactivity required before the screen times out.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_previous_password_block_count: Annotated[
        Optional[float],
        Field(
            description='Number of previous passwords to block.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_required: Annotated[
        Optional[bool], Field(description='Whether or not to require a password.')
    ] = None
    password_required_type: Optional[RequiredPasswordType] = None
    field_odata_type: str


class ManagedAppPolicyDeploymentSummary(Entity):
    configuration_deployed_user_count: Annotated[
        Optional[float],
        Field(description='Not yet documented', ge=-2147483648.0, le=2147483647.0),
    ] = None
    configuration_deployment_summary_per_app: Annotated[
        Optional[List[ManagedAppPolicyDeploymentSummaryPerApp]],
        Field(description='Not yet documented'),
    ] = None
    display_name: Annotated[Optional[str], Field(description='Not yet documented')] = (
        None
    )
    last_refresh_time: Annotated[
        Optional[datetime],
        Field(
            description='Not yet documented',
        ),
    ] = None
    version: Annotated[Optional[str], Field(description='Version of the entity.')] = (
        None
    )
    field_odata_type: str


class ManagedDeviceMobileAppConfiguration(Entity):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='DateTime the object was created.',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(description='Admin provided description of the Device Configuration.'),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(description='Admin provided name of the device configuration.'),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='DateTime the object was last modified.',
        ),
    ] = None
    targeted_mobile_apps: Annotated[
        Optional[List[str]], Field(description='the associated app.')
    ] = None
    version: Annotated[
        Optional[float],
        Field(
            description='Version of the device configuration.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    assignments: Annotated[
        Optional[List[ManagedDeviceMobileAppConfigurationAssignment]],
        Field(description='The list of group assignemenets for app configration.'),
    ] = None
    device_statuses: Annotated[
        Optional[List[ManagedDeviceMobileAppConfigurationDeviceStatus]],
        Field(description='List of ManagedDeviceMobileAppConfigurationDeviceStatus.'),
    ] = None
    device_status_summary: Annotated[
        Optional[
            Union[ManagedDeviceMobileAppConfigurationDeviceSummary, Dict[str, Any]]
        ],
        Field(description='App configuration device status summary.'),
    ] = None
    user_statuses: Annotated[
        Optional[List[ManagedDeviceMobileAppConfigurationUserStatus]],
        Field(description='List of ManagedDeviceMobileAppConfigurationUserStatus.'),
    ] = None
    user_status_summary: Annotated[
        Optional[Union[ManagedDeviceMobileAppConfigurationUserSummary, Dict[str, Any]]],
        Field(description='App configuration user status summary.'),
    ] = None
    field_odata_type: str


class ManagedEBook(Entity):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the eBook file was created.',
        ),
    ] = None
    description: Annotated[Optional[str], Field(description='Description.')] = None
    display_name: Annotated[Optional[str], Field(description='Name of the eBook.')] = (
        None
    )
    information_url: Annotated[
        Optional[str], Field(description='The more information Url.')
    ] = None
    large_cover: Annotated[
        Optional[Union[MimeContent, Dict[str, Any]]], Field(description='Book cover.')
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the eBook was last modified.',
        ),
    ] = None
    privacy_information_url: Annotated[
        Optional[str], Field(description='The privacy statement Url.')
    ] = None
    published_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the eBook was published.',
        ),
    ] = None
    publisher: Annotated[Optional[str], Field(description='Publisher.')] = None
    assignments: Annotated[
        Optional[List[ManagedEBookAssignment]],
        Field(description='The list of assignments for this eBook.'),
    ] = None
    device_states: Annotated[
        Optional[List[DeviceInstallState]],
        Field(description='The list of installation states for this eBook.'),
    ] = None
    install_summary: Annotated[
        Optional[Union[EBookInstallSummary, Dict[str, Any]]],
        Field(description='Mobile App Install Summary.'),
    ] = None
    user_state_summary: Annotated[
        Optional[List[UserInstallStateSummary]],
        Field(description='The list of installation states for this eBook.'),
    ] = None
    field_odata_type: str


class MdmWindowsInformationProtectionPolicy(WindowsInformationProtection):
    field_odata_type: str


class Message(OutlookItem):
    bcc_recipients: Annotated[
        Optional[List[Recipient]],
        Field(description='The Bcc: recipients for the message.'),
    ] = None
    body: Annotated[
        Optional[Union[ItemBody, Dict[str, Any]]],
        Field(
            description='The body of the message. It can be in HTML or text format. Find out about safe HTML in a message body.'
        ),
    ] = None
    body_preview: Annotated[
        Optional[str],
        Field(
            description='The first 255 characters of the message body. It is in text format.'
        ),
    ] = None
    cc_recipients: Annotated[
        Optional[List[Recipient]],
        Field(description='The Cc: recipients for the message.'),
    ] = None
    conversation_id: Annotated[
        Optional[str],
        Field(description='The ID of the conversation the email belongs to.'),
    ] = None
    conversation_index: Annotated[
        Optional[str],
        Field(
            description='Indicates the position of the message within the conversation.'
        ),
    ] = None
    flag: Annotated[
        Optional[Union[FollowupFlag, Dict[str, Any]]],
        Field(
            description='The flag value that indicates the status, start date, due date, or completion date for the message.'
        ),
    ] = None
    from_: Annotated[
        Optional[Union[Recipient, Dict[str, Any]]],
        Field(
            description='The owner of the mailbox from which the message is sent. In most cases, this value is the same as the sender property, except for sharing or delegation scenarios. The value must correspond to the actual mailbox used. Find out more about setting the from and sender properties of a message.'
        ),
    ] = None
    has_attachments: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether the message has attachments. This property doesn't include inline attachments, so if a message contains only inline attachments, this property is false. To verify the existence of inline attachments, parse the body property to look for a src attribute, such as <IMG src='cid:image001.jpg@01D26CD8.6C05F070'>."
        ),
    ] = None
    importance: Annotated[
        Optional[Union[Importance, Dict[str, Any]]],
        Field(
            description='The importance of the message. The possible values are: low, normal, and high.'
        ),
    ] = None
    inference_classification: Annotated[
        Optional[Union[InferenceClassificationType, Dict[str, Any]]],
        Field(
            description='The classification of the message for the user, based on inferred relevance or importance, or on an explicit override. The possible values are: focused or other.'
        ),
    ] = None
    internet_message_headers: Annotated[
        Optional[List[InternetMessageHeader]],
        Field(
            description='A collection of message headers defined by RFC5322. The set includes message headers indicating the network path taken by a message from the sender to the recipient. It can also contain custom message headers that hold app data for the message.  Returned only on applying a $select query option. Read-only.'
        ),
    ] = None
    internet_message_id: Annotated[
        Optional[str],
        Field(description='The message ID in the format specified by RFC2822.'),
    ] = None
    is_delivery_receipt_requested: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether a read receipt is requested for the message.'
        ),
    ] = None
    is_draft: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether the message is a draft. A message is a draft if it hasn't been sent yet."
        ),
    ] = None
    is_read: Annotated[
        Optional[bool],
        Field(description='Indicates whether the message has been read.'),
    ] = None
    is_read_receipt_requested: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether a read receipt is requested for the message.'
        ),
    ] = None
    parent_folder_id: Annotated[
        Optional[str],
        Field(description="The unique identifier for the message's parent mailFolder."),
    ] = None
    received_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time the message was received.  The date and time information uses ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    reply_to: Annotated[
        Optional[List[Recipient]],
        Field(description='The email addresses to use when replying.'),
    ] = None
    sender: Annotated[
        Optional[Union[Recipient, Dict[str, Any]]],
        Field(
            description='The account that is actually used to generate the message. In most cases, this value is the same as the from property. You can set this property to a different value when sending a message from a shared mailbox, for a shared calendar, or as a delegate. In any case, the value must correspond to the actual mailbox used. Find out more about setting the from and sender properties of a message.'
        ),
    ] = None
    sent_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time the message was sent.  The date and time information uses ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    subject: Annotated[
        Optional[str], Field(description='The subject of the message.')
    ] = None
    to_recipients: Annotated[
        Optional[List[Recipient]],
        Field(description='The To: recipients for the message.'),
    ] = None
    unique_body: Annotated[
        Optional[Union[ItemBody, Dict[str, Any]]],
        Field(
            description='The part of the body of the message that is unique to the current message. uniqueBody is not returned by default but can be retrieved for a given message by use of the ?$select=uniqueBody query. It can be in HTML or text format.'
        ),
    ] = None
    web_link: Annotated[
        Optional[str],
        Field(
            description='The URL to open the message in Outlook on the web.You can append an ispopout argument to the end of the URL to change how the message is displayed. If ispopout is not present or if it is set to 1, then the message is shown in a popout window. If ispopout is set to 0, the browser shows the message in the Outlook on the web review pane.The message opens in the browser if you are signed in to your mailbox via Outlook on the web. You are prompted to sign in if you are not already signed in with the browser.This URL cannot be accessed from within an iFrame.'
        ),
    ] = None
    attachments: Annotated[
        Optional[List[Attachment]],
        Field(
            description='The fileAttachment and itemAttachment attachments for the message.'
        ),
    ] = None
    extensions: Annotated[
        Optional[List[Extension]],
        Field(
            description='The collection of open extensions defined for the message. Nullable.'
        ),
    ] = None
    multi_value_extended_properties: Annotated[
        Optional[List[MultiValueLegacyExtendedProperty]],
        Field(
            description='The collection of multi-value extended properties defined for the message. Nullable.'
        ),
    ] = None
    single_value_extended_properties: Annotated[
        Optional[List[SingleValueLegacyExtendedProperty]],
        Field(
            description='The collection of single-value extended properties defined for the message. Nullable.'
        ),
    ] = None
    field_odata_type: str


class MessageRule(Entity):
    actions: Annotated[
        Optional[Union[MessageRuleActions, Dict[str, Any]]],
        Field(
            description='Actions to be taken on a message when the corresponding conditions are fulfilled.'
        ),
    ] = None
    conditions: Annotated[
        Optional[Union[MessageRulePredicates, Dict[str, Any]]],
        Field(
            description='Conditions that when fulfilled trigger the corresponding actions for that rule.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The display name of the rule.')
    ] = None
    exceptions: Annotated[
        Optional[Union[MessageRulePredicates, Dict[str, Any]]],
        Field(description='Exception conditions for the rule.'),
    ] = None
    has_error: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the rule is in an error condition. Read-only.'
        ),
    ] = None
    is_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the rule is enabled to be applied to messages.'
        ),
    ] = None
    is_read_only: Annotated[
        Optional[bool],
        Field(
            description='Indicates if the rule is read-only and cannot be modified or deleted by the rules REST API.'
        ),
    ] = None
    sequence: Annotated[
        Optional[float],
        Field(
            description='Indicates the order in which the rule is executed, among other rules.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class MicrosoftAuthenticatorAuthenticationMethod(AuthenticationMethod):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description="The date and time that this app was registered. This property is null if the device isn't registered for passwordless Phone Sign-In.",
        ),
    ] = None
    device_tag: Annotated[
        Optional[str], Field(description='Tags containing app metadata.')
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(description='The name of the device on which this app is registered.'),
    ] = None
    phone_app_version: Annotated[
        Optional[str],
        Field(
            description='Numerical version of this instance of the Authenticator app.'
        ),
    ] = None
    device: Annotated[
        Optional[Union[Device, Dict[str, Any]]],
        Field(
            description="The registered device on which Microsoft Authenticator resides. This property is null if the device isn't registered for passwordless Phone Sign-In."
        ),
    ] = None
    field_odata_type: str


class MobileApp(Entity):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time the app was created.',
        ),
    ] = None
    description: Annotated[
        Optional[str], Field(description='The description of the app.')
    ] = None
    developer: Annotated[
        Optional[str], Field(description='The developer of the app.')
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(description='The admin provided or imported title of the app.'),
    ] = None
    information_url: Annotated[
        Optional[str], Field(description='The more information Url.')
    ] = None
    is_featured: Annotated[
        Optional[bool],
        Field(
            description='The value indicating whether the app is marked as featured by the admin.'
        ),
    ] = None
    large_icon: Annotated[
        Optional[Union[MimeContent, Dict[str, Any]]],
        Field(
            description='The large icon, to be displayed in the app details and used for upload of the icon.'
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time the app was last modified.',
        ),
    ] = None
    notes: Annotated[Optional[str], Field(description='Notes for the app.')] = None
    owner: Annotated[Optional[str], Field(description='The owner of the app.')] = None
    privacy_information_url: Annotated[
        Optional[str], Field(description='The privacy statement Url.')
    ] = None
    publisher: Annotated[
        Optional[str], Field(description='The publisher of the app.')
    ] = None
    publishing_state: Optional[MobileAppPublishingState] = None
    assignments: Annotated[
        Optional[List[MobileAppAssignment]],
        Field(description='The list of group assignments for this mobile app.'),
    ] = None
    categories: Annotated[
        Optional[List[MobileAppCategory]],
        Field(description='The list of categories for this app.'),
    ] = None
    field_odata_type: str


class MobileAppContent(Entity):
    contained_apps: Annotated[
        Optional[List[MobileContainedApp]],
        Field(
            description='The collection of contained apps in a MobileLobApp acting as a package.'
        ),
    ] = None
    files: Annotated[
        Optional[List[MobileAppContentFile]],
        Field(description='The list of files for this app content version.'),
    ] = None
    field_odata_type: str


class MobileLobApp(MobileApp):
    committed_content_version: Annotated[
        Optional[str], Field(description='The internal committed content version.')
    ] = None
    file_name: Annotated[
        Optional[str], Field(description='The name of the main Lob application file.')
    ] = None
    size: Annotated[
        Optional[float],
        Field(description='The total size, including all uploaded files.'),
    ] = None
    content_versions: Annotated[
        Optional[List[MobileAppContent]],
        Field(description='The list of content versions for this app.'),
    ] = None
    field_odata_type: str


class MultiTenantOrganizationJoinRequestRecord(Entity):
    added_by_tenant_id: Annotated[
        Optional[str],
        Field(
            description='Tenant ID of the Microsoft Entra tenant that added a tenant to the multitenant organization. To reset a failed join request, set addedByTenantId to 00000000-0000-0000-0000-000000000000. Required.'
        ),
    ] = None
    member_state: Annotated[
        Optional[Union[MultiTenantOrganizationMemberState, Dict[str, Any]]],
        Field(
            description='State of the tenant in the multitenant organization. The possible values are: pending, active, removed, unknownFutureValue. Tenants in the pending state must join the multitenant organization to participate in the multitenant organization. Tenants in the active state can participate in the multitenant organization. Tenants in the removed state are in the process of being removed from the multitenant organization. Read-only.'
        ),
    ] = None
    role: Annotated[
        Optional[Union[MultiTenantOrganizationMemberRole, Dict[str, Any]]],
        Field(
            description='Role of the tenant in the multitenant organization. The possible values are: owner, member (default), unknownFutureValue. Tenants with the owner role can manage the multitenant organization. There can be multiple tenants with the owner role in a multitenant organization. Tenants with the member role can participate in a multitenant organization.'
        ),
    ] = None
    transition_details: Annotated[
        Optional[
            Union[MultiTenantOrganizationJoinRequestTransitionDetails, Dict[str, Any]]
        ],
        Field(
            description='Details of the processing status for a tenant joining a multitenant organization. Read-only.'
        ),
    ] = None
    field_odata_type: str


class MultiTenantOrganizationMember(DirectoryObject):
    added_by_tenant_id: Annotated[
        Optional[UUID],
        Field(
            description='Tenant ID of the tenant that added the tenant to the multitenant organization. Read-only.',
        ),
    ] = None
    added_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when the tenant was added to the multitenant organization. Read-only.',
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='Display name of the tenant added to the multitenant organization.'
        ),
    ] = None
    joined_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when the tenant joined the multitenant organization. Read-only.',
        ),
    ] = None
    role: Annotated[
        Optional[Union[MultiTenantOrganizationMemberRole, Dict[str, Any]]],
        Field(
            description='Role of the tenant in the multitenant organization. The possible values are: owner, member (default), unknownFutureValue. Tenants with the owner role can manage the multitenant organization but tenants with the member role can only participate in a multitenant organization. There can be multiple tenants with the owner role in a multitenant organization.'
        ),
    ] = None
    state: Annotated[
        Optional[Union[MultiTenantOrganizationMemberState, Dict[str, Any]]],
        Field(
            description='State of the tenant in the multitenant organization. The possible values are: pending, active, removed, unknownFutureValue. Tenants in the pending state must join the multitenant organization to participate in the multitenant organization. Tenants in the active state can participate in the multitenant organization. Tenants in the removed state are in the process of being removed from the multitenant organization. Read-only.'
        ),
    ] = None
    tenant_id: Annotated[
        Optional[str],
        Field(
            description='Tenant ID of the Microsoft Entra tenant added to the multitenant organization. Set at the time tenant is added.Supports $filter. Key.'
        ),
    ] = None
    transition_details: Annotated[
        Optional[Union[MultiTenantOrganizationMemberTransitionDetails, Dict[str, Any]]],
        Field(
            description='Details of the processing status for a tenant in a multitenant organization. Read-only. Nullable.'
        ),
    ] = None
    field_odata_type: str


class OfferShiftRequest(ScheduleChangeRequest):
    recipient_action_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z',
        ),
    ] = None
    recipient_action_message: Annotated[
        Optional[str],
        Field(
            description='Custom message sent by recipient of the offer shift request.'
        ),
    ] = None
    recipient_user_id: Annotated[
        Optional[str],
        Field(description='User ID of the recipient of the offer shift request.'),
    ] = None
    sender_shift_id: Annotated[
        Optional[str],
        Field(description='User ID of the sender of the offer shift request.'),
    ] = None
    field_odata_type: str


class OfficeGraphInsights(Entity):
    shared: Annotated[
        Optional[List[SharedInsight]],
        Field(
            description='Calculated relationship that identifies documents shared with or by the user. This includes URLs, file attachments, and reference attachments to OneDrive for work or school and SharePoint files found in Outlook messages and meetings. This also includes URLs and reference attachments to Teams conversations. Ordered by recency of share.'
        ),
    ] = None
    trending: Annotated[
        Optional[List[Trending]],
        Field(
            description="Calculated relationship that identifies documents trending around a user. Trending documents are calculated based on activity of the user's closest network of people and include files stored in OneDrive for work or school and SharePoint. Trending insights help the user to discover potentially useful content that the user has access to, but has never viewed before."
        ),
    ] = None
    used: Annotated[
        Optional[List[UsedInsight]],
        Field(
            description='Calculated relationship that identifies the latest documents viewed or modified by a user, including OneDrive for work or school and SharePoint documents, ranked by recency of use.'
        ),
    ] = None
    field_odata_type: str


class OnAttributeCollectionListener(AuthenticationEventListener):
    handler: Annotated[
        Optional[Union[OnAttributeCollectionHandler, Dict[str, Any]]],
        Field(
            description='Required. Configuration for what to invoke if the event resolves to this listener.'
        ),
    ] = None
    field_odata_type: str


class OnAuthenticationMethodLoadStartListener(AuthenticationEventListener):
    handler: Annotated[
        Optional[Union[OnAuthenticationMethodLoadStartHandler, Dict[str, Any]]],
        Field(
            description='Required. Configuration for what to invoke if the event resolves to this listener. This property lets us define potential handler configurations per-event.'
        ),
    ] = None
    field_odata_type: str


class OnenoteOperation(Operation):
    error: Annotated[
        Optional[Union[OnenoteOperationError, Dict[str, Any]]],
        Field(description='The error returned by the operation.'),
    ] = None
    percent_complete: Annotated[
        Optional[str],
        Field(
            description='The operation percent complete if the operation is still in running status.'
        ),
    ] = None
    resource_id: Annotated[Optional[str], Field(description='The resource id.')] = None
    resource_location: Annotated[
        Optional[str],
        Field(
            description='The resource URI for the object. For example, the resource URI for a copied page or section.'
        ),
    ] = None
    field_odata_type: str


class OnInteractiveAuthFlowStartListener(AuthenticationEventListener):
    handler: Annotated[
        Optional[Union[OnInteractiveAuthFlowStartHandler, Dict[str, Any]]],
        Field(
            description='Required. Configuration for what to invoke if the event resolves to this listener. This lets us define potential handler configurations per-event.'
        ),
    ] = None
    field_odata_type: str


class OnlineMeetingBase(Entity):
    allow_attendee_to_enable_camera: Annotated[
        Optional[bool],
        Field(description='Indicates whether attendees can turn on their camera.'),
    ] = None
    allow_attendee_to_enable_mic: Annotated[
        Optional[bool],
        Field(description='Indicates whether attendees can turn on their microphone.'),
    ] = None
    allowed_presenters: Annotated[
        Optional[Union[OnlineMeetingPresenters, Dict[str, Any]]],
        Field(description='Specifies who can be a presenter in a meeting.'),
    ] = None
    allow_meeting_chat: Annotated[
        Optional[Union[MeetingChatMode, Dict[str, Any]]],
        Field(description='Specifies the mode of the meeting chat.'),
    ] = None
    allow_participants_to_change_name: Annotated[
        Optional[bool],
        Field(
            description='Specifies if participants are allowed to rename themselves in an instance of the meeting.'
        ),
    ] = None
    allow_recording: Annotated[
        Optional[bool],
        Field(description='Indicates whether recording is enabled for the meeting.'),
    ] = None
    allow_teamwork_reactions: Annotated[
        Optional[bool],
        Field(description='Indicates if Teams reactions are enabled for the meeting.'),
    ] = None
    allow_transcription: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether transcription is enabled for the meeting.'
        ),
    ] = None
    audio_conferencing: Annotated[
        Optional[Union[AudioConferencing, Dict[str, Any]]],
        Field(
            description='The phone access (dial-in) information for an online meeting. Read-only.'
        ),
    ] = None
    chat_info: Annotated[
        Optional[Union[ChatInfo, Dict[str, Any]]],
        Field(description='The chat information associated with this online meeting.'),
    ] = None
    chat_restrictions: Annotated[
        Optional[Union[ChatRestrictions, Dict[str, Any]]],
        Field(
            description='Specifies the configuration settings for meeting chat restrictions.'
        ),
    ] = None
    is_entry_exit_announced: Annotated[
        Optional[bool],
        Field(description='Indicates whether to announce when callers join or leave.'),
    ] = None
    join_information: Annotated[
        Optional[Union[ItemBody, Dict[str, Any]]],
        Field(
            description="The join information in the language and locale variant specified in 'Accept-Language' request HTTP header. Read-only."
        ),
    ] = None
    join_meeting_id_settings: Annotated[
        Optional[Union[JoinMeetingIdSettings, Dict[str, Any]]],
        Field(
            description="Specifies the joinMeetingId, the meeting passcode, and the requirement for the passcode. Once an onlineMeeting is created, the joinMeetingIdSettings can't be modified. To make any changes to this property, you must cancel this meeting and create a new one."
        ),
    ] = None
    join_web_url: Annotated[
        Optional[str],
        Field(description='The join URL of the online meeting. Read-only.'),
    ] = None
    lobby_bypass_settings: Annotated[
        Optional[Union[LobbyBypassSettings, Dict[str, Any]]],
        Field(description='Specifies which participants can bypass the meeting lobby.'),
    ] = None
    record_automatically: Annotated[
        Optional[bool],
        Field(description='Indicates whether to record the meeting automatically.'),
    ] = None
    share_meeting_chat_history_default: Annotated[
        Optional[Union[MeetingChatHistoryDefaultMode, Dict[str, Any]]],
        Field(
            description='Specifies whether meeting chat history is shared with participants.  Possible values are: all, none, unknownFutureValue.'
        ),
    ] = None
    subject: Annotated[
        Optional[str], Field(description='The subject of the online meeting.')
    ] = None
    video_teleconference_id: Annotated[
        Optional[str], Field(description='The video teleconferencing ID. Read-only.')
    ] = None
    watermark_protection: Annotated[
        Optional[Union[WatermarkProtectionValues, Dict[str, Any]]],
        Field(
            description='Specifies whether the client application should apply a watermark to a content type.'
        ),
    ] = None
    attendance_reports: Annotated[
        Optional[List[MeetingAttendanceReport]],
        Field(description='The attendance reports of an online meeting. Read-only.'),
    ] = None
    field_odata_type: str


class OnPremisesDirectorySynchronization(Entity):
    configuration: Annotated[
        Optional[
            Union[OnPremisesDirectorySynchronizationConfiguration, Dict[str, Any]]
        ],
        Field(
            description='Consists of configurations that can be fine-tuned and impact the on-premises directory synchronization process for a tenant. Nullable.'
        ),
    ] = None
    features: Optional[OnPremisesDirectorySynchronizationFeature] = None
    field_odata_type: str


class OnTokenIssuanceStartCustomExtension(CustomAuthenticationExtension):
    claims_for_token_configuration: Annotated[
        Optional[List[OnTokenIssuanceStartReturnClaim]],
        Field(
            description='Collection of claims to be returned by the API called by this custom authentication extension. Used to populate claims mapping experience in Microsoft Entra admin center. Optional.'
        ),
    ] = None
    field_odata_type: str


class OnTokenIssuanceStartListener(AuthenticationEventListener):
    handler: Annotated[
        Optional[Union[OnTokenIssuanceStartHandler, Dict[str, Any]]],
        Field(
            description='The handler to invoke when conditions are met for this onTokenIssuanceStartListener.'
        ),
    ] = None
    field_odata_type: str


class OnUserCreateStartListener(AuthenticationEventListener):
    handler: Annotated[
        Optional[Union[OnUserCreateStartHandler, Dict[str, Any]]],
        Field(
            description='Required. Configuration for what to invoke if the event resolves to this listener. This lets us define potential handler configurations per-event.'
        ),
    ] = None
    field_odata_type: str


class OpenShiftChangeRequest(ScheduleChangeRequest):
    open_shift_id: Annotated[
        Optional[str], Field(description='ID for the open shift.')
    ] = None
    field_odata_type: str


class OrganizationalBrandingProperties(Entity):
    background_color: Annotated[
        Optional[str],
        Field(
            description='Color that appears in place of the background image in low-bandwidth connections. We recommend that you use the primary color of your banner logo or your organization color. Specify this in hexadecimal format, for example, white is #FFFFFF.'
        ),
    ] = None
    background_image: Annotated[
        Optional[str],
        Field(
            description='Image that appears as the background of the sign-in page. The allowed types are PNG or JPEG not smaller than 300 KB and not larger than 1920  1080 pixels. A smaller image reduces bandwidth requirements and make the page load faster.'
        ),
    ] = None
    background_image_relative_url: Annotated[
        Optional[str],
        Field(
            description='A relative URL for the backgroundImage property that is combined with a CDN base URL from the cdnList to provide the version served by a CDN. Read-only.'
        ),
    ] = None
    banner_logo: Annotated[
        Optional[str],
        Field(
            description='A banner version of your company logo that appears on the sign-in page. The allowed types are PNG or JPEG not larger than 36  245 pixels. We recommend using a transparent image with no padding around the logo.'
        ),
    ] = None
    banner_logo_relative_url: Annotated[
        Optional[str],
        Field(
            description='A relative URL for the bannerLogo property that is combined with a CDN base URL from the cdnList to provide the read-only version served by a CDN. Read-only.'
        ),
    ] = None
    cdn_list: Annotated[
        Optional[List[str]],
        Field(
            description='A list of base URLs for all available CDN providers that are serving the assets of the current resource. Several CDN providers are used at the same time for high availability of read requests. Read-only.'
        ),
    ] = None
    content_customization: Annotated[
        Optional[Union[ContentCustomization, Dict[str, Any]]],
        Field(
            description='Represents the content options to be customized throughout the authentication flow for a tenant. NOTE: Supported by Microsoft Entra External ID in external tenants only.'
        ),
    ] = None
    custom_account_reset_credentials_url: Annotated[
        Optional[str],
        Field(
            description='A custom URL for resetting account credentials. This URL must be in ASCII format or non-ASCII characters must be URL encoded, and not exceed 128 characters.'
        ),
    ] = None
    custom_cannot_access_your_account_text: Annotated[
        Optional[str],
        Field(
            description="A string to replace the default 'Can't access your account?' self-service password reset (SSPR) hyperlink text on the sign-in page. This text must be in Unicode format and not exceed 256 characters."
        ),
    ] = None
    custom_cannot_access_your_account_url: Annotated[
        Optional[str],
        Field(
            description="A custom URL to replace the default URL of the self-service password reset (SSPR) 'Can't access your account?' hyperlink on the sign-in page. This URL must be in ASCII format or non-ASCII characters must be URL encoded, and not exceed 128 characters. DO NOT USE. Use customAccountResetCredentialsUrl instead."
        ),
    ] = None
    custom_css: Annotated[
        Optional[str],
        Field(
            description='CSS styling that appears on the sign-in page. The allowed format is .css format only and not larger than 25 KB.'
        ),
    ] = None
    custom_css_relative_url: Annotated[
        Optional[str],
        Field(
            description='A relative URL for the customCSS property that is combined with a CDN base URL from the cdnList to provide the version served by a CDN. Read-only.'
        ),
    ] = None
    custom_forgot_my_password_text: Annotated[
        Optional[str],
        Field(
            description="A string to replace the default 'Forgot my password' hyperlink text on the sign-in form. This text must be in Unicode format and not exceed 256 characters."
        ),
    ] = None
    custom_privacy_and_cookies_text: Annotated[
        Optional[str],
        Field(
            description="A string to replace the default 'Privacy and Cookies' hyperlink text in the footer. This text must be in Unicode format and not exceed 256 characters."
        ),
    ] = None
    custom_privacy_and_cookies_url: Annotated[
        Optional[str],
        Field(
            description="A custom URL to replace the default URL of the 'Privacy and Cookies' hyperlink in the footer. This URL must be in ASCII format or non-ASCII characters must be URL encoded, and not exceed 128 characters."
        ),
    ] = None
    custom_reset_it_now_text: Annotated[
        Optional[str],
        Field(
            description="A string to replace the default 'reset it now' hyperlink text on the sign-in form. This text must be in Unicode format and not exceed 256 characters. DO NOT USE: Customization of the 'reset it now' hyperlink text is currently not supported."
        ),
    ] = None
    custom_terms_of_use_text: Annotated[
        Optional[str],
        Field(
            description="A string to replace the the default 'Terms of Use' hyperlink text in the footer. This text must be in Unicode format and not exceed 256 characters."
        ),
    ] = None
    custom_terms_of_use_url: Annotated[
        Optional[str],
        Field(
            description="A custom URL to replace the default URL of the 'Terms of Use' hyperlink in the footer. This URL must be in ASCII format or non-ASCII characters must be URL encoded, and not exceed 128characters."
        ),
    ] = None
    favicon: Annotated[
        Optional[str],
        Field(
            description='A custom icon (favicon) to replace a default Microsoft product favicon on a Microsoft Entra tenant.'
        ),
    ] = None
    favicon_relative_url: Annotated[
        Optional[str],
        Field(
            description='A relative url for the favicon above that is combined with a CDN base URL from the cdnList to provide the version served by a CDN. Read-only.'
        ),
    ] = None
    header_background_color: Annotated[
        Optional[str],
        Field(
            description='The RGB color to apply to customize the color of the header.'
        ),
    ] = None
    header_logo: Annotated[
        Optional[str],
        Field(
            description='A company logo that appears in the header of the sign-in page. The allowed types are PNG or JPEG not larger than 36  245 pixels. We recommend using a transparent image with no padding around the logo.'
        ),
    ] = None
    header_logo_relative_url: Annotated[
        Optional[str],
        Field(
            description='A relative URL for the headerLogo property that is combined with a CDN base URL from the cdnList to provide the read-only version served by a CDN. Read-only.'
        ),
    ] = None
    login_page_layout_configuration: Annotated[
        Optional[Union[LoginPageLayoutConfiguration, Dict[str, Any]]],
        Field(
            description='Represents the layout configuration to be displayed on the login page for a tenant.'
        ),
    ] = None
    login_page_text_visibility_settings: Annotated[
        Optional[Union[LoginPageTextVisibilitySettings, Dict[str, Any]]],
        Field(
            description='Represents the various texts that can be hidden on the login page for a tenant.'
        ),
    ] = None
    sign_in_page_text: Annotated[
        Optional[str],
        Field(
            description='Text that appears at the bottom of the sign-in box. Use this to communicate additional information, such as the phone number to your help desk or a legal statement. This text must be in Unicode format and not exceed 1024 characters.'
        ),
    ] = None
    square_logo: Annotated[
        Optional[str],
        Field(
            description='A square version of your company logo that appears in Windows 10 out-of-box experiences (OOBE) and when Windows Autopilot is enabled for deployment. Allowed types are PNG or JPEG not larger than 240 x 240 pixels and not more than 10 KB in size. We recommend using a transparent image with no padding around the logo.'
        ),
    ] = None
    square_logo_dark: Annotated[
        Optional[str],
        Field(
            description='A square dark version of your company logo that appears in Windows 10 out-of-box experiences (OOBE) and when Windows Autopilot is enabled for deployment. Allowed types are PNG or JPEG not larger than 240 x 240 pixels and not more than 10 KB in size. We recommend using a transparent image with no padding around the logo.'
        ),
    ] = None
    square_logo_dark_relative_url: Annotated[
        Optional[str],
        Field(
            description='A relative URL for the squareLogoDark property that is combined with a CDN base URL from the cdnList to provide the version served by a CDN. Read-only.'
        ),
    ] = None
    square_logo_relative_url: Annotated[
        Optional[str],
        Field(
            description='A relative URL for the squareLogo property that is combined with a CDN base URL from the cdnList to provide the version served by a CDN. Read-only.'
        ),
    ] = None
    username_hint_text: Annotated[
        Optional[str],
        Field(
            description="A string that shows as the hint in the username textbox on the sign-in screen. This text must be a Unicode, without links or code, and can't exceed 64 characters."
        ),
    ] = None
    field_odata_type: str


class OrgContact(DirectoryObject):
    addresses: Annotated[
        Optional[List[PhysicalOfficeAddress]],
        Field(
            description='Postal addresses for this organizational contact. For now a contact can only have one physical address.'
        ),
    ] = None
    company_name: Annotated[
        Optional[str],
        Field(
            description='Name of the company that this organizational contact belongs to.  Supports $filter (eq, ne, not, ge, le, in, startsWith, and eq for null values).'
        ),
    ] = None
    department: Annotated[
        Optional[str],
        Field(
            description='The name for the department in which the contact works.  Supports $filter (eq, ne, not, ge, le, in, startsWith, and eq for null values).'
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='Display name for this organizational contact. Maximum length is 256 characters. Supports $filter (eq, ne, not, ge, le, in, startsWith, and eq for null values), $search, and $orderby.'
        ),
    ] = None
    given_name: Annotated[
        Optional[str],
        Field(
            description='First name for this organizational contact. Supports $filter (eq, ne, not, ge, le, in, startsWith, and eq for null values).'
        ),
    ] = None
    job_title: Annotated[
        Optional[str],
        Field(
            description='Job title for this organizational contact. Supports $filter (eq, ne, not, ge, le, in, startsWith, and eq for null values).'
        ),
    ] = None
    mail: Annotated[
        Optional[str],
        Field(
            description="The SMTP address for the contact, for example, 'jeff@contoso.com'. Supports $filter (eq, ne, not, ge, le, in, startsWith, and eq for null values)."
        ),
    ] = None
    mail_nickname: Annotated[
        Optional[str],
        Field(
            description='Email alias (portion of email address pre-pending the @ symbol) for this organizational contact. Supports $filter (eq, ne, not, ge, le, in, startsWith, and eq for null values).'
        ),
    ] = None
    on_premises_last_sync_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when this organizational contact was last synchronized from on-premises AD. This date and time information uses ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Supports $filter (eq, ne, not, ge, le, in).',
        ),
    ] = None
    on_premises_provisioning_errors: Annotated[
        Optional[List[OnPremisesProvisioningError]],
        Field(
            description='List of any synchronization provisioning errors for this organizational contact. Supports $filter (eq, not for category and propertyCausingError), /$count eq 0, /$count ne 0.'
        ),
    ] = None
    on_premises_sync_enabled: Annotated[
        Optional[bool],
        Field(
            description='true if this object is synced from an on-premises directory; false if this object was originally synced from an on-premises directory but is no longer synced and now mastered in Exchange; null if this object has never been synced from an on-premises directory (default).   Supports $filter (eq, ne, not, in, and eq for null values).'
        ),
    ] = None
    phones: Annotated[
        Optional[List[Phone]],
        Field(
            description='List of phones for this organizational contact. Phone types can be mobile, business, and businessFax. Only one of each type can ever be present in the collection.'
        ),
    ] = None
    proxy_addresses: Annotated[
        Optional[List[str]],
        Field(
            description="For example: 'SMTP: bob@contoso.com', 'smtp: bob@sales.contoso.com'. The any operator is required for filter expressions on multi-valued properties. Supports $filter (eq, not, ge, le, startsWith, /$count eq 0, /$count ne 0)."
        ),
    ] = None
    service_provisioning_errors: Annotated[
        Optional[List[ServiceProvisioningError]],
        Field(
            description='Errors published by a federated service describing a non-transient, service-specific error regarding the properties or link from an organizational contact object .  Supports $filter (eq, not, for isResolved and serviceInstance).'
        ),
    ] = None
    surname: Annotated[
        Optional[str],
        Field(
            description='Last name for this organizational contact. Supports $filter (eq, ne, not, ge, le, in, startsWith, and eq for null values).'
        ),
    ] = None
    direct_reports: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description="The contact's direct reports. (The users and contacts that have their manager property set to this contact.)  Read-only. Nullable. Supports $expand."
        ),
    ] = None
    manager: Annotated[
        Optional[Union[DirectoryObject, Dict[str, Any]]],
        Field(
            description="The user or contact that is this contact's manager. Read-only. Supports $expand and $filter (eq) by id."
        ),
    ] = None
    member_of: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description='Groups that this contact is a member of. Read-only. Nullable. Supports $expand.'
        ),
    ] = None
    transitive_member_of: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description='Groups that this contact is a member of, including groups that the contact is nested under. Read-only. Nullable.'
        ),
    ] = None
    field_odata_type: str


class Participant(Entity):
    info: Optional[ParticipantInfo] = None
    is_in_lobby: Annotated[
        Optional[bool], Field(description='true if the participant is in lobby.')
    ] = None
    is_muted: Annotated[
        Optional[bool],
        Field(description='true if the participant is muted (client or server muted).'),
    ] = None
    media_streams: Annotated[
        Optional[List[MediaStream]], Field(description='The list of media streams.')
    ] = None
    metadata: Annotated[
        Optional[str],
        Field(description='A blob of data provided by the participant in the roster.'),
    ] = None
    recording_info: Annotated[
        Optional[Union[RecordingInfo, Dict[str, Any]]],
        Field(
            description='Information about whether the participant has recording capability.'
        ),
    ] = None
    removed_state: Annotated[
        Optional[Union[RemovedState, Dict[str, Any]]],
        Field(
            description='Indicates the reason why the participant was removed from the roster.'
        ),
    ] = None
    restricted_experience: Annotated[
        Optional[Union[OnlineMeetingRestricted, Dict[str, Any]]],
        Field(
            description='Indicates the reason or reasons media content from this participant is restricted.'
        ),
    ] = None
    roster_sequence_number: Annotated[
        Optional[float],
        Field(
            description='Indicates the roster sequence number in which the participant was last updated.'
        ),
    ] = None
    field_odata_type: str


class Payload(Entity):
    brand: Annotated[
        Optional[Union[PayloadBrand, Dict[str, Any]]],
        Field(
            description='The branch of a payload. Possible values are: unknown, other, americanExpress, capitalOne, dhl, docuSign, dropbox, facebook, firstAmerican, microsoft, netflix, scotiabank, sendGrid, stewartTitle, tesco, wellsFargo, syrinxCloud, adobe, teams, zoom, unknownFutureValue.'
        ),
    ] = None
    complexity: Annotated[
        Optional[Union[PayloadComplexity, Dict[str, Any]]],
        Field(
            description='The complexity of a payload. Possible values are: unknown, low, medium, high, unknownFutureValue.'
        ),
    ] = None
    created_by: Annotated[
        Optional[Union[EmailIdentity, Dict[str, Any]]],
        Field(
            description='Identity of the user who created the attack simulation and training campaign payload.'
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when the attack simulation and training campaign payload. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='Description of the attack simulation and training campaign payload.'
        ),
    ] = None
    detail: Annotated[
        Optional[Union[PayloadDetail, Dict[str, Any]]],
        Field(description='Additional details about the payload.'),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='Display name of the attack simulation and training campaign payload. Supports $filter and $orderby.'
        ),
    ] = None
    industry: Annotated[
        Optional[Union[PayloadIndustry, Dict[str, Any]]],
        Field(
            description='Industry of a payload. Possible values are: unknown, other, banking, businessServices, consumerServices, education, energy, construction, consulting, financialServices, government, hospitality, insurance, legal, courierServices, IT, healthcare, manufacturing, retail, telecom, realEstate, unknownFutureValue.'
        ),
    ] = None
    is_automated: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the attack simulation and training campaign payload was created from an automation flow. Supports $filter and $orderby.'
        ),
    ] = None
    is_controversial: Annotated[
        Optional[bool],
        Field(description='Indicates whether the payload is controversial.'),
    ] = None
    is_current_event: Annotated[
        Optional[bool],
        Field(description='Indicates whether the payload is from any recent event.'),
    ] = None
    language: Annotated[Optional[str], Field(description='Payload language.')] = None
    last_modified_by: Annotated[
        Optional[Union[EmailIdentity, Dict[str, Any]]],
        Field(
            description='Identity of the user who most recently modified the attack simulation and training campaign payload.'
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when the attack simulation and training campaign payload was last modified. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    payload_tags: Annotated[
        Optional[List[str]], Field(description='Free text tags for a payload.')
    ] = None
    platform: Annotated[
        Optional[Union[PayloadDeliveryPlatform, Dict[str, Any]]],
        Field(
            description='The payload delivery platform for a simulation. Possible values are: unknown, sms, email, teams, unknownFutureValue.'
        ),
    ] = None
    predicted_compromise_rate: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='Predicted probability for a payload to phish a targeted user.'
        ),
    ] = None
    simulation_attack_type: Annotated[
        Optional[Union[SimulationAttackType, Dict[str, Any]]],
        Field(
            description='Attack type of the attack simulation and training campaign. Supports $filter and $orderby. Possible values are: unknown, social, cloud, endpoint, unknownFutureValue.'
        ),
    ] = None
    source: Optional[SimulationContentSource] = None
    status: Annotated[
        Optional[Union[SimulationContentStatus, Dict[str, Any]]],
        Field(
            description='Simulation content status. Supports $filter and $orderby. Possible values are: unknown, draft, ready, archive, delete, unknownFutureValue.'
        ),
    ] = None
    technique: Annotated[
        Optional[Union[SimulationAttackTechnique, Dict[str, Any]]],
        Field(
            description='The social engineering technique used in the attack simulation and training campaign. Supports $filter and $orderby. Possible values are: unknown, credentialHarvesting, attachmentMalware, driveByUrl, linkInAttachment, linkToMalwareFile, unknownFutureValue, oAuthConsentGrant. Use the Prefer: include-unknown-enum-members request header to get the following values from this evolvable enum: oAuthConsentGrant. For more information on the types of social engineering attack techniques, see simulations.'
        ),
    ] = None
    theme: Annotated[
        Optional[Union[PayloadTheme, Dict[str, Any]]],
        Field(
            description='The theme of a payload. Possible values are: unknown, other, accountActivation, accountVerification, billing, cleanUpMail, controversial, documentReceived, expense, fax, financeReport, incomingMessages, invoice, itemReceived, loginAlert, mailReceived, password, payment, payroll, personalizedOffer, quarantine, remoteWork, reviewMessage, securityUpdate, serviceSuspended, signatureRequired, upgradeMailboxStorage, verifyMailbox, voicemail, advertisement, employeeEngagement, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class PeopleAdminSettings(Entity):
    item_insights: Annotated[
        Optional[Union[InsightsSettings, Dict[str, Any]]],
        Field(
            description='Represents administrator settings that manage the support for item insights in an organization.'
        ),
    ] = None
    profile_card_properties: Annotated[
        Optional[List[ProfileCardProperty]],
        Field(
            description='Contains a collection of the properties an administrator has defined as visible on the Microsoft 365 profile card.'
        ),
    ] = None
    pronouns: Annotated[
        Optional[Union[PronounsSettings, Dict[str, Any]]],
        Field(
            description='Represents administrator settings that manage the support of pronouns in an organization.'
        ),
    ] = None
    field_odata_type: str


class Permission(Entity):
    expiration_date_time: Annotated[
        Optional[datetime],
        Field(
            description="A format of yyyy-MM-ddTHH:mm:ssZ of DateTimeOffset indicates the expiration time of the permission. DateTime.MinValue indicates there's no expiration set for this permission. Optional.",
        ),
    ] = None
    granted_to: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(
            description='For user type permissions, the details of the users and applications for this permission. Read-only.'
        ),
    ] = None
    granted_to_identities: Annotated[
        Optional[List[IdentitySet]],
        Field(
            description='For type permissions, the details of the users to whom permission was granted. Read-only.'
        ),
    ] = None
    granted_to_identities_v2: Annotated[
        Optional[List[SharePointIdentitySet]],
        Field(
            description='For link type permissions, the details of the users to whom permission was granted. Read-only.'
        ),
    ] = None
    granted_to_v2: Annotated[
        Optional[Union[SharePointIdentitySet, Dict[str, Any]]],
        Field(
            description='For user type permissions, the details of the users and applications for this permission. Read-only.'
        ),
    ] = None
    has_password: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the password is set for this permission. This property only appears in the response. Optional. Read-only. For OneDrive Personal only..'
        ),
    ] = None
    inherited_from: Annotated[
        Optional[Union[ItemReference, Dict[str, Any]]],
        Field(
            description="Provides a reference to the ancestor of the current permission, if it's inherited from an ancestor. Read-only."
        ),
    ] = None
    invitation: Annotated[
        Optional[Union[SharingInvitation, Dict[str, Any]]],
        Field(
            description='Details of any associated sharing invitation for this permission. Read-only.'
        ),
    ] = None
    link: Annotated[
        Optional[Union[SharingLink, Dict[str, Any]]],
        Field(
            description="Provides the link details of the current permission, if it's a link type permission. Read-only."
        ),
    ] = None
    roles: Annotated[
        Optional[List[str]],
        Field(
            description='The type of permission, for example, read. See below for the full list of roles. Read-only.'
        ),
    ] = None
    share_id: Annotated[
        Optional[str],
        Field(
            description='A unique token that can be used to access this shared item via the shares API. Read-only.'
        ),
    ] = None
    field_odata_type: str


class PermissionGrantPolicy(PolicyBase):
    excludes: Annotated[
        Optional[List[PermissionGrantConditionSet]],
        Field(
            description='Condition sets that are excluded in this permission grant policy. Automatically expanded on GET.'
        ),
    ] = None
    includes: Annotated[
        Optional[List[PermissionGrantConditionSet]],
        Field(
            description='Condition sets that are included in this permission grant policy. Automatically expanded on GET.'
        ),
    ] = None
    field_odata_type: str


class Place(Entity):
    address: Annotated[
        Optional[Union[PhysicalAddress, Dict[str, Any]]],
        Field(description='The street address of the place.'),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The name associated with the place.')
    ] = None
    geo_coordinates: Annotated[
        Optional[Union[OutlookGeoCoordinates, Dict[str, Any]]],
        Field(
            description='Specifies the place location in latitude, longitude, and (optionally) altitude coordinates.'
        ),
    ] = None
    phone: Annotated[
        Optional[str], Field(description='The phone number of the place.')
    ] = None
    field_odata_type: str


class PlannerTask(Entity):
    active_checklist_item_count: Annotated[
        Optional[float],
        Field(
            description='Number of checklist items with value set to false, representing incomplete items.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    applied_categories: Annotated[
        Optional[Union[PlannerAppliedCategories, Dict[str, Any]]],
        Field(
            description='The categories to which the task has been applied. See applied Categories for possible values.'
        ),
    ] = None
    assignee_priority: Annotated[
        Optional[str],
        Field(
            description='Hint used to order items of this type in a list view. The format is defined as outlined here.'
        ),
    ] = None
    assignments: Annotated[
        Optional[Union[PlannerAssignments, Dict[str, Any]]],
        Field(description='The set of assignees the task is assigned to.'),
    ] = None
    bucket_id: Annotated[
        Optional[str],
        Field(
            description="Bucket ID to which the task belongs. The bucket needs to be in the plan that the task is in. It's 28 characters long and case-sensitive. Format validation is done on the service."
        ),
    ] = None
    checklist_item_count: Annotated[
        Optional[float],
        Field(
            description='Number of checklist items that are present on the task.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    completed_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Identity of the user that completed the task.'),
    ] = None
    completed_date_time: Annotated[
        Optional[datetime],
        Field(
            description="Read-only. Date and time at which the 'percentComplete' of the task is set to '100'. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z",
        ),
    ] = None
    conversation_thread_id: Annotated[
        Optional[str],
        Field(
            description='Thread ID of the conversation on the task. This is the ID of the conversation thread object created in the group.'
        ),
    ] = None
    created_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Identity of the user that created the task.'),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Read-only. Date and time at which the task is created. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z',
        ),
    ] = None
    due_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time at which the task is due. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z',
        ),
    ] = None
    has_description: Annotated[
        Optional[bool],
        Field(
            description='Read-only. Value is true if the details object of the task has a nonempty description and false otherwise.'
        ),
    ] = None
    order_hint: Annotated[
        Optional[str],
        Field(
            description='Hint used to order items of this type in a list view. The format is defined as outlined here.'
        ),
    ] = None
    percent_complete: Annotated[
        Optional[float],
        Field(
            description='Percentage of task completion. When set to 100, the task is considered completed.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    plan_id: Annotated[
        Optional[str], Field(description='Plan ID to which the task belongs.')
    ] = None
    preview_type: Annotated[
        Optional[Union[PlannerPreviewType, Dict[str, Any]]],
        Field(
            description='This sets the type of preview that shows up on the task. The possible values are: automatic, noPreview, checklist, description, reference.'
        ),
    ] = None
    priority: Annotated[
        Optional[float],
        Field(
            description="Priority of the task. The valid range of values is between 0 and 10, with the increasing value being lower priority (0 has the highest priority and 10 has the lowest priority).  Currently, Planner interprets values 0 and 1 as 'urgent', 2, 3 and 4 as 'important', 5, 6, and 7 as 'medium', and 8, 9, and 10 as 'low'.  Additionally, Planner sets the value 1 for 'urgent', 3 for 'important', 5 for 'medium', and 9 for 'low'.",
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    reference_count: Annotated[
        Optional[float],
        Field(
            description='Number of external references that exist on the task.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    start_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time at which the task starts. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z',
        ),
    ] = None
    title: Annotated[Optional[str], Field(description='Title of the task.')] = None
    assigned_to_task_board_format: Annotated[
        Optional[Union[PlannerAssignedToTaskBoardTaskFormat, Dict[str, Any]]],
        Field(
            description='Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.'
        ),
    ] = None
    bucket_task_board_format: Annotated[
        Optional[Union[PlannerBucketTaskBoardTaskFormat, Dict[str, Any]]],
        Field(
            description='Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.'
        ),
    ] = None
    details: Annotated[
        Optional[Union[PlannerTaskDetails, Dict[str, Any]]],
        Field(description='Read-only. Nullable. More details about the task.'),
    ] = None
    progress_task_board_format: Annotated[
        Optional[Union[PlannerProgressTaskBoardTaskFormat, Dict[str, Any]]],
        Field(
            description='Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.'
        ),
    ] = None
    field_odata_type: str


class Post(OutlookItem):
    body: Annotated[
        Optional[Union[ItemBody, Dict[str, Any]]],
        Field(
            description='The contents of the post. This is a default property. This property can be null.'
        ),
    ] = None
    conversation_id: Annotated[
        Optional[str], Field(description='Unique ID of the conversation. Read-only.')
    ] = None
    conversation_thread_id: Annotated[
        Optional[str],
        Field(description='Unique ID of the conversation thread. Read-only.'),
    ] = None
    from_: Optional[Recipient] = None
    has_attachments: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the post has at least one attachment. This is a default property.'
        ),
    ] = None
    new_participants: Annotated[
        Optional[List[Recipient]],
        Field(
            description='Conversation participants that were added to the thread as part of this post.'
        ),
    ] = None
    received_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Specifies when the post was received. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z',
        ),
    ] = None
    sender: Annotated[
        Optional[Union[Recipient, Dict[str, Any]]],
        Field(
            description='Contains the address of the sender. The value of Sender is assumed to be the address of the authenticated user in the case when Sender is not specified. This is a default property.'
        ),
    ] = None
    attachments: Annotated[
        Optional[List[Attachment]],
        Field(description='Read-only. Nullable. Supports $expand.'),
    ] = None
    extensions: Annotated[
        Optional[List[Extension]],
        Field(
            description='The collection of open extensions defined for the post. Read-only. Nullable. Supports $expand.'
        ),
    ] = None
    in_reply_to: Annotated[
        Optional[Union[Post, Dict[str, Any]]],
        Field(description='Read-only. Supports $expand.'),
    ] = None
    multi_value_extended_properties: Annotated[
        Optional[List[MultiValueLegacyExtendedProperty]],
        Field(
            description='The collection of multi-value extended properties defined for the post. Read-only. Nullable.'
        ),
    ] = None
    single_value_extended_properties: Annotated[
        Optional[List[SingleValueLegacyExtendedProperty]],
        Field(
            description='The collection of single-value extended properties defined for the post. Read-only. Nullable.'
        ),
    ] = None
    field_odata_type: str


class Presence(Entity):
    activity: Annotated[
        Optional[str],
        Field(
            description="The supplemental information to a user's availability. Possible values are Available, Away, BeRightBack, Busy, DoNotDisturb, InACall, InAConferenceCall, Inactive, InAMeeting, Offline, OffWork, OutOfOffice, PresenceUnknown, Presenting, UrgentInterruptionsOnly."
        ),
    ] = None
    availability: Annotated[
        Optional[str],
        Field(
            description='The base presence information for a user. Possible values are Available, AvailableIdle,  Away, BeRightBack, Busy, BusyIdle, DoNotDisturb, Offline, PresenceUnknown'
        ),
    ] = None
    status_message: Annotated[
        Optional[Union[PresenceStatusMessage, Dict[str, Any]]],
        Field(description='The presence status message of a user.'),
    ] = None
    field_odata_type: str


class PrintConnector(Entity):
    app_version: Annotated[
        Optional[str], Field(description="The connector's version.")
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The name of the connector.')
    ] = None
    fully_qualified_domain_name: Annotated[
        Optional[str], Field(description="The connector machine's hostname.")
    ] = None
    location: Annotated[
        Optional[Union[PrinterLocation, Dict[str, Any]]],
        Field(
            description='The physical and/or organizational location of the connector.'
        ),
    ] = None
    operating_system: Annotated[
        Optional[str],
        Field(description="The connector machine's operating system version."),
    ] = None
    registered_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The DateTimeOffset when the connector was registered.',
        ),
    ] = None
    field_odata_type: str


class PrintOperation(Entity):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The DateTimeOffset when the operation was created. Read-only.',
        ),
    ] = None
    status: Optional[PrintOperationStatus] = None
    field_odata_type: str


class ProtectionRuleBase(Entity):
    created_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='The identity of person who created the rule.'),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The time of creation of the rule.',
        ),
    ] = None
    error: Annotated[
        Optional[Union[PublicError, Dict[str, Any]]],
        Field(description='Contains error details if an operation on a rule fails.'),
    ] = None
    is_auto_apply_enabled: Annotated[
        Optional[bool],
        Field(
            description="true indicates that the protection rule is dynamic; false that it's static. Currently, only static rules are supported."
        ),
    ] = None
    last_modified_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='The identity of the person who last modified the rule.'),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Timestamp of the last modification made to the rule.',
        ),
    ] = None
    status: Annotated[
        Optional[Union[ProtectionRuleStatus, Dict[str, Any]]],
        Field(
            description='The status of the protection rule. The possible values are: draft, active, completed, completedWithErrors, unknownFutureValue. The draft member is currently unsupported.'
        ),
    ] = None
    field_odata_type: str


class ProtectionUnitBase(Entity):
    created_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='The identity of person who created the protection unit.'),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The time of creation of the protection unit.',
        ),
    ] = None
    error: Annotated[
        Optional[Union[PublicError, Dict[str, Any]]],
        Field(
            description='Contains error details if an error occurred while creating a protection unit.'
        ),
    ] = None
    last_modified_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(
            description='The identity of person who last modified the protection unit.'
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Timestamp of the last modification of this protection unit.',
        ),
    ] = None
    policy_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier of the protection policy based on which protection unit was created.'
        ),
    ] = None
    status: Annotated[
        Optional[Union[ProtectionUnitStatus, Dict[str, Any]]],
        Field(
            description='The status of the protection unit. The possible values are: protectRequested, protected, unprotectRequested, unprotected, removeRequested, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class ProvisioningObjectSummary(Entity):
    activity_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.  SUpports $filter (eq, gt, lt) and orderby.',
        ),
    ] = None
    change_id: Annotated[
        Optional[str],
        Field(
            description='Unique ID of this change in this cycle. Supports $filter (eq, contains).'
        ),
    ] = None
    cycle_id: Annotated[
        Optional[str],
        Field(
            description='Unique ID per job iteration. Supports $filter (eq, contains).'
        ),
    ] = None
    duration_in_milliseconds: Annotated[
        Optional[float],
        Field(
            description='Indicates how long this provisioning action took to finish. Measured in milliseconds.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    initiated_by: Annotated[
        Optional[Union[Initiator, Dict[str, Any]]],
        Field(
            description='Details of who initiated this provisioning. Supports $filter (eq, contains).'
        ),
    ] = None
    job_id: Annotated[
        Optional[str],
        Field(
            description='The unique ID for the whole provisioning job. Supports $filter (eq, contains).'
        ),
    ] = None
    modified_properties: Annotated[
        Optional[List[ModifiedProperty]],
        Field(
            description='Details of each property that was modified in this provisioning action on this object.'
        ),
    ] = None
    provisioning_action: Annotated[
        Optional[Union[ProvisioningAction, Dict[str, Any]]],
        Field(
            description='Indicates the activity name or the operation name. Possible values are: create, update, delete, stageddelete, disable, other and unknownFutureValue. For a list of activities logged, refer to Microsoft Entra activity list. Supports $filter (eq, contains).'
        ),
    ] = None
    provisioning_status_info: Annotated[
        Optional[Union[ProvisioningStatusInfo, Dict[str, Any]]],
        Field(description='Details of provisioning status.'),
    ] = None
    provisioning_steps: Annotated[
        Optional[List[ProvisioningStep]],
        Field(description='Details of each step in provisioning.'),
    ] = None
    service_principal: Annotated[
        Optional[Union[ProvisioningServicePrincipal, Dict[str, Any]]],
        Field(
            description='Represents the service principal used for provisioning. Supports $filter (eq) for id and name.'
        ),
    ] = None
    source_identity: Annotated[
        Optional[Union[ProvisionedIdentity, Dict[str, Any]]],
        Field(
            description='Details of source object being provisioned. Supports $filter (eq, contains) for identityType, id, and displayName.'
        ),
    ] = None
    source_system: Annotated[
        Optional[Union[ProvisioningSystem, Dict[str, Any]]],
        Field(
            description='Details of source system of the object being provisioned. Supports $filter (eq, contains) for displayName.'
        ),
    ] = None
    target_identity: Annotated[
        Optional[Union[ProvisionedIdentity, Dict[str, Any]]],
        Field(
            description='Details of target object being provisioned. Supports $filter (eq, contains) for identityType, id, and displayName.'
        ),
    ] = None
    target_system: Annotated[
        Optional[Union[ProvisioningSystem, Dict[str, Any]]],
        Field(
            description='Details of target system of the object being provisioned. Supports $filter (eq, contains) for displayName.'
        ),
    ] = None
    tenant_id: Annotated[
        Optional[str],
        Field(
            description='Unique Microsoft Entra tenant ID. Supports $filter (eq, contains).'
        ),
    ] = None
    field_odata_type: str


class ResellerDelegatedAdminRelationship(DelegatedAdminRelationship):
    indirect_provider_tenant_id: Annotated[
        Optional[str],
        Field(
            description='The tenant ID of the indirect provider partner who created the relationship for the indirect reseller partner.'
        ),
    ] = None
    is_partner_consent_pending: Annotated[
        Optional[bool],
        Field(
            description='Indicates the indirect reseller partner consent status. true indicates that the partner has yet to review the relationship; false indicates that the partner has already provided consent by approving or rejecting the relationship.'
        ),
    ] = None
    field_odata_type: str


class RestorePoint(Entity):
    expiration_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Expiration date time of the restore point.',
        ),
    ] = None
    protection_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date time when the restore point was created.',
        ),
    ] = None
    tags: Annotated[
        Optional[Union[RestorePointTags, Dict[str, Any]]],
        Field(
            description='The type of the restore point. The possible values are: none, fastRestore, unknownFutureValue.'
        ),
    ] = None
    protection_unit: Annotated[
        Optional[Union[ProtectionUnitBase, Dict[str, Any]]],
        Field(
            description='The site, drive, or mailbox units that are protected under a protection policy.'
        ),
    ] = None
    field_odata_type: str


class RestoreSessionBase(Entity):
    completed_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The time of completion of the restore session.',
        ),
    ] = None
    created_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='The identity of person who created the restore session.'),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The time of creation of the restore session.',
        ),
    ] = None
    error: Annotated[
        Optional[Union[PublicError, Dict[str, Any]]],
        Field(
            description='Contains error details if the restore session fails or completes with an error.'
        ),
    ] = None
    last_modified_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(
            description='Identity of the person who last modified the restore session.'
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Timestamp of the last modification of the restore session.',
        ),
    ] = None
    status: Annotated[
        Optional[Union[RestoreSessionStatus, Dict[str, Any]]],
        Field(
            description='Status of the restore session. The value is an aggregated status of the restored artifacts. The possible values are: draft, activating, active, completedWithError, completed, unknownFutureValue, failed. Use the Prefer: include-unknown-enum-members request header to get the following value in this evolvable enum: failed.'
        ),
    ] = None
    field_odata_type: str


class RichLongRunningOperation(LongRunningOperation):
    error: Annotated[
        Optional[Union[PublicError, Dict[str, Any]]],
        Field(description='Error that caused the operation to fail.'),
    ] = None
    percentage_complete: Annotated[
        Optional[float],
        Field(
            description='A value between 0 and 100 that indicates the progress of the operation.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    resource_id: Annotated[
        Optional[str], Field(description='The unique identifier for the result.')
    ] = None
    type: Annotated[Optional[str], Field(description='The type of the operation.')] = (
        None
    )
    field_odata_type: str


class RiskDetection(Entity):
    activity: Annotated[
        Optional[Union[ActivityType, Dict[str, Any]]],
        Field(
            description='Indicates the activity type the detected risk is linked to. Possible values are: signin, user, unknownFutureValue.'
        ),
    ] = None
    activity_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time that the risky activity occurred. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is look like this: 2014-01-01T00:00:00Z',
        ),
    ] = None
    additional_info: Annotated[
        Optional[str],
        Field(
            description="Additional information associated with the risk detection in JSON format. For example, '[{/'Key/':/'userAgent/',/'Value/':/'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36/'}]'. Possible keys in the additionalInfo JSON string are: userAgent, alertUrl, relatedEventTimeInUtc, relatedUserAgent, deviceInformation, relatedLocation, requestId, correlationId, lastActivityTimeInUtc, malwareName, clientLocation, clientIp, riskReasons. For more information about riskReasons and possible values, see riskReasons values."
        ),
    ] = None
    correlation_id: Annotated[
        Optional[str],
        Field(
            description='Correlation ID of the sign-in associated with the risk detection. This property is null if the risk detection is not associated with a sign-in.'
        ),
    ] = None
    detected_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time that the risk was detected. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 looks like this: 2014-01-01T00:00:00Z',
        ),
    ] = None
    detection_timing_type: Annotated[
        Optional[Union[RiskDetectionTimingType, Dict[str, Any]]],
        Field(
            description='Timing of the detected risk (real-time/offline). Possible values are: notDefined, realtime, nearRealtime, offline, unknownFutureValue.'
        ),
    ] = None
    ip_address: Annotated[
        Optional[str],
        Field(
            description='Provides the IP address of the client from where the risk occurred.'
        ),
    ] = None
    last_updated_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time that the risk detection was last updated. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is look like this: 2014-01-01T00:00:00Z',
        ),
    ] = None
    location: Annotated[
        Optional[Union[SignInLocation, Dict[str, Any]]],
        Field(description='Location of the sign-in.'),
    ] = None
    request_id: Annotated[
        Optional[str],
        Field(
            description='Request ID of the sign-in associated with the risk detection. This property is null if the risk detection is not associated with a sign-in.'
        ),
    ] = None
    risk_detail: Annotated[
        Optional[Union[RiskDetail, Dict[str, Any]]],
        Field(
            description='Details of the detected risk. The possible values are: none, adminGeneratedTemporaryPassword, userChangedPasswordOnPremises, userPerformedSecuredPasswordChange, userPerformedSecuredPasswordReset, adminConfirmedSigninSafe, aiConfirmedSigninSafe, userPassedMFADrivenByRiskBasedPolicy, adminDismissedAllRiskForUser, adminConfirmedSigninCompromised, hidden, adminConfirmedUserCompromised, unknownFutureValue, m365DAdminDismissedDetection. Use the Prefer: include - unknown -enum-members request header to get the following value(s) in this evolvable enum: m365DAdminDismissedDetection.'
        ),
    ] = None
    risk_event_type: Annotated[
        Optional[str],
        Field(
            description='The type of risk event detected. The possible values are adminConfirmedUserCompromised, anomalousToken, anomalousUserActivity, anonymizedIPAddress, generic, impossibleTravel, investigationsThreatIntelligence, suspiciousSendingPatterns, leakedCredentials, maliciousIPAddress,malwareInfectedIPAddress, mcasSuspiciousInboxManipulationRules, newCountry, passwordSpray,riskyIPAddress, suspiciousAPITraffic, suspiciousBrowser,suspiciousInboxForwarding, suspiciousIPAddress, tokenIssuerAnomaly, unfamiliarFeatures, unlikelyTravel. If the risk detection is a premium detection, will show generic. For more information about each value, see Risk types and detection.'
        ),
    ] = None
    risk_level: Annotated[
        Optional[Union[RiskLevel, Dict[str, Any]]],
        Field(
            description='Level of the detected risk. Possible values are: low, medium, high, hidden, none, unknownFutureValue.'
        ),
    ] = None
    risk_state: Annotated[
        Optional[Union[RiskState, Dict[str, Any]]],
        Field(
            description='The state of a detected risky user or sign-in. Possible values are: none, confirmedSafe, remediated, dismissed, atRisk, confirmedCompromised, unknownFutureValue.'
        ),
    ] = None
    source: Annotated[
        Optional[str],
        Field(
            description='Source of the risk detection. For example, activeDirectory.'
        ),
    ] = None
    token_issuer_type: Annotated[
        Optional[Union[TokenIssuerType, Dict[str, Any]]],
        Field(
            description='Indicates the type of token issuer for the detected sign-in risk. Possible values are: AzureAD, ADFederationServices, UnknownFutureValue.'
        ),
    ] = None
    user_display_name: Annotated[
        Optional[str], Field(description='The user principal name (UPN) of the user.')
    ] = None
    user_id: Annotated[Optional[str], Field(description='Unique ID of the user.')] = (
        None
    )
    user_principal_name: Annotated[
        Optional[str], Field(description='The user principal name (UPN) of the user.')
    ] = None
    field_odata_type: str


class Room(Place):
    audio_device_name: Annotated[
        Optional[str],
        Field(description='Specifies the name of the audio device in the room.'),
    ] = None
    booking_type: Annotated[
        Optional[Union[BookingType, Dict[str, Any]]],
        Field(description='Type of room. Possible values are standard, and reserved.'),
    ] = None
    building: Annotated[
        Optional[str],
        Field(
            description='Specifies the building name or building number that the room is in.'
        ),
    ] = None
    capacity: Annotated[
        Optional[float],
        Field(
            description='Specifies the capacity of the room.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    display_device_name: Annotated[
        Optional[str],
        Field(description='Specifies the name of the display device in the room.'),
    ] = None
    email_address: Annotated[
        Optional[str], Field(description='Email address of the room.')
    ] = None
    floor_label: Annotated[
        Optional[str],
        Field(
            description='Specifies a descriptive label for the floor, for example, P.'
        ),
    ] = None
    floor_number: Annotated[
        Optional[float],
        Field(
            description='Specifies the floor number that the room is on.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    is_wheel_chair_accessible: Annotated[
        Optional[bool],
        Field(description='Specifies whether the room is wheelchair accessible.'),
    ] = None
    label: Annotated[
        Optional[str],
        Field(
            description='Specifies a descriptive label for the room, for example, a number or name.'
        ),
    ] = None
    nickname: Annotated[
        Optional[str],
        Field(
            description="Specifies a nickname for the room, for example, 'conf room'."
        ),
    ] = None
    tags: Annotated[
        Optional[List[str]],
        Field(
            description='Specifies other features of the room, for example, details like the type of view or furniture type.'
        ),
    ] = None
    video_device_name: Annotated[
        Optional[str],
        Field(description='Specifies the name of the video device in the room.'),
    ] = None
    field_odata_type: str


class RoomList(Place):
    email_address: Annotated[
        Optional[str], Field(description='The email address of the room list.')
    ] = None
    rooms: Optional[List[Room]] = None
    field_odata_type: str


class SamlOrWsFedExternalDomainFederation(SamlOrWsFedProvider):
    domains: Annotated[
        Optional[List[ExternalDomainName]],
        Field(
            description='Collection of domain names of the external organizations that the tenant is federating with. Supports $filter (eq).'
        ),
    ] = None
    field_odata_type: str


class SecureScore(Entity):
    active_user_count: Annotated[
        Optional[float],
        Field(
            description='Active user count of the given tenant.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    average_comparative_scores: Annotated[
        Optional[List[AverageComparativeScore]],
        Field(
            description='Average score by different scopes (for example, average by industry, average by seating) and control category (Identity, Data, Device, Apps, Infrastructure) within the scope.'
        ),
    ] = None
    azure_tenant_id: Annotated[
        Optional[str], Field(description='GUID string for tenant ID.')
    ] = None
    control_scores: Annotated[
        Optional[List[ControlScore]],
        Field(description='Contains tenant scores for a set of controls.'),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='When the report was created.',
        ),
    ] = None
    current_score: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='Tenant current attained score on specified date.'),
    ] = None
    enabled_services: Annotated[
        Optional[List[str]],
        Field(
            description='Microsoft-provided services for the tenant (for example, Exchange online, Skype, Sharepoint).'
        ),
    ] = None
    licensed_user_count: Annotated[
        Optional[float],
        Field(
            description='Licensed user count of the given tenant.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    max_score: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='Tenant maximum possible score on specified date.'),
    ] = None
    vendor_information: Annotated[
        Optional[Union[SecurityVendorInformation, Dict[str, Any]]],
        Field(
            description='Complex type containing details about the security product/service vendor, provider, and subprovider (for example, vendor=Microsoft; provider=SecureScore). Required.'
        ),
    ] = None
    field_odata_type: str


class ServiceHealthIssue(ServiceAnnouncementBase):
    classification: Optional[ServiceHealthClassificationType] = None
    feature: Annotated[
        Optional[str], Field(description='The feature name of the service issue.')
    ] = None
    feature_group: Annotated[
        Optional[str], Field(description='The feature group name of the service issue.')
    ] = None
    impact_description: Annotated[
        Optional[str], Field(description='The description of the service issue impact.')
    ] = None
    is_resolved: Annotated[
        Optional[bool], Field(description='Indicates whether the issue is resolved.')
    ] = None
    origin: Optional[ServiceHealthOrigin] = None
    posts: Annotated[
        Optional[List[ServiceHealthIssuePost]],
        Field(description='Collection of historical posts for the service issue.'),
    ] = None
    service: Annotated[
        Optional[str], Field(description='Indicates the service affected by the issue.')
    ] = None
    status: Optional[ServiceHealthStatus] = None
    field_odata_type: str


class ServicePrincipalRiskDetection(Entity):
    activity: Annotated[
        Optional[Union[ActivityType, Dict[str, Any]]],
        Field(
            description='Indicates the activity type the detected risk is linked to.  The possible values are: signin, servicePrincipal. Use the Prefer: include-unknown-enum-members request header to get the following value(s) in this evolvable enum: servicePrincipal.'
        ),
    ] = None
    activity_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when the risky activity occurred. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z',
        ),
    ] = None
    additional_info: Annotated[
        Optional[str],
        Field(
            description='Additional information associated with the risk detection. This string value is represented as a JSON object with the quotations escaped.'
        ),
    ] = None
    app_id: Annotated[
        Optional[str],
        Field(description='The unique identifier for the associated application.'),
    ] = None
    correlation_id: Annotated[
        Optional[str],
        Field(
            description='Correlation ID of the sign-in activity associated with the risk detection. This property is null if the risk detection is not associated with a sign-in activity.'
        ),
    ] = None
    detected_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when the risk was detected. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    detection_timing_type: Annotated[
        Optional[Union[RiskDetectionTimingType, Dict[str, Any]]],
        Field(
            description='Timing of the detected risk , whether real-time or offline. The possible values are: notDefined, realtime, nearRealtime, offline, unknownFutureValue.'
        ),
    ] = None
    ip_address: Annotated[
        Optional[str],
        Field(
            description='Provides the IP address of the client from where the risk occurred.'
        ),
    ] = None
    key_ids: Annotated[
        Optional[List[str]],
        Field(
            description='The unique identifier for the key credential associated with the risk detection.'
        ),
    ] = None
    last_updated_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when the risk detection was last updated.',
        ),
    ] = None
    location: Annotated[
        Optional[Union[SignInLocation, Dict[str, Any]]],
        Field(description='Location from where the sign-in was initiated.'),
    ] = None
    request_id: Annotated[
        Optional[str],
        Field(
            description='Request identifier of the sign-in activity associated with the risk detection. This property is null if the risk detection is not associated with a sign-in activity. Supports $filter (eq).'
        ),
    ] = None
    risk_detail: Annotated[
        Optional[Union[RiskDetail, Dict[str, Any]]],
        Field(
            description='Details of the detected risk. Note: Details for this property are only available for Workload Identities Premium customers. Events in tenants without this license will be returned hidden. The possible values are: none, hidden, adminConfirmedServicePrincipalCompromised, adminDismissedAllRiskForServicePrincipal. Use the Prefer: include-unknown-enum-members request header to get the following value(s) in this evolvable enum: adminConfirmedServicePrincipalCompromised , adminDismissedAllRiskForServicePrincipal.'
        ),
    ] = None
    risk_event_type: Annotated[
        Optional[str],
        Field(
            description='The type of risk event detected. The possible values are: investigationsThreatIntelligence, generic, adminConfirmedServicePrincipalCompromised, suspiciousSignins, leakedCredentials, anomalousServicePrincipalActivity, maliciousApplication, suspiciousApplication.'
        ),
    ] = None
    risk_level: Annotated[
        Optional[Union[RiskLevel, Dict[str, Any]]],
        Field(
            description='Level of the detected risk. Note: Details for this property are only available for Workload Identities Premium customers. Events in tenants without this license will be returned hidden. The possible values are: low, medium, high, hidden, none.'
        ),
    ] = None
    risk_state: Annotated[
        Optional[Union[RiskState, Dict[str, Any]]],
        Field(
            description='The state of a detected risky service principal or sign-in activity. The possible values are: none, dismissed, atRisk, confirmedCompromised.'
        ),
    ] = None
    service_principal_display_name: Annotated[
        Optional[str], Field(description='The display name for the service principal.')
    ] = None
    service_principal_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier for the service principal. Supports $filter (eq).'
        ),
    ] = None
    source: Annotated[
        Optional[str],
        Field(
            description='Source of the risk detection. For example, identityProtection.'
        ),
    ] = None
    token_issuer_type: Annotated[
        Optional[Union[TokenIssuerType, Dict[str, Any]]],
        Field(
            description='Indicates the type of token issuer for the detected sign-in risk. The possible values are: AzureAD.'
        ),
    ] = None
    field_odata_type: str


class ServiceUpdateMessage(ServiceAnnouncementBase):
    action_required_by_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The expected deadline of the action for the message.',
        ),
    ] = None
    attachments_archive: Annotated[
        Optional[str],
        Field(description='The zip file that contains all attachments for a message.'),
    ] = None
    body: Optional[ItemBody] = None
    category: Optional[ServiceUpdateCategory] = None
    has_attachments: Annotated[
        Optional[bool],
        Field(description='Indicates whether the message has any attachment.'),
    ] = None
    is_major_change: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the message describes a major update for the service.'
        ),
    ] = None
    services: Annotated[
        Optional[List[str]],
        Field(description='The affected services by the service message.'),
    ] = None
    severity: Optional[ServiceUpdateSeverity] = None
    tags: Annotated[
        Optional[List[str]],
        Field(
            description='A collection of tags for the service message. Tags are provided by the service team/support team who post the message to tell whether this message contains privacy data, or whether this message is for a service new feature update, and so on.'
        ),
    ] = None
    view_point: Annotated[
        Optional[Union[ServiceUpdateMessageViewpoint, Dict[str, Any]]],
        Field(
            description='Represents user viewpoints data of the service message. This data includes message status such as whether the user has archived, read, or marked the message as favorite. This property is null when accessed with application permissions.'
        ),
    ] = None
    attachments: Annotated[
        Optional[List[ServiceAnnouncementAttachment]],
        Field(description='A collection of serviceAnnouncementAttachments.'),
    ] = None
    field_odata_type: str


class SharedPCConfiguration(DeviceConfiguration):
    account_manager_policy: Annotated[
        Optional[Union[SharedPCAccountManagerPolicy, Dict[str, Any]]],
        Field(
            description='Specifies how accounts are managed on a shared PC. Only applies when disableAccountManager is false.'
        ),
    ] = None
    allowed_accounts: Optional[SharedPCAllowedAccountType] = None
    allow_local_storage: Annotated[
        Optional[bool],
        Field(description='Specifies whether local storage is allowed on a shared PC.'),
    ] = None
    disable_account_manager: Annotated[
        Optional[bool],
        Field(description='Disables the account manager for shared PC mode.'),
    ] = None
    disable_edu_policies: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether the default shared PC education environment policies should be disabled. For Windows 10 RS2 and later, this policy will be applied without setting Enabled to true.'
        ),
    ] = None
    disable_power_policies: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether the default shared PC power policies should be disabled.'
        ),
    ] = None
    disable_sign_in_on_resume: Annotated[
        Optional[bool],
        Field(
            description='Disables the requirement to sign in whenever the device wakes up from sleep mode.'
        ),
    ] = None
    enabled: Annotated[
        Optional[bool],
        Field(description='Enables shared PC mode and applies the shared pc policies.'),
    ] = None
    idle_time_before_sleep_in_seconds: Annotated[
        Optional[float],
        Field(
            description='Specifies the time in seconds that a device must sit idle before the PC goes to sleep. Setting this value to 0 prevents the sleep timeout from occurring.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    kiosk_app_display_name: Annotated[
        Optional[str],
        Field(
            description='Specifies the display text for the account shown on the sign-in screen which launches the app specified by SetKioskAppUserModelId. Only applies when KioskAppUserModelId is set.'
        ),
    ] = None
    kiosk_app_user_model_id: Annotated[
        Optional[str],
        Field(
            description='Specifies the application user model ID of the app to use with assigned access.'
        ),
    ] = None
    maintenance_start_time: Annotated[
        Optional[time],
        Field(
            description='Specifies the daily start time of maintenance hour.',
        ),
    ] = None
    field_odata_type: str


class Sharepoint(Entity):
    settings: Optional[Union[SharepointSettings, Dict[str, Any]]] = None
    field_odata_type: str


class Shift(ChangeTrackedEntity):
    draft_shift: Annotated[
        Optional[Union[ShiftItem, Dict[str, Any]]],
        Field(
            description='Draft changes in the shift. Draft changes are only visible to managers. The changes are visible to employees when they are shared, which copies the changes from the draftShift to the sharedShift property.'
        ),
    ] = None
    is_staged_for_deletion: Annotated[
        Optional[bool],
        Field(
            description='The shift is marked for deletion, a process that is finalized when the schedule is shared.'
        ),
    ] = None
    scheduling_group_id: Annotated[
        Optional[str],
        Field(description='ID of the scheduling group the shift is part of. Required.'),
    ] = None
    shared_shift: Annotated[
        Optional[Union[ShiftItem, Dict[str, Any]]],
        Field(
            description='The shared version of this shift that is viewable by both employees and managers. Updates to the sharedShift property send notifications to users in the Teams client.'
        ),
    ] = None
    user_id: Annotated[
        Optional[str],
        Field(description='ID of the user assigned to the shift. Required.'),
    ] = None
    field_odata_type: str


class SignIn(Entity):
    app_display_name: Annotated[
        Optional[str],
        Field(
            description='App name displayed in the Microsoft Entra admin center.  Supports $filter (eq, startsWith).'
        ),
    ] = None
    app_id: Annotated[
        Optional[str],
        Field(
            description='Unique GUID that represents the app ID in the Microsoft Entra ID.  Supports $filter (eq).'
        ),
    ] = None
    applied_conditional_access_policies: Annotated[
        Optional[List[AppliedConditionalAccessPolicy]],
        Field(
            description='Provides a list of conditional access policies that the corresponding sign-in activity triggers. Apps need more Conditional Access-related privileges to read the details of this property. For more information, see Permissions for viewing applied conditional access (CA) policies in sign-ins.'
        ),
    ] = None
    client_app_used: Annotated[
        Optional[str],
        Field(
            description='Identifies the client used for the sign-in activity. Modern authentication clients include Browser, modern clients. Legacy authentication clients include Exchange ActiveSync, IMAP, MAPI, SMTP, POP, and other clients.  Supports $filter (eq).'
        ),
    ] = None
    conditional_access_status: Annotated[
        Optional[Union[ConditionalAccessStatus, Dict[str, Any]]],
        Field(
            description='Reports status of an activated conditional access policy. Possible values are: success, failure, notApplied, and unknownFutureValue.  Supports $filter (eq).'
        ),
    ] = None
    correlation_id: Annotated[
        Optional[str],
        Field(
            description='The request ID sent from the client when the sign-in is initiated. Used to troubleshoot sign-in activity.  Supports $filter (eq).'
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time (UTC) the sign-in was initiated. Example: midnight on Jan 1, 2014 is reported as 2014-01-01T00:00:00Z.  Supports $orderby, $filter (eq, le, and ge).',
        ),
    ] = None
    device_detail: Annotated[
        Optional[Union[DeviceDetail, Dict[str, Any]]],
        Field(
            description='Device information from where the sign-in occurred; includes device ID, operating system, and browser.  Supports $filter (eq, startsWith) on browser and operatingSytem properties.'
        ),
    ] = None
    ip_address: Annotated[
        Optional[str],
        Field(
            description='IP address of the client used to sign in.  Supports $filter (eq, startsWith).'
        ),
    ] = None
    is_interactive: Annotated[
        Optional[bool], Field(description='Indicates whether a sign-in is interactive.')
    ] = None
    location: Annotated[
        Optional[Union[SignInLocation, Dict[str, Any]]],
        Field(
            description='Provides the city, state, and country code where the sign-in originated.  Supports $filter (eq, startsWith) on city, state, and countryOrRegion properties.'
        ),
    ] = None
    resource_display_name: Annotated[
        Optional[str],
        Field(
            description='Name of the resource the user signed into.  Supports $filter (eq).'
        ),
    ] = None
    resource_id: Annotated[
        Optional[str],
        Field(
            description='ID of the resource that the user signed into.  Supports $filter (eq).'
        ),
    ] = None
    risk_detail: Annotated[
        Optional[Union[RiskDetail, Dict[str, Any]]],
        Field(
            description='The reason behind a specific state of a risky user, sign-in, or a risk event. The possible values are none, adminGeneratedTemporaryPassword, userPerformedSecuredPasswordChange, userPerformedSecuredPasswordReset, adminConfirmedSigninSafe, aiConfirmedSigninSafe, userPassedMFADrivenByRiskBasedPolicy, adminDismissedAllRiskForUser, adminConfirmedSigninCompromised, hidden, adminConfirmedUserCompromised, unknownFutureValue, adminConfirmedServicePrincipalCompromised, adminDismissedAllRiskForServicePrincipal, m365DAdminDismissedDetection, userChangedPasswordOnPremises, adminDismissedRiskForSignIn, adminConfirmedAccountSafe. Use the Prefer: include-unknown-enum-members request header to get the following value or values in this evolvable enum: adminConfirmedServicePrincipalCompromised, adminDismissedAllRiskForServicePrincipal, m365DAdminDismissedDetection, userChangedPasswordOnPremises, adminDismissedRiskForSignIn, adminConfirmedAccountSafe.The value none means that Microsoft Entra risk detection did not flag the user or the sign-in as a risky event so far.  Supports $filter (eq). Note: Details for this property are only available for Microsoft Entra ID P2 customers. All other customers are returned hidden.'
        ),
    ] = None
    risk_event_types: Optional[List[Union[RiskEventType, Dict[str, Any]]]] = None
    risk_event_types_v2: Annotated[
        Optional[List[str]],
        Field(
            description='The list of risk event types associated with the sign-in. Possible values: unlikelyTravel, anonymizedIPAddress, maliciousIPAddress, unfamiliarFeatures, malwareInfectedIPAddress, suspiciousIPAddress, leakedCredentials, investigationsThreatIntelligence, generic, or unknownFutureValue.  Supports $filter (eq, startsWith).'
        ),
    ] = None
    risk_level_aggregated: Annotated[
        Optional[Union[RiskLevel, Dict[str, Any]]],
        Field(
            description="Aggregated risk level. The possible values are: none, low, medium, high, hidden, and unknownFutureValue. The value hidden means the user or sign-in wasn't enabled for Microsoft Entra ID Protection.  Supports $filter (eq).  Note: Details for this property are only available for Microsoft Entra ID P2 customers. All other customers are returned hidden."
        ),
    ] = None
    risk_level_during_sign_in: Annotated[
        Optional[Union[RiskLevel, Dict[str, Any]]],
        Field(
            description="Risk level during sign-in. The possible values are: none, low, medium, high, hidden, and unknownFutureValue. The value hidden means the user or sign-in wasn't enabled for Microsoft Entra ID Protection.  Supports $filter (eq). Note: Details for this property are only available for Microsoft Entra ID P2 customers. All other customers are returned hidden."
        ),
    ] = None
    risk_state: Annotated[
        Optional[Union[RiskState, Dict[str, Any]]],
        Field(
            description='Reports status of the risky user, sign-in, or a risk event. The possible values are: none, confirmedSafe, remediated, dismissed, atRisk, confirmedCompromised, unknownFutureValue.  Supports $filter (eq).'
        ),
    ] = None
    status: Annotated[
        Optional[Union[SignInStatus, Dict[str, Any]]],
        Field(
            description='Sign-in status. Includes the error code and description of the error (if a sign-in failure occurs).  Supports $filter (eq) on errorCode property.'
        ),
    ] = None
    user_display_name: Annotated[
        Optional[str],
        Field(
            description='Display name of the user that initiated the sign-in.  Supports $filter (eq, startsWith).'
        ),
    ] = None
    user_id: Annotated[
        Optional[str],
        Field(
            description='ID of the user that initiated the sign-in.  Supports $filter (eq).'
        ),
    ] = None
    user_principal_name: Annotated[
        Optional[str],
        Field(
            description="User principal name of the user that initiated the sign-in. This value is always in lowercase. For guest users whose values in the user object typically contain #EXT# before the domain part, this property stores the value in both lowercase and the 'true' format. For example, while the user object stores AdeleVance_fabrikam.com#EXT#@contoso.com, the sign-in logs store adelevance@fabrikam.com. Supports $filter (eq, startsWith)."
        ),
    ] = None
    field_odata_type: str


class SimulationAutomation(Entity):
    created_by: Annotated[
        Optional[Union[EmailIdentity, Dict[str, Any]]],
        Field(
            description='Identity of the user who created the attack simulation automation.'
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when the attack simulation automation was created.',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(description='Description of the attack simulation automation.'),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='Display name of the attack simulation automation. Supports $filter and $orderby.'
        ),
    ] = None
    last_modified_by: Annotated[
        Optional[Union[EmailIdentity, Dict[str, Any]]],
        Field(
            description='Identity of the user who most recently modified the attack simulation automation.'
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when the attack simulation automation was most recently modified.',
        ),
    ] = None
    last_run_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time of the latest run of the attack simulation automation.',
        ),
    ] = None
    next_run_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time of the upcoming run of the attack simulation automation.',
        ),
    ] = None
    status: Annotated[
        Optional[Union[SimulationAutomationStatus, Dict[str, Any]]],
        Field(
            description='Status of the attack simulation automation. Supports $filter and $orderby. The possible values are: unknown, draft, notRunning, running, completed, unknownFutureValue.'
        ),
    ] = None
    runs: Annotated[
        Optional[List[SimulationAutomationRun]],
        Field(description='A collection of simulation automation runs.'),
    ] = None
    field_odata_type: str


class SiteProtectionRule(ProtectionRuleBase):
    site_expression: Annotated[
        Optional[str],
        Field(
            description='Contains a site expression. For examples, see siteExpression example.'
        ),
    ] = None
    field_odata_type: str


class SiteProtectionUnit(ProtectionUnitBase):
    site_id: Annotated[
        Optional[str], Field(description='Unique identifier of the SharePoint site.')
    ] = None
    site_name: Annotated[
        Optional[str], Field(description='Name of the SharePoint site.')
    ] = None
    site_web_url: Annotated[
        Optional[str], Field(description='The web URL of the SharePoint site.')
    ] = None
    field_odata_type: str


class SmsAuthenticationMethodConfiguration(AuthenticationMethodConfiguration):
    include_targets: Annotated[
        Optional[List[SmsAuthenticationMethodTarget]],
        Field(
            description='A collection of groups that are enabled to use the authentication method.'
        ),
    ] = None
    field_odata_type: str


class SoftwareOathAuthenticationMethodConfiguration(AuthenticationMethodConfiguration):
    include_targets: Annotated[
        Optional[List[AuthenticationMethodTarget]],
        Field(
            description='A collection of groups that are enabled to use the authentication method. Expanded by default.'
        ),
    ] = None
    field_odata_type: str


class StorageSettings(Entity):
    quota: Optional[Union[UnifiedStorageQuota, Dict[str, Any]]] = None
    field_odata_type: str


class SwapShiftsChangeRequest(OfferShiftRequest):
    recipient_shift_id: Annotated[
        Optional[str],
        Field(
            description='ShiftId for the recipient user with whom the request is to swap.'
        ),
    ] = None
    field_odata_type: str


class TargetedManagedAppConfiguration(ManagedAppConfiguration):
    deployed_app_count: Annotated[
        Optional[float],
        Field(
            description='Count of apps to which the current policy is deployed.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    is_assigned: Annotated[
        Optional[bool],
        Field(
            description='Indicates if the policy is deployed to any inclusion groups or not.'
        ),
    ] = None
    apps: Annotated[
        Optional[List[ManagedMobileApp]],
        Field(description='List of apps to which the policy is deployed.'),
    ] = None
    assignments: Annotated[
        Optional[List[TargetedManagedAppPolicyAssignment]],
        Field(
            description='Navigation property to list of inclusion and exclusion groups to which the policy is deployed.'
        ),
    ] = None
    deployment_summary: Annotated[
        Optional[Union[ManagedAppPolicyDeploymentSummary, Dict[str, Any]]],
        Field(
            description='Navigation property to deployment summary of the configuration.'
        ),
    ] = None
    field_odata_type: str


class TemporaryAccessPassAuthenticationMethodConfiguration(
    AuthenticationMethodConfiguration
):
    default_length: Annotated[
        Optional[float],
        Field(
            description='Default length in characters of a Temporary Access Pass object. Must be between 8 and 48 characters.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    default_lifetime_in_minutes: Annotated[
        Optional[float],
        Field(
            description='Default lifetime in minutes for a Temporary Access Pass. Value can be any integer between the minimumLifetimeInMinutes and maximumLifetimeInMinutes.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    is_usable_once: Annotated[
        Optional[bool],
        Field(
            description='If true, all the passes in the tenant will be restricted to one-time use. If false, passes in the tenant can be created to be either one-time use or reusable.'
        ),
    ] = None
    maximum_lifetime_in_minutes: Annotated[
        Optional[float],
        Field(
            description='Maximum lifetime in minutes for any Temporary Access Pass created in the tenant. Value can be between 10 and 43200 minutes (equivalent to 30 days).',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    minimum_lifetime_in_minutes: Annotated[
        Optional[float],
        Field(
            description='Minimum lifetime in minutes for any Temporary Access Pass created in the tenant. Value can be between 10 and 43200 minutes (equivalent to 30 days).',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    include_targets: Annotated[
        Optional[List[AuthenticationMethodTarget]],
        Field(
            description='A collection of groups that are enabled to use the authentication method.'
        ),
    ] = None
    field_odata_type: str


class ThreatAssessmentRequest(Entity):
    category: Optional[ThreatCategory] = None
    content_type: Annotated[
        Optional[Union[ThreatAssessmentContentType, Dict[str, Any]]],
        Field(
            description='The content type of threat assessment. Possible values are: mail, url, file.'
        ),
    ] = None
    created_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='The threat assessment request creator.'),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    expected_assessment: Optional[ThreatExpectedAssessment] = None
    request_source: Annotated[
        Optional[Union[ThreatAssessmentRequestSource, Dict[str, Any]]],
        Field(
            description='The source of the threat assessment request. Possible values are: administrator.'
        ),
    ] = None
    status: Annotated[
        Optional[Union[ThreatAssessmentStatus, Dict[str, Any]]],
        Field(
            description='The assessment process status. Possible values are: pending, completed.'
        ),
    ] = None
    results: Annotated[
        Optional[List[ThreatAssessmentResult]],
        Field(
            description='A collection of threat assessment results. Read-only. By default, a GET /threatAssessmentRequests/{id} does not return this property unless you apply $expand on it.'
        ),
    ] = None
    field_odata_type: str


class TimeOff(ChangeTrackedEntity):
    draft_time_off: Annotated[
        Optional[Union[TimeOffItem, Dict[str, Any]]],
        Field(
            description="The draft version of this timeOff item that is viewable by managers. It must be shared before it's visible to team members. Required."
        ),
    ] = None
    is_staged_for_deletion: Annotated[
        Optional[bool],
        Field(
            description='The timeOff is marked for deletion, a process that is finalized when the schedule is shared.'
        ),
    ] = None
    shared_time_off: Annotated[
        Optional[Union[TimeOffItem, Dict[str, Any]]],
        Field(
            description='The shared version of this timeOff that is viewable by both employees and managers. Updates to the sharedTimeOff property send notifications to users in the Teams client. Required.'
        ),
    ] = None
    user_id: Annotated[
        Optional[str],
        Field(description='ID of the user assigned to the timeOff. Required.'),
    ] = None
    field_odata_type: str


class TrainingLanguageDetail(Entity):
    content: Annotated[
        Optional[str], Field(description='Language specific content for the training.')
    ] = None
    created_by: Annotated[
        Optional[Union[EmailIdentity, Dict[str, Any]]],
        Field(description='Identity of the user who created the language details.'),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when the language details were created. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    description: Annotated[
        Optional[str], Field(description='Description as defined by the user.')
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='Display name as defined by the user.')
    ] = None
    is_default_langauge: Annotated[
        Optional[bool],
        Field(description='Indicates whether the training has a default language.'),
    ] = None
    last_modified_by: Annotated[
        Optional[Union[EmailIdentity, Dict[str, Any]]],
        Field(description='Identity of the user who last modified the details.'),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when the trainingLanguageDetail was last modified. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    locale: Annotated[
        Optional[str], Field(description='Content locale for the training detail.')
    ] = None
    field_odata_type: str


class UnifiedRoleAssignment(Entity):
    app_scope_id: Annotated[
        Optional[str],
        Field(
            description="Identifier of the app specific scope when the assignment scope is app specific. The scope of an assignment determines the set of resources for which the principal has been granted access. App scopes are scopes that are defined and understood by a resource application only. For the entitlement management provider, use this property to specify a catalog. For example, /AccessPackageCatalog/beedadfe-01d5-4025-910b-84abb9369997. Supports $filter (eq, in). For example, /roleManagement/entitlementManagement/roleAssignments?$filter=appScopeId eq '/AccessPackageCatalog/{catalog id}'."
        ),
    ] = None
    condition: Optional[str] = None
    directory_scope_id: Annotated[
        Optional[str],
        Field(
            description='Identifier of the directory object representing the scope of the assignment. The scope of an assignment determines the set of resources for which the principal has been granted access. Directory scopes are shared scopes stored in the directory that are understood by multiple applications, unlike app scopes that are defined and understood by a resource application only. Supports $filter (eq, in).'
        ),
    ] = None
    principal_id: Annotated[
        Optional[str],
        Field(
            description='Identifier of the principal to which the assignment is granted. Supported principals are users, role-assignable groups, and service principals. Supports $filter (eq, in).'
        ),
    ] = None
    role_definition_id: Annotated[
        Optional[str],
        Field(
            description='Identifier of the unifiedRoleDefinition the assignment is for. Read-only. Supports $filter (eq, in).'
        ),
    ] = None
    app_scope: Annotated[
        Optional[Union[AppScope, Dict[str, Any]]],
        Field(
            description='Read-only property with details of the app specific scope when the assignment scope is app specific. Containment entity. Supports $expand for the entitlement provider only.'
        ),
    ] = None
    directory_scope: Annotated[
        Optional[Union[DirectoryObject, Dict[str, Any]]],
        Field(
            description='The directory object that is the scope of the assignment. Read-only. Supports $expand for the directory provider.'
        ),
    ] = None
    principal: Annotated[
        Optional[Union[DirectoryObject, Dict[str, Any]]],
        Field(
            description='Referencing the assigned principal. Read-only. Supports $expand except for the Exchange provider.'
        ),
    ] = None
    role_definition: Annotated[
        Optional[Union[UnifiedRoleDefinition, Dict[str, Any]]],
        Field(
            description='The roleDefinition the assignment is for. Supports $expand.'
        ),
    ] = None
    field_odata_type: str


class UnifiedRoleEligibilityScheduleInstance(UnifiedRoleScheduleInstanceBase):
    end_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The end date of the schedule instance.',
        ),
    ] = None
    member_type: Annotated[
        Optional[str],
        Field(
            description='How the role eligibility is inherited. It can either be Inherited, Direct, or Group. It can further imply whether the unifiedRoleEligibilitySchedule can be managed by the caller. Supports $filter (eq, ne).'
        ),
    ] = None
    role_eligibility_schedule_id: Annotated[
        Optional[str],
        Field(
            description='The identifier of the unifiedRoleEligibilitySchedule object from which this instance was created. Supports $filter (eq, ne).'
        ),
    ] = None
    start_date_time: Annotated[
        Optional[datetime],
        Field(
            description='When this instance starts.',
        ),
    ] = None
    field_odata_type: str


class UnifiedRoleManagementPolicyRule(Entity):
    target: Annotated[
        Optional[Union[UnifiedRoleManagementPolicyRuleTarget, Dict[str, Any]]],
        Field(
            description="Defines details of scope that's targeted by role management policy rule. The details can include the principal type, the role assignment type, and actions affecting a role. Supports $filter (eq, ne)."
        ),
    ] = None
    field_odata_type: str


class UrlAssessmentRequest(ThreatAssessmentRequest):
    url: Annotated[Optional[str], Field(description='The URL string.')] = None
    field_odata_type: str


class UserConsentRequest(Request):
    reason: Annotated[
        Optional[str],
        Field(
            description="The user's justification for requiring access to the app. Supports $filter (eq only) and $orderby."
        ),
    ] = None
    approval: Annotated[
        Optional[Union[Approval, Dict[str, Any]]],
        Field(description='Approval decisions associated with a request.'),
    ] = None
    field_odata_type: str


class UserExperienceAnalyticsCategory(Entity):
    insights: Annotated[
        Optional[List[UserExperienceAnalyticsInsight]],
        Field(description='The insights for the category. Read-only.'),
    ] = None
    metric_values: Annotated[
        Optional[List[UserExperienceAnalyticsMetric]],
        Field(
            description='The metric values for the user experience analytics category. Read-only.'
        ),
    ] = None
    field_odata_type: str


class UserExperienceAnalyticsOverview(Entity):
    insights: Annotated[
        Optional[List[UserExperienceAnalyticsInsight]],
        Field(description='The user experience analytics insights. Read-only.'),
    ] = None
    field_odata_type: str


class VirtualEventPresenter(Entity):
    email: Annotated[
        Optional[str], Field(description='Email address of the presenter.')
    ] = None
    identity: Annotated[
        Optional[Union[Identity, Dict[str, Any]]],
        Field(
            description='Identity information of the presenter. The supported identities are: communicationsGuestIdentity and communicationsUserIdentity.'
        ),
    ] = None
    presenter_details: Annotated[
        Optional[Union[VirtualEventPresenterDetails, Dict[str, Any]]],
        Field(
            description='Other details about the presenter. This property returns null when the virtual event type is virtualEventTownhall.'
        ),
    ] = None
    field_odata_type: str


class VirtualEventSession(OnlineMeetingBase):
    end_date_time: Annotated[
        Optional[Union[DateTimeTimeZone, Dict[str, Any]]],
        Field(description='The virtual event session end time.'),
    ] = None
    start_date_time: Annotated[
        Optional[Union[DateTimeTimeZone, Dict[str, Any]]],
        Field(description='The virtual event session start time.'),
    ] = None
    field_odata_type: str


class VoiceAuthenticationMethodConfiguration(AuthenticationMethodConfiguration):
    is_office_phone_allowed: Annotated[
        Optional[bool],
        Field(
            description='true if users can register office phones, otherwise, false.'
        ),
    ] = None
    include_targets: Annotated[
        Optional[List[AuthenticationMethodTarget]],
        Field(
            description='A collection of groups that are enabled to use the authentication method. Expanded by default.'
        ),
    ] = None
    field_odata_type: str


class WebApp(MobileApp):
    app_url: Annotated[
        Optional[str],
        Field(description='The web app URL. This property cannot be PATCHed.'),
    ] = None
    use_managed_browser: Annotated[
        Optional[bool],
        Field(
            description='Whether or not to use managed browser. This property is only applicable for Android and IOS.'
        ),
    ] = None
    field_odata_type: str


class Win32LobApp(MobileLobApp):
    applicable_architectures: Optional[WindowsArchitecture] = None
    install_command_line: Annotated[
        Optional[str], Field(description='The command line to install this app')
    ] = None
    install_experience: Annotated[
        Optional[Union[Win32LobAppInstallExperience, Dict[str, Any]]],
        Field(description='The install experience for this app.'),
    ] = None
    minimum_cpu_speed_in_m_hz: Annotated[
        Optional[float],
        Field(
            description='The value for the minimum CPU speed which is required to install this app.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    minimum_free_disk_space_in_mb: Annotated[
        Optional[float],
        Field(
            description='The value for the minimum free disk space which is required to install this app.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    minimum_memory_in_mb: Annotated[
        Optional[float],
        Field(
            description='The value for the minimum physical memory which is required to install this app.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    minimum_number_of_processors: Annotated[
        Optional[float],
        Field(
            description='The value for the minimum number of processors which is required to install this app.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    minimum_supported_windows_release: Annotated[
        Optional[str],
        Field(description='The value for the minimum supported windows release.'),
    ] = None
    msi_information: Annotated[
        Optional[Union[Win32LobAppMsiInformation, Dict[str, Any]]],
        Field(description='The MSI details if this Win32 app is an MSI app.'),
    ] = None
    return_codes: Annotated[
        Optional[List[Win32LobAppReturnCode]],
        Field(description='The return codes for post installation behavior.'),
    ] = None
    rules: Annotated[
        Optional[List[Win32LobAppRule]],
        Field(description='The detection and requirement rules for this app.'),
    ] = None
    setup_file_path: Annotated[
        Optional[str],
        Field(
            description='The relative path of the setup file in the encrypted Win32LobApp package.'
        ),
    ] = None
    uninstall_command_line: Annotated[
        Optional[str], Field(description='The command line to uninstall this app')
    ] = None
    field_odata_type: str


class Windows10CompliancePolicy(DeviceCompliancePolicy):
    bit_locker_enabled: Annotated[
        Optional[bool],
        Field(
            description='Require devices to be reported healthy by Windows Device Health Attestation - bit locker is enabled'
        ),
    ] = None
    code_integrity_enabled: Annotated[
        Optional[bool],
        Field(
            description='Require devices to be reported as healthy by Windows Device Health Attestation.'
        ),
    ] = None
    early_launch_anti_malware_driver_enabled: Annotated[
        Optional[bool],
        Field(
            description='Require devices to be reported as healthy by Windows Device Health Attestation - early launch antimalware driver is enabled.'
        ),
    ] = None
    mobile_os_maximum_version: Annotated[
        Optional[str], Field(description='Maximum Windows Phone version.')
    ] = None
    mobile_os_minimum_version: Annotated[
        Optional[str], Field(description='Minimum Windows Phone version.')
    ] = None
    os_maximum_version: Annotated[
        Optional[str], Field(description='Maximum Windows 10 version.')
    ] = None
    os_minimum_version: Annotated[
        Optional[str], Field(description='Minimum Windows 10 version.')
    ] = None
    password_block_simple: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block simple password.'),
    ] = None
    password_expiration_days: Annotated[
        Optional[float],
        Field(
            description='The password expiration in days.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minimum_character_set_count: Annotated[
        Optional[float],
        Field(
            description='The number of character sets required in the password.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minimum_length: Annotated[
        Optional[float],
        Field(
            description='The minimum password length.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minutes_of_inactivity_before_lock: Annotated[
        Optional[float],
        Field(
            description='Minutes of inactivity before a password is required.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_previous_password_block_count: Annotated[
        Optional[float],
        Field(
            description='The number of previous passwords to prevent re-use of.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_required: Annotated[
        Optional[bool],
        Field(description='Require a password to unlock Windows device.'),
    ] = None
    password_required_to_unlock_from_idle: Annotated[
        Optional[bool],
        Field(description='Require a password to unlock an idle device.'),
    ] = None
    password_required_type: Optional[RequiredPasswordType] = None
    require_healthy_device_report: Annotated[
        Optional[bool],
        Field(
            description='Require devices to be reported as healthy by Windows Device Health Attestation.'
        ),
    ] = None
    secure_boot_enabled: Annotated[
        Optional[bool],
        Field(
            description='Require devices to be reported as healthy by Windows Device Health Attestation - secure boot is enabled.'
        ),
    ] = None
    storage_require_encryption: Annotated[
        Optional[bool], Field(description='Require encryption on windows devices.')
    ] = None
    field_odata_type: str


class Windows10CustomConfiguration(DeviceConfiguration):
    oma_settings: Annotated[
        Optional[List[OmaSetting]],
        Field(
            description='OMA settings. This collection can contain a maximum of 1000 elements.'
        ),
    ] = None
    field_odata_type: str


class Windows10EndpointProtectionConfiguration(DeviceConfiguration):
    application_guard_allow_persistence: Annotated[
        Optional[bool],
        Field(
            description='Allow persisting user generated data inside the App Guard Containter (favorites, cookies, web passwords, etc.)'
        ),
    ] = None
    application_guard_allow_print_to_local_printers: Annotated[
        Optional[bool],
        Field(description='Allow printing to Local Printers from Container'),
    ] = None
    application_guard_allow_print_to_network_printers: Annotated[
        Optional[bool],
        Field(description='Allow printing to Network Printers from Container'),
    ] = None
    application_guard_allow_print_to_pdf: Annotated[
        Optional[bool], Field(description='Allow printing to PDF from Container')
    ] = None
    application_guard_allow_print_to_xps: Annotated[
        Optional[bool], Field(description='Allow printing to XPS from Container')
    ] = None
    application_guard_block_clipboard_sharing: Optional[
        ApplicationGuardBlockClipboardSharingType
    ] = None
    application_guard_block_file_transfer: Optional[
        ApplicationGuardBlockFileTransferType
    ] = None
    application_guard_block_non_enterprise_content: Annotated[
        Optional[bool],
        Field(
            description='Block enterprise sites to load non-enterprise content, such as third party plug-ins'
        ),
    ] = None
    application_guard_enabled: Annotated[
        Optional[bool], Field(description='Enable Windows Defender Application Guard')
    ] = None
    application_guard_force_auditing: Annotated[
        Optional[bool],
        Field(
            description='Force auditing will persist Windows logs and events to meet security/compliance criteria (sample events are user login-logoff, use of privilege rights, software installation, system changes, etc.)'
        ),
    ] = None
    app_locker_application_control: Optional[AppLockerApplicationControlType] = None
    bit_locker_disable_warning_for_other_disk_encryption: Annotated[
        Optional[bool],
        Field(
            description='Allows the Admin to disable the warning prompt for other disk encryption on the user machines.'
        ),
    ] = None
    bit_locker_enable_storage_card_encryption_on_mobile: Annotated[
        Optional[bool],
        Field(
            description='Allows the admin to require encryption to be turned on using BitLocker. This policy is valid only for a mobile SKU.'
        ),
    ] = None
    bit_locker_encrypt_device: Annotated[
        Optional[bool],
        Field(
            description='Allows the admin to require encryption to be turned on using BitLocker.'
        ),
    ] = None
    bit_locker_removable_drive_policy: Annotated[
        Optional[Union[BitLockerRemovableDrivePolicy, Dict[str, Any]]],
        Field(description='BitLocker Removable Drive Policy.'),
    ] = None
    defender_additional_guarded_folders: Annotated[
        Optional[List[str]],
        Field(
            description='List of folder paths to be added to the list of protected folders'
        ),
    ] = None
    defender_attack_surface_reduction_excluded_paths: Annotated[
        Optional[List[str]],
        Field(
            description='List of exe files and folders to be excluded from attack surface reduction rules'
        ),
    ] = None
    defender_exploit_protection_xml: Annotated[
        Optional[str],
        Field(
            description='Xml content containing information regarding exploit protection details.'
        ),
    ] = None
    defender_exploit_protection_xml_file_name: Annotated[
        Optional[str],
        Field(
            description='Name of the file from which DefenderExploitProtectionXml was obtained.'
        ),
    ] = None
    defender_guarded_folders_allowed_app_paths: Annotated[
        Optional[List[str]],
        Field(
            description='List of paths to exe that are allowed to access protected folders'
        ),
    ] = None
    defender_security_center_block_exploit_protection_override: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block user from overriding Exploit Protection settings.'
        ),
    ] = None
    firewall_block_stateful_ftp: Annotated[
        Optional[bool],
        Field(description='Blocks stateful FTP connections to the device'),
    ] = None
    firewall_certificate_revocation_list_check_method: Optional[
        FirewallCertificateRevocationListCheckMethodType
    ] = None
    firewall_idle_timeout_for_security_association_in_seconds: Annotated[
        Optional[float],
        Field(
            description='Configures the idle timeout for security associations, in seconds, from 300 to 3600 inclusive. This is the period after which security associations will expire and be deleted. Valid values 300 to 3600',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    firewall_ip_sec_exemptions_allow_dhcp: Annotated[
        Optional[bool],
        Field(
            description='Configures IPSec exemptions to allow both IPv4 and IPv6 DHCP traffic'
        ),
    ] = None
    firewall_ip_sec_exemptions_allow_icmp: Annotated[
        Optional[bool], Field(description='Configures IPSec exemptions to allow ICMP')
    ] = None
    firewall_ip_sec_exemptions_allow_neighbor_discovery: Annotated[
        Optional[bool],
        Field(
            description='Configures IPSec exemptions to allow neighbor discovery IPv6 ICMP type-codes'
        ),
    ] = None
    firewall_ip_sec_exemptions_allow_router_discovery: Annotated[
        Optional[bool],
        Field(
            description='Configures IPSec exemptions to allow router discovery IPv6 ICMP type-codes'
        ),
    ] = None
    firewall_merge_keying_module_settings: Annotated[
        Optional[bool],
        Field(
            description='If an authentication set is not fully supported by a keying module, direct the module to ignore only unsupported authentication suites rather than the entire set'
        ),
    ] = None
    firewall_packet_queueing_method: Optional[FirewallPacketQueueingMethodType] = None
    firewall_pre_shared_key_encoding_method: Optional[
        FirewallPreSharedKeyEncodingMethodType
    ] = None
    firewall_profile_domain: Annotated[
        Optional[Union[WindowsFirewallNetworkProfile, Dict[str, Any]]],
        Field(
            description='Configures the firewall profile settings for domain networks'
        ),
    ] = None
    firewall_profile_private: Annotated[
        Optional[Union[WindowsFirewallNetworkProfile, Dict[str, Any]]],
        Field(
            description='Configures the firewall profile settings for private networks'
        ),
    ] = None
    firewall_profile_public: Annotated[
        Optional[Union[WindowsFirewallNetworkProfile, Dict[str, Any]]],
        Field(
            description='Configures the firewall profile settings for public networks'
        ),
    ] = None
    smart_screen_block_override_for_files: Annotated[
        Optional[bool],
        Field(
            description='Allows IT Admins to control whether users can can ignore SmartScreen warnings and run malicious files.'
        ),
    ] = None
    smart_screen_enable_in_shell: Annotated[
        Optional[bool],
        Field(description='Allows IT Admins to configure SmartScreen for Windows.'),
    ] = None
    field_odata_type: str


class Windows10EnrollmentCompletionPageConfiguration(DeviceEnrollmentConfiguration):
    allow_non_blocking_app_installation: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, ESP (Enrollment Status Page) installs all required apps targeted during technician phase and ignores any failures for non-blocking apps. When FALSE, ESP fails on any error during app install. The default is false.'
        ),
    ] = None
    field_odata_type: str


class Windows10EnterpriseModernAppManagementConfiguration(DeviceConfiguration):
    uninstall_built_in_apps: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to uninstall a fixed list of built-in Windows apps.'
        ),
    ] = None
    field_odata_type: str


class Windows10GeneralConfiguration(DeviceConfiguration):
    accounts_block_adding_non_microsoft_account_email: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to Block the user from adding email accounts to the device that are not associated with a Microsoft account.'
        ),
    ] = None
    anti_theft_mode_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from selecting an AntiTheft mode preference (Windows 10 Mobile only).'
        ),
    ] = None
    apps_allow_trusted_apps_sideloading: Optional[StateManagementSetting] = None
    apps_block_windows_store_originated_apps: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to disable the launch of all apps from Windows Store that came pre-installed or were downloaded.'
        ),
    ] = None
    bluetooth_allowed_services: Annotated[
        Optional[List[str]],
        Field(
            description='Specify a list of allowed Bluetooth services and profiles in hex formatted strings.'
        ),
    ] = None
    bluetooth_block_advertising: Annotated[
        Optional[bool],
        Field(
            description='Whether or not to Block the user from using bluetooth advertising.'
        ),
    ] = None
    bluetooth_block_discoverable_mode: Annotated[
        Optional[bool],
        Field(
            description='Whether or not to Block the user from using bluetooth discoverable mode.'
        ),
    ] = None
    bluetooth_blocked: Annotated[
        Optional[bool],
        Field(description='Whether or not to Block the user from using bluetooth.'),
    ] = None
    bluetooth_block_pre_pairing: Annotated[
        Optional[bool],
        Field(
            description='Whether or not to block specific bundled Bluetooth peripherals to automatically pair with the host device.'
        ),
    ] = None
    camera_blocked: Annotated[
        Optional[bool],
        Field(
            description='Whether or not to Block the user from accessing the camera of the device.'
        ),
    ] = None
    cellular_block_data_when_roaming: Annotated[
        Optional[bool],
        Field(
            description='Whether or not to Block the user from using data over cellular while roaming.'
        ),
    ] = None
    cellular_block_vpn: Annotated[
        Optional[bool],
        Field(
            description='Whether or not to Block the user from using VPN over cellular.'
        ),
    ] = None
    cellular_block_vpn_when_roaming: Annotated[
        Optional[bool],
        Field(
            description='Whether or not to Block the user from using VPN when roaming over cellular.'
        ),
    ] = None
    certificates_block_manual_root_certificate_installation: Annotated[
        Optional[bool],
        Field(
            description='Whether or not to Block the user from doing manual root certificate installation.'
        ),
    ] = None
    connected_devices_service_blocked: Annotated[
        Optional[bool],
        Field(
            description='Whether or not to block Connected Devices Service which enables discovery and connection to other devices, remote messaging, remote app sessions and other cross-device experiences.'
        ),
    ] = None
    copy_paste_blocked: Annotated[
        Optional[bool],
        Field(description='Whether or not to Block the user from using copy paste.'),
    ] = None
    cortana_blocked: Annotated[
        Optional[bool],
        Field(description='Whether or not to Block the user from using Cortana.'),
    ] = None
    defender_block_end_user_access: Annotated[
        Optional[bool],
        Field(description='Whether or not to block end user access to Defender.'),
    ] = None
    defender_cloud_block_level: Optional[DefenderCloudBlockLevelType] = None
    defender_days_before_deleting_quarantined_malware: Annotated[
        Optional[float],
        Field(
            description='Number of days before deleting quarantined malware. Valid values 0 to 90',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    defender_detected_malware_actions: Annotated[
        Optional[Union[DefenderDetectedMalwareActions, Dict[str, Any]]],
        Field(
            description='Gets or sets Defenders actions to take on detected Malware per threat level.'
        ),
    ] = None
    defender_file_extensions_to_exclude: Annotated[
        Optional[List[str]],
        Field(
            description='File extensions to exclude from scans and real time protection.'
        ),
    ] = None
    defender_files_and_folders_to_exclude: Annotated[
        Optional[List[str]],
        Field(
            description='Files and folder to exclude from scans and real time protection.'
        ),
    ] = None
    defender_monitor_file_activity: Optional[DefenderMonitorFileActivity] = None
    defender_processes_to_exclude: Annotated[
        Optional[List[str]],
        Field(description='Processes to exclude from scans and real time protection.'),
    ] = None
    defender_prompt_for_sample_submission: Optional[
        DefenderPromptForSampleSubmission
    ] = None
    defender_require_behavior_monitoring: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to require behavior monitoring.'),
    ] = None
    defender_require_cloud_protection: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to require cloud protection.'),
    ] = None
    defender_require_network_inspection_system: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to require network inspection system.'
        ),
    ] = None
    defender_require_real_time_monitoring: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to require real time monitoring.'),
    ] = None
    defender_scan_archive_files: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to scan archive files.'),
    ] = None
    defender_scan_downloads: Annotated[
        Optional[bool], Field(description='Indicates whether or not to scan downloads.')
    ] = None
    defender_scan_incoming_mail: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to scan incoming mail messages.'),
    ] = None
    defender_scan_mapped_network_drives_during_full_scan: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to scan mapped network drives during full scan.'
        ),
    ] = None
    defender_scan_max_cpu: Annotated[
        Optional[float],
        Field(
            description='Max CPU usage percentage during scan. Valid values 0 to 100',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    defender_scan_network_files: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to scan files opened from a network folder.'
        ),
    ] = None
    defender_scan_removable_drives_during_full_scan: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to scan removable drives during full scan.'
        ),
    ] = None
    defender_scan_scripts_loaded_in_internet_explorer: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to scan scripts loaded in Internet Explorer browser.'
        ),
    ] = None
    defender_scan_type: Optional[DefenderScanType] = None
    defender_scheduled_quick_scan_time: Annotated[
        Optional[time],
        Field(
            description='The time to perform a daily quick scan.',
        ),
    ] = None
    defender_scheduled_scan_time: Annotated[
        Optional[time],
        Field(
            description='The defender time for the system scan.',
        ),
    ] = None
    defender_signature_update_interval_in_hours: Annotated[
        Optional[float],
        Field(
            description='The signature update interval in hours. Specify 0 not to check. Valid values 0 to 24',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    defender_system_scan_schedule: Optional[WeeklySchedule] = None
    developer_unlock_setting: Optional[StateManagementSetting] = None
    device_management_block_factory_reset_on_mobile: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to Block the user from resetting their phone.'
        ),
    ] = None
    device_management_block_manual_unenroll: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to Block the user from doing manual un-enrollment from device management.'
        ),
    ] = None
    diagnostics_data_submission_mode: Optional[DiagnosticDataSubmissionMode] = None
    edge_allow_start_pages_modification: Annotated[
        Optional[bool],
        Field(
            description='Allow users to change Start pages on Edge. Use the EdgeHomepageUrls to specify the Start pages that the user would see by default when they open Edge.'
        ),
    ] = None
    edge_block_access_to_about_flags: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to prevent access to about flags on Edge browser.'
        ),
    ] = None
    edge_block_address_bar_dropdown: Annotated[
        Optional[bool],
        Field(
            description='Block the address bar dropdown functionality in Microsoft Edge. Disable this settings to minimize network connections from Microsoft Edge to Microsoft services.'
        ),
    ] = None
    edge_block_autofill: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block auto fill.'),
    ] = None
    edge_block_compatibility_list: Annotated[
        Optional[bool],
        Field(
            description='Block Microsoft compatibility list in Microsoft Edge. This list from Microsoft helps Edge properly display sites with known compatibility issues.'
        ),
    ] = None
    edge_block_developer_tools: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block developer tools in the Edge browser.'
        ),
    ] = None
    edge_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to Block the user from using the Edge browser.'
        ),
    ] = None
    edge_block_extensions: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block extensions in the Edge browser.'
        ),
    ] = None
    edge_block_in_private_browsing: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block InPrivate browsing on corporate networks, in the Edge browser.'
        ),
    ] = None
    edge_block_java_script: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to Block the user from using JavaScript.'
        ),
    ] = None
    edge_block_live_tile_data_collection: Annotated[
        Optional[bool],
        Field(
            description='Block the collection of information by Microsoft for live tile creation when users pin a site to Start from Microsoft Edge.'
        ),
    ] = None
    edge_block_password_manager: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to Block password manager.'),
    ] = None
    edge_block_popups: Annotated[
        Optional[bool], Field(description='Indicates whether or not to block popups.')
    ] = None
    edge_block_search_suggestions: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from using the search suggestions in the address bar.'
        ),
    ] = None
    edge_block_sending_do_not_track_header: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to Block the user from sending the do not track header.'
        ),
    ] = None
    edge_block_sending_intranet_traffic_to_internet_explorer: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to switch the intranet traffic from Edge to Internet Explorer. Note: the name of this property is misleading; the property is obsolete, use EdgeSendIntranetTrafficToInternetExplorer instead.'
        ),
    ] = None
    edge_clear_browsing_data_on_exit: Annotated[
        Optional[bool],
        Field(description='Clear browsing data on exiting Microsoft Edge.'),
    ] = None
    edge_cookie_policy: Optional[EdgeCookiePolicy] = None
    edge_disable_first_run_page: Annotated[
        Optional[bool],
        Field(
            description='Block the Microsoft web page that opens on the first use of Microsoft Edge. This policy allows enterprises, like those enrolled in zero emissions configurations, to block this page.'
        ),
    ] = None
    edge_enterprise_mode_site_list_location: Annotated[
        Optional[str],
        Field(
            description='Indicates the enterprise mode site list location. Could be a local file, local network or http location.'
        ),
    ] = None
    edge_first_run_url: Annotated[
        Optional[str],
        Field(
            description='The first run URL for when Edge browser is opened for the first time.'
        ),
    ] = None
    edge_homepage_urls: Annotated[
        Optional[List[str]],
        Field(
            description='The list of URLs for homepages shodwn on MDM-enrolled devices on Edge browser.'
        ),
    ] = None
    edge_require_smart_screen: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to Require the user to use the smart screen filter.'
        ),
    ] = None
    edge_search_engine: Annotated[
        Optional[Union[EdgeSearchEngineBase, Dict[str, Any]]],
        Field(
            description='Allows IT admins to set a default search engine for MDM-Controlled devices. Users can override this and change their default search engine provided the AllowSearchEngineCustomization policy is not set.'
        ),
    ] = None
    edge_send_intranet_traffic_to_internet_explorer: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to switch the intranet traffic from Edge to Internet Explorer.'
        ),
    ] = None
    edge_sync_favorites_with_internet_explorer: Annotated[
        Optional[bool],
        Field(
            description='Enable favorites sync between Internet Explorer and Microsoft Edge. Additions, deletions, modifications and order changes to favorites are shared between browsers.'
        ),
    ] = None
    enterprise_cloud_print_discovery_end_point: Annotated[
        Optional[str], Field(description='Endpoint for discovering cloud printers.')
    ] = None
    enterprise_cloud_print_discovery_max_limit: Annotated[
        Optional[float],
        Field(
            description='Maximum number of printers that should be queried from a discovery endpoint. This is a mobile only setting. Valid values 1 to 65535',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    enterprise_cloud_print_mopria_discovery_resource_identifier: Annotated[
        Optional[str],
        Field(
            description='OAuth resource URI for printer discovery service as configured in Azure portal.'
        ),
    ] = None
    enterprise_cloud_print_o_auth_authority: Annotated[
        Optional[str],
        Field(description='Authentication endpoint for acquiring OAuth tokens.'),
    ] = None
    enterprise_cloud_print_o_auth_client_identifier: Annotated[
        Optional[str],
        Field(
            description='GUID of a client application authorized to retrieve OAuth tokens from the OAuth Authority.'
        ),
    ] = None
    enterprise_cloud_print_resource_identifier: Annotated[
        Optional[str],
        Field(
            description='OAuth resource URI for print service as configured in the Azure portal.'
        ),
    ] = None
    experience_block_device_discovery: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to enable device discovery UX.'),
    ] = None
    experience_block_error_dialog_when_no_sim: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to allow the error dialog from displaying if no SIM card is detected.'
        ),
    ] = None
    experience_block_task_switcher: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to enable task switching on the device.'
        ),
    ] = None
    game_dvr_blocked: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block DVR and broadcasting.'),
    ] = None
    internet_sharing_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to Block the user from using internet sharing.'
        ),
    ] = None
    location_services_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to Block the user from location services.'
        ),
    ] = None
    lock_screen_allow_timeout_configuration: Annotated[
        Optional[bool],
        Field(
            description='Specify whether to show a user-configurable setting to control the screen timeout while on the lock screen of Windows 10 Mobile devices. If this policy is set to Allow, the value set by lockScreenTimeoutInSeconds is ignored.'
        ),
    ] = None
    lock_screen_block_action_center_notifications: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block action center notifications over lock screen.'
        ),
    ] = None
    lock_screen_block_cortana: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not the user can interact with Cortana using speech while the system is locked.'
        ),
    ] = None
    lock_screen_block_toast_notifications: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether to allow toast notifications above the device lock screen.'
        ),
    ] = None
    lock_screen_timeout_in_seconds: Annotated[
        Optional[float],
        Field(
            description='Set the duration (in seconds) from the screen locking to the screen turning off for Windows 10 Mobile devices. Supported values are 11-1800. Valid values 11 to 1800',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    logon_block_fast_user_switching: Annotated[
        Optional[bool],
        Field(
            description='Disables the ability to quickly switch between users that are logged on simultaneously without logging off.'
        ),
    ] = None
    microsoft_account_blocked: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to Block a Microsoft account.'),
    ] = None
    microsoft_account_block_settings_sync: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to Block Microsoft account settings sync.'
        ),
    ] = None
    network_proxy_apply_settings_device_wide: Annotated[
        Optional[bool],
        Field(
            description='If set, proxy settings will be applied to all processes and accounts in the device. Otherwise, it will be applied to the user account thats enrolled into MDM.'
        ),
    ] = None
    network_proxy_automatic_configuration_url: Annotated[
        Optional[str],
        Field(
            description='Address to the proxy auto-config (PAC) script you want to use.'
        ),
    ] = None
    network_proxy_disable_auto_detect: Annotated[
        Optional[bool],
        Field(
            description='Disable automatic detection of settings. If enabled, the system will try to find the path to a proxy auto-config (PAC) script.'
        ),
    ] = None
    network_proxy_server: Annotated[
        Optional[Union[Windows10NetworkProxyServer, Dict[str, Any]]],
        Field(description='Specifies manual proxy server settings.'),
    ] = None
    nfc_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to Block the user from using near field communication.'
        ),
    ] = None
    one_drive_disable_file_sync: Annotated[
        Optional[bool],
        Field(
            description='Gets or sets a value allowing IT admins to prevent apps and features from working with files on OneDrive.'
        ),
    ] = None
    password_block_simple: Annotated[
        Optional[bool],
        Field(
            description="Specify whether PINs or passwords such as '1111' or '1234' are allowed. For Windows 10 desktops, it also controls the use of picture passwords."
        ),
    ] = None
    password_expiration_days: Annotated[
        Optional[float],
        Field(
            description='The password expiration in days. Valid values 0 to 730',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minimum_character_set_count: Annotated[
        Optional[float],
        Field(
            description='The number of character sets required in the password.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minimum_length: Annotated[
        Optional[float],
        Field(
            description='The minimum password length. Valid values 4 to 16',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minutes_of_inactivity_before_screen_timeout: Annotated[
        Optional[float],
        Field(
            description='The minutes of inactivity before the screen times out.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_previous_password_block_count: Annotated[
        Optional[float],
        Field(
            description='The number of previous passwords to prevent reuse of. Valid values 0 to 50',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_required: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to require the user to have a password.'
        ),
    ] = None
    password_required_type: Optional[RequiredPasswordType] = None
    password_require_when_resume_from_idle_state: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to require a password upon resuming from an idle state.'
        ),
    ] = None
    password_sign_in_failure_count_before_factory_reset: Annotated[
        Optional[float],
        Field(
            description='The number of sign in failures before factory reset. Valid values 0 to 999',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    personalization_desktop_image_url: Annotated[
        Optional[str],
        Field(
            description='A http or https Url to a jpg, jpeg or png image that needs to be downloaded and used as the Desktop Image or a file Url to a local image on the file system that needs to used as the Desktop Image.'
        ),
    ] = None
    personalization_lock_screen_image_url: Annotated[
        Optional[str],
        Field(
            description='A http or https Url to a jpg, jpeg or png image that neeeds to be downloaded and used as the Lock Screen Image or a file Url to a local image on the file system that needs to be used as the Lock Screen Image.'
        ),
    ] = None
    privacy_advertising_id: Optional[StateManagementSetting] = None
    privacy_auto_accept_pairing_and_consent_prompts: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to allow the automatic acceptance of the pairing and privacy user consent dialog when launching apps.'
        ),
    ] = None
    privacy_block_input_personalization: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the usage of cloud based speech services for Cortana, Dictation, or Store applications.'
        ),
    ] = None
    reset_protection_mode_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to Block the user from reset protection mode.'
        ),
    ] = None
    safe_search_filter: Optional[SafeSearchFilterType] = None
    screen_capture_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to Block the user from taking Screenshots.'
        ),
    ] = None
    search_block_diacritics: Annotated[
        Optional[bool], Field(description='Specifies if search can use diacritics.')
    ] = None
    search_disable_auto_language_detection: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether to use automatic language detection when indexing content and properties.'
        ),
    ] = None
    search_disable_indexer_backoff: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to disable the search indexer backoff feature.'
        ),
    ] = None
    search_disable_indexing_encrypted_items: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block indexing of WIP-protected items to prevent them from appearing in search results for Cortana or Explorer.'
        ),
    ] = None
    search_disable_indexing_removable_drive: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to allow users to add locations on removable drives to libraries and to be indexed.'
        ),
    ] = None
    search_enable_automatic_index_size_manangement: Annotated[
        Optional[bool],
        Field(
            description='Specifies minimum amount of hard drive space on the same drive as the index location before indexing stops.'
        ),
    ] = None
    search_enable_remote_queries: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block remote queries of this computers index.'
        ),
    ] = None
    settings_block_accounts_page: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block access to Accounts in Settings app.'
        ),
    ] = None
    settings_block_add_provisioning_package: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from installing provisioning packages.'
        ),
    ] = None
    settings_block_apps_page: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block access to Apps in Settings app.'
        ),
    ] = None
    settings_block_change_language: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from changing the language settings.'
        ),
    ] = None
    settings_block_change_power_sleep: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from changing power and sleep settings.'
        ),
    ] = None
    settings_block_change_region: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from changing the region settings.'
        ),
    ] = None
    settings_block_change_system_time: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from changing date and time settings.'
        ),
    ] = None
    settings_block_devices_page: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block access to Devices in Settings app.'
        ),
    ] = None
    settings_block_ease_of_access_page: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block access to Ease of Access in Settings app.'
        ),
    ] = None
    settings_block_edit_device_name: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from editing the device name.'
        ),
    ] = None
    settings_block_gaming_page: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block access to Gaming in Settings app.'
        ),
    ] = None
    settings_block_network_internet_page: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block access to Network & Internet in Settings app.'
        ),
    ] = None
    settings_block_personalization_page: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block access to Personalization in Settings app.'
        ),
    ] = None
    settings_block_privacy_page: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block access to Privacy in Settings app.'
        ),
    ] = None
    settings_block_remove_provisioning_package: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the runtime configuration agent from removing provisioning packages.'
        ),
    ] = None
    settings_block_settings_app: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block access to Settings app.'),
    ] = None
    settings_block_system_page: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block access to System in Settings app.'
        ),
    ] = None
    settings_block_time_language_page: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block access to Time & Language in Settings app.'
        ),
    ] = None
    settings_block_update_security_page: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block access to Update & Security in Settings app.'
        ),
    ] = None
    shared_user_app_data_allowed: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block multiple users of the same app to share data.'
        ),
    ] = None
    smart_screen_block_prompt_override: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not users can override SmartScreen Filter warnings about potentially malicious websites.'
        ),
    ] = None
    smart_screen_block_prompt_override_for_files: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not users can override the SmartScreen Filter warnings about downloading unverified files'
        ),
    ] = None
    smart_screen_enable_app_install_control: Annotated[
        Optional[bool],
        Field(
            description='This property will be deprecated in July 2019 and will be replaced by property SmartScreenAppInstallControl. Allows IT Admins to control whether users are allowed to install apps from places other than the Store.'
        ),
    ] = None
    start_block_unpinning_apps_from_taskbar: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the user from unpinning apps from taskbar.'
        ),
    ] = None
    start_menu_app_list_visibility: Optional[WindowsStartMenuAppListVisibilityType] = (
        None
    )
    start_menu_hide_change_account_settings: Annotated[
        Optional[bool],
        Field(
            description='Enabling this policy hides the change account setting from appearing in the user tile in the start menu.'
        ),
    ] = None
    start_menu_hide_frequently_used_apps: Annotated[
        Optional[bool],
        Field(
            description='Enabling this policy hides the most used apps from appearing on the start menu and disables the corresponding toggle in the Settings app.'
        ),
    ] = None
    start_menu_hide_hibernate: Annotated[
        Optional[bool],
        Field(
            description='Enabling this policy hides hibernate from appearing in the power button in the start menu.'
        ),
    ] = None
    start_menu_hide_lock: Annotated[
        Optional[bool],
        Field(
            description='Enabling this policy hides lock from appearing in the user tile in the start menu.'
        ),
    ] = None
    start_menu_hide_power_button: Annotated[
        Optional[bool],
        Field(
            description='Enabling this policy hides the power button from appearing in the start menu.'
        ),
    ] = None
    start_menu_hide_recent_jump_lists: Annotated[
        Optional[bool],
        Field(
            description='Enabling this policy hides recent jump lists from appearing on the start menu/taskbar and disables the corresponding toggle in the Settings app.'
        ),
    ] = None
    start_menu_hide_recently_added_apps: Annotated[
        Optional[bool],
        Field(
            description='Enabling this policy hides recently added apps from appearing on the start menu and disables the corresponding toggle in the Settings app.'
        ),
    ] = None
    start_menu_hide_restart_options: Annotated[
        Optional[bool],
        Field(
            description="Enabling this policy hides 'Restart/Update and Restart' from appearing in the power button in the start menu."
        ),
    ] = None
    start_menu_hide_shut_down: Annotated[
        Optional[bool],
        Field(
            description='Enabling this policy hides shut down/update and shut down from appearing in the power button in the start menu.'
        ),
    ] = None
    start_menu_hide_sign_out: Annotated[
        Optional[bool],
        Field(
            description='Enabling this policy hides sign out from appearing in the user tile in the start menu.'
        ),
    ] = None
    start_menu_hide_sleep: Annotated[
        Optional[bool],
        Field(
            description='Enabling this policy hides sleep from appearing in the power button in the start menu.'
        ),
    ] = None
    start_menu_hide_switch_account: Annotated[
        Optional[bool],
        Field(
            description='Enabling this policy hides switch account from appearing in the user tile in the start menu.'
        ),
    ] = None
    start_menu_hide_user_tile: Annotated[
        Optional[bool],
        Field(
            description='Enabling this policy hides the user tile from appearing in the start menu.'
        ),
    ] = None
    start_menu_layout_edge_assets_xml: Annotated[
        Optional[str],
        Field(
            description='This policy setting allows you to import Edge assets to be used with startMenuLayoutXml policy. Start layout can contain secondary tile from Edge app which looks for Edge local asset file. Edge local asset would not exist and cause Edge secondary tile to appear empty in this case. This policy only gets applied when startMenuLayoutXml policy is modified. The value should be a UTF-8 Base64 encoded byte array.'
        ),
    ] = None
    start_menu_layout_xml: Annotated[
        Optional[str],
        Field(
            description='Allows admins to override the default Start menu layout and prevents the user from changing it. The layout is modified by specifying an XML file based on a layout modification schema. XML needs to be in a UTF8 encoded byte array format.'
        ),
    ] = None
    start_menu_mode: Optional[WindowsStartMenuModeType] = None
    start_menu_pinned_folder_documents: Optional[VisibilitySetting] = None
    start_menu_pinned_folder_downloads: Optional[VisibilitySetting] = None
    start_menu_pinned_folder_file_explorer: Optional[VisibilitySetting] = None
    start_menu_pinned_folder_home_group: Optional[VisibilitySetting] = None
    start_menu_pinned_folder_music: Optional[VisibilitySetting] = None
    start_menu_pinned_folder_network: Optional[VisibilitySetting] = None
    start_menu_pinned_folder_personal_folder: Optional[VisibilitySetting] = None
    start_menu_pinned_folder_pictures: Optional[VisibilitySetting] = None
    start_menu_pinned_folder_settings: Optional[VisibilitySetting] = None
    start_menu_pinned_folder_videos: Optional[VisibilitySetting] = None
    storage_block_removable_storage: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to Block the user from using removable storage.'
        ),
    ] = None
    storage_require_mobile_device_encryption: Annotated[
        Optional[bool],
        Field(
            description='Indicating whether or not to require encryption on a mobile device.'
        ),
    ] = None
    storage_restrict_app_data_to_system_volume: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether application data is restricted to the system drive.'
        ),
    ] = None
    storage_restrict_app_install_to_system_volume: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the installation of applications is restricted to the system drive.'
        ),
    ] = None
    tenant_lockdown_require_network_during_out_of_box_experience: Annotated[
        Optional[bool],
        Field(description='Whether the device is required to connect to the network.'),
    ] = None
    usb_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to Block the user from USB connection.'
        ),
    ] = None
    voice_recording_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to Block the user from voice recording.'
        ),
    ] = None
    web_rtc_block_localhost_ip_address: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether or not user's localhost IP address is displayed while making phone calls using the WebRTC"
        ),
    ] = None
    wi_fi_block_automatic_connect_hotspots: Annotated[
        Optional[bool],
        Field(
            description='Indicating whether or not to block automatically connecting to Wi-Fi hotspots. Has no impact if Wi-Fi is blocked.'
        ),
    ] = None
    wi_fi_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to Block the user from using Wi-Fi.'
        ),
    ] = None
    wi_fi_block_manual_configuration: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to Block the user from using Wi-Fi manual configuration.'
        ),
    ] = None
    wi_fi_scan_interval: Annotated[
        Optional[float],
        Field(
            description='Specify how often devices scan for Wi-Fi networks. Supported values are 1-500, where 100 = default, and 500 = low frequency. Valid values 1 to 500',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    windows_spotlight_block_consumer_specific_features: Annotated[
        Optional[bool],
        Field(
            description='Allows IT admins to block experiences that are typically for consumers only, such as Start suggestions, Membership notifications, Post-OOBE app install and redirect tiles.'
        ),
    ] = None
    windows_spotlight_blocked: Annotated[
        Optional[bool],
        Field(
            description='Allows IT admins to turn off all Windows Spotlight features'
        ),
    ] = None
    windows_spotlight_block_on_action_center: Annotated[
        Optional[bool],
        Field(
            description='Block suggestions from Microsoft that show after each OS clean install, upgrade or in an on-going basis to introduce users to what is new or changed'
        ),
    ] = None
    windows_spotlight_block_tailored_experiences: Annotated[
        Optional[bool],
        Field(
            description='Block personalized content in Windows spotlight based on users device usage.'
        ),
    ] = None
    windows_spotlight_block_third_party_notifications: Annotated[
        Optional[bool],
        Field(description='Block third party content delivered via Windows Spotlight'),
    ] = None
    windows_spotlight_block_welcome_experience: Annotated[
        Optional[bool],
        Field(description='Block Windows Spotlight Windows welcome experience'),
    ] = None
    windows_spotlight_block_windows_tips: Annotated[
        Optional[bool],
        Field(description='Allows IT admins to turn off the popup of Windows Tips.'),
    ] = None
    windows_spotlight_configure_on_lock_screen: Optional[
        WindowsSpotlightEnablementSettings
    ] = None
    windows_store_block_auto_update: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block automatic update of apps from Windows Store.'
        ),
    ] = None
    windows_store_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to Block the user from using the Windows store.'
        ),
    ] = None
    windows_store_enable_private_store_only: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to enable Private Store Only.'),
    ] = None
    wireless_display_block_projection_to_this_device: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to allow other devices from discovering this PC for projection.'
        ),
    ] = None
    wireless_display_block_user_input_from_receiver: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to allow user input from wireless display receiver.'
        ),
    ] = None
    wireless_display_require_pin_for_pairing: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to require a PIN for new devices to initiate pairing.'
        ),
    ] = None
    field_odata_type: str


class Windows10MobileCompliancePolicy(DeviceCompliancePolicy):
    bit_locker_enabled: Annotated[
        Optional[bool],
        Field(
            description='Require devices to be reported healthy by Windows Device Health Attestation - bit locker is enabled'
        ),
    ] = None
    code_integrity_enabled: Annotated[
        Optional[bool],
        Field(
            description='Require devices to be reported as healthy by Windows Device Health Attestation.'
        ),
    ] = None
    early_launch_anti_malware_driver_enabled: Annotated[
        Optional[bool],
        Field(
            description='Require devices to be reported as healthy by Windows Device Health Attestation - early launch antimalware driver is enabled.'
        ),
    ] = None
    os_maximum_version: Annotated[
        Optional[str], Field(description='Maximum Windows Phone version.')
    ] = None
    os_minimum_version: Annotated[
        Optional[str], Field(description='Minimum Windows Phone version.')
    ] = None
    password_block_simple: Annotated[
        Optional[bool],
        Field(description='Whether or not to block syncing the calendar.'),
    ] = None
    password_expiration_days: Annotated[
        Optional[float],
        Field(
            description='Number of days before password expiration. Valid values 1 to 255',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minimum_character_set_count: Annotated[
        Optional[float],
        Field(
            description='The number of character sets required in the password.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minimum_length: Annotated[
        Optional[float],
        Field(
            description='Minimum password length. Valid values 4 to 16',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minutes_of_inactivity_before_lock: Annotated[
        Optional[float],
        Field(
            description='Minutes of inactivity before a password is required.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_previous_password_block_count: Annotated[
        Optional[float],
        Field(
            description='The number of previous passwords to prevent re-use of.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_required: Annotated[
        Optional[bool],
        Field(description='Require a password to unlock Windows Phone device.'),
    ] = None
    password_required_type: Optional[RequiredPasswordType] = None
    password_require_to_unlock_from_idle: Annotated[
        Optional[bool],
        Field(description='Require a password to unlock an idle device.'),
    ] = None
    secure_boot_enabled: Annotated[
        Optional[bool],
        Field(
            description='Require devices to be reported as healthy by Windows Device Health Attestation - secure boot is enabled.'
        ),
    ] = None
    storage_require_encryption: Annotated[
        Optional[bool], Field(description='Require encryption on windows devices.')
    ] = None
    field_odata_type: str


class Windows10SecureAssessmentConfiguration(DeviceConfiguration):
    allow_printing: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to allow the app from printing during the test.'
        ),
    ] = None
    allow_screen_capture: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to allow screen capture capability during a test.'
        ),
    ] = None
    allow_text_suggestion: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to allow text suggestions during the test.'
        ),
    ] = None
    configuration_account: Annotated[
        Optional[str],
        Field(
            description='The account used to configure the Windows device for taking the test. The user can be a domain account (domain/user), an AAD account (username@tenant.com) or a local account (username).'
        ),
    ] = None
    launch_uri: Annotated[
        Optional[str],
        Field(
            description="Url link to an assessment that's automatically loaded when the secure assessment browser is launched. It has to be a valid Url (http[s]://msdn.microsoft.com/)."
        ),
    ] = None
    field_odata_type: str


class Windows10TeamGeneralConfiguration(DeviceConfiguration):
    azure_operational_insights_block_telemetry: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to Block Azure Operational Insights.'
        ),
    ] = None
    azure_operational_insights_workspace_id: Annotated[
        Optional[str], Field(description='The Azure Operational Insights workspace id.')
    ] = None
    azure_operational_insights_workspace_key: Annotated[
        Optional[str],
        Field(description='The Azure Operational Insights Workspace key.'),
    ] = None
    connect_app_block_auto_launch: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether to automatically launch the Connect app whenever a projection is initiated.'
        ),
    ] = None
    maintenance_window_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to Block setting a maintenance window for device updates.'
        ),
    ] = None
    maintenance_window_duration_in_hours: Annotated[
        Optional[float],
        Field(
            description='Maintenance window duration for device updates. Valid values 0 to 5',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    maintenance_window_start_time: Annotated[
        Optional[time],
        Field(
            description='Maintenance window start time for device updates.',
        ),
    ] = None
    miracast_blocked: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to Block wireless projection.'),
    ] = None
    miracast_channel: Optional[MiracastChannel] = None
    miracast_require_pin: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to require a pin for wireless projection.'
        ),
    ] = None
    settings_block_my_meetings_and_files: Annotated[
        Optional[bool],
        Field(
            description="Specifies whether to disable the 'My meetings and files' feature in the Start menu, which shows the signed-in user's meetings and files from Office 365."
        ),
    ] = None
    settings_block_session_resume: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether to allow the ability to resume a session when the session times out.'
        ),
    ] = None
    settings_block_signin_suggestions: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether to disable auto-populating of the sign-in dialog with invitees from scheduled meetings.'
        ),
    ] = None
    settings_default_volume: Annotated[
        Optional[float],
        Field(
            description='Specifies the default volume value for a new session. Permitted values are 0-100. The default is 45. Valid values 0 to 100',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    settings_screen_timeout_in_minutes: Annotated[
        Optional[float],
        Field(
            description='Specifies the number of minutes until the Hub screen turns off.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    settings_session_timeout_in_minutes: Annotated[
        Optional[float],
        Field(
            description='Specifies the number of minutes until the session times out.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    settings_sleep_timeout_in_minutes: Annotated[
        Optional[float],
        Field(
            description='Specifies the number of minutes until the Hub enters sleep mode.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    welcome_screen_background_image_url: Annotated[
        Optional[str],
        Field(
            description='The welcome screen background image URL. The URL must use the HTTPS protocol and return a PNG image.'
        ),
    ] = None
    welcome_screen_block_automatic_wake_up: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to Block the welcome screen from waking up automatically when someone enters the room.'
        ),
    ] = None
    welcome_screen_meeting_information: Optional[WelcomeScreenMeetingInformation] = None
    field_odata_type: str


class Windows81CompliancePolicy(DeviceCompliancePolicy):
    os_maximum_version: Annotated[
        Optional[str], Field(description='Maximum Windows 8.1 version.')
    ] = None
    os_minimum_version: Annotated[
        Optional[str], Field(description='Minimum Windows 8.1 version.')
    ] = None
    password_block_simple: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block simple password.'),
    ] = None
    password_expiration_days: Annotated[
        Optional[float],
        Field(
            description='Password expiration in days.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minimum_character_set_count: Annotated[
        Optional[float],
        Field(
            description='The number of character sets required in the password.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minimum_length: Annotated[
        Optional[float],
        Field(
            description='The minimum password length.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minutes_of_inactivity_before_lock: Annotated[
        Optional[float],
        Field(
            description='Minutes of inactivity before a password is required.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_previous_password_block_count: Annotated[
        Optional[float],
        Field(
            description='The number of previous passwords to prevent re-use of. Valid values 0 to 24',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_required: Annotated[
        Optional[bool],
        Field(description='Require a password to unlock Windows device.'),
    ] = None
    password_required_type: Optional[RequiredPasswordType] = None
    storage_require_encryption: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to require encryption on a windows 8.1 device.'
        ),
    ] = None
    field_odata_type: str


class Windows81GeneralConfiguration(DeviceConfiguration):
    accounts_block_adding_non_microsoft_account_email: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to Block the user from adding email accounts to the device that are not associated with a Microsoft account.'
        ),
    ] = None
    apply_only_to_windows81: Annotated[
        Optional[bool],
        Field(
            description='Value indicating whether this policy only applies to Windows 8.1. This property is read-only.'
        ),
    ] = None
    browser_block_autofill: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block auto fill.'),
    ] = None
    browser_block_automatic_detection_of_intranet_sites: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block automatic detection of Intranet sites.'
        ),
    ] = None
    browser_block_enterprise_mode_access: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block enterprise mode access.'),
    ] = None
    browser_block_java_script: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to Block the user from using JavaScript.'
        ),
    ] = None
    browser_block_plugins: Annotated[
        Optional[bool], Field(description='Indicates whether or not to block plug-ins.')
    ] = None
    browser_block_popups: Annotated[
        Optional[bool], Field(description='Indicates whether or not to block popups.')
    ] = None
    browser_block_sending_do_not_track_header: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to Block the user from sending the do not track header.'
        ),
    ] = None
    browser_block_single_word_entry_on_intranet_sites: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block a single word entry on Intranet sites.'
        ),
    ] = None
    browser_enterprise_mode_site_list_location: Annotated[
        Optional[str],
        Field(
            description='The enterprise mode site list location. Could be a local file, local network or http location.'
        ),
    ] = None
    browser_internet_security_level: Optional[InternetSiteSecurityLevel] = None
    browser_intranet_security_level: Optional[SiteSecurityLevel] = None
    browser_logging_report_location: Annotated[
        Optional[str], Field(description='The logging report location.')
    ] = None
    browser_require_firewall: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to require a firewall.'),
    ] = None
    browser_require_fraud_warning: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to require fraud warning.'),
    ] = None
    browser_require_high_security_for_restricted_sites: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to require high security for restricted sites.'
        ),
    ] = None
    browser_require_smart_screen: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to require the user to use the smart screen filter.'
        ),
    ] = None
    browser_trusted_sites_security_level: Optional[SiteSecurityLevel] = None
    cellular_block_data_roaming: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block data roaming.'),
    ] = None
    diagnostics_block_data_submission: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block diagnostic data submission.'
        ),
    ] = None
    password_block_picture_password_and_pin: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to Block the user from using a pictures password and pin.'
        ),
    ] = None
    password_expiration_days: Annotated[
        Optional[float],
        Field(
            description='Password expiration in days.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minimum_character_set_count: Annotated[
        Optional[float],
        Field(
            description='The number of character sets required in the password.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minimum_length: Annotated[
        Optional[float],
        Field(
            description='The minimum password length.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minutes_of_inactivity_before_screen_timeout: Annotated[
        Optional[float],
        Field(
            description='The minutes of inactivity before the screen times out.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_previous_password_block_count: Annotated[
        Optional[float],
        Field(
            description='The number of previous passwords to prevent re-use of. Valid values 0 to 24',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_required_type: Optional[RequiredPasswordType] = None
    password_sign_in_failure_count_before_factory_reset: Annotated[
        Optional[float],
        Field(
            description='The number of sign in failures before factory reset.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    storage_require_device_encryption: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to require encryption on a mobile device.'
        ),
    ] = None
    updates_require_automatic_updates: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to require automatic updates.'),
    ] = None
    user_account_control_settings: Optional[WindowsUserAccountControlSettings] = None
    work_folders_url: Annotated[
        Optional[str], Field(description='The work folders url.')
    ] = None
    field_odata_type: str


class WindowsAppX(MobileLobApp):
    applicable_architectures: Optional[WindowsArchitecture] = None
    identity_name: Annotated[
        Optional[str],
        Field(
            description="The identity name of the uploaded app package. For example: 'Contoso.DemoApp'."
        ),
    ] = None
    identity_publisher_hash: Annotated[
        Optional[str],
        Field(
            description="The identity publisher hash of the uploaded app package. This is the hash of the publisher from the manifest. For example: 'AB82CD0XYZ'."
        ),
    ] = None
    identity_resource_identifier: Annotated[
        Optional[str],
        Field(
            description="The identity resource identifier of the uploaded app package. For example: 'TestResourceId'."
        ),
    ] = None
    identity_version: Annotated[
        Optional[str],
        Field(
            description="The identity version of the uploaded app package. For example: '1.0.0.0'."
        ),
    ] = None
    is_bundle: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates that the app is a bundle. When FALSE, indicates that the app is not a bundle. By default, property is set to FALSE.'
        ),
    ] = None
    minimum_supported_operating_system: Optional[WindowsMinimumOperatingSystem] = None
    field_odata_type: str


class WindowsAutopilotDeploymentProfile(Entity):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description="The date and time of when the deployment profile was created. The value cannot be modified and is automatically populated when the profile was created. The timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look like this: '2014-01-01T00:00:00Z'. Supports: $select, $top, $skip. $Search, $orderBy and $filter are not supported. Read-Only.",
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='A description of the deployment profile. Max allowed length is 1500 chars. Supports: $select, $top, $skip, $orderBy. $Search and $filter are not supported.'
        ),
    ] = None
    device_name_template: Annotated[
        Optional[str],
        Field(
            description='The template used to name the Autopilot device. This can be a custom text and can also contain either the serial number of the device, or a randomly generated number. The total length of the text generated by the template can be no more than 15 characters. Supports: $select, $top, $skip. $Search, $orderBy and $filter are not supported.'
        ),
    ] = None
    device_type: Optional[WindowsAutopilotDeviceType] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='The display name of the deployment profile. Max allowed length is 200 chars. Returned by default. Supports: $select, $top, $skip, $orderby. $Search and $filter are not supported.'
        ),
    ] = None
    hardware_hash_extraction_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the profile supports the extraction of hardware hash values and registration of the device into Windows Autopilot. When TRUE, indicates if hardware extraction and Windows Autopilot registration will happen on the next successful check-in. When FALSE, hardware hash extraction and Windows Autopilot registration will not happen. Default value is FALSE. Supports: $select, $top, $skip. $Search, $orderBy and $filter are not supported.'
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description="The date and time of when the deployment profile was last modified. The value cannot be updated manually and is automatically populated when any changes are made to the profile. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look like this: '2014-01-01T00:00:00Z'. Supports: $select, $top, $skip. $Search, $orderBy and $filter are not supported Read-Only.",
        ),
    ] = None
    locale: Annotated[
        Optional[str],
        Field(
            description='The locale (language) to be used when configuring the device. E.g. en-US. The default value is os-default. Supports: $select, $top, $skip. $Search, $orderBy and $filter are not supported.'
        ),
    ] = None
    management_service_app_id: Annotated[
        Optional[str],
        Field(
            description='The Entra management service App ID which gets used during client device-based enrollment discovery. Supports: $select, $top, $skip. $Search, $orderBy and $filter are not supported.'
        ),
    ] = None
    out_of_box_experience_setting: Annotated[
        Optional[Union[OutOfBoxExperienceSetting, Dict[str, Any]]],
        Field(
            description='The Windows Autopilot Deployment Profile settings used by the device for the out-of-box experience. Supports: $select, $top, $skip. $Search, $orderBy and $filter are not supported.'
        ),
    ] = None
    preprovisioning_allowed: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the user is allowed to use Windows Autopilot for pre-provisioned deployment mode during Out of Box experience (OOBE). When TRUE, indicates that Windows Autopilot for pre-provisioned deployment mode for OOBE is allowed to be used. When false, Windows Autopilot for pre-provisioned deployment mode for OOBE is not allowed. The default is FALSE.'
        ),
    ] = None
    role_scope_tag_ids: Annotated[
        Optional[List[str]],
        Field(description='List of role scope tags for the deployment profile. '),
    ] = None
    assigned_devices: Annotated[
        Optional[List[WindowsAutopilotDeviceIdentity]],
        Field(description='The list of assigned devices for the profile.'),
    ] = None
    field_odata_type: str


class WindowsDefenderAdvancedThreatProtectionConfiguration(DeviceConfiguration):
    allow_sample_sharing: Annotated[
        Optional[bool],
        Field(
            description="Windows Defender AdvancedThreatProtection 'Allow Sample Sharing' Rule"
        ),
    ] = None
    enable_expedited_telemetry_reporting: Annotated[
        Optional[bool],
        Field(
            description='Expedite Windows Defender Advanced Threat Protection telemetry reporting frequency.'
        ),
    ] = None
    field_odata_type: str


class WindowsHelloForBusinessAuthenticationMethod(AuthenticationMethod):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time that this Windows Hello for Business key was registered.',
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='The name of the device on which Windows Hello for Business is registered'
        ),
    ] = None
    key_strength: Annotated[
        Optional[Union[AuthenticationMethodKeyStrength, Dict[str, Any]]],
        Field(
            description='Key strength of this Windows Hello for Business key. Possible values are: normal, weak, unknown.'
        ),
    ] = None
    device: Annotated[
        Optional[Union[Device, Dict[str, Any]]],
        Field(
            description="The registered device on which this Windows Hello for Business key resides. Supports $expand. When you get a user's Windows Hello for Business registration information, this property is returned only on a single GET and when you specify ?$expand. For example, GET /users/admin@contoso.com/authentication/windowsHelloForBusinessMethods/_jpuR-TGZtk6aQCLF3BQjA2?$expand=device."
        ),
    ] = None
    field_odata_type: str


class WindowsMicrosoftEdgeApp(MobileApp):
    channel: Optional[MicrosoftEdgeChannel] = None
    display_language_locale: Annotated[
        Optional[str],
        Field(
            description='The language locale to use when the Edge app displays text to the user.'
        ),
    ] = None
    field_odata_type: str


class WindowsMobileMSI(MobileLobApp):
    command_line: Annotated[Optional[str], Field(description='The command line.')] = (
        None
    )
    ignore_version_detection: Annotated[
        Optional[bool],
        Field(
            description="A boolean to control whether the app's version will be used to detect the app after it is installed on a device. Set this to true for Windows Mobile MSI Line of Business (LoB) apps that use a self update feature."
        ),
    ] = None
    product_code: Annotated[Optional[str], Field(description='The product code.')] = (
        None
    )
    product_version: Annotated[
        Optional[str],
        Field(
            description='The product version of Windows Mobile MSI Line of Business (LoB) app.'
        ),
    ] = None
    field_odata_type: str


class WindowsPhone81CompliancePolicy(DeviceCompliancePolicy):
    os_maximum_version: Annotated[
        Optional[str], Field(description='Maximum Windows Phone version.')
    ] = None
    os_minimum_version: Annotated[
        Optional[str], Field(description='Minimum Windows Phone version.')
    ] = None
    password_block_simple: Annotated[
        Optional[bool],
        Field(description='Whether or not to block syncing the calendar.'),
    ] = None
    password_expiration_days: Annotated[
        Optional[float],
        Field(
            description='Number of days before the password expires.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minimum_character_set_count: Annotated[
        Optional[float],
        Field(
            description='The number of character sets required in the password.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minimum_length: Annotated[
        Optional[float],
        Field(
            description='Minimum length of passwords.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minutes_of_inactivity_before_lock: Annotated[
        Optional[float],
        Field(
            description='Minutes of inactivity before a password is required.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_previous_password_block_count: Annotated[
        Optional[float],
        Field(
            description='Number of previous passwords to block. Valid values 0 to 24',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_required: Annotated[
        Optional[bool], Field(description='Whether or not to require a password.')
    ] = None
    password_required_type: Optional[RequiredPasswordType] = None
    storage_require_encryption: Annotated[
        Optional[bool],
        Field(description='Require encryption on windows phone devices.'),
    ] = None
    field_odata_type: str


class WindowsPhone81CustomConfiguration(DeviceConfiguration):
    oma_settings: Annotated[
        Optional[List[OmaSetting]],
        Field(
            description='OMA settings. This collection can contain a maximum of 1000 elements.'
        ),
    ] = None
    field_odata_type: str


class WindowsPhone81GeneralConfiguration(DeviceConfiguration):
    apply_only_to_windows_phone81: Annotated[
        Optional[bool],
        Field(
            description='Value indicating whether this policy only applies to Windows Phone 8.1. This property is read-only.'
        ),
    ] = None
    apps_block_copy_paste: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block copy paste.'),
    ] = None
    bluetooth_blocked: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block bluetooth.'),
    ] = None
    camera_blocked: Annotated[
        Optional[bool], Field(description='Indicates whether or not to block camera.')
    ] = None
    cellular_block_wifi_tethering: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block Wi-Fi tethering. Has no impact if Wi-Fi is blocked.'
        ),
    ] = None
    compliant_app_list_type: Optional[AppListType] = None
    compliant_apps_list: Annotated[
        Optional[List[AppListItem]],
        Field(
            description='List of apps in the compliance (either allow list or block list, controlled by CompliantAppListType). This collection can contain a maximum of 10000 elements.'
        ),
    ] = None
    diagnostic_data_block_submission: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block diagnostic data submission.'
        ),
    ] = None
    email_block_adding_accounts: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block custom email accounts.'),
    ] = None
    location_services_blocked: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block location services.'),
    ] = None
    microsoft_account_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block using a Microsoft Account.'
        ),
    ] = None
    nfc_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block Near-Field Communication.'
        ),
    ] = None
    password_block_simple: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block syncing the calendar.'),
    ] = None
    password_expiration_days: Annotated[
        Optional[float],
        Field(
            description='Number of days before the password expires.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minimum_character_set_count: Annotated[
        Optional[float],
        Field(
            description='Number of character sets a password must contain.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minimum_length: Annotated[
        Optional[float],
        Field(
            description='Minimum length of passwords.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minutes_of_inactivity_before_screen_timeout: Annotated[
        Optional[float],
        Field(
            description='Minutes of inactivity before screen timeout.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_previous_password_block_count: Annotated[
        Optional[float],
        Field(
            description='Number of previous passwords to block. Valid values 0 to 24',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_required: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to require a password.'),
    ] = None
    password_required_type: Optional[RequiredPasswordType] = None
    password_sign_in_failure_count_before_factory_reset: Annotated[
        Optional[float],
        Field(
            description='Number of sign in failures allowed before factory reset.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    screen_capture_blocked: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block screenshots.'),
    ] = None
    storage_block_removable_storage: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block removable storage.'),
    ] = None
    storage_require_encryption: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to require encryption.'),
    ] = None
    web_browser_blocked: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block the web browser.'),
    ] = None
    wifi_block_automatic_connect_hotspots: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block automatically connecting to Wi-Fi hotspots. Has no impact if Wi-Fi is blocked.'
        ),
    ] = None
    wifi_blocked: Annotated[
        Optional[bool], Field(description='Indicates whether or not to block Wi-Fi.')
    ] = None
    wifi_block_hotspot_reporting: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block Wi-Fi hotspot reporting. Has no impact if Wi-Fi is blocked.'
        ),
    ] = None
    windows_store_blocked: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block the Windows Store.'),
    ] = None
    field_odata_type: str


class WindowsUniversalAppX(MobileLobApp):
    applicable_architectures: Optional[WindowsArchitecture] = None
    applicable_device_types: Optional[WindowsDeviceType] = None
    identity_name: Annotated[Optional[str], Field(description='The Identity Name.')] = (
        None
    )
    identity_publisher_hash: Annotated[
        Optional[str], Field(description='The Identity Publisher Hash.')
    ] = None
    identity_resource_identifier: Annotated[
        Optional[str], Field(description='The Identity Resource Identifier.')
    ] = None
    identity_version: Annotated[
        Optional[str], Field(description='The identity version.')
    ] = None
    is_bundle: Annotated[
        Optional[bool], Field(description='Whether or not the app is a bundle.')
    ] = None
    minimum_supported_operating_system: Optional[WindowsMinimumOperatingSystem] = None
    committed_contained_apps: Annotated[
        Optional[List[MobileContainedApp]],
        Field(
            description='The collection of contained apps in the committed mobileAppContent of a windowsUniversalAppX app.'
        ),
    ] = None
    field_odata_type: str


class WindowsUpdateForBusinessConfiguration(DeviceConfiguration):
    allow_windows11_upgrade: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, allows eligible Windows 10 devices to upgrade to Windows 11. When FALSE, implies the device stays on the existing operating system. Returned by default. Query parameters are not supported.'
        ),
    ] = None
    automatic_update_mode: Optional[AutomaticUpdateMode] = None
    auto_restart_notification_dismissal: Optional[
        AutoRestartNotificationDismissalMethod
    ] = None
    business_ready_updates_only: Optional[WindowsUpdateType] = None
    deadline_for_feature_updates_in_days: Annotated[
        Optional[float],
        Field(
            description='Number of days before feature updates are installed automatically with valid range from 0 to 30 days. Returned by default. Query parameters are not supported.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    deadline_for_quality_updates_in_days: Annotated[
        Optional[float],
        Field(
            description='Number of days before quality updates are installed automatically with valid range from 0 to 30 days. Returned by default. Query parameters are not supported.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    deadline_grace_period_in_days: Annotated[
        Optional[float],
        Field(
            description='Number of days after deadline until restarts occur automatically with valid range from 0 to 7 days. Returned by default. Query parameters are not supported.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    delivery_optimization_mode: Optional[WindowsDeliveryOptimizationMode] = None
    drivers_excluded: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, excludes Windows update Drivers. When FALSE, does not exclude Windows update Drivers. Returned by default. Query parameters are not supported.'
        ),
    ] = None
    engaged_restart_deadline_in_days: Annotated[
        Optional[float],
        Field(
            description='Deadline in days before automatically scheduling and executing a pending restart outside of active hours, with valid range from 2 to 30 days. Returned by default. Query parameters are not supported.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    engaged_restart_snooze_schedule_in_days: Annotated[
        Optional[float],
        Field(
            description='Number of days a user can snooze Engaged Restart reminder notifications with valid range from 1 to 3 days. Returned by default. Query parameters are not supported.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    engaged_restart_transition_schedule_in_days: Annotated[
        Optional[float],
        Field(
            description='Number of days before transitioning from Auto Restarts scheduled outside of active hours to Engaged Restart, which requires the user to schedule, with valid range from 0 to 30 days. Returned by default. Query parameters are not supported.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    feature_updates_deferral_period_in_days: Annotated[
        Optional[float],
        Field(
            description='Defer Feature Updates by these many days with valid range from 0 to 30 days. Returned by default. Query parameters are not supported.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    feature_updates_paused: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, assigned devices are paused from receiving feature updates for up to 35 days from the time you pause the ring. When FALSE, does not pause Feature Updates. Returned by default. Query parameters are not supported.s'
        ),
    ] = None
    feature_updates_pause_expiry_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Feature Updates Pause Expiry datetime. This value is 35 days from the time admin paused or extended the pause for the ring. Returned by default. Query parameters are not supported.',
        ),
    ] = None
    feature_updates_pause_start_date: Annotated[
        Optional[date],
        Field(
            description='The Feature Updates Pause start date. This value is the time when the admin paused or extended the pause for the ring. Returned by default. Query parameters are not supported. This property is read-only.',
        ),
    ] = None
    feature_updates_rollback_start_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Feature Updates Rollback Start datetime.This value is the time when the admin rolled back the Feature update for the ring.Returned by default.Query parameters are not supported.',
        ),
    ] = None
    feature_updates_rollback_window_in_days: Annotated[
        Optional[float],
        Field(
            description='The number of days after a Feature Update for which a rollback is valid with valid range from 2 to 60 days. Returned by default. Query parameters are not supported.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    feature_updates_will_be_rolled_back: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, rollback Feature Updates on the next device check in. When FALSE, do not rollback Feature Updates on the next device check in. Returned by default.Query parameters are not supported.'
        ),
    ] = None
    installation_schedule: Annotated[
        Optional[Union[WindowsUpdateInstallScheduleType, Dict[str, Any]]],
        Field(
            description='The Installation Schedule. Possible values are: ActiveHoursStart, ActiveHoursEnd, ScheduledInstallDay, ScheduledInstallTime. Returned by default. Query parameters are not supported.'
        ),
    ] = None
    microsoft_update_service_allowed: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, allows Microsoft Update Service. When FALSE, does not allow Microsoft Update Service. Returned by default. Query parameters are not supported.'
        ),
    ] = None
    postpone_reboot_until_after_deadline: Annotated[
        Optional[bool],
        Field(
            description='When TRUE the device should wait until deadline for rebooting outside of active hours. When FALSE the device should not wait until deadline for rebooting outside of active hours. Returned by default. Query parameters are not supported.'
        ),
    ] = None
    prerelease_features: Optional[PrereleaseFeatures] = None
    quality_updates_deferral_period_in_days: Annotated[
        Optional[float],
        Field(
            description='Defer Quality Updates by these many days with valid range from 0 to 30 days. Returned by default. Query parameters are not supported.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    quality_updates_paused: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, assigned devices are paused from receiving quality updates for up to 35 days from the time you pause the ring. When FALSE, does not pause Quality Updates. Returned by default. Query parameters are not supported.'
        ),
    ] = None
    quality_updates_pause_expiry_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Quality Updates Pause Expiry datetime. This value is 35 days from the time admin paused or extended the pause for the ring. Returned by default. Query parameters are not supported.',
        ),
    ] = None
    quality_updates_pause_start_date: Annotated[
        Optional[date],
        Field(
            description='The Quality Updates Pause start date. This value is the time when the admin paused or extended the pause for the ring. Returned by default. Query parameters are not supported. This property is read-only.',
        ),
    ] = None
    quality_updates_rollback_start_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Quality Updates Rollback Start datetime. This value is the time when the admin rolled back the Quality update for the ring. Returned by default. Query parameters are not supported.',
        ),
    ] = None
    quality_updates_will_be_rolled_back: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, rollback Quality Updates on the next device check in. When FALSE, do not rollback Quality Updates on the next device check in. Returned by default. Query parameters are not supported.'
        ),
    ] = None
    schedule_imminent_restart_warning_in_minutes: Annotated[
        Optional[float],
        Field(
            description='Specify the period for auto-restart imminent warning notifications. Supported values: 15, 30 or 60 (minutes). Returned by default. Query parameters are not supported.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    schedule_restart_warning_in_hours: Annotated[
        Optional[float],
        Field(
            description='Specify the period for auto-restart warning reminder notifications. Supported values: 2, 4, 8, 12 or 24 (hours). Returned by default. Query parameters are not supported.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    skip_checks_before_restart: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, skips all checks before restart: Battery level = 40%, User presence, Display Needed, Presentation mode, Full screen mode, phone call state, game mode etc. When FALSE, does not skip all checks before restart. Returned by default. Query parameters are not supported.'
        ),
    ] = None
    update_notification_level: Optional[WindowsUpdateNotificationDisplayOption] = None
    update_weeks: Annotated[
        Optional[Union[WindowsUpdateForBusinessUpdateWeeks, Dict[str, Any]]],
        Field(
            description='Schedule the update installation on the weeks of the month. Possible values are: UserDefined, FirstWeek, SecondWeek, ThirdWeek, FourthWeek, EveryWeek. Returned by default. Query parameters are not supported. Possible values are: userDefined, firstWeek, secondWeek, thirdWeek, fourthWeek, everyWeek, unknownFutureValue.'
        ),
    ] = None
    user_pause_access: Optional[Enablement] = None
    user_windows_update_scan_access: Optional[Enablement] = None
    field_odata_type: str


class WindowsWebApp(MobileApp):
    app_url: Annotated[
        Optional[str],
        Field(
            description="Indicates the Windows web app URL. Example: 'https://www.contoso.com'"
        ),
    ] = None
    field_odata_type: str


class WorkbookChartAreaFormat(Entity):
    fill: Annotated[
        Optional[Union[WorkbookChartFill, Dict[str, Any]]],
        Field(
            description='Represents the fill format of an object, which includes background formatting information. Read-only.'
        ),
    ] = None
    font: Annotated[
        Optional[Union[WorkbookChartFont, Dict[str, Any]]],
        Field(
            description='Represents the font attributes (font name, font size, color, etc.) for the current object. Read-only.'
        ),
    ] = None
    field_odata_type: str


class WorkbookChartAxisFormat(Entity):
    font: Annotated[
        Optional[Union[WorkbookChartFont, Dict[str, Any]]],
        Field(
            description='Represents the font attributes (font name, font size, color, etc.) for a chart axis element. Read-only.'
        ),
    ] = None
    line: Annotated[
        Optional[Union[WorkbookChartLineFormat, Dict[str, Any]]],
        Field(description='Represents chart line formatting. Read-only.'),
    ] = None
    field_odata_type: str


class WorkbookChartAxisTitleFormat(Entity):
    font: Annotated[
        Optional[Union[WorkbookChartFont, Dict[str, Any]]],
        Field(
            description='Represents the font attributes, such as font name, font size, color, etc. of chart axis title object. Read-only.'
        ),
    ] = None
    field_odata_type: str


class WorkbookChartDataLabelFormat(Entity):
    fill: Annotated[
        Optional[Union[WorkbookChartFill, Dict[str, Any]]],
        Field(
            description='Represents the fill format of the current chart data label. Read-only.'
        ),
    ] = None
    font: Annotated[
        Optional[Union[WorkbookChartFont, Dict[str, Any]]],
        Field(
            description='Represents the font attributes (font name, font size, color, etc.) for a chart data label. Read-only.'
        ),
    ] = None
    field_odata_type: str


class WorkbookChartDataLabels(Entity):
    position: Annotated[
        Optional[str],
        Field(
            description='DataLabelPosition value that represents the position of the data label. The possible values are: None, Center, InsideEnd, InsideBase, OutsideEnd, Left, Right, Top, Bottom, BestFit, Callout.'
        ),
    ] = None
    separator: Annotated[
        Optional[str],
        Field(
            description='String that represents the separator used for the data labels on a chart.'
        ),
    ] = None
    show_bubble_size: Annotated[
        Optional[bool],
        Field(
            description='Boolean value that represents whether the data label bubble size is visible.'
        ),
    ] = None
    show_category_name: Annotated[
        Optional[bool],
        Field(
            description='Boolean value that represents whether the data label category name is visible.'
        ),
    ] = None
    show_legend_key: Annotated[
        Optional[bool],
        Field(
            description='Boolean value that represents whether the data label legend key is visible.'
        ),
    ] = None
    show_percentage: Annotated[
        Optional[bool],
        Field(
            description='Boolean value that represents whether the data label percentage is visible.'
        ),
    ] = None
    show_series_name: Annotated[
        Optional[bool],
        Field(
            description='Boolean value that represents whether the data label series name is visible.'
        ),
    ] = None
    show_value: Annotated[
        Optional[bool],
        Field(
            description='Boolean value that represents whether the data label value is visible.'
        ),
    ] = None
    format: Annotated[
        Optional[Union[WorkbookChartDataLabelFormat, Dict[str, Any]]],
        Field(
            description='Represents the format of chart data labels, which includes fill and font formatting. Read-only.'
        ),
    ] = None
    field_odata_type: str


class WorkbookChartGridlines(Entity):
    visible: Annotated[
        Optional[bool],
        Field(description='Indicates whether the axis gridlines are visible.'),
    ] = None
    format: Annotated[
        Optional[Union[WorkbookChartGridlinesFormat, Dict[str, Any]]],
        Field(description='Represents the formatting of chart gridlines. Read-only.'),
    ] = None
    field_odata_type: str


class WorkbookChartLegend(Entity):
    overlay: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the chart legend should overlap with the main body of the chart.'
        ),
    ] = None
    position: Annotated[
        Optional[str],
        Field(
            description='Represents the position of the legend on the chart. The possible values are: Top, Bottom, Left, Right, Corner, Custom.'
        ),
    ] = None
    visible: Annotated[
        Optional[bool],
        Field(description='Indicates whether the chart legend is visible.'),
    ] = None
    format: Annotated[
        Optional[Union[WorkbookChartLegendFormat, Dict[str, Any]]],
        Field(
            description='Represents the formatting of a chart legend, which includes fill and font formatting. Read-only.'
        ),
    ] = None
    field_odata_type: str


class WorkbookChartTitle(Entity):
    overlay: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the chart title will overlay the chart or not.'
        ),
    ] = None
    text: Annotated[
        Optional[str], Field(description='The title text of the chart.')
    ] = None
    visible: Annotated[
        Optional[bool],
        Field(description='Indicates whether the chart title is visible.'),
    ] = None
    format: Annotated[
        Optional[Union[WorkbookChartTitleFormat, Dict[str, Any]]],
        Field(
            description='The formatting of a chart title, which includes fill and font formatting. Read-only.'
        ),
    ] = None
    field_odata_type: str


class WorkbookFilter(Entity):
    criteria: Annotated[
        Optional[Union[WorkbookFilterCriteria, Dict[str, Any]]],
        Field(
            description='The currently applied filter on the given column. Read-only.'
        ),
    ] = None
    field_odata_type: str


class WorkbookTableColumn(Entity):
    index: Annotated[
        Optional[float],
        Field(
            description='The index of the column within the columns collection of the table. Zero-indexed. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    name: Annotated[
        Optional[str], Field(description='The name of the table column.')
    ] = None
    values: Annotated[
        Optional[Any],
        Field(
            description='TRepresents the raw values of the specified range. The data returned could be of type string, number, or a Boolean. Cell that contain an error will return the error string.'
        ),
    ] = None
    filter: Annotated[
        Optional[Union[WorkbookFilter, Dict[str, Any]]],
        Field(description='The filter applied to the column. Read-only.'),
    ] = None
    field_odata_type: str


class WorkforceIntegration(ChangeTrackedEntity):
    api_version: Annotated[
        Optional[float],
        Field(
            description='API version for the call back URL. Start with 1.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='Name of the workforce integration.')
    ] = None
    eligibility_filtering_enabled_entities: Annotated[
        Optional[Union[EligibilityFilteringEnabledEntities, Dict[str, Any]]],
        Field(
            description='Support to view eligibility-filtered results. Possible values are: none, swapRequest, offerShiftRequest, unknownFutureValue, timeOffReason. Use the Prefer: include-unknown-enum-members request header to get the following value in this evolvable enum: timeOffReason.'
        ),
    ] = None
    encryption: Annotated[
        Optional[Union[WorkforceIntegrationEncryption, Dict[str, Any]]],
        Field(description='The workforce integration encryption resource.'),
    ] = None
    is_active: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether this workforce integration is currently active and available.'
        ),
    ] = None
    supported_entities: Annotated[
        Optional[Union[WorkforceIntegrationSupportedEntities, Dict[str, Any]]],
        Field(
            description='The Shifts entities supported for synchronous change notifications. Shifts call back to the provided URL when client changes occur to the entities specified in this property. By default, no entities are supported for change notifications. Possible values are: none, shift, swapRequest, userShiftPreferences, openShift, openShiftRequest, offerShiftRequest, unknownFutureValue, timeOffReason, timeOff, timeOffRequest. Use the Prefer: include-unknown-enum-members request header to get the following values in this evolvable enum: timeOffReason, timeOff, timeOffRequest.'
        ),
    ] = None
    url: Annotated[
        Optional[str],
        Field(
            description='Workforce Integration URL for callbacks from the Shifts service.'
        ),
    ] = None
    field_odata_type: str


class AccessReviewInactiveUsersQueryScope(AccessReviewQueryScope):
    inactive_duration: Annotated[
        Optional[timedelta],
        Field(
            description="Defines the duration of inactivity. Inactivity is based on the last sign in date of the user compared to the access review instance's start date. If this property is not specified, it's assigned the default value PT0S.",
        ),
    ] = None
    field_odata_type: str


class ActionResultPart(BaseModel):
    error: Annotated[
        Optional[Union[PublicError, Dict[str, Any]]],
        Field(
            description='The error that occurred, if any, during the bulk operation.'
        ),
    ] = None
    field_odata_type: str


class AggregationOption(BaseModel):
    bucket_definition: Optional[BucketAggregationDefinition] = None
    field: Annotated[
        Optional[str],
        Field(
            description='Computes aggregation on the field while the field exists in the current entity type. Required.'
        ),
    ] = None
    size: Annotated[
        Optional[float],
        Field(
            description="The number of searchBucket resources to be returned. This isn't required when the range is provided manually in the search request. The minimum accepted size is 1, and the maximum is 65535. Optional.",
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class AppManagementConfiguration(BaseModel):
    key_credentials: Annotated[
        Optional[List[KeyCredentialConfiguration]],
        Field(
            description='Collection of keyCredential restrictions settings to be applied to an application or service principal.'
        ),
    ] = None
    password_credentials: Annotated[
        Optional[List[PasswordCredentialConfiguration]],
        Field(
            description='Collection of password restrictions settings to be applied to an application or service principal.'
        ),
    ] = None
    field_odata_type: str


class AppManagementServicePrincipalConfiguration(AppManagementConfiguration):
    field_odata_type: str


class AttackSimulationTrainingUserCoverage(BaseModel):
    attack_simulation_user: Annotated[
        Optional[Union[AttackSimulationUser, Dict[str, Any]]],
        Field(description='User in an attack simulation and training campaign.'),
    ] = None
    user_trainings: Annotated[
        Optional[List[UserTrainingStatusInfo]],
        Field(
            description='List of assigned trainings and their statuses for the user.'
        ),
    ] = None
    field_odata_type: str


class Attendee(AttendeeBase):
    proposed_new_time: Annotated[
        Optional[Union[TimeSlot, Dict[str, Any]]],
        Field(
            description="An alternate date/time proposed by the attendee for a meeting request to start and end. If the attendee hasn't proposed another time, then this property isn't included in a response of a GET event."
        ),
    ] = None
    status: Annotated[
        Optional[Union[ResponseStatus, Dict[str, Any]]],
        Field(
            description="The attendee's response (none, accepted, declined, etc.) for the event and date-time that the response was sent."
        ),
    ] = None
    field_odata_type: str


class AttendeeAvailability(BaseModel):
    attendee: Annotated[
        Optional[Union[AttendeeBase, Dict[str, Any]]],
        Field(
            description="The email address and type of attendee - whether it's a person or a resource, and whether required or optional if it's a person."
        ),
    ] = None
    availability: Annotated[
        Optional[Union[FreeBusyStatus, Dict[str, Any]]],
        Field(
            description='The availability status of the attendee. The possible values are: free, tentative, busy, oof, workingElsewhere, unknown.'
        ),
    ] = None
    field_odata_type: str


class AttributeDefinition(BaseModel):
    anchor: Annotated[
        Optional[bool],
        Field(
            description="true if the attribute should be used as the anchor for the object. Anchor attributes must have a unique value identifying an object, and must be immutable. Default is false. One, and only one, of the object's attributes must be designated as the anchor to support synchronization."
        ),
    ] = None
    api_expressions: Optional[List[StringKeyStringValuePair]] = None
    case_exact: Annotated[
        Optional[bool],
        Field(
            description='true if value of this attribute should be treated as case-sensitive. This setting affects how the synchronization engine detects changes for the attribute.'
        ),
    ] = None
    default_value: Annotated[
        Optional[str], Field(description='The default value of the attribute.')
    ] = None
    flow_null_values: Annotated[
        Optional[bool], Field(description="'true' to allow null values for attributes.")
    ] = None
    metadata: Annotated[
        Optional[List[AttributeDefinitionMetadataEntry]],
        Field(description='Metadata for the given object.'),
    ] = None
    multivalued: Annotated[
        Optional[bool],
        Field(
            description='true if an attribute can have multiple values. Default is false.'
        ),
    ] = None
    mutability: Optional[Mutability] = None
    name: Annotated[
        Optional[str],
        Field(
            description='Name of the attribute. Must be unique within the object definition. Not nullable.'
        ),
    ] = None
    referenced_objects: Annotated[
        Optional[List[ReferencedObject]],
        Field(
            description='For attributes with reference type, lists referenced objects (for example, the manager attribute would list User as the referenced object).'
        ),
    ] = None
    required: Annotated[
        Optional[bool],
        Field(
            description='true if attribute is required. Object can not be created if any of the required attributes are missing. If during synchronization, the required attribute has no value, the default value will be used. If default the value was not set, synchronization will record an error.'
        ),
    ] = None
    type: Optional[AttributeType] = None
    field_odata_type: str


class AuthenticationAttributeCollectionPage(BaseModel):
    views: Annotated[
        Optional[List[AuthenticationAttributeCollectionPageViewConfiguration]],
        Field(description='A collection of displays of the attribute collection page.'),
    ] = None
    field_odata_type: str


class AuthenticationMethodFeatureConfiguration(BaseModel):
    exclude_target: Annotated[
        Optional[Union[FeatureTarget, Dict[str, Any]]],
        Field(description='A single entity that is excluded from this feature.'),
    ] = None
    include_target: Annotated[
        Optional[Union[FeatureTarget, Dict[str, Any]]],
        Field(description='A single entity that is included in this feature.'),
    ] = None
    state: Annotated[
        Optional[Union[AdvancedConfigState, Dict[str, Any]]],
        Field(
            description="Enable or disable the feature. Possible values are: default, enabled, disabled, unknownFutureValue. The default value is used when the configuration hasn't been explicitly set and uses the default behavior of Microsoft Entra ID for the setting. The default value is disabled."
        ),
    ] = None
    field_odata_type: str


class AuthenticationMethodsRegistrationCampaign(BaseModel):
    exclude_targets: Annotated[
        Optional[List[ExcludeTarget]],
        Field(
            description='Users and groups of users that are excluded from being prompted to set up the authentication method.'
        ),
    ] = None
    include_targets: Annotated[
        Optional[List[AuthenticationMethodsRegistrationCampaignIncludeTarget]],
        Field(
            description='Users and groups of users that are prompted to set up the authentication method.'
        ),
    ] = None
    snooze_duration_in_days: Annotated[
        Optional[float],
        Field(
            description="Specifies the number of days that the user sees a prompt again if they select 'Not now' and snoozes the prompt. Minimum: 0 days. Maximum: 14 days. If the value is '0', the user is prompted during every MFA attempt.",
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    state: Optional[AdvancedConfigState] = None
    field_odata_type: str


class BookingsAvailability(BaseModel):
    availability_type: Optional[BookingsServiceAvailabilityType] = None
    business_hours: Annotated[
        Optional[List[BookingWorkHours]],
        Field(
            description="The hours of operation in a week. The business hours value is set to null if the availability type isn't customWeeklyHours."
        ),
    ] = None
    field_odata_type: str


class BookingsAvailabilityWindow(BookingsAvailability):
    end_date: Annotated[
        Optional[date],
        Field(
            description='End date of the availability window.',
        ),
    ] = None
    start_date: Annotated[
        Optional[date],
        Field(
            description='Start date of the availability window.',
        ),
    ] = None
    field_odata_type: str


class BookingSchedulingPolicy(BaseModel):
    allow_staff_selection: Annotated[
        Optional[bool],
        Field(
            description='True to allow customers to choose a specific person for the booking.'
        ),
    ] = None
    custom_availabilities: Annotated[
        Optional[List[BookingsAvailabilityWindow]],
        Field(description='Custom availability of the service in a given time frame.'),
    ] = None
    general_availability: Annotated[
        Optional[Union[BookingsAvailability, Dict[str, Any]]],
        Field(
            description='General availability of the service defined by the scheduling policy.'
        ),
    ] = None
    is_meeting_invite_to_customers_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the meeting invite is sent to the customers. The default value is false.'
        ),
    ] = None
    maximum_advance: Annotated[
        Optional[timedelta],
        Field(
            description='Maximum number of days in advance that a booking can be made. It follows the ISO 8601 format.',
        ),
    ] = None
    minimum_lead_time: Annotated[
        Optional[timedelta],
        Field(
            description='The minimum amount of time before which bookings and cancellations must be made. It follows the ISO 8601 format.',
        ),
    ] = None
    send_confirmations_to_owner: Annotated[
        Optional[bool],
        Field(
            description='True to notify the business via email when a booking is created or changed. Use the email address specified in the email property of the bookingBusiness entity for the business.'
        ),
    ] = None
    time_slot_interval: Annotated[
        Optional[timedelta],
        Field(
            description='Duration of each time slot, denoted in ISO 8601 format.',
        ),
    ] = None
    field_odata_type: str


class CallEndedEventMessageDetail(EventMessageDetail):
    call_duration: Annotated[
        Optional[timedelta],
        Field(
            description='Duration of the call.',
        ),
    ] = None
    call_event_type: Annotated[
        Optional[Union[TeamworkCallEventType, Dict[str, Any]]],
        Field(
            description='Represents the call event type. Possible values are: call, meeting, screenShare, unknownFutureValue.'
        ),
    ] = None
    call_id: Annotated[
        Optional[str], Field(description='Unique identifier of the call.')
    ] = None
    call_participants: Annotated[
        Optional[List[CallParticipantInfo]],
        Field(description='List of call participants.'),
    ] = None
    initiator: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Initiator of the event.'),
    ] = None
    field_odata_type: str


class ChatMessageMentionedIdentitySet(IdentitySet):
    conversation: Annotated[
        Optional[Union[TeamworkConversationIdentity, Dict[str, Any]]],
        Field(
            description='If present, represents a conversation (for example, team, channel, or chat) @mentioned in a message.'
        ),
    ] = None
    field_odata_type: str


class ChatMessageReaction(BaseModel):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The name of the reaction.')
    ] = None
    reaction_content_url: Annotated[
        Optional[str],
        Field(description='The hosted content URL for the custom reaction type.'),
    ] = None
    reaction_type: Annotated[
        Optional[str],
        Field(
            description='The reaction type. Supported values include Unicode characters, custom, and some backward-compatible reaction types, such as like, angry, sad, laugh, heart, and surprised.'
        ),
    ] = None
    user: Optional[ChatMessageReactionIdentitySet] = None
    field_odata_type: str


class ConditionalAccessAllExternalTenants(ConditionalAccessExternalTenants):
    field_odata_type: str


class ConditionalAccessApplications(BaseModel):
    application_filter: Optional[Union[ConditionalAccessFilter, Dict[str, Any]]] = None
    exclude_applications: Annotated[
        Optional[List[str]],
        Field(
            description='Can be one of the following:  The list of client IDs (appId) explicitly excluded from the policy. Office365 - For the list of apps included in Office365, see Apps included in Conditional Access Office 365 app suite  MicrosoftAdminPortals - For more information, see Conditional Access Target resources: Microsoft Admin Portals'
        ),
    ] = None
    include_applications: Annotated[
        Optional[List[str]],
        Field(
            description='Can be one of the following:  The list of client IDs (appId) the policy applies to, unless explicitly excluded (in excludeApplications)  All  Office365 - For the list of apps included in Office365, see Apps included in Conditional Access Office 365 app suite  MicrosoftAdminPortals - For more information, see Conditional Access Target resources: Microsoft Admin Portals'
        ),
    ] = None
    include_authentication_context_class_references: Optional[List[str]] = None
    include_user_actions: Annotated[
        Optional[List[str]],
        Field(
            description='User actions to include. Supported values are urn:user:registersecurityinfo and urn:user:registerdevice'
        ),
    ] = None
    field_odata_type: str


class ConditionalAccessClientApplications(BaseModel):
    exclude_service_principals: Annotated[
        Optional[List[str]],
        Field(description='Service principal IDs excluded from the policy scope.'),
    ] = None
    include_service_principals: Annotated[
        Optional[List[str]],
        Field(
            description='Service principal IDs included in the policy scope, or ServicePrincipalsInMyTenant.'
        ),
    ] = None
    service_principal_filter: Annotated[
        Optional[Union[ConditionalAccessFilter, Dict[str, Any]]],
        Field(
            description='Filter that defines the dynamic-servicePrincipal-syntax rule to include/exclude service principals. A filter can use custom security attributes to include/exclude service principals.'
        ),
    ] = None
    field_odata_type: str


class ConditionalAccessDevices(BaseModel):
    device_filter: Annotated[
        Optional[Union[ConditionalAccessFilter, Dict[str, Any]]],
        Field(
            description='Filter that defines the dynamic-device-syntax rule to include/exclude devices. A filter can use device properties (such as extension attributes) to include/exclude them.'
        ),
    ] = None
    field_odata_type: str


class ConditionalAccessEnumeratedExternalTenants(ConditionalAccessExternalTenants):
    members: Annotated[
        Optional[List[str]],
        Field(
            description='A collection of tenant IDs that define the scope of a policy targeting conditional access for guests and external users.'
        ),
    ] = None
    field_odata_type: str


class ConditionalAccessSessionControls(BaseModel):
    application_enforced_restrictions: Annotated[
        Optional[Union[ApplicationEnforcedRestrictionsSessionControl, Dict[str, Any]]],
        Field(
            description='Session control to enforce application restrictions. Only Exchange Online and Sharepoint Online support this session control.'
        ),
    ] = None
    cloud_app_security: Annotated[
        Optional[Union[CloudAppSecuritySessionControl, Dict[str, Any]]],
        Field(description='Session control to apply cloud app security.'),
    ] = None
    disable_resilience_defaults: Annotated[
        Optional[bool],
        Field(
            description='Session control that determines whether it is acceptable for Microsoft Entra ID to extend existing sessions based on information collected prior to an outage or not.'
        ),
    ] = None
    persistent_browser: Annotated[
        Optional[Union[PersistentBrowserSessionControl, Dict[str, Any]]],
        Field(
            description='Session control to define whether to persist cookies or not. All apps should be selected for this session control to work correctly.'
        ),
    ] = None
    sign_in_frequency: Annotated[
        Optional[Union[SignInFrequencySessionControl, Dict[str, Any]]],
        Field(description='Session control to enforce signin frequency.'),
    ] = None
    field_odata_type: str


class ConversationMemberRoleUpdatedEventMessageDetail(EventMessageDetail):
    conversation_member_roles: Annotated[
        Optional[List[str]], Field(description='Roles for the coversation member user.')
    ] = None
    conversation_member_user: Annotated[
        Optional[Union[TeamworkUserIdentity, Dict[str, Any]]],
        Field(description='Identity of the conversation member user.'),
    ] = None
    initiator: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Initiator of the event.'),
    ] = None
    field_odata_type: str


class CrossTenantAccessPolicyB2BSetting(BaseModel):
    applications: Annotated[
        Optional[Union[CrossTenantAccessPolicyTargetConfiguration, Dict[str, Any]]],
        Field(
            description='The list of applications targeted with your cross-tenant access policy.'
        ),
    ] = None
    users_and_groups: Annotated[
        Optional[Union[CrossTenantAccessPolicyTargetConfiguration, Dict[str, Any]]],
        Field(
            description='The list of users and groups targeted with your cross-tenant access policy.'
        ),
    ] = None
    field_odata_type: str


class CrossTenantAccessPolicyTenantRestrictions(CrossTenantAccessPolicyB2BSetting):
    devices: Annotated[
        Optional[Union[DevicesFilter, Dict[str, Any]]],
        Field(
            description="Defines the rule for filtering devices and whether devices that satisfy the rule should be allowed or blocked. This property isn't supported on the server side yet."
        ),
    ] = None
    field_odata_type: str


class CustomAppManagementConfiguration(AppManagementConfiguration):
    field_odata_type: str


class CustomTrainingSetting(TrainingSetting):
    assigned_to: Annotated[
        Optional[List[Union[TrainingAssignedTo, Dict[str, Any]]]],
        Field(
            description='A user collection that specifies to whom the training should be assigned. Possible values are: none, allUsers, clickedPayload, compromised, reportedPhish, readButNotClicked, didNothing, unknownFutureValue.'
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(description='The description of the custom training setting.'),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(description='The display name of the custom training setting.'),
    ] = None
    duration_in_minutes: Annotated[
        Optional[float],
        Field(description='Training duration.', ge=-2147483648.0, le=2147483647.0),
    ] = None
    url: Annotated[Optional[str], Field(description='The training URL.')] = None
    field_odata_type: str


class DaylightTimeZoneOffset(StandardTimeZoneOffset):
    daylight_bias: Annotated[
        Optional[float],
        Field(
            description='The time offset from Coordinated Universal Time (UTC) for daylight saving time. This value is in minutes.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class DefaultInvitationRedemptionIdentityProviderConfiguration(
    InvitationRedemptionIdentityProviderConfiguration
):
    field_odata_type: str


class DeleteUserFromSharedAppleDeviceActionResult(DeviceActionResult):
    user_principal_name: Annotated[
        Optional[str],
        Field(description='User principal name of the user to be deleted'),
    ] = None
    field_odata_type: str


class DeviceCompliancePolicySettingState(BaseModel):
    current_value: Annotated[
        Optional[str], Field(description='Current value of setting on device')
    ] = None
    error_code: Annotated[
        Optional[float], Field(description='Error code for the setting')
    ] = None
    error_description: Annotated[
        Optional[str], Field(description='Error description')
    ] = None
    instance_display_name: Annotated[
        Optional[str],
        Field(description='Name of setting instance that is being reported.'),
    ] = None
    setting: Annotated[
        Optional[str], Field(description='The setting that is being reported')
    ] = None
    setting_name: Annotated[
        Optional[str],
        Field(
            description='Localized/user friendly setting name that is being reported'
        ),
    ] = None
    sources: Annotated[
        Optional[List[SettingSource]], Field(description='Contributing policies')
    ] = None
    state: Optional[ComplianceStatus] = None
    user_email: Annotated[Optional[str], Field(description='UserEmail')] = None
    user_id: Annotated[Optional[str], Field(description='UserId')] = None
    user_name: Annotated[Optional[str], Field(description='UserName')] = None
    user_principal_name: Annotated[
        Optional[str], Field(description='UserPrincipalName.')
    ] = None
    field_odata_type: str


class DeviceConfigurationSettingState(BaseModel):
    current_value: Annotated[
        Optional[str], Field(description='Current value of setting on device')
    ] = None
    error_code: Annotated[
        Optional[float], Field(description='Error code for the setting')
    ] = None
    error_description: Annotated[
        Optional[str], Field(description='Error description')
    ] = None
    instance_display_name: Annotated[
        Optional[str],
        Field(description='Name of setting instance that is being reported.'),
    ] = None
    setting: Annotated[
        Optional[str], Field(description='The setting that is being reported')
    ] = None
    setting_name: Annotated[
        Optional[str],
        Field(
            description='Localized/user friendly setting name that is being reported'
        ),
    ] = None
    sources: Annotated[
        Optional[List[SettingSource]], Field(description='Contributing policies')
    ] = None
    state: Optional[ComplianceStatus] = None
    user_email: Annotated[Optional[str], Field(description='UserEmail')] = None
    user_id: Annotated[Optional[str], Field(description='UserId')] = None
    user_name: Annotated[Optional[str], Field(description='UserName')] = None
    user_principal_name: Annotated[
        Optional[str], Field(description='UserPrincipalName.')
    ] = None
    field_odata_type: str


class DriveItemUploadableProperties(BaseModel):
    description: Annotated[
        Optional[str],
        Field(
            description='Provides a user-visible description of the item. Read-write. Only on OneDrive Personal.'
        ),
    ] = None
    drive_item_source: Annotated[
        Optional[Union[DriveItemSource, Dict[str, Any]]],
        Field(
            description='Information about the drive item source. Read-write. Only on OneDrive for Business and SharePoint.'
        ),
    ] = None
    file_size: Annotated[
        Optional[float],
        Field(
            description='Provides an expected file size to perform a quota check before uploading. Only on OneDrive Personal.'
        ),
    ] = None
    file_system_info: Annotated[
        Optional[Union[FileSystemInfo, Dict[str, Any]]],
        Field(description='File system information on client. Read-write.'),
    ] = None
    media_source: Annotated[
        Optional[Union[MediaSource, Dict[str, Any]]],
        Field(
            description='Media source information. Read-write. Only on OneDrive for Business and SharePoint.'
        ),
    ] = None
    name: Annotated[
        Optional[str],
        Field(description='The name of the item (filename and extension). Read-write.'),
    ] = None
    field_odata_type: str


class EducationChannelResource(EducationResource):
    url: Annotated[Optional[str], Field(description='URL of the channel resource.')] = (
        None
    )
    field_odata_type: str


class EducationExcelResource(EducationResource):
    file_url: Annotated[
        Optional[str], Field(description='Pointer to the Excel file object.')
    ] = None
    field_odata_type: str


class EducationExternalResource(EducationResource):
    web_url: Annotated[
        Optional[str], Field(description='Location of the resource. Required.')
    ] = None
    field_odata_type: str


class EducationFeedback(BaseModel):
    feedback_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='User who created the feedback.'),
    ] = None
    feedback_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Moment in time when the feedback was given. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z',
        ),
    ] = None
    text: Annotated[
        Optional[Union[EducationItemBody, Dict[str, Any]]],
        Field(description='Feedback.'),
    ] = None
    field_odata_type: str


class EducationFileResource(EducationResource):
    file_url: Annotated[
        Optional[str], Field(description='Location on disk of the file resource.')
    ] = None
    field_odata_type: str


class EducationLinkedAssignmentResource(EducationResource):
    url: Annotated[
        Optional[str], Field(description='URL of the actual assignment.')
    ] = None
    field_odata_type: str


class EducationLinkResource(EducationResource):
    link: Annotated[Optional[str], Field(description='URL to the resource.')] = None
    field_odata_type: str


class EducationMediaResource(EducationResource):
    file_url: Annotated[
        Optional[str],
        Field(description='Location of the file on shared point folder. Required'),
    ] = None
    field_odata_type: str


class EducationPowerPointResource(EducationResource):
    file_url: Annotated[
        Optional[str], Field(description='Location of the file on disk.')
    ] = None
    field_odata_type: str


class EmailPayloadDetail(PayloadDetail):
    from_email: Annotated[
        Optional[str], Field(description='Email address of the user.')
    ] = None
    from_name: Annotated[
        Optional[str], Field(description='Display name of the user.')
    ] = None
    is_external_sender: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether the sender isn't from the user's organization."
        ),
    ] = None
    subject: Annotated[
        Optional[str],
        Field(description='The subject of the email address sent to the user.'),
    ] = None
    field_odata_type: str


class ExtractSensitivityLabelsResult(BaseModel):
    labels: Annotated[
        Optional[List[SensitivityLabelAssignment]],
        Field(description='List of sensitivity labels assigned to a file.'),
    ] = None
    field_odata_type: str


class Filter(BaseModel):
    category_filter_groups: Annotated[
        Optional[List[FilterGroup]],
        Field(
            description='*Experimental* Filter group set used to decide whether given object belongs and should be processed as part of this object mapping. An object is considered in scope if ANY of the groups in the collection is evaluated to true.'
        ),
    ] = None
    groups: Annotated[
        Optional[List[FilterGroup]],
        Field(
            description="Filter group set used to decide whether given object is in scope for provisioning. This is the filter which should be used in most cases. If an object used to satisfy this filter at a given moment, and then the object or the filter was changed so that filter isn't satisfied any longer, such object will get deprovisioned'. An object is considered in scope if ANY of the groups in the collection is evaluated to true."
        ),
    ] = None
    input_filter_groups: Annotated[
        Optional[List[FilterGroup]],
        Field(
            description="*Experimental* Filter group set used to filter out objects at the early stage of reading them from the directory. If an object doesn't satisfy this filter, then it will not be processed further. Important to understand is that if an object used to satisfy this filter at a given moment, and then the object or the filter was changed so that filter is no longer satisfied, such object will NOT get deprovisioned. An object is considered in scope if ANY of the groups in the collection is evaluated to true."
        ),
    ] = None
    field_odata_type: str


class IosHomeScreenFolder(IosHomeScreenItem):
    pages: Annotated[
        Optional[List[IosHomeScreenFolderPage]],
        Field(
            description='Pages of Home Screen Layout Icons which must be applications or web clips. This collection can contain a maximum of 500 elements.'
        ),
    ] = None
    field_odata_type: str


class Location(BaseModel):
    address: Annotated[
        Optional[Union[PhysicalAddress, Dict[str, Any]]],
        Field(description='The street address of the location.'),
    ] = None
    coordinates: Annotated[
        Optional[Union[OutlookGeoCoordinates, Dict[str, Any]]],
        Field(description='The geographic coordinates and elevation of the location.'),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The name associated with the location.')
    ] = None
    location_email_address: Annotated[
        Optional[str], Field(description='Optional email address of the location.')
    ] = None
    location_type: Annotated[
        Optional[Union[LocationType, Dict[str, Any]]],
        Field(
            description='The type of location. The possible values are: default, conferenceRoom, homeAddress, businessAddress,geoCoordinates, streetAddress, hotel, restaurant, localBusiness, postalAddress. Read-only.'
        ),
    ] = None
    location_uri: Annotated[
        Optional[str], Field(description='Optional URI representing the location.')
    ] = None
    unique_id: Annotated[Optional[str], Field(description='For internal use only.')] = (
        None
    )
    unique_id_type: Annotated[
        Optional[Union[LocationUniqueIdType, Dict[str, Any]]],
        Field(description='For internal use only.'),
    ] = None
    field_odata_type: str


class LocationConstraintItem(Location):
    resolve_availability: Annotated[
        Optional[bool],
        Field(
            description="If set to true and the specified resource is busy, findMeetingTimes looks for another resource that is free. If set to false and the specified resource is busy, findMeetingTimes returns the resource best ranked in the user's cache without checking if it's free. Default is true."
        ),
    ] = None
    field_odata_type: str


class MailboxSettings(BaseModel):
    archive_folder: Annotated[
        Optional[str], Field(description='Folder ID of an archive folder for the user.')
    ] = None
    automatic_replies_setting: Annotated[
        Optional[Union[AutomaticRepliesSetting, Dict[str, Any]]],
        Field(
            description='Configuration settings to automatically notify the sender of an incoming email with a message from the signed-in user.'
        ),
    ] = None
    date_format: Annotated[
        Optional[str], Field(description="The date format for the user's mailbox.")
    ] = None
    delegate_meeting_message_delivery_options: Annotated[
        Optional[Union[DelegateMeetingMessageDeliveryOptions, Dict[str, Any]]],
        Field(
            description='If the user has a calendar delegate, this specifies whether the delegate, mailbox owner, or both receive meeting messages and meeting responses. Possible values are: sendToDelegateAndInformationToPrincipal, sendToDelegateAndPrincipal, sendToDelegateOnly.'
        ),
    ] = None
    language: Annotated[
        Optional[Union[LocaleInfo, Dict[str, Any]]],
        Field(
            description='The locale information for the user, including the preferred language and country/region.'
        ),
    ] = None
    time_format: Annotated[
        Optional[str], Field(description="The time format for the user's mailbox.")
    ] = None
    time_zone: Annotated[
        Optional[str],
        Field(description="The default time zone for the user's mailbox."),
    ] = None
    user_purpose: Annotated[
        Optional[Union[UserPurpose, Dict[str, Any]]],
        Field(
            description='The purpose of the mailbox. Differentiates a mailbox for a single user from a shared mailbox and equipment mailbox in Exchange Online. Possible values are: user, linked, shared, room, equipment, others, unknownFutureValue. Read-only.'
        ),
    ] = None
    working_hours: Annotated[
        Optional[Union[WorkingHours, Dict[str, Any]]],
        Field(
            description='The days of the week and hours in a specific time zone that the user works.'
        ),
    ] = None
    field_odata_type: str


class MeetingTimeSuggestion(BaseModel):
    attendee_availability: Annotated[
        Optional[List[AttendeeAvailability]],
        Field(
            description='An array that shows the availability status of each attendee for this meeting suggestion.'
        ),
    ] = None
    confidence: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='A percentage that represents the likelhood of all the attendees attending.'
        ),
    ] = None
    locations: Annotated[
        Optional[List[Location]],
        Field(
            description='An array that specifies the name and geographic location of each meeting location for this meeting suggestion.'
        ),
    ] = None
    meeting_time_slot: Annotated[
        Optional[Union[TimeSlot, Dict[str, Any]]],
        Field(description='A time period suggested for the meeting.'),
    ] = None
    order: Annotated[
        Optional[float],
        Field(
            description='Order of meeting time suggestions sorted by their computed confidence value from high to low, then by chronology if there are suggestions with the same confidence.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    organizer_availability: Annotated[
        Optional[Union[FreeBusyStatus, Dict[str, Any]]],
        Field(
            description='Availability of the meeting organizer for this meeting suggestion. The possible values are: free, tentative, busy, oof, workingElsewhere, unknown.'
        ),
    ] = None
    suggestion_reason: Annotated[
        Optional[str], Field(description='Reason for suggesting the meeting time.')
    ] = None
    field_odata_type: str


class MeetingTimeSuggestionsResult(BaseModel):
    empty_suggestions_reason: Annotated[
        Optional[str],
        Field(
            description='A reason for not returning any meeting suggestions. The possible values are: attendeesUnavailable, attendeesUnavailableOrUnknown, locationsUnavailable, organizerUnavailable, or unknown. This property is an empty string if the meetingTimeSuggestions property does include any meeting suggestions.'
        ),
    ] = None
    meeting_time_suggestions: Annotated[
        Optional[List[MeetingTimeSuggestion]],
        Field(description='An array of meeting suggestions.'),
    ] = None
    field_odata_type: str


class MembersAddedEventMessageDetail(EventMessageDetail):
    initiator: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Initiator of the event.'),
    ] = None
    members: Annotated[
        Optional[List[TeamworkUserIdentity]],
        Field(description='List of members added.'),
    ] = None
    visible_history_start_date_time: Annotated[
        Optional[datetime],
        Field(
            description="The timestamp that denotes how far back a conversation's history is shared with the conversation members.",
        ),
    ] = None
    field_odata_type: str


class MembersDeletedEventMessageDetail(EventMessageDetail):
    initiator: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Initiator of the event.'),
    ] = None
    members: Annotated[
        Optional[List[TeamworkUserIdentity]],
        Field(description='List of members deleted.'),
    ] = None
    field_odata_type: str


class MembersJoinedEventMessageDetail(EventMessageDetail):
    initiator: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Initiator of the event.'),
    ] = None
    members: Annotated[
        Optional[List[TeamworkUserIdentity]],
        Field(description='List of members who joined the chat.'),
    ] = None
    field_odata_type: str


class MembersLeftEventMessageDetail(EventMessageDetail):
    initiator: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Initiator of the event.'),
    ] = None
    members: Annotated[
        Optional[List[TeamworkUserIdentity]],
        Field(description='List of members who left the chat.'),
    ] = None
    field_odata_type: str


class MicrosoftAuthenticatorFeatureSettings(BaseModel):
    display_app_information_required_state: Annotated[
        Optional[Union[AuthenticationMethodFeatureConfiguration, Dict[str, Any]]],
        Field(
            description="Determines whether the user's Authenticator app shows them the client app they're signing into."
        ),
    ] = None
    display_location_information_required_state: Annotated[
        Optional[Union[AuthenticationMethodFeatureConfiguration, Dict[str, Any]]],
        Field(
            description="Determines whether the user's Authenticator app shows them the geographic location of where the authentication request originated from."
        ),
    ] = None
    field_odata_type: str


class MicrosoftManagedTrainingSetting(TrainingSetting):
    completion_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The completion date for the training. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    training_completion_duration: Annotated[
        Optional[Union[TrainingCompletionDuration, Dict[str, Any]]],
        Field(
            description='The training completion duration that needs to be provided before scheduling the training. The possible values are: week, fortnite, month, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class NoTrainingSetting(TrainingSetting):
    field_odata_type: str


class ObjectDefinition(BaseModel):
    attributes: Annotated[
        Optional[List[AttributeDefinition]],
        Field(description='Defines attributes of the object.'),
    ] = None
    metadata: Annotated[
        Optional[List[ObjectDefinitionMetadataEntry]],
        Field(description='Metadata for the given object.'),
    ] = None
    name: Annotated[
        Optional[str],
        Field(
            description='Name of the object. Must be unique within a directory definition. Not nullable.'
        ),
    ] = None
    supported_apis: Annotated[
        Optional[List[str]],
        Field(
            description='The API that the provisioning service queries to retrieve data for synchronization.'
        ),
    ] = None
    field_odata_type: str


class OnAttributeCollectionExternalUsersSelfServiceSignUp(OnAttributeCollectionHandler):
    attribute_collection_page: Annotated[
        Optional[Union[AuthenticationAttributeCollectionPage, Dict[str, Any]]],
        Field(
            description='Required. The configuration for how attributes are displayed in the sign-up experience defined by a user flow, like the externalUsersSelfServiceSignupEventsFlow, specifically on the attribute collection page.'
        ),
    ] = None
    attributes: Optional[List[IdentityUserFlowAttribute]] = None
    field_odata_type: str


class OnlineMeetingInfo(BaseModel):
    conference_id: Annotated[
        Optional[str], Field(description='The ID of the conference.')
    ] = None
    join_url: Annotated[
        Optional[str],
        Field(
            description='The external link that launches the online meeting. This is a URL that clients launch into a browser and will redirect the user to join the meeting.'
        ),
    ] = None
    phones: Annotated[
        Optional[List[Phone]],
        Field(description='All of the phone numbers associated with this conference.'),
    ] = None
    quick_dial: Annotated[
        Optional[str], Field(description='The preformatted quick dial for this call.')
    ] = None
    toll_free_numbers: Annotated[
        Optional[List[str]],
        Field(
            description='The toll free numbers that can be used to join the conference.'
        ),
    ] = None
    toll_number: Annotated[
        Optional[str],
        Field(description='The toll number that can be used to join the conference.'),
    ] = None
    field_odata_type: str


class OnTokenIssuanceStartCustomExtensionHandler(OnTokenIssuanceStartHandler):
    configuration: Optional[
        Union[CustomExtensionOverwriteConfiguration, Dict[str, Any]]
    ] = None
    custom_extension: Optional[
        Union[OnTokenIssuanceStartCustomExtension, Dict[str, Any]]
    ] = None
    field_odata_type: str


class OpenShiftItem(ShiftItem):
    open_slot_count: Annotated[
        Optional[float],
        Field(
            description='Count of the number of slots for the given open shift.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class PatternedRecurrence(BaseModel):
    pattern: Annotated[
        Optional[Union[RecurrencePattern, Dict[str, Any]]],
        Field(
            description='The frequency of an event.  For access reviews: Do not specify this property for a one-time access review.  Only interval, dayOfMonth, and type (weekly, absoluteMonthly) properties of recurrencePattern are supported.'
        ),
    ] = None
    range: Annotated[
        Optional[Union[RecurrenceRange, Dict[str, Any]]],
        Field(description='The duration of an event.'),
    ] = None
    field_odata_type: str


class RegistrationEnforcement(BaseModel):
    authentication_methods_registration_campaign: Annotated[
        Optional[Union[AuthenticationMethodsRegistrationCampaign, Dict[str, Any]]],
        Field(
            description='Run campaigns to remind users to set up targeted authentication methods.'
        ),
    ] = None
    field_odata_type: str


class Reminder(BaseModel):
    change_key: Annotated[
        Optional[str],
        Field(
            description='Identifies the version of the reminder. Every time the reminder is changed, changeKey changes as well. This allows Exchange to apply changes to the correct version of the object.'
        ),
    ] = None
    event_end_time: Annotated[
        Optional[Union[DateTimeTimeZone, Dict[str, Any]]],
        Field(description='The date, time and time zone that the event ends.'),
    ] = None
    event_id: Annotated[
        Optional[str], Field(description='The unique ID of the event. Read only.')
    ] = None
    event_location: Annotated[
        Optional[Union[Location, Dict[str, Any]]],
        Field(description='The location of the event.'),
    ] = None
    event_start_time: Annotated[
        Optional[Union[DateTimeTimeZone, Dict[str, Any]]],
        Field(description='The date, time, and time zone that the event starts.'),
    ] = None
    event_subject: Annotated[
        Optional[str], Field(description="The text of the event's subject line.")
    ] = None
    event_web_link: Annotated[
        Optional[str],
        Field(
            description="The URL to open the event in Outlook on the web.The event opens in the browser if you're logged in to your mailbox via Outlook on the web. You're prompted to log in if you aren't already logged in with the browser.This URL can't be accessed from within an iFrame."
        ),
    ] = None
    reminder_fire_time: Annotated[
        Optional[Union[DateTimeTimeZone, Dict[str, Any]]],
        Field(
            description='The date, time, and time zone that the reminder is set to occur.'
        ),
    ] = None
    field_odata_type: str


class RemoteItem(BaseModel):
    created_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(
            description='Identity of the user, device, and application which created the item. Read-only.'
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time of item creation. Read-only.',
        ),
    ] = None
    file: Annotated[
        Optional[Union[File, Dict[str, Any]]],
        Field(description='Indicates that the remote item is a file. Read-only.'),
    ] = None
    file_system_info: Annotated[
        Optional[Union[FileSystemInfo, Dict[str, Any]]],
        Field(
            description='Information about the remote item from the local file system. Read-only.'
        ),
    ] = None
    folder: Annotated[
        Optional[Union[Folder, Dict[str, Any]]],
        Field(description='Indicates that the remote item is a folder. Read-only.'),
    ] = None
    id: Annotated[
        Optional[str],
        Field(
            description='Unique identifier for the remote item in its drive. Read-only.'
        ),
    ] = None
    image: Annotated[
        Optional[Union[Image, Dict[str, Any]]],
        Field(description='Image metadata, if the item is an image. Read-only.'),
    ] = None
    last_modified_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(
            description='Identity of the user, device, and application which last modified the item. Read-only.'
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time the item was last modified. Read-only.',
        ),
    ] = None
    name: Annotated[
        Optional[str],
        Field(description='Optional. Filename of the remote item. Read-only.'),
    ] = None
    package: Annotated[
        Optional[Union[Package, Dict[str, Any]]],
        Field(
            description='If present, indicates that this item is a package instead of a folder or file. Packages are treated like files in some contexts and folders in others. Read-only.'
        ),
    ] = None
    parent_reference: Annotated[
        Optional[Union[ItemReference, Dict[str, Any]]],
        Field(description='Properties of the parent of the remote item. Read-only.'),
    ] = None
    shared: Annotated[
        Optional[Union[Shared, Dict[str, Any]]],
        Field(
            description='Indicates that the item has been shared with others and provides information about the shared state of the item. Read-only.'
        ),
    ] = None
    sharepoint_ids: Annotated[
        Optional[Union[SharepointIds, Dict[str, Any]]],
        Field(
            description='Provides interop between items in OneDrive for Business and SharePoint with the full set of item identifiers. Read-only.'
        ),
    ] = None
    size: Annotated[
        Optional[float], Field(description='Size of the remote item. Read-only.')
    ] = None
    special_folder: Annotated[
        Optional[Union[SpecialFolder, Dict[str, Any]]],
        Field(
            description='If the current item is also available as a special folder, this facet is returned. Read-only.'
        ),
    ] = None
    video: Annotated[
        Optional[Union[Video, Dict[str, Any]]],
        Field(description='Video metadata, if the item is a video. Read-only.'),
    ] = None
    web_dav_url: Annotated[
        Optional[str], Field(description='DAV compatible URL for the item.')
    ] = None
    web_url: Annotated[
        Optional[str],
        Field(description='URL that displays the resource in the browser. Read-only.'),
    ] = None
    field_odata_type: str


class RequestSchedule(BaseModel):
    expiration: Annotated[
        Optional[Union[ExpirationPattern, Dict[str, Any]]],
        Field(description='When the eligible or active assignment expires.'),
    ] = None
    recurrence: Annotated[
        Optional[Union[PatternedRecurrence, Dict[str, Any]]],
        Field(
            description='The frequency of the  eligible or active assignment. This property is currently unsupported in PIM.'
        ),
    ] = None
    start_date_time: Annotated[
        Optional[datetime],
        Field(
            description='When the  eligible or active assignment becomes active.',
        ),
    ] = None
    field_odata_type: str


class RestorePointSearchResult(BaseModel):
    artifact_hit_count: Annotated[
        Optional[float],
        Field(
            description='Total number of artifacts restored.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    restore_point: Optional[Union[RestorePoint, Dict[str, Any]]] = None
    field_odata_type: str


class ScheduleInformation(BaseModel):
    availability_view: Annotated[
        Optional[str],
        Field(
            description='Represents a merged view of availability of all the items in scheduleItems. The view consists of time slots. Availability during each time slot is indicated with: 0= free or working elswhere, 1= tentative, 2= busy, 3= out of office.Note: Working elsewhere is set to 0 instead of 4 for backward compatibility. For details, see the Q&A and Exchange 2007 and Exchange 2010 do not use the WorkingElsewhere value.'
        ),
    ] = None
    error: Annotated[
        Optional[Union[FreeBusyError, Dict[str, Any]]],
        Field(
            description='Error information from attempting to get the availability of the user, distribution list, or resource.'
        ),
    ] = None
    schedule_id: Annotated[
        Optional[str],
        Field(
            description='An SMTP address of the user, distribution list, or resource, identifying an instance of scheduleInformation.'
        ),
    ] = None
    schedule_items: Annotated[
        Optional[List[ScheduleItem]],
        Field(
            description='Contains the items that describe the availability of the user or resource.'
        ),
    ] = None
    working_hours: Annotated[
        Optional[Union[WorkingHours, Dict[str, Any]]],
        Field(
            description="The days of the week and hours in a specific time zone that the user works. These are set as part of the user's mailboxSettings."
        ),
    ] = None
    field_odata_type: str


class SearchRequest(BaseModel):
    aggregation_filters: Annotated[
        Optional[List[str]],
        Field(
            description="Contains one or more filters to obtain search results aggregated and filtered to a specific value of a field. Optional.Build this filter based on a prior search that aggregates by the same field. From the response of the prior search, identify the searchBucket that filters results to the specific value of the field, use the string in its aggregationFilterToken property, and build an aggregation filter string in the format '{field}:/'{aggregationFilterToken}/''. If multiple values for the same field need to be provided, use the strings in its aggregationFilterToken property and build an aggregation filter string in the format '{field}:or(/'{aggregationFilterToken1}/',/'{aggregationFilterToken2}/')'. For example, searching and aggregating drive items by file type returns a searchBucket for the file type docx in the response. You can conveniently use the aggregationFilterToken returned for this searchBucket in a subsequent search query and filter matches down to drive items of the docx file type. Example 1 and example 2 show the actual requests and responses."
        ),
    ] = None
    aggregations: Annotated[
        Optional[List[AggregationOption]],
        Field(
            description='Specifies aggregations (also known as refiners) to be returned alongside search results. Optional.'
        ),
    ] = None
    collapse_properties: Annotated[
        Optional[List[CollapseProperty]],
        Field(
            description='Contains the ordered collection of fields and limit to collapse results. Optional.'
        ),
    ] = None
    content_sources: Annotated[
        Optional[List[str]],
        Field(description='Contains the connection to be targeted.'),
    ] = None
    enable_top_results: Annotated[
        Optional[bool],
        Field(
            description='This triggers hybrid sort for messages : the first 3 messages are the most relevant. This property is only applicable to entityType=message. Optional.'
        ),
    ] = None
    entity_types: Annotated[
        Optional[List[Union[EntityType, Dict[str, Any]]]],
        Field(
            description='One or more types of resources expected in the response. Possible values are: event, message, driveItem, externalItem, site, list, listItem, drive, chatMessage, person, acronym, bookmark.  Use the Prefer: include-unknown-enum-members request header to get the following value(s) in this evolvable enum: chatMessage, person, acronym, bookmark. See known limitations for those combinations of two or more entity types that are supported in the same search request. Required.'
        ),
    ] = None
    fields: Annotated[
        Optional[List[str]],
        Field(
            description='Contains the fields to be returned for each resource object specified in entityTypes, allowing customization of the fields returned by default; otherwise, including additional fields such as custom managed properties from SharePoint and OneDrive, or custom fields in externalItem from the content that Microsoft Graph connectors bring in. The fields property can use the semantic labels applied to properties. For example, if a property is labeled as title, you can retrieve it using the following syntax: label_title. Optional.'
        ),
    ] = None
    from_: Annotated[
        Optional[float],
        Field(
            description='Specifies the offset for the search results. Offset 0 returns the very first result. Optional.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    query: Optional[SearchQuery] = None
    query_alteration_options: Annotated[
        Optional[Union[SearchAlterationOptions, Dict[str, Any]]],
        Field(
            description='Query alteration options formatted in a JSON blob that contains two optional flags related to spelling correction. Optional.'
        ),
    ] = None
    region: Annotated[
        Optional[str],
        Field(
            description='The geographic location for the search. Required for searches that use application permissions. For details, see Get the region value.'
        ),
    ] = None
    result_template_options: Annotated[
        Optional[Union[ResultTemplateOption, Dict[str, Any]]],
        Field(
            description='Provides the search result template options to render search results from connectors.'
        ),
    ] = None
    share_point_one_drive_options: Annotated[
        Optional[Union[SharePointOneDriveOptions, Dict[str, Any]]],
        Field(
            description='Indicates the kind of contents to be searched when a search is performed using application permissions. Optional.'
        ),
    ] = None
    size: Annotated[
        Optional[float],
        Field(
            description='The size of the page to be retrieved. The maximum value is 500. Optional.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    sort_properties: Annotated[
        Optional[List[SortProperty]],
        Field(
            description='Contains the ordered collection of fields and direction to sort results. There can be at most 5 sort properties in the collection. Optional.'
        ),
    ] = None
    field_odata_type: str


class ShiftAvailability(BaseModel):
    recurrence: Annotated[
        Optional[Union[PatternedRecurrence, Dict[str, Any]]],
        Field(description='Specifies the pattern for recurrence'),
    ] = None
    time_slots: Annotated[
        Optional[List[TimeRange]],
        Field(description='The time slot(s) preferred by the user.'),
    ] = None
    time_zone: Annotated[
        Optional[str],
        Field(description='Specifies the time zone for the indicated time.'),
    ] = None
    field_odata_type: str


class SynchronizationStatus(BaseModel):
    code: Optional[SynchronizationStatusCode] = None
    count_successive_complete_failures: Annotated[
        Optional[float],
        Field(description='Number of consecutive times this job failed.'),
    ] = None
    escrows_pruned: Annotated[
        Optional[bool],
        Field(
            description="true if the job's escrows (object-level errors) were pruned during initial synchronization. Escrows can be pruned if during the initial synchronization, you reach the threshold of errors that would normally put the job in quarantine. Instead of going into quarantine, the synchronization process clears the job's errors and continues until the initial synchronization is completed. When the initial synchronization is completed, the job will pause and wait for the customer to clean up the errors."
        ),
    ] = None
    last_execution: Annotated[
        Optional[Union[SynchronizationTaskExecution, Dict[str, Any]]],
        Field(description='Details of the last execution of the job.'),
    ] = None
    last_successful_execution: Annotated[
        Optional[Union[SynchronizationTaskExecution, Dict[str, Any]]],
        Field(
            description="Details of the last execution of this job, which didn't have any errors."
        ),
    ] = None
    last_successful_execution_with_exports: Annotated[
        Optional[Union[SynchronizationTaskExecution, Dict[str, Any]]],
        Field(
            description='Details of the last execution of the job, which exported objects into the target directory.'
        ),
    ] = None
    progress: Annotated[
        Optional[List[SynchronizationProgress]],
        Field(description='Details of the progress of a job toward completion.'),
    ] = None
    quarantine: Annotated[
        Optional[Union[SynchronizationQuarantine, Dict[str, Any]]],
        Field(description='If job is in quarantine, quarantine details.'),
    ] = None
    steady_state_first_achieved_time: Annotated[
        Optional[datetime],
        Field(
            description='The time when steady state (no more changes to the process) was first achieved. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    steady_state_last_achieved_time: Annotated[
        Optional[datetime],
        Field(
            description='The time when steady state (no more changes to the process) was last achieved. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    synchronized_entry_count_by_type: Annotated[
        Optional[List[StringKeyLongValuePair]],
        Field(description='Count of synchronized objects, listed by object type.'),
    ] = None
    troubleshooting_url: Annotated[
        Optional[str],
        Field(
            description='In the event of an error, the URL with the troubleshooting steps for the issue.'
        ),
    ] = None
    field_odata_type: str


class TeamsAppPermissionSet(BaseModel):
    resource_specific_permissions: Annotated[
        Optional[List[TeamsAppResourceSpecificPermission]],
        Field(description='A collection of resource-specific permissions.'),
    ] = None
    field_odata_type: str


class TeamworkOnlineMeetingInfo(BaseModel):
    calendar_event_id: Annotated[
        Optional[str],
        Field(
            description='The identifier of the calendar event associated with the meeting.'
        ),
    ] = None
    join_web_url: Annotated[
        Optional[str],
        Field(
            description='The URL that users click to join or uniquely identify the meeting.'
        ),
    ] = None
    organizer: Annotated[
        Optional[Union[TeamworkUserIdentity, Dict[str, Any]]],
        Field(description='The organizer of the meeting.'),
    ] = None
    field_odata_type: str


class TeleconferenceDeviceAudioQuality(TeleconferenceDeviceMediaQuality):
    field_odata_type: str


class TeleconferenceDeviceScreenSharingQuality(TeleconferenceDeviceVideoQuality):
    field_odata_type: str


class UserSimulationDetails(BaseModel):
    assigned_trainings_count: Annotated[
        Optional[float],
        Field(
            description='Number of trainings assigned to a user in an attack simulation and training campaign.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    completed_trainings_count: Annotated[
        Optional[float],
        Field(
            description='Number of trainings completed by a user in an attack simulation and training campaign.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    compromised_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time of the compromising online action by a user in an attack simulation and training campaign.',
        ),
    ] = None
    in_progress_trainings_count: Annotated[
        Optional[float],
        Field(
            description='Number of trainings in progress by a user in an attack simulation and training campaign.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    is_compromised: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether a user was compromised in an attack simulation and training campaign.'
        ),
    ] = None
    reported_phish_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when a user reported the delivered payload as phishing in the attack simulation and training campaign.',
        ),
    ] = None
    simulation_events: Annotated[
        Optional[List[UserSimulationEventInfo]],
        Field(
            description='List of simulation events of a user in the attack simulation and training campaign.'
        ),
    ] = None
    simulation_user: Annotated[
        Optional[Union[AttackSimulationUser, Dict[str, Any]]],
        Field(description='User in an attack simulation and training campaign.'),
    ] = None
    training_events: Annotated[
        Optional[List[UserTrainingEventInfo]],
        Field(
            description='List of training events of a user in the attack simulation and training campaign.'
        ),
    ] = None
    field_odata_type: str


class Win32LobAppAssignmentSettings(MobileAppAssignmentSettings):
    auto_update_settings: Annotated[
        Optional[Union[Win32LobAppAutoUpdateSettings, Dict[str, Any]]],
        Field(description='The auto-update settings to apply for this app assignment.'),
    ] = None
    delivery_optimization_priority: Optional[
        Win32LobAppDeliveryOptimizationPriority
    ] = None
    install_time_settings: Annotated[
        Optional[Union[MobileAppInstallTimeSettings, Dict[str, Any]]],
        Field(
            description='The install time settings to apply for this app assignment.'
        ),
    ] = None
    notifications: Optional[Win32LobAppNotification] = None
    restart_settings: Annotated[
        Optional[Union[Win32LobAppRestartSettings, Dict[str, Any]]],
        Field(description='The reboot settings to apply for this app assignment.'),
    ] = None
    field_odata_type: str


class Win32LobAppFileSystemRule(Win32LobAppRule):
    check32_bit_on64_system: Annotated[
        Optional[bool],
        Field(
            description='A value indicating whether to expand environment variables in the 32-bit context on 64-bit systems.'
        ),
    ] = None
    comparison_value: Annotated[
        Optional[str], Field(description='The file or folder comparison value.')
    ] = None
    file_or_folder_name: Annotated[
        Optional[str], Field(description='The file or folder name to look up.')
    ] = None
    operation_type: Optional[Win32LobAppFileSystemOperationType] = None
    operator: Optional[Win32LobAppRuleOperator] = None
    path: Annotated[
        Optional[str], Field(description='The file or folder path to look up.')
    ] = None
    field_odata_type: str


class Win32LobAppPowerShellScriptRule(Win32LobAppRule):
    comparison_value: Annotated[
        Optional[str],
        Field(
            description='The script output comparison value. Do not specify a value if the rule is used for detection.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='The display name for the rule. Do not specify this value if the rule is used for detection.'
        ),
    ] = None
    enforce_signature_check: Annotated[
        Optional[bool],
        Field(description='A value indicating whether a signature check is enforced.'),
    ] = None
    operation_type: Optional[Win32LobAppPowerShellScriptRuleOperationType] = None
    operator: Optional[Win32LobAppRuleOperator] = None
    run_as32_bit: Annotated[
        Optional[bool],
        Field(
            description='A value indicating whether the script should run as 32-bit.'
        ),
    ] = None
    run_as_account: Annotated[
        Optional[Union[RunAsAccountType, Dict[str, Any]]],
        Field(
            description='The execution context of the script. Do not specify this value if the rule is used for detection. Script detection rules will run in the same context as the associated app install context. Possible values are: system, user.'
        ),
    ] = None
    script_content: Annotated[
        Optional[str], Field(description='The base64-encoded script content.')
    ] = None
    field_odata_type: str


class Win32LobAppProductCodeRule(Win32LobAppRule):
    product_code: Annotated[
        Optional[str], Field(description='The product code of the app.')
    ] = None
    product_version: Annotated[
        Optional[str], Field(description='The product version comparison value.')
    ] = None
    product_version_operator: Optional[Win32LobAppRuleOperator] = None
    field_odata_type: str


class Win32LobAppRegistryRule(Win32LobAppRule):
    check32_bit_on64_system: Annotated[
        Optional[bool],
        Field(
            description='A value indicating whether to search the 32-bit registry on 64-bit systems.'
        ),
    ] = None
    comparison_value: Annotated[
        Optional[str], Field(description='The registry comparison value.')
    ] = None
    key_path: Annotated[
        Optional[str],
        Field(
            description='The full path of the registry entry containing the value to detect.'
        ),
    ] = None
    operation_type: Optional[Win32LobAppRegistryRuleOperationType] = None
    operator: Optional[Win32LobAppRuleOperator] = None
    value_name: Annotated[
        Optional[str], Field(description='The name of the registry value to detect.')
    ] = None
    field_odata_type: str


class WindowsMalwareOverview(BaseModel):
    malware_category_summary: Annotated[
        Optional[List[WindowsMalwareCategoryCount]],
        Field(description='List of device counts per malware category'),
    ] = None
    malware_detected_device_count: Annotated[
        Optional[float],
        Field(
            description='Count of devices with malware detected in the last 30 days',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    malware_execution_state_summary: Annotated[
        Optional[List[WindowsMalwareExecutionStateCount]],
        Field(description='List of device counts per malware execution state'),
    ] = None
    malware_name_summary: Annotated[
        Optional[List[WindowsMalwareNameCount]],
        Field(description='List of device counts per malware'),
    ] = None
    malware_severity_summary: Annotated[
        Optional[List[WindowsMalwareSeverityCount]],
        Field(description='List of active malware counts per malware severity'),
    ] = None
    malware_state_summary: Annotated[
        Optional[List[WindowsMalwareStateCount]],
        Field(description='List of device counts per malware state'),
    ] = None
    os_versions_summary: Annotated[
        Optional[List[OsVersionCount]],
        Field(description='List of device counts with malware per windows OS version'),
    ] = None
    total_distinct_malware_count: Annotated[
        Optional[float],
        Field(
            description='Count of all distinct malwares detected across all devices. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    total_malware_count: Annotated[
        Optional[float],
        Field(
            description='Count of all malware detections across all devices. Valid values -2147483648 to 2147483647',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class X509CertificateAuthenticationModeConfiguration(BaseModel):
    rules: Annotated[
        Optional[List[X509CertificateRule]],
        Field(
            description='Rules are configured in addition to the authentication mode to bind a specific x509CertificateRuleType to an x509CertificateAuthenticationMode. For example, bind the policyOID with identifier 1.32.132.343 to x509CertificateMultiFactor authentication mode.'
        ),
    ] = None
    x509_certificate_authentication_default_mode: Annotated[
        Optional[Union[X509CertificateAuthenticationMode, Dict[str, Any]]],
        Field(
            description='The type of strong authentication mode. The possible values are: x509CertificateSingleFactor, x509CertificateMultiFactor, unknownFutureValue.'
        ),
    ] = None
    x509_certificate_default_required_affinity_level: Optional[
        Union[X509CertificateAffinityLevel, Dict[str, Any]]
    ] = None
    field_odata_type: str


class AppRoleAssignmentCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AppRoleAssignment]] = None


class AuthenticationMethodConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AuthenticationMethodConfiguration]] = None


class OrgContactCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[OrgContact]] = None


class ContractCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Contract]] = None


class DeviceCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Device]] = None


class DirectoryRoleCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[DirectoryRole]] = None


class AttributeMappingFunctionSchemaCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AttributeMappingFunctionSchema]] = None


class PlaceCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Place]] = None


class AccessReviewInstanceCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AccessReviewInstance]] = None


class AgreementFileLocalizationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AgreementFileLocalization]] = None


class MobileAppContentCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[MobileAppContent]] = None


class UserConsentRequestCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[UserConsentRequest]] = None


class HomeRealmDiscoveryPolicyCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[HomeRealmDiscoveryPolicy]] = None


class LandingPageCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[LandingPage]] = None


class LoginPageCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[LoginPage]] = None


class AttackSimulationOperationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AttackSimulationOperation]] = None


class PayloadCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Payload]] = None


class SimulationAutomationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SimulationAutomation]] = None


class DirectoryAuditCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[DirectoryAudit]] = None


class ProvisioningObjectSummaryCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[ProvisioningObjectSummary]] = None


class SignInCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SignIn]] = None


class MicrosoftAuthenticatorAuthenticationMethodCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[MicrosoftAuthenticatorAuthenticationMethod]] = None


class WindowsHelloForBusinessAuthenticationMethodCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[WindowsHelloForBusinessAuthenticationMethod]] = None


class ProtectionUnitBaseCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ProtectionUnitBase]] = None


class RestorePointCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[RestorePoint]] = None


class RestoreSessionBaseCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[RestoreSessionBase]] = None


class SiteProtectionRuleCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SiteProtectionRule]] = None


class SiteProtectionUnitCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SiteProtectionUnit]] = None


class BrowserSharedCookieCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[BrowserSharedCookie]] = None


class BrowserSiteCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[BrowserSite]] = None


class ParticipantCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Participant]] = None


class HorizontalSectionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[HorizontalSection]] = None


class PresenceCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Presence]] = None


class PostCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Post]] = None


class DelegatedAdminAccessAssignmentCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DelegatedAdminAccessAssignment]] = None


class ManagedEBookCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ManagedEBook]] = None


class MdmWindowsInformationProtectionPolicyCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[MdmWindowsInformationProtectionPolicy]] = None


class ManagedDeviceMobileAppConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[ManagedDeviceMobileAppConfiguration]] = None


class MobileAppCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[MobileApp]] = None


class TargetedManagedAppConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[TargetedManagedAppConfiguration]] = None


class ComplianceManagementPartnerCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[ComplianceManagementPartner]] = None


class DeviceCompliancePolicyCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[DeviceCompliancePolicy]] = None


class DeviceCompliancePolicySettingStateSummaryCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DeviceCompliancePolicySettingStateSummary]] = None


class DeviceConfigurationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[DeviceConfiguration]] = None


class DeviceEnrollmentConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DeviceEnrollmentConfiguration]] = None


class ImportedWindowsAutopilotDeviceIdentityCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[ImportedWindowsAutopilotDeviceIdentity]] = None


class UserExperienceAnalyticsCategoryCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UserExperienceAnalyticsCategory]] = None


class AdministrativeUnitCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AdministrativeUnit]] = None


class OnPremisesDirectorySynchronizationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[OnPremisesDirectorySynchronization]] = None


class InternalDomainFederationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[InternalDomainFederation]] = None


class PermissionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Permission]] = None


class EducationAssignmentResourceCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[EducationAssignmentResource]] = None


class EducationModuleResourceCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[EducationModuleResource]] = None


class EducationSubmissionResourceCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[EducationSubmissionResource]] = None


class EducationRubricCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[EducationRubric]] = None


class EngagementAsyncOperationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[EngagementAsyncOperation]] = None


class EndUserNotificationDetailCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[EndUserNotificationDetail]] = None


class ApprovalCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Approval]] = None


class ConnectedOrganizationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ConnectedOrganization]] = None


class AuthenticationEventListenerCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AuthenticationEventListener]] = None


class AuthenticationEventsFlowCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AuthenticationEventsFlow]] = None


class B2xIdentityUserFlowCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[B2xIdentityUserFlow]] = None


class CustomAuthenticationExtensionCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[CustomAuthenticationExtension]] = None


class RiskDetectionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[RiskDetection]] = None


class ServicePrincipalRiskDetectionCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[ServicePrincipalRiskDetection]] = None


class ThreatAssessmentRequestCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ThreatAssessmentRequest]] = None


class BrowserSiteListCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[BrowserSiteList]] = None


class RichLongRunningOperationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[RichLongRunningOperation]] = None


class DocumentSetVersionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[DocumentSetVersion]] = None


class MessageRuleCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[MessageRule]] = None


class MessageCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Message]] = None


class MultiTenantOrganizationMemberCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[MultiTenantOrganizationMember]] = None


class OnenoteOperationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[OnenoteOperation]] = None


class PlannerTaskCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[PlannerTask]] = None


class ActivityBasedTimeoutPolicyCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[ActivityBasedTimeoutPolicy]] = None


class ClaimsMappingPolicyCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ClaimsMappingPolicy]] = None


class PermissionGrantPolicyCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[PermissionGrantPolicy]] = None


class PrintConnectorCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[PrintConnector]] = None


class PrintOperationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[PrintOperation]] = None


class UnifiedRoleAssignmentCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[UnifiedRoleAssignment]] = None


class UnifiedRoleEligibilityScheduleInstanceCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UnifiedRoleEligibilityScheduleInstance]] = None


class RoomCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Room]] = None


class OfferShiftRequestCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[OfferShiftRequest]] = None


class OpenShiftChangeRequestCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[OpenShiftChangeRequest]] = None


class ShiftCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Shift]] = None


class SwapShiftsChangeRequestCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SwapShiftsChangeRequest]] = None


class TimeOffCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[TimeOff]] = None


class AlertCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Alert]] = None


class SecureScoreCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SecureScore]] = None


class ServiceHealthIssueCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ServiceHealthIssue]] = None


class ServiceUpdateMessageCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ServiceUpdateMessage]] = None


class AuthoredNoteCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AuthoredNote]] = None


class WorkforceIntegrationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[WorkforceIntegration]] = None


class DelegatedAdminCustomerCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[DelegatedAdminCustomer]] = None


class DelegatedAdminRelationshipCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DelegatedAdminRelationship]] = None


class TrainingLanguageDetailCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[TrainingLanguageDetail]] = None


class UnifiedRoleManagementPolicyRuleCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UnifiedRoleManagementPolicyRule]] = None


class CloudPcAuditEventCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[CloudPcAuditEvent]] = None


class CloudPcOnPremisesConnectionCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[CloudPcOnPremisesConnection]] = None


class CloudPcUserSettingCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[CloudPcUserSetting]] = None


class VirtualEventPresenterCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[VirtualEventPresenter]] = None


class VirtualEventSessionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[VirtualEventSession]] = None


class WorkbookTableColumnCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[WorkbookTableColumn]] = None


class EmailAuthenticationMethodConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[EmailAuthenticationMethodConfiguration]] = None


class Fido2AuthenticationMethodConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[Fido2AuthenticationMethodConfiguration]] = None


class SmsAuthenticationMethodConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[SmsAuthenticationMethodConfiguration]] = None


class SoftwareOathAuthenticationMethodConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[SoftwareOathAuthenticationMethodConfiguration]] = None


class TemporaryAccessPassAuthenticationMethodConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[TemporaryAccessPassAuthenticationMethodConfiguration]] = None


class VoiceAuthenticationMethodConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[VoiceAuthenticationMethodConfiguration]] = None


class AuthorizationPolicyCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AuthorizationPolicy]] = None


class IdentitySecurityDefaultsEnforcementPolicyCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[IdentitySecurityDefaultsEnforcementPolicy]] = None


class DomainDnsCnameRecordCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[DomainDnsCnameRecord]] = None


class DomainDnsMxRecordCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[DomainDnsMxRecord]] = None


class RoomListCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[RoomList]] = None


class AccessPackageMultipleChoiceQuestionCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AccessPackageMultipleChoiceQuestion]] = None


class AccessPackageAssignmentRequestWorkflowExtensionCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AccessPackageAssignmentRequestWorkflowExtension]] = None


class AccessPackageAssignmentWorkflowExtensionCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AccessPackageAssignmentWorkflowExtension]] = None


class OnTokenIssuanceStartCustomExtensionCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[OnTokenIssuanceStartCustomExtension]] = None


class SamlOrWsFedExternalDomainFederationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[SamlOrWsFedExternalDomainFederation]] = None


class BookingCustomerCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[BookingCustomer]] = None


class BookingStaffMemberCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[BookingStaffMember]] = None


class AddLargeGalleryViewOperationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AddLargeGalleryViewOperation]] = None


class CancelMediaProcessingOperationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[CancelMediaProcessingOperation]] = None


class AnonymousGuestConversationMemberCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AnonymousGuestConversationMember]] = None


class AzureCommunicationServicesUserConversationMemberCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AzureCommunicationServicesUserConversationMember]] = None


class AndroidManagedAppRegistrationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AndroidManagedAppRegistration]] = None


class IosManagedAppRegistrationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[IosManagedAppRegistration]] = None


class MobileLobAppCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[MobileLobApp]] = None


class Win32LobAppCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Win32LobApp]] = None


class WindowsAppXCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[WindowsAppX]] = None


class WindowsMobileMSICollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[WindowsMobileMSI]] = None


class WindowsUniversalAppXCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[WindowsUniversalAppX]] = None


class WebAppCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[WebApp]] = None


class WindowsMicrosoftEdgeAppCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[WindowsMicrosoftEdgeApp]] = None


class WindowsWebAppCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[WindowsWebApp]] = None


class IosCompliancePolicyCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[IosCompliancePolicy]] = None


class MacOSCompliancePolicyCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[MacOSCompliancePolicy]] = None


class Windows10CompliancePolicyCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[Windows10CompliancePolicy]] = None


class Windows10MobileCompliancePolicyCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[Windows10MobileCompliancePolicy]] = None


class Windows81CompliancePolicyCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[Windows81CompliancePolicy]] = None


class WindowsPhone81CompliancePolicyCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[WindowsPhone81CompliancePolicy]] = None


class EditionUpgradeConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[EditionUpgradeConfiguration]] = None


class IosCertificateProfileCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[IosCertificateProfile]] = None


class IosCustomConfigurationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[IosCustomConfiguration]] = None


class IosGeneralDeviceConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[IosGeneralDeviceConfiguration]] = None


class IosUpdateConfigurationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[IosUpdateConfiguration]] = None


class MacOSCustomConfigurationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[MacOSCustomConfiguration]] = None


class MacOSGeneralDeviceConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[MacOSGeneralDeviceConfiguration]] = None


class SharedPCConfigurationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SharedPCConfiguration]] = None


class Windows10CustomConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[Windows10CustomConfiguration]] = None


class Windows10EndpointProtectionConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[Windows10EndpointProtectionConfiguration]] = None


class Windows10EnterpriseModernAppManagementConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[Windows10EnterpriseModernAppManagementConfiguration]] = None


class Windows10GeneralConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[Windows10GeneralConfiguration]] = None


class Windows10SecureAssessmentConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[Windows10SecureAssessmentConfiguration]] = None


class Windows10TeamGeneralConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[Windows10TeamGeneralConfiguration]] = None


class Windows81GeneralConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[Windows81GeneralConfiguration]] = None


class WindowsDefenderAdvancedThreatProtectionConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[WindowsDefenderAdvancedThreatProtectionConfiguration]] = None


class WindowsPhone81CustomConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[WindowsPhone81CustomConfiguration]] = None


class WindowsPhone81GeneralConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[WindowsPhone81GeneralConfiguration]] = None


class WindowsUpdateForBusinessConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[WindowsUpdateForBusinessConfiguration]] = None


class DeviceEnrollmentLimitConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DeviceEnrollmentLimitConfiguration]] = None


class DeviceEnrollmentPlatformRestrictionsConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DeviceEnrollmentPlatformRestrictionsConfiguration]] = None


class DeviceEnrollmentWindowsHelloForBusinessConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DeviceEnrollmentWindowsHelloForBusinessConfiguration]] = None


class Windows10EnrollmentCompletionPageConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[Windows10EnrollmentCompletionPageConfiguration]] = None


class EducationFeedbackResourceOutcomeCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[EducationFeedbackResourceOutcome]] = None


class EducationPointsOutcomeCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[EducationPointsOutcome]] = None


class EducationRubricOutcomeCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[EducationRubricOutcome]] = None


class LearningAssignmentCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[LearningAssignment]] = None


class OnAttributeCollectionListenerCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[OnAttributeCollectionListener]] = None


class OnAuthenticationMethodLoadStartListenerCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[OnAuthenticationMethodLoadStartListener]] = None


class OnInteractiveAuthFlowStartListenerCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[OnInteractiveAuthFlowStartListener]] = None


class OnTokenIssuanceStartListenerCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[OnTokenIssuanceStartListener]] = None


class OnUserCreateStartListenerCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[OnUserCreateStartListener]] = None


class ExternalUsersSelfServiceSignUpEventsFlowCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[ExternalUsersSelfServiceSignUpEventsFlow]] = None


class IdentityBuiltInUserFlowAttributeCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[IdentityBuiltInUserFlowAttribute]] = None


class IdentityCustomUserFlowAttributeCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[IdentityCustomUserFlowAttribute]] = None


class UrlAssessmentRequestCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[UrlAssessmentRequest]] = None


class IosVppEBookAssignmentCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[IosVppEBookAssignment]] = None


class ResellerDelegatedAdminRelationshipCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[ResellerDelegatedAdminRelationship]] = None


class ChatMessageReactionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ChatMessageReaction]] = None


class DeviceCompliancePolicySettingStateCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DeviceCompliancePolicySettingState]] = None


class DeviceConfigurationSettingStateCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DeviceConfigurationSettingState]] = None


class ObjectDefinitionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ObjectDefinition]] = None


class AttendeeCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Attendee]] = None


class LocationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Location]] = None


class ShiftAvailabilityCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ShiftAvailability]] = None


class BookingsAvailabilityWindowCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[BookingsAvailabilityWindow]] = None


class LocationConstraintItemCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[LocationConstraintItem]] = None


class AttendeeAvailabilityCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AttendeeAvailability]] = None


class MeetingTimeSuggestionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[MeetingTimeSuggestion]] = None


class AttributeDefinitionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AttributeDefinition]] = None


class RestorePointSearchResultCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[RestorePointSearchResult]] = None


class AggregationOptionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AggregationOption]] = None


class UserSimulationDetailsCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[UserSimulationDetails]] = None


class AccessPackageSubject(Entity):
    display_name: Annotated[
        Optional[str], Field(description='The display name of the subject.')
    ] = None
    email: Annotated[
        Optional[str], Field(description='The email address of the subject.')
    ] = None
    object_id: Annotated[
        Optional[str],
        Field(
            description="The object identifier of the subject. null if the subject isn't yet a user in the tenant."
        ),
    ] = None
    on_premises_security_identifier: Annotated[
        Optional[str],
        Field(
            description="A string representation of the principal's security identifier, if known, or null if the subject doesn't have a security identifier."
        ),
    ] = None
    principal_name: Annotated[
        Optional[str],
        Field(description='The principal name, if known, of the subject.'),
    ] = None
    subject_type: Annotated[
        Optional[Union[AccessPackageSubjectType, Dict[str, Any]]],
        Field(
            description='The resource type of the subject. The possible values are: notSpecified, user, servicePrincipal, unknownFutureValue.'
        ),
    ] = None
    connected_organization: Annotated[
        Optional[Union[ConnectedOrganization, Dict[str, Any]]],
        Field(
            description='The connected organization of the subject. Read-only. Nullable.'
        ),
    ] = None
    field_odata_type: str


class AgreementFile(AgreementFileProperties):
    localizations: Annotated[
        Optional[List[AgreementFileLocalization]],
        Field(
            description='The localized version of the terms of use agreement files attached to the agreement.'
        ),
    ] = None
    field_odata_type: str


class AndroidCompliancePolicy(DeviceCompliancePolicy):
    device_threat_protection_enabled: Annotated[
        Optional[bool],
        Field(
            description='Require that devices have enabled device threat protection.'
        ),
    ] = None
    device_threat_protection_required_security_level: Optional[
        DeviceThreatProtectionLevel
    ] = None
    min_android_security_patch_level: Annotated[
        Optional[str], Field(description='Minimum Android security patch level.')
    ] = None
    os_maximum_version: Annotated[
        Optional[str], Field(description='Maximum Android version.')
    ] = None
    os_minimum_version: Annotated[
        Optional[str], Field(description='Minimum Android version.')
    ] = None
    password_expiration_days: Annotated[
        Optional[float],
        Field(
            description='Number of days before the password expires. Valid values 1 to 365',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minimum_length: Annotated[
        Optional[float],
        Field(
            description='Minimum password length. Valid values 4 to 16',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minutes_of_inactivity_before_lock: Annotated[
        Optional[float],
        Field(
            description='Minutes of inactivity before a password is required.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_previous_password_block_count: Annotated[
        Optional[float],
        Field(
            description='Number of previous passwords to block. Valid values 1 to 24',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_required: Annotated[
        Optional[bool], Field(description='Require a password to unlock device.')
    ] = None
    password_required_type: Optional[AndroidRequiredPasswordType] = None
    security_block_jailbroken_devices: Annotated[
        Optional[bool], Field(description='Devices must not be jailbroken or rooted.')
    ] = None
    security_disable_usb_debugging: Annotated[
        Optional[bool], Field(description='Disable USB debugging on Android devices.')
    ] = None
    security_prevent_install_apps_from_unknown_sources: Annotated[
        Optional[bool],
        Field(
            description='Require that devices disallow installation of apps from unknown sources.'
        ),
    ] = None
    security_require_company_portal_app_integrity: Annotated[
        Optional[bool],
        Field(
            description='Require the device to pass the Company Portal client app runtime integrity check.'
        ),
    ] = None
    security_require_google_play_services: Annotated[
        Optional[bool],
        Field(
            description='Require Google Play Services to be installed and enabled on the device.'
        ),
    ] = None
    security_require_safety_net_attestation_basic_integrity: Annotated[
        Optional[bool],
        Field(
            description='Require the device to pass the SafetyNet basic integrity check.'
        ),
    ] = None
    security_require_safety_net_attestation_certified_device: Annotated[
        Optional[bool],
        Field(
            description='Require the device to pass the SafetyNet certified device check.'
        ),
    ] = None
    security_require_up_to_date_security_providers: Annotated[
        Optional[bool],
        Field(
            description='Require the device to have up to date security providers. The device will require Google Play Services to be enabled and up to date.'
        ),
    ] = None
    security_require_verify_apps: Annotated[
        Optional[bool],
        Field(description='Require the Android Verify apps feature is turned on.'),
    ] = None
    storage_require_encryption: Annotated[
        Optional[bool], Field(description='Require encryption on Android devices.')
    ] = None
    field_odata_type: str


class AndroidCustomConfiguration(DeviceConfiguration):
    oma_settings: Annotated[
        Optional[List[OmaSetting]],
        Field(
            description='OMA settings. This collection can contain a maximum of 1000 elements.'
        ),
    ] = None
    field_odata_type: str


class AndroidGeneralDeviceConfiguration(DeviceConfiguration):
    apps_block_clipboard_sharing: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block clipboard sharing to copy and paste between applications.'
        ),
    ] = None
    apps_block_copy_paste: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block copy and paste within applications.'
        ),
    ] = None
    apps_block_you_tube: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block the YouTube app.'),
    ] = None
    apps_hide_list: Annotated[
        Optional[List[AppListItem]],
        Field(
            description='List of apps to be hidden on the KNOX device. This collection can contain a maximum of 500 elements.'
        ),
    ] = None
    apps_install_allow_list: Annotated[
        Optional[List[AppListItem]],
        Field(
            description='List of apps which can be installed on the KNOX device. This collection can contain a maximum of 500 elements.'
        ),
    ] = None
    apps_launch_block_list: Annotated[
        Optional[List[AppListItem]],
        Field(
            description='List of apps which are blocked from being launched on the KNOX device. This collection can contain a maximum of 500 elements.'
        ),
    ] = None
    bluetooth_blocked: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block Bluetooth.'),
    ] = None
    camera_blocked: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block the use of the camera.'),
    ] = None
    cellular_block_data_roaming: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block data roaming.'),
    ] = None
    cellular_block_messaging: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block SMS/MMS messaging.'),
    ] = None
    cellular_block_voice_roaming: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block voice roaming.'),
    ] = None
    cellular_block_wi_fi_tethering: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block syncing Wi-Fi tethering.'),
    ] = None
    compliant_app_list_type: Optional[AppListType] = None
    compliant_apps_list: Annotated[
        Optional[List[AppListItem]],
        Field(
            description='List of apps in the compliance (either allow list or block list, controlled by CompliantAppListType). This collection can contain a maximum of 10000 elements.'
        ),
    ] = None
    device_sharing_allowed: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to allow device sharing mode.'),
    ] = None
    diagnostic_data_block_submission: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block diagnostic data submission.'
        ),
    ] = None
    factory_reset_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block user performing a factory reset.'
        ),
    ] = None
    google_account_block_auto_sync: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block Google account auto sync.'
        ),
    ] = None
    google_play_store_blocked: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block the Google Play store.'),
    ] = None
    kiosk_mode_apps: Annotated[
        Optional[List[AppListItem]],
        Field(
            description='A list of apps that will be allowed to run when the device is in Kiosk Mode. This collection can contain a maximum of 500 elements.'
        ),
    ] = None
    kiosk_mode_block_sleep_button: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the screen sleep button while in Kiosk Mode.'
        ),
    ] = None
    kiosk_mode_block_volume_buttons: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the volume buttons while in Kiosk Mode.'
        ),
    ] = None
    location_services_blocked: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block location services.'),
    ] = None
    nfc_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block Near-Field Communication.'
        ),
    ] = None
    password_block_fingerprint_unlock: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block fingerprint unlock.'),
    ] = None
    password_block_trust_agents: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block Smart Lock and other trust agents.'
        ),
    ] = None
    password_expiration_days: Annotated[
        Optional[float],
        Field(
            description='Number of days before the password expires. Valid values 1 to 365',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minimum_length: Annotated[
        Optional[float],
        Field(
            description='Minimum length of passwords. Valid values 4 to 16',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minutes_of_inactivity_before_screen_timeout: Annotated[
        Optional[float],
        Field(
            description='Minutes of inactivity before the screen times out.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_previous_password_block_count: Annotated[
        Optional[float],
        Field(
            description='Number of previous passwords to block. Valid values 0 to 24',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_required: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to require a password.'),
    ] = None
    password_required_type: Optional[AndroidRequiredPasswordType] = None
    password_sign_in_failure_count_before_factory_reset: Annotated[
        Optional[float],
        Field(
            description='Number of sign in failures allowed before factory reset. Valid values 1 to 16',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    power_off_blocked: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block powering off the device.'),
    ] = None
    screen_capture_blocked: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block screenshots.'),
    ] = None
    security_require_verify_apps: Annotated[
        Optional[bool],
        Field(description='Require the Android Verify apps feature is turned on.'),
    ] = None
    storage_block_google_backup: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block Google Backup.'),
    ] = None
    storage_block_removable_storage: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block removable storage usage.'),
    ] = None
    storage_require_device_encryption: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to require device encryption.'),
    ] = None
    storage_require_removable_storage_encryption: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to require removable storage encryption.'
        ),
    ] = None
    voice_assistant_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block the use of the Voice Assistant.'
        ),
    ] = None
    voice_dialing_blocked: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block voice dialing.'),
    ] = None
    web_browser_block_autofill: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether or not to block the web browser's auto fill feature."
        ),
    ] = None
    web_browser_blocked: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block the web browser.'),
    ] = None
    web_browser_block_java_script: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block JavaScript within the web browser.'
        ),
    ] = None
    web_browser_block_popups: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block popups within the web browser.'
        ),
    ] = None
    web_browser_cookie_settings: Optional[WebBrowserCookieSettings] = None
    wi_fi_blocked: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block syncing Wi-Fi.'),
    ] = None
    field_odata_type: str


class AndroidLobApp(MobileLobApp):
    minimum_supported_operating_system: Annotated[
        Optional[Union[AndroidMinimumOperatingSystem, Dict[str, Any]]],
        Field(description='The value for the minimum applicable operating system.'),
    ] = None
    package_id: Annotated[
        Optional[str], Field(description='The package identifier.')
    ] = None
    version_code: Annotated[
        Optional[str],
        Field(description='The version code of Android Line of Business (LoB) app.'),
    ] = None
    version_name: Annotated[
        Optional[str],
        Field(description='The version name of Android Line of Business (LoB) app.'),
    ] = None
    field_odata_type: str


class AndroidManagedAppProtection(TargetedManagedAppProtection):
    custom_browser_display_name: Annotated[
        Optional[str],
        Field(
            description='Friendly name of the preferred custom browser to open weblink on Android. When this property is configured, ManagedBrowserToOpenLinksRequired should be true.'
        ),
    ] = None
    custom_browser_package_id: Annotated[
        Optional[str],
        Field(
            description='Unique identifier of the preferred custom browser to open weblink on Android. When this property is configured, ManagedBrowserToOpenLinksRequired should be true.'
        ),
    ] = None
    deployed_app_count: Annotated[
        Optional[float],
        Field(
            description='Count of apps to which the current policy is deployed.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    disable_app_encryption_if_device_encryption_is_enabled: Annotated[
        Optional[bool],
        Field(
            description='When this setting is enabled, app level encryption is disabled if device level encryption is enabled'
        ),
    ] = None
    encrypt_app_data: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether application data for managed apps should be encrypted'
        ),
    ] = None
    minimum_required_patch_version: Annotated[
        Optional[str],
        Field(
            description='Define the oldest required Android security patch level a user can have to gain secure access to the app.'
        ),
    ] = None
    minimum_warning_patch_version: Annotated[
        Optional[str],
        Field(
            description='Define the oldest recommended Android security patch level a user can have for secure access to the app.'
        ),
    ] = None
    screen_capture_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether a managed user can take screen captures of managed apps'
        ),
    ] = None
    apps: Annotated[
        Optional[List[ManagedMobileApp]],
        Field(description='List of apps to which the policy is deployed.'),
    ] = None
    deployment_summary: Annotated[
        Optional[Union[ManagedAppPolicyDeploymentSummary, Dict[str, Any]]],
        Field(
            description='Navigation property to deployment summary of the configuration.'
        ),
    ] = None
    field_odata_type: str


class AndroidStoreApp(MobileApp):
    app_store_url: Annotated[
        Optional[str], Field(description='The Android app store URL.')
    ] = None
    minimum_supported_operating_system: Annotated[
        Optional[Union[AndroidMinimumOperatingSystem, Dict[str, Any]]],
        Field(description='The value for the minimum applicable operating system.'),
    ] = None
    package_id: Annotated[
        Optional[str], Field(description='The package identifier.')
    ] = None
    field_odata_type: str


class AndroidWorkProfileCompliancePolicy(DeviceCompliancePolicy):
    device_threat_protection_enabled: Annotated[
        Optional[bool],
        Field(
            description='Require that devices have enabled device threat protection.'
        ),
    ] = None
    device_threat_protection_required_security_level: Optional[
        DeviceThreatProtectionLevel
    ] = None
    min_android_security_patch_level: Annotated[
        Optional[str], Field(description='Minimum Android security patch level.')
    ] = None
    os_maximum_version: Annotated[
        Optional[str], Field(description='Maximum Android version.')
    ] = None
    os_minimum_version: Annotated[
        Optional[str], Field(description='Minimum Android version.')
    ] = None
    password_expiration_days: Annotated[
        Optional[float],
        Field(
            description='Number of days before the password expires. Valid values 1 to 365',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minimum_length: Annotated[
        Optional[float],
        Field(
            description='Minimum password length. Valid values 4 to 16',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minutes_of_inactivity_before_lock: Annotated[
        Optional[float],
        Field(
            description='Minutes of inactivity before a password is required.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_previous_password_block_count: Annotated[
        Optional[float],
        Field(
            description='Number of previous passwords to block. Valid values 1 to 24',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_required: Annotated[
        Optional[bool], Field(description='Require a password to unlock device.')
    ] = None
    password_required_type: Optional[AndroidRequiredPasswordType] = None
    security_block_jailbroken_devices: Annotated[
        Optional[bool], Field(description='Devices must not be jailbroken or rooted.')
    ] = None
    security_disable_usb_debugging: Annotated[
        Optional[bool], Field(description='Disable USB debugging on Android devices.')
    ] = None
    security_prevent_install_apps_from_unknown_sources: Annotated[
        Optional[bool],
        Field(
            description='Require that devices disallow installation of apps from unknown sources.'
        ),
    ] = None
    security_require_company_portal_app_integrity: Annotated[
        Optional[bool],
        Field(
            description='Require the device to pass the Company Portal client app runtime integrity check.'
        ),
    ] = None
    security_require_google_play_services: Annotated[
        Optional[bool],
        Field(
            description='Require Google Play Services to be installed and enabled on the device.'
        ),
    ] = None
    security_require_safety_net_attestation_basic_integrity: Annotated[
        Optional[bool],
        Field(
            description='Require the device to pass the SafetyNet basic integrity check.'
        ),
    ] = None
    security_require_safety_net_attestation_certified_device: Annotated[
        Optional[bool],
        Field(
            description='Require the device to pass the SafetyNet certified device check.'
        ),
    ] = None
    security_require_up_to_date_security_providers: Annotated[
        Optional[bool],
        Field(
            description='Require the device to have up to date security providers. The device will require Google Play Services to be enabled and up to date.'
        ),
    ] = None
    security_require_verify_apps: Annotated[
        Optional[bool],
        Field(description='Require the Android Verify apps feature is turned on.'),
    ] = None
    storage_require_encryption: Annotated[
        Optional[bool], Field(description='Require encryption on Android devices.')
    ] = None
    field_odata_type: str


class AndroidWorkProfileCustomConfiguration(DeviceConfiguration):
    oma_settings: Annotated[
        Optional[List[OmaSetting]],
        Field(
            description='OMA settings. This collection can contain a maximum of 500 elements.'
        ),
    ] = None
    field_odata_type: str


class AndroidWorkProfileGeneralDeviceConfiguration(DeviceConfiguration):
    password_block_fingerprint_unlock: Annotated[
        Optional[bool],
        Field(description='Indicates whether or not to block fingerprint unlock.'),
    ] = None
    password_block_trust_agents: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block Smart Lock and other trust agents.'
        ),
    ] = None
    password_expiration_days: Annotated[
        Optional[float],
        Field(
            description='Number of days before the password expires. Valid values 1 to 365',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minimum_length: Annotated[
        Optional[float],
        Field(
            description='Minimum length of passwords. Valid values 4 to 16',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_minutes_of_inactivity_before_screen_timeout: Annotated[
        Optional[float],
        Field(
            description='Minutes of inactivity before the screen times out.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_previous_password_block_count: Annotated[
        Optional[float],
        Field(
            description='Number of previous passwords to block. Valid values 0 to 24',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_required_type: Optional[AndroidWorkProfileRequiredPasswordType] = None
    password_sign_in_failure_count_before_factory_reset: Annotated[
        Optional[float],
        Field(
            description='Number of sign in failures allowed before factory reset. Valid values 1 to 16',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    security_require_verify_apps: Annotated[
        Optional[bool],
        Field(description='Require the Android Verify apps feature is turned on.'),
    ] = None
    work_profile_block_adding_accounts: Annotated[
        Optional[bool],
        Field(description='Block users from adding/removing accounts in work profile.'),
    ] = None
    work_profile_block_camera: Annotated[
        Optional[bool], Field(description='Block work profile camera.')
    ] = None
    work_profile_block_cross_profile_caller_id: Annotated[
        Optional[bool],
        Field(description='Block display work profile caller ID in personal profile.'),
    ] = None
    work_profile_block_cross_profile_contacts_search: Annotated[
        Optional[bool],
        Field(
            description='Block work profile contacts availability in personal profile.'
        ),
    ] = None
    work_profile_block_cross_profile_copy_paste: Annotated[
        Optional[bool],
        Field(
            description='Boolean that indicates if the setting disallow cross profile copy/paste is enabled.'
        ),
    ] = None
    work_profile_block_notifications_while_device_locked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block notifications while device locked.'
        ),
    ] = None
    work_profile_block_screen_capture: Annotated[
        Optional[bool], Field(description='Block screen capture in work profile.')
    ] = None
    work_profile_bluetooth_enable_contact_sharing: Annotated[
        Optional[bool],
        Field(description='Allow bluetooth devices to access enterprise contacts.'),
    ] = None
    work_profile_data_sharing_type: Optional[
        AndroidWorkProfileCrossProfileDataSharingType
    ] = None
    work_profile_default_app_permission_policy: Optional[
        AndroidWorkProfileDefaultAppPermissionPolicyType
    ] = None
    work_profile_password_block_fingerprint_unlock: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block fingerprint unlock for work profile.'
        ),
    ] = None
    work_profile_password_block_trust_agents: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether or not to block Smart Lock and other trust agents for work profile.'
        ),
    ] = None
    work_profile_password_expiration_days: Annotated[
        Optional[float],
        Field(
            description='Number of days before the work profile password expires. Valid values 1 to 365',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    work_profile_password_minimum_length: Annotated[
        Optional[float],
        Field(
            description='Minimum length of work profile password. Valid values 4 to 16',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    work_profile_password_min_letter_characters: Annotated[
        Optional[float],
        Field(
            description='Minimum # of letter characters required in work profile password. Valid values 1 to 10',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    work_profile_password_min_lower_case_characters: Annotated[
        Optional[float],
        Field(
            description='Minimum # of lower-case characters required in work profile password. Valid values 1 to 10',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    work_profile_password_min_non_letter_characters: Annotated[
        Optional[float],
        Field(
            description='Minimum # of non-letter characters required in work profile password. Valid values 1 to 10',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    work_profile_password_min_numeric_characters: Annotated[
        Optional[float],
        Field(
            description='Minimum # of numeric characters required in work profile password. Valid values 1 to 10',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    work_profile_password_min_symbol_characters: Annotated[
        Optional[float],
        Field(
            description='Minimum # of symbols required in work profile password. Valid values 1 to 10',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    work_profile_password_min_upper_case_characters: Annotated[
        Optional[float],
        Field(
            description='Minimum # of upper-case characters required in work profile password. Valid values 1 to 10',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    work_profile_password_minutes_of_inactivity_before_screen_timeout: Annotated[
        Optional[float],
        Field(
            description='Minutes of inactivity before the screen times out.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    work_profile_password_previous_password_block_count: Annotated[
        Optional[float],
        Field(
            description='Number of previous work profile passwords to block. Valid values 0 to 24',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    work_profile_password_required_type: Optional[
        AndroidWorkProfileRequiredPasswordType
    ] = None
    work_profile_password_sign_in_failure_count_before_factory_reset: Annotated[
        Optional[float],
        Field(
            description='Number of sign in failures allowed before work profile is removed and all corporate data deleted. Valid values 1 to 16',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    work_profile_require_password: Annotated[
        Optional[bool],
        Field(description='Password is required or not for work profile'),
    ] = None
    field_odata_type: str


class AppConsentRequest(Entity):
    app_display_name: Annotated[
        Optional[str],
        Field(
            description='The display name of the app for which consent is requested. Required. Supports $filter (eq only) and $orderby.'
        ),
    ] = None
    app_id: Annotated[
        Optional[str],
        Field(
            description='The identifier of the application. Required. Supports $filter (eq only) and $orderby.'
        ),
    ] = None
    pending_scopes: Annotated[
        Optional[List[AppConsentRequestScope]],
        Field(description='A list of pending scopes waiting for approval. Required.'),
    ] = None
    user_consent_requests: Annotated[
        Optional[List[UserConsentRequest]],
        Field(
            description='A list of pending user consent requests. Supports $filter (eq).'
        ),
    ] = None
    field_odata_type: str


class AppleDeviceFeaturesConfigurationBase(DeviceConfiguration):
    field_odata_type: str


class AppManagementPolicy(PolicyBase):
    is_enabled: Annotated[
        Optional[bool], Field(description='Denotes whether the policy is enabled.')
    ] = None
    restrictions: Annotated[
        Optional[Union[CustomAppManagementConfiguration, Dict[str, Any]]],
        Field(
            description='Restrictions that apply to an application or service principal object.'
        ),
    ] = None
    applies_to: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description='Collection of applications and service principals to which the policy is applied.'
        ),
    ] = None
    field_odata_type: str


class AuditLogRoot(Entity):
    directory_audits: Optional[List[DirectoryAudit]] = None
    provisioning: Optional[List[ProvisioningObjectSummary]] = None
    sign_ins: Optional[List[SignIn]] = None
    field_odata_type: str


class Authentication(Entity):
    email_methods: Annotated[
        Optional[List[EmailAuthenticationMethod]],
        Field(description='The email address registered to a user for authentication.'),
    ] = None
    fido2_methods: Annotated[
        Optional[List[Fido2AuthenticationMethod]],
        Field(
            description='Represents the FIDO2 security keys registered to a user for authentication.'
        ),
    ] = None
    methods: Annotated[
        Optional[List[AuthenticationMethod]],
        Field(
            description='Represents all authentication methods registered to a user.'
        ),
    ] = None
    microsoft_authenticator_methods: Annotated[
        Optional[List[MicrosoftAuthenticatorAuthenticationMethod]],
        Field(
            description='The details of the Microsoft Authenticator app registered to a user for authentication.'
        ),
    ] = None
    operations: Annotated[
        Optional[List[LongRunningOperation]],
        Field(
            description='Represents the status of a long-running operation, such as a password reset operation.'
        ),
    ] = None
    password_methods: Annotated[
        Optional[List[PasswordAuthenticationMethod]],
        Field(
            description='Represents the password registered to a user for authentication. For security, the password itself is never returned in the object, but action can be taken to reset a password.'
        ),
    ] = None
    phone_methods: Annotated[
        Optional[List[PhoneAuthenticationMethod]],
        Field(description='The phone numbers registered to a user for authentication.'),
    ] = None
    software_oath_methods: Annotated[
        Optional[List[SoftwareOathAuthenticationMethod]],
        Field(
            description='The software OATH time-based one-time password (TOTP) applications registered to a user for authentication.'
        ),
    ] = None
    temporary_access_pass_methods: Annotated[
        Optional[List[TemporaryAccessPassAuthenticationMethod]],
        Field(
            description='Represents a Temporary Access Pass registered to a user for authentication through time-limited passcodes.'
        ),
    ] = None
    windows_hello_for_business_methods: Annotated[
        Optional[List[WindowsHelloForBusinessAuthenticationMethod]],
        Field(
            description='Represents the Windows Hello for Business authentication method registered to a user for authentication.'
        ),
    ] = None
    field_odata_type: str


class AuthenticationMethodsPolicy(Entity):
    description: Annotated[
        Optional[str], Field(description='A description of the policy. Read-only.')
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The name of the policy. Read-only.')
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time of the last update to the policy. Read-only.',
        ),
    ] = None
    policy_migration_state: Annotated[
        Optional[Union[AuthenticationMethodsPolicyMigrationState, Dict[str, Any]]],
        Field(
            description='The state of migration of the authentication methods policy from the legacy multifactor authentication and self-service password reset (SSPR) policies. The possible values are: premigration - means the authentication methods policy is used for authentication only, legacy policies are respected. migrationInProgress - means the authentication methods policy is used for both authentication and SSPR, legacy policies are respected. migrationComplete - means the authentication methods policy is used for authentication and SSPR, legacy policies are ignored. unknownFutureValue - Evolvable enumeration sentinel value. Do not use.'
        ),
    ] = None
    policy_version: Annotated[
        Optional[str], Field(description='The version of the policy in use. Read-only.')
    ] = None
    reconfirmation_in_days: Annotated[
        Optional[float], Field(ge=-2147483648.0, le=2147483647.0)
    ] = None
    registration_enforcement: Annotated[
        Optional[Union[RegistrationEnforcement, Dict[str, Any]]],
        Field(
            description='Enforce registration at sign-in time. This property can be used to remind users to set up targeted authentication methods.'
        ),
    ] = None
    authentication_method_configurations: Annotated[
        Optional[List[AuthenticationMethodConfiguration]],
        Field(
            description='Represents the settings for each authentication method. Automatically expanded on GET /policies/authenticationMethodsPolicy.'
        ),
    ] = None
    field_odata_type: str


class BookingAppointment(Entity):
    additional_information: Annotated[
        Optional[str],
        Field(
            description='Additional information that is sent to the customer when an appointment is confirmed.'
        ),
    ] = None
    anonymous_join_web_url: Annotated[
        Optional[str], Field(description='The URL of the meeting to join anonymously.')
    ] = None
    appointment_label: Annotated[
        Optional[str],
        Field(
            description='The custom label that can be stamped on this appointment by users.'
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date, time, and time zone when the appointment was created. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    customer_email_address: Annotated[
        Optional[str],
        Field(
            description='The SMTP address of the bookingCustomer who books the appointment.'
        ),
    ] = None
    customer_name: Annotated[
        Optional[str], Field(description="The customer's name.")
    ] = None
    customer_notes: Annotated[
        Optional[str],
        Field(
            description='Notes from the customer associated with this appointment. You can get the value only when you read this bookingAppointment by its ID. You can set this property only when you initially create an appointment with a new customer.'
        ),
    ] = None
    customer_phone: Annotated[
        Optional[str], Field(description="The customer's phone number.")
    ] = None
    customers: Annotated[
        Optional[List[BookingCustomerInformationBase]],
        Field(
            description='A collection of customer properties for an appointment. An appointment contains a list of customer information and each unit will indicate the properties of a customer who is part of that appointment. Optional.'
        ),
    ] = None
    customer_time_zone: Annotated[
        Optional[str],
        Field(
            description='The time zone of the customer. For a list of possible values, see dateTimeTimeZone.'
        ),
    ] = None
    duration: Annotated[
        Optional[timedelta],
        Field(
            description='The length of the appointment, denoted in ISO8601 format.',
        ),
    ] = None
    end_date_time: Optional[DateTimeTimeZone] = None
    filled_attendees_count: Annotated[
        Optional[float],
        Field(
            description='The current number of customers in the appointment.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    is_customer_allowed_to_manage_booking: Annotated[
        Optional[bool],
        Field(
            description='Indicates that the customer can manage bookings created by the staff. The default value is false.'
        ),
    ] = None
    is_location_online: Annotated[
        Optional[bool],
        Field(
            description='Indicates that the appointment is held online. The default value is false.'
        ),
    ] = None
    join_web_url: Annotated[
        Optional[str],
        Field(description='The URL of the online meeting for the appointment.'),
    ] = None
    last_updated_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date, time, and time zone when the booking business was last updated. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    maximum_attendees_count: Annotated[
        Optional[float],
        Field(
            description='The maximum number of customers allowed in an appointment. If maximumAttendeesCount of the service is greater than 1, pass valid customer IDs while creating or updating an appointment. To create a customer, use the Create bookingCustomer operation.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    opt_out_of_customer_email: Annotated[
        Optional[bool],
        Field(
            description="If true indicates that the bookingCustomer for this appointment doesn't wish to receive a confirmation for this appointment."
        ),
    ] = None
    post_buffer: Annotated[
        Optional[timedelta],
        Field(
            description='The amount of time to reserve after the appointment ends, for cleaning up, as an example. The value is expressed in ISO8601 format.',
        ),
    ] = None
    pre_buffer: Annotated[
        Optional[timedelta],
        Field(
            description='The amount of time to reserve before the appointment begins, for preparation, as an example. The value is expressed in ISO8601 format.',
        ),
    ] = None
    price: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='The regular price for an appointment for the specified bookingService.'
        ),
    ] = None
    price_type: Optional[BookingPriceType] = None
    reminders: Annotated[
        Optional[List[BookingReminder]],
        Field(
            description='The collection of customer reminders sent for this appointment. The value of this property is available only when reading this bookingAppointment by its ID.'
        ),
    ] = None
    self_service_appointment_id: Annotated[
        Optional[str],
        Field(
            description='Another tracking ID for the appointment, if the appointment was created directly by the customer on the scheduling page, as opposed to by a staff member on behalf of the customer.'
        ),
    ] = None
    service_id: Annotated[
        Optional[str],
        Field(
            description='The ID of the bookingService associated with this appointment.'
        ),
    ] = None
    service_location: Annotated[
        Optional[Union[Location, Dict[str, Any]]],
        Field(description='The location where the service is delivered.'),
    ] = None
    service_name: Annotated[
        Optional[str],
        Field(
            description="The name of the bookingService associated with this appointment.This property is optional when creating a new appointment. If not specified, it's computed from the service associated with the appointment by the serviceId property."
        ),
    ] = None
    service_notes: Annotated[
        Optional[str],
        Field(
            description='Notes from a bookingStaffMember. The value of this property is available only when reading this bookingAppointment by its ID.'
        ),
    ] = None
    sms_notifications_enabled: Annotated[
        Optional[bool],
        Field(
            description='If true, indicates SMS notifications will be sent to the customers for the appointment. Default value is false.'
        ),
    ] = None
    staff_member_ids: Annotated[
        Optional[List[str]],
        Field(
            description='The ID of each bookingStaffMember who is scheduled in this appointment.'
        ),
    ] = None
    start_date_time: Optional[DateTimeTimeZone] = None
    field_odata_type: str


class BookingService(Entity):
    additional_information: Annotated[
        Optional[str],
        Field(
            description='Additional information that is sent to the customer when an appointment is confirmed.'
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date, time, and time zone when the service was created. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    custom_questions: Annotated[
        Optional[List[BookingQuestionAssignment]],
        Field(
            description='Contains the set of custom questions associated with a particular service.'
        ),
    ] = None
    default_duration: Annotated[
        Optional[timedelta],
        Field(
            description='The default length of the service, represented in numbers of days, hours, minutes, and seconds. For example, P11D23H59M59.999999999999S.',
        ),
    ] = None
    default_location: Annotated[
        Optional[Union[Location, Dict[str, Any]]],
        Field(description='The default physical location for the service.'),
    ] = None
    default_price: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='The default monetary price for the service.'),
    ] = None
    default_price_type: Optional[BookingPriceType] = None
    default_reminders: Annotated[
        Optional[List[BookingReminder]],
        Field(
            description='The default set of reminders for an appointment of this service. The value of this property is available only when reading this bookingService by its ID.'
        ),
    ] = None
    description: Annotated[
        Optional[str], Field(description='A text description for the service.')
    ] = None
    display_name: Annotated[Optional[str], Field(description='A service name.')] = None
    is_anonymous_join_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates if an anonymousJoinWebUrl(webrtcUrl) is generated for the appointment booked for this service. The default value is false.'
        ),
    ] = None
    is_customer_allowed_to_manage_booking: Annotated[
        Optional[bool],
        Field(
            description='Indicates that the customer can manage bookings created by the staff. The default value is false.'
        ),
    ] = None
    is_hidden_from_customers: Annotated[
        Optional[bool],
        Field(
            description="True indicates that this service isn't available to customers for booking."
        ),
    ] = None
    is_location_online: Annotated[
        Optional[bool],
        Field(
            description='Indicates that the appointments for the service are held online. The default value is false.'
        ),
    ] = None
    language_tag: Annotated[
        Optional[str],
        Field(description='The language of the self-service booking page.'),
    ] = None
    last_updated_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date, time, and time zone when the service was last updated. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    maximum_attendees_count: Annotated[
        Optional[float],
        Field(
            description='The maximum number of customers allowed in a service. If maximumAttendeesCount of the service is greater than 1, pass valid customer IDs while creating or updating an appointment. To create a customer, use the Create bookingCustomer operation.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    notes: Annotated[
        Optional[str], Field(description='Additional information about this service.')
    ] = None
    post_buffer: Annotated[
        Optional[timedelta],
        Field(
            description='The time to buffer after an appointment for this service ends, and before the next customer appointment can be booked.',
        ),
    ] = None
    pre_buffer: Annotated[
        Optional[timedelta],
        Field(
            description='The time to buffer before an appointment for this service can start.',
        ),
    ] = None
    scheduling_policy: Annotated[
        Optional[Union[BookingSchedulingPolicy, Dict[str, Any]]],
        Field(
            description='The set of policies that determine how appointments for this type of service should be created and managed.'
        ),
    ] = None
    sms_notifications_enabled: Annotated[
        Optional[bool],
        Field(
            description='True indicates SMS notifications can be sent to the customers for the appointment of the service. Default value is false.'
        ),
    ] = None
    staff_member_ids: Annotated[
        Optional[List[str]],
        Field(description='Represents those staff members who provide this service.'),
    ] = None
    web_url: Annotated[
        Optional[str],
        Field(description='The URL a customer uses to access the service.'),
    ] = None
    field_odata_type: str


class CalendarSharingMessage(Message):
    can_accept: Optional[bool] = None
    sharing_message_action: Optional[
        Union[CalendarSharingMessageAction, Dict[str, Any]]
    ] = None
    sharing_message_actions: Optional[List[CalendarSharingMessageAction]] = None
    suggested_calendar_name: Optional[str] = None
    field_odata_type: str


class Call(Entity):
    callback_uri: Annotated[
        Optional[str],
        Field(
            description='The callback URL on which callbacks are delivered. Must be an HTTPS URL.'
        ),
    ] = None
    call_chain_id: Annotated[
        Optional[str],
        Field(
            description='A unique identifier for all the participant calls in a conference or a unique identifier for two participant calls in a P2P call.  This identifier must be copied over from Microsoft.Graph.Call.CallChainId.'
        ),
    ] = None
    call_options: Annotated[
        Optional[Union[CallOptions, Dict[str, Any]]],
        Field(description='Contains the optional features for the call.'),
    ] = None
    call_routes: Annotated[
        Optional[List[CallRoute]],
        Field(
            description='The routing information on how the call was retargeted. Read-only.'
        ),
    ] = None
    chat_info: Annotated[
        Optional[Union[ChatInfo, Dict[str, Any]]],
        Field(
            description='The chat information. Required information for joining a meeting.'
        ),
    ] = None
    direction: Annotated[
        Optional[Union[CallDirection, Dict[str, Any]]],
        Field(
            description='The direction of the call. The possible values are incoming or outgoing. Read-only.'
        ),
    ] = None
    incoming_context: Annotated[
        Optional[Union[IncomingContext, Dict[str, Any]]],
        Field(description='Call context associated with an incoming call.'),
    ] = None
    media_config: Annotated[
        Optional[Union[MediaConfig, Dict[str, Any]]],
        Field(description='The media configuration. Required.'),
    ] = None
    media_state: Annotated[
        Optional[Union[CallMediaState, Dict[str, Any]]],
        Field(description='Read-only. The call media state.'),
    ] = None
    meeting_info: Annotated[
        Optional[Union[MeetingInfo, Dict[str, Any]]],
        Field(
            description='The meeting information. Required information for meeting scenarios.'
        ),
    ] = None
    my_participant_id: Optional[str] = None
    requested_modalities: Annotated[
        Optional[List[Union[Modality, Dict[str, Any]]]],
        Field(
            description='The list of requested modalities. Possible values are: unknown, audio, video, videoBasedScreenSharing, data.'
        ),
    ] = None
    result_info: Annotated[
        Optional[Union[ResultInfo, Dict[str, Any]]],
        Field(
            description='The result information. For example, the result can hold termination reason. Read-only.'
        ),
    ] = None
    source: Annotated[
        Optional[Union[ParticipantInfo, Dict[str, Any]]],
        Field(description='The originator of the call.'),
    ] = None
    state: Annotated[
        Optional[Union[CallState, Dict[str, Any]]],
        Field(
            description='The call state. Possible values are: incoming, establishing, ringing, established, hold, transferring, transferAccepted, redirecting, terminating, terminated. Read-only.'
        ),
    ] = None
    subject: Annotated[
        Optional[str], Field(description='The subject of the conversation.')
    ] = None
    targets: Annotated[
        Optional[List[InvitationParticipantInfo]],
        Field(
            description='The targets of the call. Required information for creating peer to peer call.'
        ),
    ] = None
    tenant_id: Optional[str] = None
    tone_info: Optional[Union[ToneInfo, Dict[str, Any]]] = None
    transcription: Annotated[
        Optional[Union[CallTranscriptionInfo, Dict[str, Any]]],
        Field(description='The transcription information for the call. Read-only.'),
    ] = None
    audio_routing_groups: Optional[List[AudioRoutingGroup]] = None
    content_sharing_sessions: Optional[List[ContentSharingSession]] = None
    operations: Optional[List[CommsOperation]] = None
    participants: Optional[List[Participant]] = None
    field_odata_type: str


class CanvasLayout(Entity):
    horizontal_sections: Annotated[
        Optional[List[HorizontalSection]],
        Field(description='Collection of horizontal sections on the SharePoint page.'),
    ] = None
    vertical_section: Annotated[
        Optional[Union[VerticalSection, Dict[str, Any]]],
        Field(description='Vertical section on the SharePoint page.'),
    ] = None
    field_odata_type: str


class ConversationThread(Entity):
    cc_recipients: Annotated[
        Optional[List[Recipient]],
        Field(
            description='The Cc: recipients for the thread. Returned only on $select.'
        ),
    ] = None
    has_attachments: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether any of the posts within this thread has at least one attachment. Returned by default.'
        ),
    ] = None
    is_locked: Annotated[
        Optional[bool],
        Field(description='Indicates if the thread is locked. Returned by default.'),
    ] = None
    last_delivered_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.Returned by default.',
        ),
    ] = None
    preview: Annotated[
        Optional[str],
        Field(
            description='A short summary from the body of the latest post in this conversation. Returned by default.'
        ),
    ] = None
    topic: Annotated[
        Optional[str],
        Field(
            description='The topic of the conversation. This property can be set when the conversation is created, but it cannot be updated. Returned by default.'
        ),
    ] = None
    to_recipients: Annotated[
        Optional[List[Recipient]],
        Field(
            description='The To: recipients for the thread. Returned only on $select.'
        ),
    ] = None
    unique_senders: Annotated[
        Optional[List[str]],
        Field(
            description='All the users that sent a message to this thread. Returned by default.'
        ),
    ] = None
    posts: Optional[List[Post]] = None
    field_odata_type: str


class CrossTenantAccessPolicyConfigurationDefault(Entity):
    automatic_user_consent_settings: Annotated[
        Optional[Union[InboundOutboundPolicyConfiguration, Dict[str, Any]]],
        Field(
            description="Determines the default configuration for automatic user consent settings. The inboundAllowed and outboundAllowed properties are always false and can't be updated in the default configuration. Read-only."
        ),
    ] = None
    b2b_collaboration_inbound: Annotated[
        Optional[Union[CrossTenantAccessPolicyB2BSetting, Dict[str, Any]]],
        Field(
            description='Defines your default configuration for users from other organizations accessing your resources via Microsoft Entra B2B collaboration.'
        ),
    ] = None
    b2b_collaboration_outbound: Annotated[
        Optional[Union[CrossTenantAccessPolicyB2BSetting, Dict[str, Any]]],
        Field(
            description='Defines your default configuration for users in your organization going outbound to access resources in another organization via Microsoft Entra B2B collaboration.'
        ),
    ] = None
    b2b_direct_connect_inbound: Annotated[
        Optional[Union[CrossTenantAccessPolicyB2BSetting, Dict[str, Any]]],
        Field(
            description='Defines your default configuration for users from other organizations accessing your resources via Microsoft Entra B2B direct connect.'
        ),
    ] = None
    b2b_direct_connect_outbound: Annotated[
        Optional[Union[CrossTenantAccessPolicyB2BSetting, Dict[str, Any]]],
        Field(
            description='Defines your default configuration for users in your organization going outbound to access resources in another organization via Microsoft Entra B2B direct connect.'
        ),
    ] = None
    inbound_trust: Annotated[
        Optional[Union[CrossTenantAccessPolicyInboundTrust, Dict[str, Any]]],
        Field(
            description='Determines the default configuration for trusting other Conditional Access claims from external Microsoft Entra organizations.'
        ),
    ] = None
    invitation_redemption_identity_provider_configuration: Annotated[
        Optional[
            Union[
                DefaultInvitationRedemptionIdentityProviderConfiguration, Dict[str, Any]
            ]
        ],
        Field(
            description='Defines the priority order based on which an identity provider is selected during invitation redemption for a guest user.'
        ),
    ] = None
    is_service_default: Annotated[
        Optional[bool],
        Field(
            description='If true, the default configuration is set to the system default configuration. If false, the default settings are customized.'
        ),
    ] = None
    tenant_restrictions: Annotated[
        Optional[Union[CrossTenantAccessPolicyTenantRestrictions, Dict[str, Any]]],
        Field(
            description='Defines the default tenant restrictions configuration for users in your organization who access an external organization on your network or devices.'
        ),
    ] = None
    field_odata_type: str


class CrossTenantAccessPolicyConfigurationPartner(BaseModel):
    automatic_user_consent_settings: Annotated[
        Optional[Union[InboundOutboundPolicyConfiguration, Dict[str, Any]]],
        Field(
            description='Determines the partner-specific configuration for automatic user consent settings. Unless specifically configured, the inboundAllowed and outboundAllowed properties are null and inherit from the default settings, which is always false.'
        ),
    ] = None
    b2b_collaboration_inbound: Annotated[
        Optional[Union[CrossTenantAccessPolicyB2BSetting, Dict[str, Any]]],
        Field(
            description='Defines your partner-specific configuration for users from other organizations accessing your resources via Microsoft Entra B2B collaboration.'
        ),
    ] = None
    b2b_collaboration_outbound: Annotated[
        Optional[Union[CrossTenantAccessPolicyB2BSetting, Dict[str, Any]]],
        Field(
            description='Defines your partner-specific configuration for users in your organization going outbound to access resources in another organization via Microsoft Entra B2B collaboration.'
        ),
    ] = None
    b2b_direct_connect_inbound: Annotated[
        Optional[Union[CrossTenantAccessPolicyB2BSetting, Dict[str, Any]]],
        Field(
            description='Defines your partner-specific configuration for users from other organizations accessing your resources via Azure B2B direct connect.'
        ),
    ] = None
    b2b_direct_connect_outbound: Annotated[
        Optional[Union[CrossTenantAccessPolicyB2BSetting, Dict[str, Any]]],
        Field(
            description='Defines your partner-specific configuration for users in your organization going outbound to access resources in another organization via Microsoft Entra B2B direct connect.'
        ),
    ] = None
    inbound_trust: Annotated[
        Optional[Union[CrossTenantAccessPolicyInboundTrust, Dict[str, Any]]],
        Field(
            description='Determines the partner-specific configuration for trusting other Conditional Access claims from external Microsoft Entra organizations.'
        ),
    ] = None
    is_in_multi_tenant_organization: Annotated[
        Optional[bool],
        Field(
            description='Identifies whether a tenant is a member of a multitenant organization.'
        ),
    ] = None
    is_service_provider: Annotated[
        Optional[bool],
        Field(
            description='Identifies whether the partner-specific configuration is a Cloud Service Provider for your organization.'
        ),
    ] = None
    tenant_id: Annotated[
        Optional[str],
        Field(
            description='The tenant identifier for the partner Microsoft Entra organization. Read-only. Key.'
        ),
    ] = None
    tenant_restrictions: Annotated[
        Optional[Union[CrossTenantAccessPolicyTenantRestrictions, Dict[str, Any]]],
        Field(
            description='Defines the partner-specific tenant restrictions configuration for users in your organization who access a partner organization using partner supplied identities on your network or devices.'
        ),
    ] = None
    identity_synchronization: Annotated[
        Optional[Union[CrossTenantIdentitySyncPolicyPartner, Dict[str, Any]]],
        Field(
            description='Defines the cross-tenant policy for the synchronization of users from a partner tenant. Use this user synchronization policy to streamline collaboration between users in a multitenant organization by automating the creation, update, and deletion of users from one tenant to another.'
        ),
    ] = None
    field_odata_type: str


class DefaultManagedAppProtection(ManagedAppProtection):
    app_data_encryption_type: Optional[ManagedAppDataEncryptionType] = None
    custom_settings: Annotated[
        Optional[List[KeyValuePair]],
        Field(
            description='A set of string key and string value pairs to be sent to the affected users, unalterned by this service'
        ),
    ] = None
    deployed_app_count: Annotated[
        Optional[float],
        Field(
            description='Count of apps to which the current policy is deployed.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    disable_app_encryption_if_device_encryption_is_enabled: Annotated[
        Optional[bool],
        Field(
            description='When this setting is enabled, app level encryption is disabled if device level encryption is enabled. (Android only)'
        ),
    ] = None
    encrypt_app_data: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether managed-app data should be encrypted. (Android only)'
        ),
    ] = None
    face_id_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether use of the FaceID is allowed in place of a pin if PinRequired is set to True. (iOS Only)'
        ),
    ] = None
    minimum_required_patch_version: Annotated[
        Optional[str],
        Field(
            description='Define the oldest required Android security patch level a user can have to gain secure access to the app. (Android only)'
        ),
    ] = None
    minimum_required_sdk_version: Annotated[
        Optional[str],
        Field(
            description='Versions less than the specified version will block the managed app from accessing company data. (iOS Only)'
        ),
    ] = None
    minimum_warning_patch_version: Annotated[
        Optional[str],
        Field(
            description='Define the oldest recommended Android security patch level a user can have for secure access to the app. (Android only)'
        ),
    ] = None
    screen_capture_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether screen capture is blocked. (Android only)'
        ),
    ] = None
    apps: Annotated[
        Optional[List[ManagedMobileApp]],
        Field(description='List of apps to which the policy is deployed.'),
    ] = None
    deployment_summary: Annotated[
        Optional[Union[ManagedAppPolicyDeploymentSummary, Dict[str, Any]]],
        Field(
            description='Navigation property to deployment summary of the configuration.'
        ),
    ] = None
    field_odata_type: str


class DeltaParticipants(Entity):
    sequence_number: Annotated[
        Optional[float],
        Field(
            description='The sequence number for the roster update that is used to identify the notification order.'
        ),
    ] = None
    participants: Annotated[
        Optional[List[Participant]],
        Field(
            description='The collection of participants that were updated since the last roster update.'
        ),
    ] = None
    field_odata_type: str


class DeviceCompliancePolicyState(Entity):
    display_name: Annotated[
        Optional[str], Field(description='The name of the policy for this policyBase')
    ] = None
    platform_type: Optional[PolicyPlatformType] = None
    setting_count: Annotated[
        Optional[float],
        Field(
            description='Count of how many setting a policy holds',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    setting_states: Optional[List[DeviceCompliancePolicySettingState]] = None
    state: Optional[ComplianceStatus] = None
    version: Annotated[
        Optional[float],
        Field(
            description='The version of the policy', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    field_odata_type: str


class DeviceConfigurationState(Entity):
    display_name: Annotated[
        Optional[str], Field(description='The name of the policy for this policyBase')
    ] = None
    platform_type: Optional[PolicyPlatformType] = None
    setting_count: Annotated[
        Optional[float],
        Field(
            description='Count of how many setting a policy holds',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    setting_states: Optional[List[DeviceConfigurationSettingState]] = None
    state: Optional[ComplianceStatus] = None
    version: Annotated[
        Optional[float],
        Field(
            description='The version of the policy', ge=-2147483648.0, le=2147483647.0
        ),
    ] = None
    field_odata_type: str


class Directory(Entity):
    administrative_units: Annotated[
        Optional[List[AdministrativeUnit]],
        Field(description='Conceptual container for user and group directory objects.'),
    ] = None
    attribute_sets: Annotated[
        Optional[List[AttributeSet]],
        Field(description='Group of related custom security attribute definitions.'),
    ] = None
    custom_security_attribute_definitions: Annotated[
        Optional[List[CustomSecurityAttributeDefinition]],
        Field(description='Schema of a custom security attributes (key-value pairs).'),
    ] = None
    deleted_items: Annotated[
        Optional[List[DirectoryObject]],
        Field(description='Recently deleted items. Read-only. Nullable.'),
    ] = None
    device_local_credentials: Annotated[
        Optional[List[DeviceLocalCredentialInfo]],
        Field(
            description="The credentials of the device's local administrator account backed up to Microsoft Entra ID."
        ),
    ] = None
    federation_configurations: Annotated[
        Optional[List[IdentityProviderBase]],
        Field(
            description='Configure domain federation with organizations whose identity provider (IdP) supports either the SAML or WS-Fed protocol.'
        ),
    ] = None
    on_premises_synchronization: Annotated[
        Optional[List[OnPremisesDirectorySynchronization]],
        Field(
            description='A container for on-premises directory synchronization functionalities that are available for the organization.'
        ),
    ] = None
    subscriptions: Annotated[
        Optional[List[CompanySubscription]],
        Field(
            description='List of commercial subscriptions that an organization acquired.'
        ),
    ] = None
    field_odata_type: str


class DirectoryDefinition(Entity):
    discoverabilities: Optional[DirectoryDefinitionDiscoverabilities] = None
    discovery_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Represents the discovery date and time using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    name: Annotated[
        Optional[str],
        Field(
            description='Name of the directory. Must be unique within the synchronization schema. Not nullable.'
        ),
    ] = None
    objects: Annotated[
        Optional[List[ObjectDefinition]],
        Field(description='Collection of objects supported by the directory.'),
    ] = None
    read_only: Annotated[
        Optional[bool], Field(description='Whether this object is read-only.')
    ] = None
    version: Annotated[
        Optional[str],
        Field(
            description="Read only value that indicates version discovered. null if discovery hasn't yet occurred."
        ),
    ] = None
    field_odata_type: str


class Domain(Entity):
    authentication_type: Annotated[
        Optional[str],
        Field(
            description="Indicates the configured authentication type for the domain. The value is either Managed or Federated. Managed indicates a cloud managed domain where Microsoft Entra ID performs user authentication. Federated indicates authentication is federated with an identity provider such as the tenant's on-premises Active Directory via Active Directory Federation Services. Not nullable.  To update this property in delegated scenarios, the calling app must be assigned the Directory.AccessAsUser.All delegated permission."
        ),
    ] = None
    availability_status: Annotated[
        Optional[str],
        Field(
            description='This property is always null except when the verify action is used. When the verify action is used, a domain entity is returned in the response. The availabilityStatus property of the domain entity in the response is either AvailableImmediately or EmailVerifiedDomainTakeoverScheduled.'
        ),
    ] = None
    is_admin_managed: Annotated[
        Optional[bool],
        Field(
            description='The value of the property is false if the DNS record management of the domain is delegated to Microsoft 365. Otherwise, the value is true. Not nullable'
        ),
    ] = None
    is_default: Annotated[
        Optional[bool],
        Field(
            description="true if this is the default domain that is used for user creation. There's only one default domain per company. Not nullable."
        ),
    ] = None
    is_initial: Annotated[
        Optional[bool],
        Field(
            description="true if this is the initial domain created by Microsoft Online Services (contoso.com). There's only one initial domain per company. Not nullable"
        ),
    ] = None
    is_root: Annotated[
        Optional[bool],
        Field(
            description='true if the domain is a verified root domain. Otherwise, false if the domain is a subdomain or unverified. Not nullable.'
        ),
    ] = None
    is_verified: Annotated[
        Optional[bool],
        Field(
            description='true if the domain completed domain ownership verification. Not nullable.'
        ),
    ] = None
    manufacturer: Optional[str] = None
    model: Optional[str] = None
    password_notification_window_in_days: Annotated[
        Optional[float],
        Field(
            description="Specifies the number of days before a user receives notification that their password expires. If the property isn't set, a default value of 14 days is used.",
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    password_validity_period_in_days: Annotated[
        Optional[float],
        Field(
            description="Specifies the length of time that a password is valid before it must be changed. If the property isn't set, a default value of 90 days is used.",
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    state: Annotated[
        Optional[Union[DomainState, Dict[str, Any]]],
        Field(
            description='Status of asynchronous operations scheduled for the domain.'
        ),
    ] = None
    supported_services: Annotated[
        Optional[List[str]],
        Field(
            description='The capabilities assigned to the domain. Can include 0, 1 or more of following values: Email, Sharepoint, EmailInternalRelayOnly, OfficeCommunicationsOnline, SharePointDefaultDomain, FullRedelegation, SharePointPublic, OrgIdAuthentication, Yammer, Intune. The values that you can add or remove using the API include: Email, OfficeCommunicationsOnline, Yammer. Not nullable.'
        ),
    ] = None
    domain_name_references: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description="The objects such as users and groups that reference the domain ID. Read-only, Nullable. Doesn't support $expand. Supports $filter by the OData type of objects returned. For example, /domains/{domainId}/domainNameReferences/microsoft.graph.user and /domains/{domainId}/domainNameReferences/microsoft.graph.group."
        ),
    ] = None
    federation_configuration: Annotated[
        Optional[List[InternalDomainFederation]],
        Field(
            description="Domain settings configured by a customer when federated with Microsoft Entra ID. Doesn't support $expand."
        ),
    ] = None
    root_domain: Annotated[
        Optional[Union[Domain, Dict[str, Any]]],
        Field(
            description='Root domain of a subdomain. Read-only, Nullable. Supports $expand.'
        ),
    ] = None
    service_configuration_records: Annotated[
        Optional[List[DomainDnsRecord]],
        Field(
            description="DNS records the customer adds to the DNS zone file of the domain before the domain can be used by Microsoft Online services. Read-only, Nullable. Doesn't support $expand."
        ),
    ] = None
    verification_dns_records: Annotated[
        Optional[List[DomainDnsRecord]],
        Field(
            description="DNS records that the customer adds to the DNS zone file of the domain before the customer can complete domain ownership verification with Microsoft Entra ID. Read-only, Nullable. Doesn't support $expand."
        ),
    ] = None
    field_odata_type: str


class DriveProtectionRule(ProtectionRuleBase):
    drive_expression: Annotated[
        Optional[str],
        Field(
            description='Contains a drive expression. For examples, see driveExpression examples.'
        ),
    ] = None
    field_odata_type: str


class DriveProtectionUnit(ProtectionUnitBase):
    directory_object_id: Annotated[
        Optional[str], Field(description='ID of the directory object.')
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='Display name of the directory object.')
    ] = None
    email: Annotated[
        Optional[str], Field(description='Email associated with the directory object.')
    ] = None
    field_odata_type: str


class Edge(Entity):
    internet_explorer_mode: Annotated[
        Optional[Union[InternetExplorerMode, Dict[str, Any]]],
        Field(description='A container for Internet Explorer mode resources.'),
    ] = None
    field_odata_type: str


class EducationFeedbackOutcome(EducationOutcome):
    feedback: Annotated[
        Optional[Union[EducationFeedback, Dict[str, Any]]],
        Field(description="Teacher's written feedback to the student."),
    ] = None
    published_feedback: Annotated[
        Optional[Union[EducationFeedback, Dict[str, Any]]],
        Field(
            description='A copy of the feedback property that is made when the grade is released to the student.'
        ),
    ] = None
    field_odata_type: str


class EducationModule(Entity):
    created_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='The display name of the user that created the module.'),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date time the module was created. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014, is 2014-01-01T00:00:00Z',
        ),
    ] = None
    description: Annotated[
        Optional[str], Field(description='Description of the module.')
    ] = None
    display_name: Annotated[Optional[str], Field(description='Name of the module.')] = (
        None
    )
    is_pinned: Annotated[
        Optional[bool],
        Field(description='Indicates whether the module is pinned or not.'),
    ] = None
    last_modified_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='The last user that modified the module.'),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date time the module was last modified. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014, is 2014-01-01T00:00:00Z',
        ),
    ] = None
    resources_folder_url: Annotated[
        Optional[str],
        Field(
            description='Folder URL where all the file resources for this module are stored.'
        ),
    ] = None
    status: Annotated[
        Optional[Union[EducationModuleStatus, Dict[str, Any]]],
        Field(
            description="Status of the module. You can't use a PATCH operation to update this value. Possible values are: draft and published."
        ),
    ] = None
    resources: Annotated[
        Optional[List[EducationModuleResource]],
        Field(
            description='Learning objects that are associated with this module. Only teachers can modify this list. Nullable.'
        ),
    ] = None
    field_odata_type: str


class EducationSubmission(Entity):
    excused_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='The user that marked the submission as excused.'),
    ] = None
    excused_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The time that the submission was excused. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    reassigned_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(
            description='User who moved the status of this submission to reassigned.'
        ),
    ] = None
    reassigned_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Moment in time when the submission was reassigned. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    recipient: Annotated[
        Optional[Union[EducationSubmissionRecipient, Dict[str, Any]]],
        Field(description='Who this submission is assigned to.'),
    ] = None
    resources_folder_url: Annotated[
        Optional[str],
        Field(
            description='Folder where all file resources for this submission need to be stored.'
        ),
    ] = None
    returned_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='User who moved the status of this submission to returned.'),
    ] = None
    returned_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Moment in time when the submission was returned. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    status: Annotated[
        Optional[Union[EducationSubmissionStatus, Dict[str, Any]]],
        Field(
            description='Read-only. Possible values are: excused, reassigned, returned, submitted and working. Use the Prefer: include-unknown-enum-members request header to get the following values in this evolvable enum: excused and reassigned.'
        ),
    ] = None
    submitted_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='User who moved the resource into the submitted state.'),
    ] = None
    submitted_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Moment in time when the submission was moved into the submitted state. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    unsubmitted_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(
            description='User who moved the resource from submitted into the working state.'
        ),
    ] = None
    unsubmitted_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Moment in time when the submission was moved from submitted into the working state. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    web_url: Annotated[
        Optional[str], Field(description='The deep link URL for the given submission.')
    ] = None
    outcomes: Optional[List[EducationOutcome]] = None
    resources: Optional[List[EducationSubmissionResource]] = None
    submitted_resources: Optional[List[EducationSubmissionResource]] = None
    field_odata_type: str


class EmailFileAssessmentRequest(ThreatAssessmentRequest):
    content_data: Annotated[
        Optional[str],
        Field(
            description="Base64 encoded .eml email file content. The file content can't fetch back because it isn't stored."
        ),
    ] = None
    destination_routing_reason: Annotated[
        Optional[Union[MailDestinationRoutingReason, Dict[str, Any]]],
        Field(
            description='The reason for mail routed to its destination. Possible values are: none, mailFlowRule, safeSender, blockedSender, advancedSpamFiltering, domainAllowList, domainBlockList, notInAddressBook, firstTimeSender, autoPurgeToInbox, autoPurgeToJunk, autoPurgeToDeleted, outbound, notJunk, junk.'
        ),
    ] = None
    recipient_email: Annotated[
        Optional[str],
        Field(
            description='The mail recipient whose policies are used to assess the mail.'
        ),
    ] = None
    field_odata_type: str


class EndUserNotification(Entity):
    created_by: Annotated[
        Optional[Union[EmailIdentity, Dict[str, Any]]],
        Field(description='Identity of the user who created the notification.'),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when the notification was created. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(description='Description of the notification as defined by the user.'),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(description='Name of the notification as defined by the user.'),
    ] = None
    last_modified_by: Annotated[
        Optional[Union[EmailIdentity, Dict[str, Any]]],
        Field(description='Identity of the user who last modified the notification.'),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when the notification was last modified. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    notification_type: Annotated[
        Optional[Union[EndUserNotificationType, Dict[str, Any]]],
        Field(
            description='Type of notification. Possible values are: unknown, positiveReinforcement, noTraining, trainingAssignment, trainingReminder, unknownFutureValue.'
        ),
    ] = None
    source: Annotated[
        Optional[Union[SimulationContentSource, Dict[str, Any]]],
        Field(
            description='The source of the content. Possible values are: unknown, global, tenant, unknownFutureValue.'
        ),
    ] = None
    status: Annotated[
        Optional[Union[SimulationContentStatus, Dict[str, Any]]],
        Field(
            description='The status of the notification. Possible values are: unknown, draft, ready, archive, delete, unknownFutureValue.'
        ),
    ] = None
    supported_locales: Annotated[
        Optional[List[str]],
        Field(description='Supported locales for endUserNotification content.'),
    ] = None
    details: Optional[List[EndUserNotificationDetail]] = None
    field_odata_type: str


class FileAssessmentRequest(ThreatAssessmentRequest):
    content_data: Annotated[
        Optional[str],
        Field(
            description="Base64 encoded file content. The file content can't fetch back because it isn't stored."
        ),
    ] = None
    file_name: Annotated[Optional[str], Field(description='The file name.')] = None
    field_odata_type: str


class InformationProtection(BaseModel):
    bitlocker: Optional[Union[Bitlocker, Dict[str, Any]]] = None
    threat_assessment_requests: Optional[List[ThreatAssessmentRequest]] = None
    field_odata_type: str


class IosDeviceFeaturesConfiguration(AppleDeviceFeaturesConfigurationBase):
    asset_tag_template: Annotated[
        Optional[str],
        Field(
            description='Asset tag information for the device, displayed on the login window and lock screen.'
        ),
    ] = None
    home_screen_dock_icons: Annotated[
        Optional[List[IosHomeScreenItem]],
        Field(
            description='A list of app and folders to appear on the Home Screen Dock. This collection can contain a maximum of 500 elements.'
        ),
    ] = None
    home_screen_pages: Annotated[
        Optional[List[IosHomeScreenPage]],
        Field(
            description='A list of pages on the Home Screen. This collection can contain a maximum of 500 elements.'
        ),
    ] = None
    lock_screen_footnote: Annotated[
        Optional[str],
        Field(
            description='A footnote displayed on the login window and lock screen. Available in iOS 9.3.1 and later.'
        ),
    ] = None
    notification_settings: Annotated[
        Optional[List[IosNotificationSettings]],
        Field(
            description='Notification settings for each bundle id. Applicable to devices in supervised mode only (iOS 9.3 and later). This collection can contain a maximum of 500 elements.'
        ),
    ] = None
    field_odata_type: str


class IosiPadOSWebClip(MobileApp):
    app_url: Annotated[
        Optional[str],
        Field(
            description="Indicates iOS/iPadOS web clip app URL. Example: 'https://www.contoso.com'"
        ),
    ] = None
    use_managed_browser: Annotated[
        Optional[bool],
        Field(
            description='Whether or not to use managed browser. When TRUE, the app will be required to be opened in Microsoft Edge. When FALSE, the app will not be required to be opened in Microsoft Edge. By default, this property is set to FALSE.'
        ),
    ] = None
    field_odata_type: str


class IosLobApp(MobileLobApp):
    applicable_device_type: Optional[IosDeviceType] = None
    build_number: Annotated[
        Optional[str],
        Field(description='The build number of iOS Line of Business (LoB) app.'),
    ] = None
    bundle_id: Annotated[Optional[str], Field(description='The Identity Name.')] = None
    expiration_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The expiration time.',
        ),
    ] = None
    minimum_supported_operating_system: Annotated[
        Optional[Union[IosMinimumOperatingSystem, Dict[str, Any]]],
        Field(description='The value for the minimum applicable operating system.'),
    ] = None
    version_number: Annotated[
        Optional[str],
        Field(description='The version number of iOS Line of Business (LoB) app.'),
    ] = None
    field_odata_type: str


class IosManagedAppProtection(TargetedManagedAppProtection):
    app_data_encryption_type: Optional[ManagedAppDataEncryptionType] = None
    custom_browser_protocol: Annotated[
        Optional[str],
        Field(
            description='A custom browser protocol to open weblink on iOS. When this property is configured, ManagedBrowserToOpenLinksRequired should be true.'
        ),
    ] = None
    deployed_app_count: Annotated[
        Optional[float],
        Field(
            description='Count of apps to which the current policy is deployed.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    face_id_blocked: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether use of the FaceID is allowed in place of a pin if PinRequired is set to True.'
        ),
    ] = None
    minimum_required_sdk_version: Annotated[
        Optional[str],
        Field(
            description='Versions less than the specified version will block the managed app from accessing company data.'
        ),
    ] = None
    apps: Annotated[
        Optional[List[ManagedMobileApp]],
        Field(description='List of apps to which the policy is deployed.'),
    ] = None
    deployment_summary: Annotated[
        Optional[Union[ManagedAppPolicyDeploymentSummary, Dict[str, Any]]],
        Field(
            description='Navigation property to deployment summary of the configuration.'
        ),
    ] = None
    field_odata_type: str


class IosMobileAppConfiguration(ManagedDeviceMobileAppConfiguration):
    encoded_setting_xml: Annotated[
        Optional[str], Field(description='mdm app configuration Base64 binary.')
    ] = None
    settings: Annotated[
        Optional[List[AppConfigurationSettingItem]],
        Field(description='app configuration setting items.'),
    ] = None
    field_odata_type: str


class IosStoreApp(MobileApp):
    applicable_device_type: Optional[IosDeviceType] = None
    app_store_url: Annotated[
        Optional[str], Field(description='The Apple App Store URL')
    ] = None
    bundle_id: Annotated[Optional[str], Field(description='The Identity Name.')] = None
    minimum_supported_operating_system: Annotated[
        Optional[Union[IosMinimumOperatingSystem, Dict[str, Any]]],
        Field(description='The value for the minimum applicable operating system.'),
    ] = None
    field_odata_type: str


class IosVppApp(MobileApp):
    applicable_device_type: Annotated[
        Optional[Union[IosDeviceType, Dict[str, Any]]],
        Field(description='The applicable iOS Device Type.'),
    ] = None
    app_store_url: Annotated[Optional[str], Field(description='The store URL.')] = None
    bundle_id: Annotated[Optional[str], Field(description='The Identity Name.')] = None
    licensing_type: Annotated[
        Optional[Union[VppLicensingType, Dict[str, Any]]],
        Field(description='The supported License Type.'),
    ] = None
    release_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The VPP application release date and time.',
        ),
    ] = None
    total_license_count: Annotated[
        Optional[float],
        Field(
            description='The total number of VPP licenses.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    used_license_count: Annotated[
        Optional[float],
        Field(
            description='The number of VPP licenses in use.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    vpp_token_account_type: Optional[VppTokenAccountType] = None
    vpp_token_apple_id: Annotated[
        Optional[str],
        Field(
            description='The Apple Id associated with the given Apple Volume Purchase Program Token.'
        ),
    ] = None
    vpp_token_organization_name: Annotated[
        Optional[str],
        Field(
            description='The organization associated with the Apple Volume Purchase Program Token'
        ),
    ] = None
    field_odata_type: str


class IosVppEBook(ManagedEBook):
    apple_id: Annotated[
        Optional[str], Field(description='The Apple ID associated with Vpp token.')
    ] = None
    genres: Annotated[Optional[List[str]], Field(description='Genres.')] = None
    language: Annotated[Optional[str], Field(description='Language.')] = None
    seller: Annotated[Optional[str], Field(description='Seller.')] = None
    total_license_count: Annotated[
        Optional[float],
        Field(description='Total license count.', ge=-2147483648.0, le=2147483647.0),
    ] = None
    used_license_count: Annotated[
        Optional[float],
        Field(description='Used license count.', ge=-2147483648.0, le=2147483647.0),
    ] = None
    vpp_organization_name: Annotated[
        Optional[str], Field(description="The Vpp token's organization name.")
    ] = None
    vpp_token_id: Annotated[
        Optional[UUID],
        Field(
            description='The Vpp token ID.',
        ),
    ] = None
    field_odata_type: str


class ItemInsights(OfficeGraphInsights):
    field_odata_type: str


class MacOSDeviceFeaturesConfiguration(AppleDeviceFeaturesConfigurationBase):
    field_odata_type: str


class MacOSDmgApp(MobileLobApp):
    ignore_version_detection: Annotated[
        Optional[bool],
        Field(
            description="When TRUE, indicates that the app's version will NOT be used to detect if the app is installed on a device. When FALSE, indicates that the app's version will be used to detect if the app is installed on a device. Set this to true for apps that use a self update feature. The default value is FALSE."
        ),
    ] = None
    included_apps: Annotated[
        Optional[List[MacOSIncludedApp]],
        Field(
            description='The list of .apps expected to be installed by the DMG (Apple Disk Image). This collection can contain a maximum of 500 elements.'
        ),
    ] = None
    minimum_supported_operating_system: Annotated[
        Optional[Union[MacOSMinimumOperatingSystem, Dict[str, Any]]],
        Field(
            description='ComplexType macOSMinimumOperatingSystem that indicates the minimum operating system applicable for the application.'
        ),
    ] = None
    primary_bundle_id: Annotated[
        Optional[str],
        Field(
            description="The bundleId of the primary .app in the DMG (Apple Disk Image). This maps to the CFBundleIdentifier in the app's bundle configuration."
        ),
    ] = None
    primary_bundle_version: Annotated[
        Optional[str],
        Field(
            description="The version of the primary .app in the DMG (Apple Disk Image). This maps to the CFBundleShortVersion in the app's bundle configuration."
        ),
    ] = None
    field_odata_type: str


class MacOSLobApp(MobileLobApp):
    build_number: Annotated[
        Optional[str],
        Field(
            description='The build number of the package. This should match the package CFBundleShortVersionString of the .pkg file.'
        ),
    ] = None
    bundle_id: Annotated[
        Optional[str], Field(description='The primary bundleId of the package.')
    ] = None
    child_apps: Annotated[
        Optional[List[MacOSLobChildApp]],
        Field(
            description='List of ComplexType macOSLobChildApp objects. Represents the apps expected to be installed by the package.'
        ),
    ] = None
    ignore_version_detection: Annotated[
        Optional[bool],
        Field(
            description="When TRUE, indicates that the app's version will NOT be used to detect if the app is installed on a device. When FALSE, indicates that the app's version will be used to detect if the app is installed on a device. Set this to true for apps that use a self update feature."
        ),
    ] = None
    install_as_managed: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates that the app will be installed as managed (requires macOS 11.0 and other managed package restrictions). When FALSE, indicates that the app will be installed as unmanaged.'
        ),
    ] = None
    md5_hash: Annotated[
        Optional[List[str]],
        Field(
            description='The MD5 hash codes. This is empty if the package was uploaded directly. If the Intune App Wrapping Tool is used to create a .intunemac, this value can be found inside the Detection.xml file.'
        ),
    ] = None
    md5_hash_chunk_size: Annotated[
        Optional[float],
        Field(
            description="The chunk size for MD5 hash. This is '0' or empty if the package was uploaded directly. If the Intune App Wrapping Tool is used to create a .intunemac, this value can be found inside the Detection.xml file.",
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    minimum_supported_operating_system: Annotated[
        Optional[Union[MacOSMinimumOperatingSystem, Dict[str, Any]]],
        Field(
            description='ComplexType macOSMinimumOperatingSystem that indicates the minimum operating system applicable for the application.'
        ),
    ] = None
    version_number: Annotated[
        Optional[str],
        Field(
            description='The version number of the package. This should match the package CFBundleVersion in the packageinfo file.'
        ),
    ] = None
    field_odata_type: str


class MacOSMicrosoftDefenderApp(MobileApp):
    field_odata_type: str


class MacOSMicrosoftEdgeApp(MobileApp):
    channel: Optional[MicrosoftEdgeChannel] = None
    field_odata_type: str


class MacOSOfficeSuiteApp(MobileApp):
    field_odata_type: str


class MailAssessmentRequest(ThreatAssessmentRequest):
    destination_routing_reason: Annotated[
        Optional[Union[MailDestinationRoutingReason, Dict[str, Any]]],
        Field(
            description='The reason for mail routed to its destination. Possible values are: none, mailFlowRule, safeSender, blockedSender, advancedSpamFiltering, domainAllowList, domainBlockList, notInAddressBook, firstTimeSender, autoPurgeToInbox, autoPurgeToJunk, autoPurgeToDeleted, outbound, notJunk, junk.'
        ),
    ] = None
    message_uri: Annotated[
        Optional[str],
        Field(description='The resource URI of the mail message for assessment.'),
    ] = None
    recipient_email: Annotated[
        Optional[str],
        Field(
            description='The mail recipient whose policies are used to assess the mail.'
        ),
    ] = None
    field_odata_type: str


class MailboxProtectionRule(ProtectionRuleBase):
    mailbox_expression: Annotated[
        Optional[str],
        Field(
            description='Contains a mailbox expression. For examples, see mailboxExpression examples.'
        ),
    ] = None
    field_odata_type: str


class MailboxProtectionUnit(ProtectionUnitBase):
    directory_object_id: Annotated[
        Optional[str], Field(description='The ID of the directory object.')
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='Display name of the directory object.')
    ] = None
    email: Annotated[
        Optional[str],
        Field(description='Email address associated with the directory object.'),
    ] = None
    field_odata_type: str


class MailFolder(Entity):
    child_folder_count: Annotated[
        Optional[float],
        Field(
            description='The number of immediate child mailFolders in the current mailFolder.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description="The mailFolder's display name.")
    ] = None
    is_hidden: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the mailFolder is hidden. This property can be set only when creating the folder. Find more information in Hidden mail folders.'
        ),
    ] = None
    parent_folder_id: Annotated[
        Optional[str],
        Field(
            description="The unique identifier for the mailFolder's parent mailFolder."
        ),
    ] = None
    total_item_count: Annotated[
        Optional[float],
        Field(
            description='The number of items in the mailFolder.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    unread_item_count: Annotated[
        Optional[float],
        Field(
            description='The number of items in the mailFolder marked as unread.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    child_folders: Annotated[
        Optional[List[MailFolder]],
        Field(description='The collection of child folders in the mailFolder.'),
    ] = None
    message_rules: Annotated[
        Optional[List[MessageRule]],
        Field(
            description="The collection of rules that apply to the user's Inbox folder."
        ),
    ] = None
    messages: Annotated[
        Optional[List[Message]],
        Field(description='The collection of messages in the mailFolder.'),
    ] = None
    multi_value_extended_properties: Annotated[
        Optional[List[MultiValueLegacyExtendedProperty]],
        Field(
            description='The collection of multi-value extended properties defined for the mailFolder. Read-only. Nullable.'
        ),
    ] = None
    single_value_extended_properties: Annotated[
        Optional[List[SingleValueLegacyExtendedProperty]],
        Field(
            description='The collection of single-value extended properties defined for the mailFolder. Read-only. Nullable.'
        ),
    ] = None
    field_odata_type: str


class MailSearchFolder(MailFolder):
    filter_query: Annotated[
        Optional[str], Field(description='The OData query to filter the messages.')
    ] = None
    include_nested_folders: Annotated[
        Optional[bool],
        Field(
            description='Indicates how the mailbox folder hierarchy should be traversed in the search. true means that a deep search should be done to include child folders in the hierarchy of each folder explicitly specified in sourceFolderIds. false means a shallow search of only each of the folders explicitly specified in sourceFolderIds.'
        ),
    ] = None
    is_supported: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether a search folder is editable using REST APIs.'
        ),
    ] = None
    source_folder_ids: Annotated[
        Optional[List[str]],
        Field(description='The mailbox folders that should be mined.'),
    ] = None
    field_odata_type: str


class ManagedApp(MobileApp):
    app_availability: Optional[ManagedAppAvailability] = None
    version: Annotated[
        Optional[str], Field(description="The Application's version.")
    ] = None
    field_odata_type: str


class ManagedIOSStoreApp(ManagedApp):
    applicable_device_type: Optional[IosDeviceType] = None
    app_store_url: Annotated[
        Optional[str], Field(description='The Apple AppStoreUrl.')
    ] = None
    bundle_id: Annotated[Optional[str], Field(description="The app's Bundle ID.")] = (
        None
    )
    minimum_supported_operating_system: Optional[IosMinimumOperatingSystem] = None
    field_odata_type: str


class ManagedMobileLobApp(ManagedApp):
    committed_content_version: Annotated[
        Optional[str], Field(description='The internal committed content version.')
    ] = None
    file_name: Annotated[
        Optional[str], Field(description='The name of the main Lob application file.')
    ] = None
    size: Annotated[
        Optional[float],
        Field(description='The total size, including all uploaded files.'),
    ] = None
    content_versions: Annotated[
        Optional[List[MobileAppContent]],
        Field(description='The list of content versions for this app.'),
    ] = None
    field_odata_type: str


class MicrosoftAuthenticatorAuthenticationMethodConfiguration(
    AuthenticationMethodConfiguration
):
    feature_settings: Annotated[
        Optional[Union[MicrosoftAuthenticatorFeatureSettings, Dict[str, Any]]],
        Field(
            description='A collection of Microsoft Authenticator settings such as application context and location context, and whether they are enabled for all users or specific users only.'
        ),
    ] = None
    is_software_oath_enabled: Optional[bool] = None
    include_targets: Annotated[
        Optional[List[MicrosoftAuthenticatorAuthenticationMethodTarget]],
        Field(
            description='A collection of groups that are enabled to use the authentication method. Expanded by default.'
        ),
    ] = None
    field_odata_type: str


class MicrosoftStoreForBusinessApp(MobileApp):
    license_type: Optional[MicrosoftStoreForBusinessLicenseType] = None
    package_identity_name: Annotated[
        Optional[str], Field(description='The app package identifier')
    ] = None
    product_key: Annotated[Optional[str], Field(description='The app product key')] = (
        None
    )
    total_license_count: Annotated[
        Optional[float],
        Field(
            description='The total number of Microsoft Store for Business licenses.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    used_license_count: Annotated[
        Optional[float],
        Field(
            description='The number of Microsoft Store for Business licenses in use.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    field_odata_type: str


class MultiTenantOrganization(Entity):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date when multitenant organization was created. Read-only.',
        ),
    ] = None
    description: Annotated[
        Optional[str], Field(description='Description of the multitenant organization.')
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(description='Display name of the multitenant organization.'),
    ] = None
    state: Annotated[
        Optional[Union[MultiTenantOrganizationState, Dict[str, Any]]],
        Field(
            description="State of the multitenant organization. The possible values are: active, inactive, unknownFutureValue. active indicates the multitenant organization is created. inactive indicates the multitenant organization isn't created. Read-only."
        ),
    ] = None
    join_request: Annotated[
        Optional[Union[MultiTenantOrganizationJoinRequestRecord, Dict[str, Any]]],
        Field(
            description='Defines the status of a tenant joining a multitenant organization.'
        ),
    ] = None
    tenants: Annotated[
        Optional[List[MultiTenantOrganizationMember]],
        Field(description='Defines tenants added to a multitenant organization.'),
    ] = None
    field_odata_type: str


class MultiTenantOrganizationPartnerConfigurationTemplate(Entity):
    automatic_user_consent_settings: Annotated[
        Optional[Union[InboundOutboundPolicyConfiguration, Dict[str, Any]]],
        Field(
            description='Determines the partner-specific configuration for automatic user consent settings. Unless configured, the inboundAllowed and outboundAllowed properties are null and inherit from the default settings, which is always false.'
        ),
    ] = None
    b2b_collaboration_inbound: Annotated[
        Optional[Union[CrossTenantAccessPolicyB2BSetting, Dict[str, Any]]],
        Field(
            description='Defines your partner-specific configuration for users from other organizations accessing your resources via Microsoft Entra B2B collaboration.'
        ),
    ] = None
    b2b_collaboration_outbound: Annotated[
        Optional[Union[CrossTenantAccessPolicyB2BSetting, Dict[str, Any]]],
        Field(
            description='Defines your partner-specific configuration for users in your organization going outbound to access resources in another organization via Microsoft Entra B2B collaboration.'
        ),
    ] = None
    b2b_direct_connect_inbound: Annotated[
        Optional[Union[CrossTenantAccessPolicyB2BSetting, Dict[str, Any]]],
        Field(
            description='Defines your partner-specific configuration for users from other organizations accessing your resources via Azure B2B direct connect.'
        ),
    ] = None
    b2b_direct_connect_outbound: Annotated[
        Optional[Union[CrossTenantAccessPolicyB2BSetting, Dict[str, Any]]],
        Field(
            description='Defines your partner-specific configuration for users in your organization going outbound to access resources in another organization via Microsoft Entra B2B direct connect.'
        ),
    ] = None
    inbound_trust: Annotated[
        Optional[Union[CrossTenantAccessPolicyInboundTrust, Dict[str, Any]]],
        Field(
            description='Determines the partner-specific configuration for trusting other Conditional Access claims from external Microsoft Entra organizations.'
        ),
    ] = None
    template_application_level: Optional[TemplateApplicationLevel] = None
    field_odata_type: str


class OneDriveForBusinessProtectionPolicy(ProtectionPolicyBase):
    drive_inclusion_rules: Annotated[
        Optional[List[DriveProtectionRule]],
        Field(
            description='Contains the details of the Onedrive for Business protection rule.'
        ),
    ] = None
    drive_protection_units: Annotated[
        Optional[List[DriveProtectionUnit]],
        Field(
            description='Contains the protection units associated with a  OneDrive for Business protection policy.'
        ),
    ] = None
    field_odata_type: str


class OnlineMeeting(OnlineMeetingBase):
    attendee_report: Annotated[
        Optional[str],
        Field(
            description='The content stream of the attendee report of a Microsoft Teams live event. Read-only.'
        ),
    ] = None
    broadcast_settings: Annotated[
        Optional[Union[BroadcastMeetingSettings, Dict[str, Any]]],
        Field(description='Settings related to a live event.'),
    ] = None
    creation_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The meeting creation time in UTC. Read-only.',
        ),
    ] = None
    end_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The meeting end time in UTC. Required when you create an online meeting.',
        ),
    ] = None
    external_id: Optional[str] = None
    is_broadcast: Annotated[
        Optional[bool],
        Field(description='Indicates whether this meeting is a Teams live event.'),
    ] = None
    meeting_template_id: Annotated[
        Optional[str], Field(description='The ID of the meeting template.')
    ] = None
    participants: Annotated[
        Optional[Union[MeetingParticipants, Dict[str, Any]]],
        Field(
            description='The participants associated with the online meeting, including the organizer and the attendees.'
        ),
    ] = None
    start_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The meeting start time in UTC.',
        ),
    ] = None
    recordings: Annotated[
        Optional[List[CallRecording]],
        Field(description='The recordings of an online meeting. Read-only.'),
    ] = None
    transcripts: Annotated[
        Optional[List[CallTranscript]],
        Field(description='The transcripts of an online meeting. Read-only.'),
    ] = None
    field_odata_type: str


class OpenShift(ChangeTrackedEntity):
    draft_open_shift: Annotated[
        Optional[Union[OpenShiftItem, Dict[str, Any]]],
        Field(
            description="Draft changes in the openShift are only visible to managers until they're shared."
        ),
    ] = None
    is_staged_for_deletion: Annotated[
        Optional[bool],
        Field(
            description='The openShift is marked for deletion, a process that is finalized when the schedule is shared.'
        ),
    ] = None
    scheduling_group_id: Annotated[
        Optional[str],
        Field(description='The ID of the schedulingGroup that contains the openShift.'),
    ] = None
    shared_open_shift: Annotated[
        Optional[Union[OpenShiftItem, Dict[str, Any]]],
        Field(
            description='The shared version of this openShift that is viewable by both employees and managers.'
        ),
    ] = None
    field_odata_type: str


class OrganizationalBrandingLocalization(OrganizationalBrandingProperties):
    field_odata_type: str


class ParticipantJoiningNotification(Entity):
    call: Optional[Union[Call, Dict[str, Any]]] = None
    field_odata_type: str


class ParticipantLeftNotification(Entity):
    participant_id: Annotated[
        Optional[str],
        Field(
            description='ID of the participant under the policy who has left the meeting.'
        ),
    ] = None
    call: Optional[Union[Call, Dict[str, Any]]] = None
    field_odata_type: str


class Partners(Entity):
    billing: Annotated[
        Optional[Union[billing.Billing, Dict[str, Any]]],
        Field(description='Represents billing details for billed and unbilled data.'),
    ] = None
    field_odata_type: str


class Person(Entity):
    birthday: Annotated[Optional[str], Field(description="The person's birthday.")] = (
        None
    )
    company_name: Annotated[
        Optional[str], Field(description="The name of the person's company.")
    ] = None
    department: Annotated[
        Optional[str], Field(description="The person's department.")
    ] = None
    display_name: Annotated[
        Optional[str], Field(description="The person's display name.")
    ] = None
    given_name: Annotated[
        Optional[str], Field(description="The person's given name.")
    ] = None
    im_address: Annotated[
        Optional[str],
        Field(
            description='The instant message voice over IP (VOIP) session initiation protocol (SIP) address for the user. Read-only.'
        ),
    ] = None
    is_favorite: Annotated[
        Optional[bool],
        Field(description='True if the user has flagged this person as a favorite.'),
    ] = None
    job_title: Annotated[
        Optional[str], Field(description="The person's job title.")
    ] = None
    office_location: Annotated[
        Optional[str], Field(description="The location of the person's office.")
    ] = None
    person_notes: Annotated[
        Optional[str],
        Field(description='Free-form notes that the user has taken about this person.'),
    ] = None
    person_type: Annotated[
        Optional[Union[PersonType, Dict[str, Any]]],
        Field(description='The type of person.'),
    ] = None
    phones: Annotated[
        Optional[List[Phone]], Field(description="The person's phone numbers.")
    ] = None
    postal_addresses: Annotated[
        Optional[List[Location]], Field(description="The person's addresses.")
    ] = None
    profession: Annotated[
        Optional[str], Field(description="The person's profession.")
    ] = None
    scored_email_addresses: Annotated[
        Optional[List[ScoredEmailAddress]],
        Field(description="The person's email addresses."),
    ] = None
    surname: Annotated[Optional[str], Field(description="The person's surname.")] = None
    user_principal_name: Annotated[
        Optional[str],
        Field(
            description="The user principal name (UPN) of the person. The UPN is an Internet-style login name for the person based on the Internet standard RFC 822. By convention, this should map to the person's email name. The general format is alias@domain."
        ),
    ] = None
    websites: Annotated[
        Optional[List[Website]], Field(description="The person's websites.")
    ] = None
    yomi_company: Annotated[
        Optional[str],
        Field(description="The phonetic Japanese name of the person's company."),
    ] = None
    field_odata_type: str


class PlannerBucket(Entity):
    name: Annotated[Optional[str], Field(description='Name of the bucket.')] = None
    order_hint: Annotated[
        Optional[str],
        Field(
            description='Hint used to order items of this type in a list view. For details about the supported format, see Using order hints in Planner.'
        ),
    ] = None
    plan_id: Annotated[
        Optional[str], Field(description='Plan ID to which the bucket belongs.')
    ] = None
    tasks: Annotated[
        Optional[List[PlannerTask]],
        Field(
            description='Read-only. Nullable. The collection of tasks in the bucket.'
        ),
    ] = None
    field_odata_type: str


class PlannerPlan(Entity):
    container: Annotated[
        Optional[Union[PlannerPlanContainer, Dict[str, Any]]],
        Field(
            description="Identifies the container of the plan. Specify only the url, the containerId and type, or all properties. After it's set, this property cant be updated. Required."
        ),
    ] = None
    created_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Read-only. The user who created the plan.'),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Read-only. Date and time at which the plan is created. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z',
        ),
    ] = None
    owner: Annotated[
        Optional[str],
        Field(
            description="Use the container property instead. ID of the group that owns the plan. After it's set, this property cant be updated. This property won't return a valid group ID if the container of the plan isn't a group."
        ),
    ] = None
    title: Annotated[
        Optional[str], Field(description='Required. Title of the plan.')
    ] = None
    buckets: Annotated[
        Optional[List[PlannerBucket]],
        Field(description='Read-only. Nullable. Collection of buckets in the plan.'),
    ] = None
    details: Annotated[
        Optional[Union[PlannerPlanDetails, Dict[str, Any]]],
        Field(description='Read-only. Nullable. Extra details about the plan.'),
    ] = None
    tasks: Annotated[
        Optional[List[PlannerTask]],
        Field(description='Read-only. Nullable. Collection of tasks in the plan.'),
    ] = None
    field_odata_type: str


class PlannerUser(Entity):
    plans: Annotated[
        Optional[List[PlannerPlan]],
        Field(
            description='Read-only. Nullable. Returns the plannerTasks assigned to the user.'
        ),
    ] = None
    tasks: Annotated[
        Optional[List[PlannerTask]],
        Field(
            description='Read-only. Nullable. Returns the plannerPlans shared with the user.'
        ),
    ] = None
    field_odata_type: str


class PolicyTemplate(Entity):
    multi_tenant_organization_identity_synchronization: Annotated[
        Optional[
            Union[MultiTenantOrganizationIdentitySyncPolicyTemplate, Dict[str, Any]]
        ],
        Field(
            description='Defines an optional cross-tenant access policy template with user synchronization settings for a multitenant organization.'
        ),
    ] = None
    multi_tenant_organization_partner_configuration: Annotated[
        Optional[
            Union[MultiTenantOrganizationPartnerConfigurationTemplate, Dict[str, Any]]
        ],
        Field(
            description='Defines an optional cross-tenant access policy template with inbound and outbound partner configuration settings for a multitenant organization.'
        ),
    ] = None
    field_odata_type: str


class PrivilegedAccessSchedule(Entity):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='When the schedule was created. Optional.',
        ),
    ] = None
    created_using: Annotated[
        Optional[str],
        Field(
            description='The identifier of the access assignment or eligibility request that created this schedule. Optional.'
        ),
    ] = None
    modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='When the schedule was last modified. Optional.',
        ),
    ] = None
    schedule_info: Annotated[
        Optional[Union[RequestSchedule, Dict[str, Any]]],
        Field(
            description='Represents the period of the access assignment or eligibility. The scheduleInfo can represent a single occurrence or multiple recurring instances. Required.'
        ),
    ] = None
    status: Annotated[
        Optional[str],
        Field(
            description='The status of the access assignment or eligibility request. The possible values are: Canceled, Denied, Failed, Granted, PendingAdminDecision, PendingApproval, PendingProvisioning, PendingScheduleCreation, Provisioned, Revoked, and ScheduleCreated. Not nullable. Optional.'
        ),
    ] = None
    field_odata_type: str


class PrivilegedAccessScheduleRequest(Request):
    action: Annotated[
        Optional[Union[ScheduleRequestActions, Dict[str, Any]]],
        Field(
            description='Represents the type of operation on the group membership or ownership assignment request. The possible values are: adminAssign, adminUpdate, adminRemove, selfActivate, selfDeactivate, adminExtend, adminRenew. adminAssign: For administrators to assign group membership or ownership to principals.adminRemove: For administrators to remove principals from group membership or ownership. adminUpdate: For administrators to change existing group membership or ownership assignments.adminExtend: For administrators to extend expiring assignments.adminRenew: For administrators to renew expired assignments.selfActivate: For principals to activate their assignments.selfDeactivate: For principals to deactivate their active assignments.'
        ),
    ] = None
    is_validation_only: Annotated[
        Optional[bool],
        Field(
            description='Determines whether the call is a validation or an actual call. Only set this property if you want to check whether an activation is subject to additional rules like MFA before actually submitting the request.'
        ),
    ] = None
    justification: Annotated[
        Optional[str],
        Field(
            description='A message provided by users and administrators when create they create the privilegedAccessGroupAssignmentScheduleRequest object.'
        ),
    ] = None
    schedule_info: Annotated[
        Optional[Union[RequestSchedule, Dict[str, Any]]],
        Field(
            description='The period of the group membership or ownership assignment. Recurring schedules are currently unsupported.'
        ),
    ] = None
    ticket_info: Annotated[
        Optional[Union[TicketInfo, Dict[str, Any]]],
        Field(
            description='Ticket details linked to the group membership or ownership assignment request including details of the ticket number and ticket system.'
        ),
    ] = None
    field_odata_type: str


class ReportRoot(BaseModel):
    authentication_methods: Annotated[
        Optional[Union[AuthenticationMethodsRoot, Dict[str, Any]]],
        Field(
            description='Container for navigation properties for Microsoft Entra authentication methods resources.'
        ),
    ] = None
    daily_print_usage_by_printer: Annotated[
        Optional[List[PrintUsageByPrinter]],
        Field(
            description='Retrieve a list of daily print usage summaries, grouped by printer.'
        ),
    ] = None
    daily_print_usage_by_user: Annotated[
        Optional[List[PrintUsageByUser]],
        Field(
            description='Retrieve a list of daily print usage summaries, grouped by user.'
        ),
    ] = None
    monthly_print_usage_by_printer: Annotated[
        Optional[List[PrintUsageByPrinter]],
        Field(
            description='Retrieve a list of monthly print usage summaries, grouped by printer.'
        ),
    ] = None
    monthly_print_usage_by_user: Annotated[
        Optional[List[PrintUsageByUser]],
        Field(
            description='Retrieve a list of monthly print usage summaries, grouped by user.'
        ),
    ] = None
    partners: Annotated[
        Optional[Union[Partners, Dict[str, Any]]],
        Field(description='Represents billing details for a Microsoft direct partner.'),
    ] = None
    security: Annotated[
        Optional[Union[SecurityReportsRoot, Dict[str, Any]]],
        Field(
            description='Represents an abstract type that contains resources for attack simulation and training reports.'
        ),
    ] = None
    field_odata_type: str


class RestoreArtifactBase(Entity):
    completion_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The time when restoration of restore artifact is completed.',
        ),
    ] = None
    destination_type: Annotated[
        Optional[Union[DestinationType, Dict[str, Any]]],
        Field(
            description='Indicates the restoration destination. The possible values are: new, inPlace, unknownFutureValue.'
        ),
    ] = None
    error: Annotated[
        Optional[Union[PublicError, Dict[str, Any]]],
        Field(
            description='Contains error details if the restore session fails or completes with an error.'
        ),
    ] = None
    start_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The time when restoration of restore artifact is started.',
        ),
    ] = None
    status: Annotated[
        Optional[Union[ArtifactRestoreStatus, Dict[str, Any]]],
        Field(
            description='The individual restoration status of the restore artifact. The possible values are: added, scheduling, scheduled, inProgress, succeeded, failed, unknownFutureValue.'
        ),
    ] = None
    restore_point: Annotated[
        Optional[Union[RestorePoint, Dict[str, Any]]],
        Field(
            description='Represents the date and time when an artifact is protected by a protectionPolicy and can be restored.'
        ),
    ] = None
    field_odata_type: str


class Schedule(Entity):
    enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the schedule is enabled for the team. Required.'
        ),
    ] = None
    offer_shift_requests_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether offer shift requests are enabled for the schedule.'
        ),
    ] = None
    open_shifts_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether open shifts are enabled for the schedule.'
        ),
    ] = None
    provision_status: Annotated[
        Optional[Union[OperationStatus, Dict[str, Any]]],
        Field(
            description='The status of the schedule provisioning. The possible values are notStarted, running, completed, failed.'
        ),
    ] = None
    provision_status_code: Annotated[
        Optional[str],
        Field(
            description='Additional information about why schedule provisioning failed.'
        ),
    ] = None
    swap_shifts_requests_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether swap shifts requests are enabled for the schedule.'
        ),
    ] = None
    time_clock_enabled: Annotated[
        Optional[bool],
        Field(description='Indicates whether time clock is enabled for the schedule.'),
    ] = None
    time_off_requests_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether time off requests are enabled for the schedule.'
        ),
    ] = None
    time_zone: Annotated[
        Optional[str],
        Field(
            description='Indicates the time zone of the schedule team using tz database format. Required.'
        ),
    ] = None
    workforce_integration_ids: Optional[List[str]] = None
    offer_shift_requests: Annotated[
        Optional[List[OfferShiftRequest]],
        Field(description='The offer requests for shifts in the schedule.'),
    ] = None
    open_shift_change_requests: Annotated[
        Optional[List[OpenShiftChangeRequest]],
        Field(description='The open shift requests in the schedule.'),
    ] = None
    open_shifts: Annotated[
        Optional[List[OpenShift]],
        Field(
            description='The set of open shifts in a scheduling group in the schedule.'
        ),
    ] = None
    scheduling_groups: Annotated[
        Optional[List[SchedulingGroup]],
        Field(
            description='The logical grouping of users in the schedule (usually by role).'
        ),
    ] = None
    shifts: Annotated[
        Optional[List[Shift]], Field(description='The shifts in the schedule.')
    ] = None
    swap_shifts_change_requests: Annotated[
        Optional[List[SwapShiftsChangeRequest]],
        Field(description='The swap requests for shifts in the schedule.'),
    ] = None
    time_off_reasons: Annotated[
        Optional[List[TimeOffReason]],
        Field(description='The set of reasons for a time off in the schedule.'),
    ] = None
    time_off_requests: Annotated[
        Optional[List[TimeOffRequest]],
        Field(description='The time off requests in the schedule.'),
    ] = None
    times_off: Annotated[
        Optional[List[TimeOff]],
        Field(description='The instances of times off in the schedule.'),
    ] = None
    field_odata_type: str


class SearchEntity(Entity):
    acronyms: Annotated[
        Optional[List[search.Acronym]],
        Field(
            description='Administrative answer in Microsoft Search results to define common acronyms in an organization.'
        ),
    ] = None
    bookmarks: Annotated[
        Optional[List[search.Bookmark]],
        Field(
            description='Administrative answer in Microsoft Search results for common search queries in an organization.'
        ),
    ] = None
    qnas: Annotated[
        Optional[List[search.Qna]],
        Field(
            description='Administrative answer in Microsoft Search results that provide answers for specific search keywords in an organization.'
        ),
    ] = None
    field_odata_type: str


class ServiceHealth(Entity):
    service: Annotated[
        Optional[str],
        Field(
            description='The service name. Use the list healthOverviews operation to get exact string names for services subscribed by the tenant.'
        ),
    ] = None
    status: Optional[ServiceHealthStatus] = None
    issues: Annotated[
        Optional[List[ServiceHealthIssue]],
        Field(
            description='A collection of issues that happened on the service, with detailed information for each issue.'
        ),
    ] = None
    field_odata_type: str


class SharePointProtectionPolicy(ProtectionPolicyBase):
    site_inclusion_rules: Annotated[
        Optional[List[SiteProtectionRule]],
        Field(
            description='The rules associated with the SharePoint Protection policy.'
        ),
    ] = None
    site_protection_units: Annotated[
        Optional[List[SiteProtectionUnit]],
        Field(
            description='The protection units (sites) that are protected under the site protection policy.'
        ),
    ] = None
    field_odata_type: str


class ShiftPreferences(ChangeTrackedEntity):
    availability: Annotated[
        Optional[List[ShiftAvailability]],
        Field(
            description='Availability of the user to be scheduled for work and its recurrence pattern.'
        ),
    ] = None
    field_odata_type: str


class SiteRestoreArtifact(RestoreArtifactBase):
    restored_site_id: Annotated[
        Optional[str],
        Field(
            description='The new site identifier if the value of the destinationType property is new, and the existing site ID if the value is inPlace.'
        ),
    ] = None
    restored_site_name: Annotated[
        Optional[str], Field(description='The name of the restored site.')
    ] = None
    restored_site_web_url: Annotated[
        Optional[str], Field(description='The web URL of the restored site.')
    ] = None
    field_odata_type: str


class TenantRelationship(BaseModel):
    delegated_admin_customers: Annotated[
        Optional[List[DelegatedAdminCustomer]],
        Field(
            description='The customer who has a delegated admin relationship with a Microsoft partner.'
        ),
    ] = None
    delegated_admin_relationships: Annotated[
        Optional[List[DelegatedAdminRelationship]],
        Field(
            description='The details of the delegated administrative privileges that a Microsoft partner has in a customer tenant.'
        ),
    ] = None
    multi_tenant_organization: Annotated[
        Optional[Union[MultiTenantOrganization, Dict[str, Any]]],
        Field(
            description='Defines an organization with more than one instance of Microsoft Entra ID.'
        ),
    ] = None
    field_odata_type: str


class TodoTask(Entity):
    body: Annotated[
        Optional[Union[ItemBody, Dict[str, Any]]],
        Field(
            description='The task body that typically contains information about the task.'
        ),
    ] = None
    body_last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description="The date and time when the task body was last modified. By default, it is in UTC. You can provide a custom time zone in the request header. The property value uses ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2020 would look like this: '2020-01-01T00:00:00Z'.",
        ),
    ] = None
    categories: Annotated[
        Optional[List[str]],
        Field(
            description='The categories associated with the task. Each category corresponds to the displayName property of an outlookCategory that the user has defined.'
        ),
    ] = None
    completed_date_time: Annotated[
        Optional[Union[DateTimeTimeZone, Dict[str, Any]]],
        Field(
            description='The date and time in the specified time zone that the task was finished.'
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description="The date and time when the task was created. By default, it is in UTC. You can provide a custom time zone in the request header. The property value uses ISO 8601 format. For example, midnight UTC on Jan 1, 2020 would look like this: '2020-01-01T00:00:00Z'.",
        ),
    ] = None
    due_date_time: Annotated[
        Optional[Union[DateTimeTimeZone, Dict[str, Any]]],
        Field(
            description='The date and time in the specified time zone that the task is to be finished.'
        ),
    ] = None
    has_attachments: Annotated[
        Optional[bool], Field(description='Indicates whether the task has attachments.')
    ] = None
    importance: Optional[Importance] = None
    is_reminder_on: Annotated[
        Optional[bool],
        Field(
            description='Set to true if an alert is set to remind the user of the task.'
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description="The date and time when the task was last modified. By default, it is in UTC. You can provide a custom time zone in the request header. The property value uses ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2020 would look like this: '2020-01-01T00:00:00Z'.",
        ),
    ] = None
    recurrence: Annotated[
        Optional[Union[PatternedRecurrence, Dict[str, Any]]],
        Field(description='The recurrence pattern for the task.'),
    ] = None
    reminder_date_time: Annotated[
        Optional[Union[DateTimeTimeZone, Dict[str, Any]]],
        Field(
            description='The date and time in the specified time zone for a reminder alert of the task to occur.'
        ),
    ] = None
    start_date_time: Annotated[
        Optional[Union[DateTimeTimeZone, Dict[str, Any]]],
        Field(
            description='The date and time in the specified time zone at which the task is scheduled to start.'
        ),
    ] = None
    status: Optional[TaskStatus] = None
    title: Annotated[
        Optional[str], Field(description='A brief description of the task.')
    ] = None
    attachments: Annotated[
        Optional[List[AttachmentBase]],
        Field(description='A collection of file attachments for the task.'),
    ] = None
    attachment_sessions: Optional[List[AttachmentSession]] = None
    checklist_items: Annotated[
        Optional[List[ChecklistItem]],
        Field(description='A collection of checklistItems linked to a task.'),
    ] = None
    extensions: Annotated[
        Optional[List[Extension]],
        Field(
            description='The collection of open extensions defined for the task. Nullable.'
        ),
    ] = None
    linked_resources: Annotated[
        Optional[List[LinkedResource]],
        Field(description='A collection of resources linked to the task.'),
    ] = None
    field_odata_type: str


class TodoTaskList(Entity):
    display_name: Annotated[
        Optional[str], Field(description='The name of the task list.')
    ] = None
    is_owner: Annotated[
        Optional[bool],
        Field(description='True if the user is owner of the given task list.'),
    ] = None
    is_shared: Annotated[
        Optional[bool],
        Field(description='True if the task list is shared with other users'),
    ] = None
    wellknown_list_name: Optional[WellknownListName] = None
    extensions: Annotated[
        Optional[List[Extension]],
        Field(
            description='The collection of open extensions defined for the task list. Nullable.'
        ),
    ] = None
    tasks: Annotated[
        Optional[List[TodoTask]],
        Field(description='The tasks in this task list. Read-only. Nullable.'),
    ] = None
    field_odata_type: str


class Training(Entity):
    availability_status: Annotated[
        Optional[Union[TrainingAvailabilityStatus, Dict[str, Any]]],
        Field(
            description='Training availability status. Possible values are: unknown, notAvailable, available, archive, delete, unknownFutureValue.'
        ),
    ] = None
    created_by: Annotated[
        Optional[Union[EmailIdentity, Dict[str, Any]]],
        Field(description='Identity of the user who created the training.'),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when the training was created. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    description: Annotated[
        Optional[str], Field(description='The description for the training.')
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The display name for the training.')
    ] = None
    duration_in_minutes: Annotated[
        Optional[float],
        Field(description='Training duration.', ge=-2147483648.0, le=2147483647.0),
    ] = None
    has_evaluation: Annotated[
        Optional[bool],
        Field(description='Indicates whether the training has any evaluation.'),
    ] = None
    last_modified_by: Annotated[
        Optional[Union[EmailIdentity, Dict[str, Any]]],
        Field(description='Identity of the user who last modified the training.'),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when the training was last modified. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    source: Annotated[
        Optional[Union[SimulationContentSource, Dict[str, Any]]],
        Field(
            description='Training content source. Possible values are: unknown, global, tenant, unknownFutureValue.'
        ),
    ] = None
    supported_locales: Annotated[
        Optional[List[str]],
        Field(description='Supported locales for content for the associated training.'),
    ] = None
    tags: Annotated[Optional[List[str]], Field(description='Training tags.')] = None
    type: Annotated[
        Optional[Union[TrainingType, Dict[str, Any]]],
        Field(
            description='The type of training. Possible values are: unknown, phishing, unknownFutureValue.'
        ),
    ] = None
    language_details: Annotated[
        Optional[List[TrainingLanguageDetail]],
        Field(description='Language specific details on a training.'),
    ] = None
    field_odata_type: str


class UnifiedRoleAssignmentScheduleInstance(UnifiedRoleScheduleInstanceBase):
    assignment_type: Annotated[
        Optional[str],
        Field(
            description='The type of the assignment that can either be Assigned or Activated. Supports $filter (eq, ne).'
        ),
    ] = None
    end_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The end date of the schedule instance.',
        ),
    ] = None
    member_type: Annotated[
        Optional[str],
        Field(
            description='How the assignment is inherited. It can either be Inherited, Direct, or Group. It can further imply whether the unifiedRoleAssignmentSchedule can be managed by the caller. Supports $filter (eq, ne).'
        ),
    ] = None
    role_assignment_origin_id: Annotated[
        Optional[str],
        Field(
            description='The identifier of the role assignment in Microsoft Entra. Supports $filter (eq, ne).'
        ),
    ] = None
    role_assignment_schedule_id: Annotated[
        Optional[str],
        Field(
            description='The identifier of the unifiedRoleAssignmentSchedule object from which this instance was created. Supports $filter (eq, ne).'
        ),
    ] = None
    start_date_time: Annotated[
        Optional[datetime],
        Field(
            description='When this instance starts.',
        ),
    ] = None
    activated_using: Annotated[
        Optional[Union[UnifiedRoleEligibilityScheduleInstance, Dict[str, Any]]],
        Field(
            description="If the request is from an eligible administrator to activate a role, this parameter shows the related eligible assignment for that activation. Otherwise, it's null. Supports $expand and $select nested in $expand."
        ),
    ] = None
    field_odata_type: str


class UnifiedRoleEligibilitySchedule(UnifiedRoleScheduleBase):
    member_type: Annotated[
        Optional[str],
        Field(
            description='How the role eligibility is inherited. It can either be Inherited, Direct, or Group. It can further imply whether the unifiedRoleEligibilitySchedule can be managed by the caller. Supports $filter (eq, ne).'
        ),
    ] = None
    schedule_info: Annotated[
        Optional[Union[RequestSchedule, Dict[str, Any]]],
        Field(description='The period of the role eligibility.'),
    ] = None
    field_odata_type: str


class UnifiedRoleEligibilityScheduleRequest(Request):
    action: Annotated[
        Optional[Union[UnifiedRoleScheduleRequestActions, Dict[str, Any]]],
        Field(
            description='Represents the type of operation on the role eligibility request. The possible values are: adminAssign, adminUpdate, adminRemove, selfActivate, selfDeactivate, adminExtend, adminRenew, selfExtend, selfRenew, unknownFutureValue. adminAssign: For administrators to assign eligible roles to principals.adminRemove: For administrators to remove eligible roles from principals. adminUpdate: For administrators to change existing role eligibilities.adminExtend: For administrators to extend expiring role eligibilities.adminRenew: For administrators to renew expired eligibilities.selfActivate: For users to activate their assignments.selfDeactivate: For users to deactivate their active assignments.selfExtend: For users to request to extend their expiring assignments.selfRenew: For users to request to renew their expired assignments.'
        ),
    ] = None
    app_scope_id: Annotated[
        Optional[str],
        Field(
            description='Identifier of the app-specific scope when the role eligibility is scoped to an app. The scope of a role eligibility determines the set of resources for which the principal is eligible to access. App scopes are scopes that are defined and understood by this application only. Use / for tenant-wide app scopes. Use directoryScopeId to limit the scope to particular directory objects, for example, administrative units. Supports $filter (eq, ne, and on null values).'
        ),
    ] = None
    directory_scope_id: Annotated[
        Optional[str],
        Field(
            description='Identifier of the directory object representing the scope of the role eligibility. The scope of a role eligibility determines the set of resources for which the principal has been granted access. Directory scopes are shared scopes stored in the directory that are understood by multiple applications. Use / for tenant-wide scope. Use appScopeId to limit the scope to an application only. Supports $filter (eq, ne, and on null values).'
        ),
    ] = None
    is_validation_only: Annotated[
        Optional[bool],
        Field(
            description='Determines whether the call is a validation or an actual call. Only set this property if you want to check whether an activation is subject to additional rules like MFA before actually submitting the request.'
        ),
    ] = None
    justification: Annotated[
        Optional[str],
        Field(
            description='A message provided by users and administrators when create they create the unifiedRoleEligibilityScheduleRequest object.'
        ),
    ] = None
    principal_id: Annotated[
        Optional[str],
        Field(
            description='Identifier of the principal that has been granted the role eligibility. Can be a user or a role-assignable group. You can grant only active assignments service principals.Supports $filter (eq, ne).'
        ),
    ] = None
    role_definition_id: Annotated[
        Optional[str],
        Field(
            description='Identifier of the unifiedRoleDefinition object that is being assigned to the principal. Supports $filter (eq, ne).'
        ),
    ] = None
    schedule_info: Annotated[
        Optional[Union[RequestSchedule, Dict[str, Any]]],
        Field(
            description='The period of the role eligibility. Recurring schedules are currently unsupported.'
        ),
    ] = None
    target_schedule_id: Annotated[
        Optional[str],
        Field(
            description="Identifier of the schedule object that's linked to the eligibility request. Supports $filter (eq, ne)."
        ),
    ] = None
    ticket_info: Annotated[
        Optional[Union[TicketInfo, Dict[str, Any]]],
        Field(
            description='Ticket details linked to the role eligibility request including details of the ticket number and ticket system. Optional.'
        ),
    ] = None
    app_scope: Annotated[
        Optional[Union[AppScope, Dict[str, Any]]],
        Field(
            description='Read-only property with details of the app-specific scope when the role eligibility is scoped to an app. Nullable. Supports $expand.'
        ),
    ] = None
    directory_scope: Annotated[
        Optional[Union[DirectoryObject, Dict[str, Any]]],
        Field(
            description='The directory object that is the scope of the role eligibility. Read-only. Supports $expand.'
        ),
    ] = None
    principal: Annotated[
        Optional[Union[DirectoryObject, Dict[str, Any]]],
        Field(
            description="The principal that's getting a role eligibility through the request. Supports $expand."
        ),
    ] = None
    role_definition: Annotated[
        Optional[Union[UnifiedRoleDefinition, Dict[str, Any]]],
        Field(
            description='Detailed information for the unifiedRoleDefinition object that is referenced through the roleDefinitionId property. Supports $expand.'
        ),
    ] = None
    target_schedule: Annotated[
        Optional[Union[UnifiedRoleEligibilitySchedule, Dict[str, Any]]],
        Field(
            description='The schedule for a role eligibility that is referenced through the targetScheduleId property. Supports $expand.'
        ),
    ] = None
    field_odata_type: str


class UnifiedRoleManagementPolicy(Entity):
    description: Annotated[
        Optional[str], Field(description='Description for the policy.')
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='Display name for the policy.')
    ] = None
    is_organization_default: Annotated[
        Optional[bool],
        Field(
            description='This can only be set to true for a single tenant-wide policy which will apply to all scopes and roles. Set the scopeId to / and scopeType to Directory. Supports $filter (eq, ne).'
        ),
    ] = None
    last_modified_by: Annotated[
        Optional[Union[Identity, Dict[str, Any]]],
        Field(description='The identity who last modified the role setting.'),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The time when the role setting was last modified.',
        ),
    ] = None
    scope_id: Annotated[
        Optional[str],
        Field(
            description='The identifier of the scope where the policy is created. Can be / for the tenant or a group ID. Required.'
        ),
    ] = None
    scope_type: Annotated[
        Optional[str],
        Field(
            description='The type of the scope where the policy is created. One of Directory, DirectoryRole, Group. Required.'
        ),
    ] = None
    effective_rules: Annotated[
        Optional[List[UnifiedRoleManagementPolicyRule]],
        Field(
            description='The list of effective rules like approval rules and expiration rules evaluated based on inherited referenced rules. For example, if there is a tenant-wide policy to enforce enabling an approval rule, the effective rule will be to enable approval even if the policy has a rule to disable approval. Supports $expand.'
        ),
    ] = None
    rules: Annotated[
        Optional[List[UnifiedRoleManagementPolicyRule]],
        Field(
            description='The collection of rules like approval rules and expiration rules. Supports $expand.'
        ),
    ] = None
    field_odata_type: str


class UnifiedRoleManagementPolicyApprovalRule(UnifiedRoleManagementPolicyRule):
    setting: Annotated[
        Optional[Union[ApprovalSettings, Dict[str, Any]]],
        Field(description='The settings for approval of the role assignment.'),
    ] = None
    field_odata_type: str


class UnifiedRoleManagementPolicyAssignment(Entity):
    policy_id: Annotated[
        Optional[str], Field(description='The id of the policy. Inherited from entity.')
    ] = None
    role_definition_id: Annotated[
        Optional[str],
        Field(
            description="For Microsoft Entra roles policy, it's the identifier of the role definition object where the policy applies. For PIM for groups membership and ownership, it's either member or owner. Supports $filter (eq)."
        ),
    ] = None
    scope_id: Annotated[
        Optional[str],
        Field(
            description='The identifier of the scope where the policy is assigned.  Can be / for the tenant or a group ID. Required.'
        ),
    ] = None
    scope_type: Annotated[
        Optional[str],
        Field(
            description='The type of the scope where the policy is assigned. One of Directory, DirectoryRole, Group. Required.'
        ),
    ] = None
    policy: Annotated[
        Optional[Union[UnifiedRoleManagementPolicy, Dict[str, Any]]],
        Field(
            description="The policy that's associated with a policy assignment. Supports $expand and a nested $expand of the rules and effectiveRules relationships for the policy."
        ),
    ] = None
    field_odata_type: str


class UnifiedRoleManagementPolicyAuthenticationContextRule(
    UnifiedRoleManagementPolicyRule
):
    claim_value: Annotated[
        Optional[str],
        Field(description='The value of the authentication context claim.'),
    ] = None
    is_enabled: Annotated[
        Optional[bool], Field(description='Determines whether this rule is enabled.')
    ] = None
    field_odata_type: str


class UnifiedRoleManagementPolicyEnablementRule(UnifiedRoleManagementPolicyRule):
    enabled_rules: Annotated[
        Optional[List[str]],
        Field(
            description='The collection of rules that are enabled for this policy rule. For example, MultiFactorAuthentication, Ticketing, and Justification.'
        ),
    ] = None
    field_odata_type: str


class UnifiedRoleManagementPolicyExpirationRule(UnifiedRoleManagementPolicyRule):
    is_expiration_required: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether expiration is required or if it's a permanently active assignment or eligibility."
        ),
    ] = None
    maximum_duration: Annotated[
        Optional[timedelta],
        Field(
            description="The maximum duration allowed for eligibility or assignment that isn't permanent. Required when isExpirationRequired is true.",
        ),
    ] = None
    field_odata_type: str


class UnifiedRoleManagementPolicyNotificationRule(UnifiedRoleManagementPolicyRule):
    is_default_recipients_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether a default recipient will receive the notification email.'
        ),
    ] = None
    notification_level: Annotated[
        Optional[str],
        Field(
            description='The level of notification. The possible values are None, Critical, All.'
        ),
    ] = None
    notification_recipients: Annotated[
        Optional[List[str]],
        Field(description='The list of recipients of the email notifications.'),
    ] = None
    notification_type: Annotated[
        Optional[str],
        Field(description='The type of notification. Only Email is supported.'),
    ] = None
    recipient_type: Annotated[
        Optional[str],
        Field(
            description='The type of recipient of the notification. The possible values are Requestor, Approver, Admin.'
        ),
    ] = None
    field_odata_type: str


class UserExperienceAnalyticsBaseline(Entity):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description="The date the custom baseline was created. The value cannot be modified and is automatically populated when the baseline is created. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look like this: '2014-01-01T00:00:00Z'. Returned by default.",
        ),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The name of the baseline.')
    ] = None
    is_built_in: Annotated[
        Optional[bool],
        Field(
            description='When TRUE, indicates the current baseline is the commercial median baseline. When FALSE, indicates it is a custom baseline. FALSE by default.'
        ),
    ] = None
    app_health_metrics: Annotated[
        Optional[Union[UserExperienceAnalyticsCategory, Dict[str, Any]]],
        Field(
            description='The scores and insights for the application health metrics.'
        ),
    ] = None
    battery_health_metrics: Annotated[
        Optional[Union[UserExperienceAnalyticsCategory, Dict[str, Any]]],
        Field(description='The scores and insights for the battery health metrics.'),
    ] = None
    best_practices_metrics: Annotated[
        Optional[Union[UserExperienceAnalyticsCategory, Dict[str, Any]]],
        Field(description='The scores and insights for the best practices metrics.'),
    ] = None
    device_boot_performance_metrics: Annotated[
        Optional[Union[UserExperienceAnalyticsCategory, Dict[str, Any]]],
        Field(
            description='The scores and insights for the device boot performance metrics.'
        ),
    ] = None
    reboot_analytics_metrics: Annotated[
        Optional[Union[UserExperienceAnalyticsCategory, Dict[str, Any]]],
        Field(description='The scores and insights for the reboot analytics metrics.'),
    ] = None
    resource_performance_metrics: Annotated[
        Optional[Union[UserExperienceAnalyticsCategory, Dict[str, Any]]],
        Field(
            description='The scores and insights for the resource performance metrics.'
        ),
    ] = None
    work_from_anywhere_metrics: Annotated[
        Optional[Union[UserExperienceAnalyticsCategory, Dict[str, Any]]],
        Field(
            description='The scores and insights for the work from anywhere metrics.'
        ),
    ] = None
    field_odata_type: str


class UserSettings(Entity):
    contribution_to_content_discovery_as_organization_disabled: Annotated[
        Optional[bool],
        Field(
            description="Reflects the organization level setting controlling delegate access to the trending API. When set to true, the organization doesn't have access to Office Delve. The relevancy of the content displayed in Microsoft 365, for example in Suggested sites in SharePoint Home and the Discover view in OneDrive for work or school is affected for the whole organization. This setting is read-only and can only be changed by administrators in the SharePoint admin center."
        ),
    ] = None
    contribution_to_content_discovery_disabled: Annotated[
        Optional[bool],
        Field(
            description="When set to true, the delegate access to the user's trending API is disabled. When set to true, documents in the user's Office Delve are disabled. When set to true, the relevancy of the content displayed in Microsoft 365, for example in Suggested sites in SharePoint Home and the Discover view in OneDrive for work or school is affected. Users can control this setting in Office Delve."
        ),
    ] = None
    item_insights: Annotated[
        Optional[Union[UserInsightsSettings, Dict[str, Any]]],
        Field(
            description="The user's settings for the visibility of meeting hour insights, and insights derived between a user and other items in Microsoft 365, such as documents or sites. Get userInsightsSettings through this navigation property."
        ),
    ] = None
    shift_preferences: Optional[Union[ShiftPreferences, Dict[str, Any]]] = None
    storage: Optional[Union[UserStorage, Dict[str, Any]]] = None
    windows: Optional[List[WindowsSetting]] = None
    field_odata_type: str


class VirtualEvent(Entity):
    created_by: Annotated[
        Optional[Union[CommunicationsIdentitySet, Dict[str, Any]]],
        Field(
            description='The identity information for the creator of the virtual event. Inherited from virtualEvent.'
        ),
    ] = None
    description: Annotated[
        Optional[Union[ItemBody, Dict[str, Any]]],
        Field(description='A description of the virtual event.'),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The display name of the virtual event.')
    ] = None
    end_date_time: Annotated[
        Optional[Union[DateTimeTimeZone, Dict[str, Any]]],
        Field(
            description='The end time of the virtual event. The timeZone property can be set to any of the time zones currently supported by Windows. For details on how to get all available time zones using PowerShell, see Get-TimeZone.'
        ),
    ] = None
    external_event_information: Annotated[
        Optional[List[VirtualEventExternalInformation]],
        Field(
            description='The external information of a virtual event. Returned only for event organizers or coorganizers; otherwise, null.'
        ),
    ] = None
    settings: Annotated[
        Optional[Union[VirtualEventSettings, Dict[str, Any]]],
        Field(description='The virtual event settings.'),
    ] = None
    start_date_time: Annotated[
        Optional[Union[DateTimeTimeZone, Dict[str, Any]]],
        Field(
            description='Start time of the virtual event. The timeZone property can be set to any of the time zones currently supported by Windows. For details on how to get all available time zones using PowerShell, see Get-TimeZone.'
        ),
    ] = None
    status: Annotated[
        Optional[Union[VirtualEventStatus, Dict[str, Any]]],
        Field(
            description='The status of the virtual event. The possible values are: draft, published, canceled, and unknownFutureValue.'
        ),
    ] = None
    presenters: Annotated[
        Optional[List[VirtualEventPresenter]],
        Field(description='The virtual event presenters.'),
    ] = None
    sessions: Annotated[
        Optional[List[VirtualEventSession]],
        Field(description='The sessions for the virtual event.'),
    ] = None
    field_odata_type: str


class VirtualEventRegistration(Entity):
    cancelation_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when the registrant cancels their registration for the virtual event. Only appears when applicable. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    email: Annotated[
        Optional[str], Field(description='Email address of the registrant.')
    ] = None
    external_registration_information: Annotated[
        Optional[Union[VirtualEventExternalRegistrationInformation, Dict[str, Any]]],
        Field(description='The external information for a virtual event registration.'),
    ] = None
    first_name: Annotated[
        Optional[str], Field(description='First name of the registrant.')
    ] = None
    last_name: Annotated[
        Optional[str], Field(description='Last name of the registrant.')
    ] = None
    preferred_language: Annotated[
        Optional[str], Field(description="The registrant's preferred language.")
    ] = None
    preferred_timezone: Annotated[
        Optional[str], Field(description="The registrant's time zone details.")
    ] = None
    registration_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when the registrant registers for the virtual event. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    registration_question_answers: Annotated[
        Optional[List[VirtualEventRegistrationQuestionAnswer]],
        Field(description="The registrant's answer to the registration questions."),
    ] = None
    status: Annotated[
        Optional[Union[VirtualEventAttendeeRegistrationStatus, Dict[str, Any]]],
        Field(
            description='Registration status of the registrant. Read-only. Possible values are registered, canceled, waitlisted, pendingApproval, rejectedByOrganizer, and unknownFutureValue.'
        ),
    ] = None
    user_id: Annotated[
        Optional[str],
        Field(
            description="The registrant's ID in Microsoft Entra ID. Only appears when the registrant is registered in Microsoft Entra ID."
        ),
    ] = None
    sessions: Annotated[
        Optional[List[VirtualEventSession]],
        Field(description='Sessions for a registration.'),
    ] = None
    field_odata_type: str


class VirtualEventTownhall(VirtualEvent):
    audience: Annotated[
        Optional[Union[MeetingAudience, Dict[str, Any]]],
        Field(
            description='The audience to whom the town hall is visible. Possible values are: everyone, organization, and unknownFutureValue.'
        ),
    ] = None
    co_organizers: Annotated[
        Optional[List[CommunicationsUserIdentity]],
        Field(description='Identity information of the coorganizers of the town hall.'),
    ] = None
    invited_attendees: Annotated[
        Optional[List[Identity]],
        Field(
            description='The attendees invited to the town hall. The supported identities are: communicationsUserIdentity and communicationsGuestIdentity.'
        ),
    ] = None
    is_invite_only: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the town hall is only open to invited people and groups within your organization. The isInviteOnly property can only be true if the value of the audience property is set to organization.'
        ),
    ] = None
    field_odata_type: str


class VirtualEventWebinar(VirtualEvent):
    audience: Annotated[
        Optional[Union[MeetingAudience, Dict[str, Any]]],
        Field(
            description='To whom the webinar is visible. Possible values are: everyone, organization, and unknownFutureValue.'
        ),
    ] = None
    co_organizers: Annotated[
        Optional[List[CommunicationsUserIdentity]],
        Field(description='Identity information of coorganizers of the webinar.'),
    ] = None
    registration_configuration: Annotated[
        Optional[Union[VirtualEventWebinarRegistrationConfiguration, Dict[str, Any]]],
        Field(description='Registration configuration of the webinar.'),
    ] = None
    registrations: Annotated[
        Optional[List[VirtualEventRegistration]],
        Field(description='Registration records of the webinar.'),
    ] = None
    field_odata_type: str


class WorkbookChartAxisTitle(Entity):
    text: Annotated[Optional[str], Field(description='Represents the axis title.')] = (
        None
    )
    visible: Annotated[
        Optional[bool],
        Field(description='A Boolean that specifies the visibility of an axis title.'),
    ] = None
    format: Annotated[
        Optional[Union[WorkbookChartAxisTitleFormat, Dict[str, Any]]],
        Field(description='Represents the formatting of chart axis title. Read-only.'),
    ] = None
    field_odata_type: str


class X509CertificateAuthenticationMethodConfiguration(
    AuthenticationMethodConfiguration
):
    authentication_mode_configuration: Annotated[
        Optional[Union[X509CertificateAuthenticationModeConfiguration, Dict[str, Any]]],
        Field(
            description='Defines strong authentication configurations. This configuration includes the default authentication mode and the different rules for strong authentication bindings.'
        ),
    ] = None
    certificate_user_bindings: Annotated[
        Optional[List[X509CertificateUserBinding]],
        Field(
            description='Defines fields in the X.509 certificate that map to attributes of the Microsoft Entra user object in order to bind the certificate to the user. The priority of the object determines the order in which the binding is carried out. The first binding that matches will be used and the rest ignored.'
        ),
    ] = None
    crl_validation_configuration: Optional[
        X509CertificateCRLValidationConfiguration
    ] = None
    include_targets: Annotated[
        Optional[List[AuthenticationMethodTarget]],
        Field(
            description='A collection of groups that are enabled to use the authentication method.'
        ),
    ] = None
    field_odata_type: str


class AadUserConversationMemberResult(ActionResultPart):
    user_id: Optional[str] = None
    field_odata_type: str


class AccessReviewHistoryScheduleSettings(BaseModel):
    recurrence: Optional[PatternedRecurrence] = None
    report_range: Annotated[
        Optional[str],
        Field(
            description="A duration string in ISO 8601 duration format specifying the lookback period of the generated review history data. For example, if a history definition is scheduled to run on the first of every month, the reportRange is P1M. In this case, on the first of every month, access review history data is collected containing only the previous month's review data. Note: Only years, months, and days ISO 8601 properties are supported. Required."
        ),
    ] = None
    field_odata_type: str


class AccessReviewScheduleSettings(BaseModel):
    apply_actions: Annotated[
        Optional[List[AccessReviewApplyAction]],
        Field(
            description='Optional field. Describes the  actions to take once a review is complete. There are two types that are currently supported: removeAccessApplyAction (default) and disableAndDeleteUserApplyAction. Field only needs to be specified in the case of disableAndDeleteUserApplyAction.'
        ),
    ] = None
    auto_apply_decisions_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether decisions are automatically applied. When set to false, an admin must apply the decisions manually once the reviewer completes the access review. When set to true, decisions are applied automatically after the access review instance duration ends, whether or not the reviewers have responded. Default value is false.  CAUTION: If both autoApplyDecisionsEnabled and defaultDecisionEnabled are true, all access for the principals to the resource risks being revoked if the reviewers fail to respond.'
        ),
    ] = None
    decision_histories_for_reviewers_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether decisions on previous access review stages are available for reviewers on an accessReviewInstance with multiple subsequent stages. If not provided, the default is disabled (false).'
        ),
    ] = None
    default_decision: Annotated[
        Optional[str],
        Field(
            description='Decision chosen if defaultDecisionEnabled is enabled. Can be one of Approve, Deny, or Recommendation.'
        ),
    ] = None
    default_decision_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the default decision is enabled or disabled when reviewers do not respond. Default value is false.  CAUTION: If both autoApplyDecisionsEnabled and defaultDecisionEnabled are true, all access for the principals to the resource risks being revoked if the reviewers fail to respond.'
        ),
    ] = None
    instance_duration_in_days: Annotated[
        Optional[float],
        Field(
            description='Duration of an access review instance in days. NOTE: If the stageSettings of the accessReviewScheduleDefinition object is defined, its durationInDays setting will be used instead of the value of this property.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    justification_required_on_approval: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether reviewers are required to provide justification with their decision. Default value is false.'
        ),
    ] = None
    mail_notifications_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether emails are enabled or disabled. Default value is false.'
        ),
    ] = None
    recommendation_insight_settings: Annotated[
        Optional[List[AccessReviewRecommendationInsightSetting]],
        Field(
            description='Optional. Describes the types of insights that aid reviewers to make access review decisions. NOTE: If the stageSettings of the accessReviewScheduleDefinition object is defined, its recommendationInsightSettings setting will be used instead of the value of this property.'
        ),
    ] = None
    recommendation_look_back_duration: Annotated[
        Optional[timedelta],
        Field(
            description='Optional field. Indicates the period of inactivity (with respect to the start date of the review instance) that recommendations will be configured from. The recommendation will be to deny if the user is inactive during the look-back duration. For reviews of groups and Microsoft Entra roles, any duration is accepted. For reviews of applications, 30 days is the maximum duration. If not specified, the duration is 30 days. NOTE: If the stageSettings of the accessReviewScheduleDefinition object is defined, its recommendationLookBackDuration setting will be used instead of the value of this property.',
        ),
    ] = None
    recommendations_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether decision recommendations are enabled or disabled. NOTE: If the stageSettings of the accessReviewScheduleDefinition object is defined, its recommendationsEnabled setting will be used instead of the value of this property.'
        ),
    ] = None
    recurrence: Annotated[
        Optional[Union[PatternedRecurrence, Dict[str, Any]]],
        Field(
            description='Detailed settings for recurrence using the standard Outlook recurrence object. Note: Only dayOfMonth, interval, and type (weekly, absoluteMonthly) properties are supported. Use the property startDate on recurrenceRange to determine the day the review starts.'
        ),
    ] = None
    reminder_notifications_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether reminders are enabled or disabled. Default value is false.'
        ),
    ] = None
    field_odata_type: str


class AppManagementApplicationConfiguration(AppManagementConfiguration):
    field_odata_type: str


class BaseEndUserNotification(BaseModel):
    default_language: Annotated[
        Optional[str],
        Field(description='The default language for the end user notification.'),
    ] = None
    end_user_notification: Optional[Union[EndUserNotification, Dict[str, Any]]] = None
    field_odata_type: str


class BookingCustomerInformation(BookingCustomerInformationBase):
    customer_id: Annotated[
        Optional[str],
        Field(
            description='The ID of the bookingCustomer for this appointment. If no ID is specified when an appointment is created, then a new bookingCustomer object is created. Once set, you should consider the customerId immutable.'
        ),
    ] = None
    custom_question_answers: Annotated[
        Optional[List[BookingQuestionAnswer]],
        Field(
            description='It consists of the list of custom questions and answers given by the customer as part of the appointment'
        ),
    ] = None
    email_address: Annotated[
        Optional[str],
        Field(
            description='The SMTP address of the bookingCustomer who is booking the appointment'
        ),
    ] = None
    location: Annotated[
        Optional[Union[Location, Dict[str, Any]]],
        Field(
            description='Represents location information for the\u202fbookingCustomer\u202fwho is booking the appointment.'
        ),
    ] = None
    name: Annotated[Optional[str], Field(description="The customer's name.")] = None
    notes: Annotated[
        Optional[str],
        Field(
            description='Notes from the customer associated with this appointment. You can get the value only when reading this bookingAppointment by its ID. You can set this property only when initially creating an appointment with a new customer. After that point, the value is computed from the customer represented by the customerId.'
        ),
    ] = None
    phone: Annotated[
        Optional[str], Field(description="The customer's phone number.")
    ] = None
    time_zone: Annotated[
        Optional[str],
        Field(
            description='The time zone of the customer. For a list of possible values, see dateTimeTimeZone.'
        ),
    ] = None
    field_odata_type: str


class ChatMessageHistoryItem(BaseModel):
    actions: Optional[ChatMessageActions] = None
    modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the message was modified.',
        ),
    ] = None
    reaction: Annotated[
        Optional[Union[ChatMessageReaction, Dict[str, Any]]],
        Field(description='The reaction in the modified message.'),
    ] = None
    field_odata_type: str


class ChatMessageMention(BaseModel):
    id: Annotated[
        Optional[float],
        Field(
            description="Index of an entity being mentioned in the specified chatMessage. Matches the {index} value in the corresponding <at id='{index}'> tag in the message body.",
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    mentioned: Annotated[
        Optional[Union[ChatMessageMentionedIdentitySet, Dict[str, Any]]],
        Field(
            description='The entity (user, application, team, channel, or chat) that was @mentioned.'
        ),
    ] = None
    mention_text: Annotated[
        Optional[str],
        Field(
            description="String used to represent the mention. For example, a user's display name, a team name."
        ),
    ] = None
    field_odata_type: str


class ConditionalAccessConditionSet(BaseModel):
    applications: Annotated[
        Optional[Union[ConditionalAccessApplications, Dict[str, Any]]],
        Field(
            description='Applications and user actions included in and excluded from the policy. Required.'
        ),
    ] = None
    authentication_flows: Annotated[
        Optional[Union[ConditionalAccessAuthenticationFlows, Dict[str, Any]]],
        Field(description='Authentication flows included in the policy scope.'),
    ] = None
    client_applications: Annotated[
        Optional[Union[ConditionalAccessClientApplications, Dict[str, Any]]],
        Field(
            description='Client applications (service principals and workload identities) included in and excluded from the policy. Either users or clientApplications is required.'
        ),
    ] = None
    client_app_types: Annotated[
        Optional[List[ConditionalAccessClientApp]],
        Field(
            description='Client application types included in the policy. Possible values are: all, browser, mobileAppsAndDesktopClients, exchangeActiveSync, easSupported, other. Required.  The easUnsupported enumeration member will be deprecated in favor of exchangeActiveSync, which includes EAS supported and unsupported platforms.'
        ),
    ] = None
    devices: Annotated[
        Optional[Union[ConditionalAccessDevices, Dict[str, Any]]],
        Field(description='Devices in the policy.'),
    ] = None
    insider_risk_levels: Annotated[
        Optional[Union[ConditionalAccessInsiderRiskLevels, Dict[str, Any]]],
        Field(
            description='Insider risk levels included in the policy. The possible values are: minor, moderate, elevated, unknownFutureValue.'
        ),
    ] = None
    locations: Annotated[
        Optional[Union[ConditionalAccessLocations, Dict[str, Any]]],
        Field(description='Locations included in and excluded from the policy.'),
    ] = None
    platforms: Annotated[
        Optional[Union[ConditionalAccessPlatforms, Dict[str, Any]]],
        Field(description='Platforms included in and excluded from the policy.'),
    ] = None
    service_principal_risk_levels: Annotated[
        Optional[List[RiskLevel]],
        Field(
            description='Service principal risk levels included in the policy. Possible values are: low, medium, high, none, unknownFutureValue.'
        ),
    ] = None
    sign_in_risk_levels: Annotated[
        Optional[List[RiskLevel]],
        Field(
            description='Sign-in risk levels included in the policy. Possible values are: low, medium, high, hidden, none, unknownFutureValue. Required.'
        ),
    ] = None
    user_risk_levels: Annotated[
        Optional[List[RiskLevel]],
        Field(
            description='User risk levels included in the policy. Possible values are: low, medium, high, hidden, none, unknownFutureValue. Required.'
        ),
    ] = None
    users: Annotated[
        Optional[Union[ConditionalAccessUsers, Dict[str, Any]]],
        Field(
            description='Users, groups, and roles included in and excluded from the policy. Either users or clientApplications is required.'
        ),
    ] = None
    field_odata_type: str


class ConditionalAccessPolicyDetail(BaseModel):
    conditions: Optional[ConditionalAccessConditionSet] = None
    grant_controls: Annotated[
        Optional[Union[ConditionalAccessGrantControls, Dict[str, Any]]],
        Field(
            description='Represents grant controls that must be fulfilled for the policy.'
        ),
    ] = None
    session_controls: Annotated[
        Optional[Union[ConditionalAccessSessionControls, Dict[str, Any]]],
        Field(
            description='Represents a complex type of session controls that is enforced after sign-in.'
        ),
    ] = None
    field_odata_type: str


class CustomTimeZone(TimeZoneBase):
    bias: Annotated[
        Optional[float],
        Field(
            description='The time offset of the time zone from Coordinated Universal Time (UTC). This value is in minutes.\xa0Time zones that are ahead of UTC have a positive offset; time zones that are behind UTC have a negative offset.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    daylight_offset: Annotated[
        Optional[Union[DaylightTimeZoneOffset, Dict[str, Any]]],
        Field(
            description='Specifies when the time zone switches from standard time to daylight saving time.'
        ),
    ] = None
    standard_offset: Annotated[
        Optional[Union[StandardTimeZoneOffset, Dict[str, Any]]],
        Field(
            description='Specifies when the time zone switches from daylight saving time to standard time.'
        ),
    ] = None
    field_odata_type: str


class EntitlementManagementSchedule(BaseModel):
    expiration: Annotated[
        Optional[Union[ExpirationPattern, Dict[str, Any]]],
        Field(description='When the access should expire.'),
    ] = None
    recurrence: Annotated[
        Optional[Union[PatternedRecurrence, Dict[str, Any]]],
        Field(
            description='The recurring access review pattern. Not used in access requests.'
        ),
    ] = None
    start_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    field_odata_type: str


class ExpressionInputObject(BaseModel):
    definition: Annotated[
        Optional[Union[ObjectDefinition, Dict[str, Any]]],
        Field(description='Definition of the test object.'),
    ] = None
    properties: Annotated[
        Optional[List[StringKeyObjectValuePair]],
        Field(description='Property values of the test object.'),
    ] = None
    field_odata_type: str


class LocationConstraint(BaseModel):
    is_required: Annotated[
        Optional[bool],
        Field(
            description="The client requests the service to include in the response a meeting location for the meeting. If this is true and all the resources are busy, findMeetingTimes won't return any meeting time suggestions. If this is false and all the resources are busy, findMeetingTimes would still look for meeting times without locations."
        ),
    ] = None
    locations: Annotated[
        Optional[List[LocationConstraintItem]],
        Field(
            description='Constraint information for one or more locations that the client requests for the meeting.'
        ),
    ] = None
    suggest_location: Annotated[
        Optional[bool],
        Field(
            description='The client requests the service to suggest one or more meeting locations.'
        ),
    ] = None
    field_odata_type: str


class MicrosoftTrainingAssignmentMapping(TrainingSetting):
    assigned_to: Annotated[
        Optional[List[Union[TrainingAssignedTo, Dict[str, Any]]]],
        Field(
            description='A user collection that specifies to whom the training should be assigned. Possible values are: none, allUsers, clickedPayload, compromised, reportedPhish, readButNotClicked, didNothing, unknownFutureValue.'
        ),
    ] = None
    training: Optional[Union[Training, Dict[str, Any]]] = None
    field_odata_type: str


class PositiveReinforcementNotification(BaseEndUserNotification):
    delivery_preference: Annotated[
        Optional[Union[NotificationDeliveryPreference, Dict[str, Any]]],
        Field(
            description='Delivery preference. Possible values are: unknown, deliverImmedietly, deliverAfterCampaignEnd, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class RestorePointSearchResponse(BaseModel):
    no_result_protection_unit_ids: Annotated[
        Optional[List[str]],
        Field(
            description='Contains  alist of protection units with no restore points.'
        ),
    ] = None
    search_response_id: Annotated[
        Optional[str],
        Field(description='The unique identifier of the search response.'),
    ] = None
    search_results: Annotated[
        Optional[List[RestorePointSearchResult]],
        Field(description='Contains a collection of restore points.'),
    ] = None
    field_odata_type: str


class SimulationNotification(BaseEndUserNotification):
    targetted_user_type: Annotated[
        Optional[Union[TargettedUserType, Dict[str, Any]]],
        Field(
            description='Target user type. Possible values are: unknown, clicked, compromised, allUsers, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class SimulationReport(BaseModel):
    overview: Annotated[
        Optional[Union[SimulationReportOverview, Dict[str, Any]]],
        Field(description='Overview of an attack simulation and training campaign.'),
    ] = None
    simulation_users: Annotated[
        Optional[List[UserSimulationDetails]],
        Field(
            description='The tenant users and their online actions in an attack simulation and training campaign.'
        ),
    ] = None
    field_odata_type: str


class TeamsAppAuthorization(BaseModel):
    client_app_id: Annotated[
        Optional[str],
        Field(
            description='The registration ID of the Microsoft Entra app ID associated with the teamsApp.'
        ),
    ] = None
    required_permission_set: Annotated[
        Optional[Union[TeamsAppPermissionSet, Dict[str, Any]]],
        Field(description='Set of permissions required by the teamsApp.'),
    ] = None
    field_odata_type: str


class TrainingReminderNotification(BaseEndUserNotification):
    delivery_frequency: Annotated[
        Optional[Union[NotificationDeliveryFrequency, Dict[str, Any]]],
        Field(
            description='Configurable frequency for the reminder email introduced during simulation creation. Possible values are: unknown, weekly, biWeekly, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class DomainCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Domain]] = None


class AppConsentRequestCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AppConsentRequest]] = None


class AppManagementPolicyCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AppManagementPolicy]] = None


class EndUserNotificationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[EndUserNotification]] = None


class TrainingCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Training]] = None


class DriveProtectionRuleCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[DriveProtectionRule]] = None


class DriveProtectionUnitCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[DriveProtectionUnit]] = None


class MailboxProtectionRuleCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[MailboxProtectionRule]] = None


class MailboxProtectionUnitCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[MailboxProtectionUnit]] = None


class OneDriveForBusinessProtectionPolicyCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[OneDriveForBusinessProtectionPolicy]] = None


class SharePointProtectionPolicyCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[SharePointProtectionPolicy]] = None


class BookingAppointmentCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[BookingAppointment]] = None


class BookingServiceCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[BookingService]] = None


class CallCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Call]] = None


class OnlineMeetingCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[OnlineMeeting]] = None


class ConversationThreadCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ConversationThread]] = None


class CrossTenantAccessPolicyConfigurationPartnerCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[CrossTenantAccessPolicyConfigurationPartner]] = None


class AndroidManagedAppProtectionCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AndroidManagedAppProtection]] = None


class DefaultManagedAppProtectionCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DefaultManagedAppProtection]] = None


class IosManagedAppProtectionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[IosManagedAppProtection]] = None


class UserExperienceAnalyticsBaselineCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UserExperienceAnalyticsBaseline]] = None


class EducationSubmissionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[EducationSubmission]] = None


class EducationModuleCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[EducationModule]] = None


class MailFolderCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[MailFolder]] = None


class DeviceCompliancePolicyStateCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DeviceCompliancePolicyState]] = None


class DeviceConfigurationStateCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[DeviceConfigurationState]] = None


class OrganizationalBrandingLocalizationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[OrganizationalBrandingLocalization]] = None


class PlannerBucketCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[PlannerBucket]] = None


class PlannerPlanCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[PlannerPlan]] = None


class UnifiedRoleManagementPolicyCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UnifiedRoleManagementPolicy]] = None


class UnifiedRoleManagementPolicyAssignmentCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UnifiedRoleManagementPolicyAssignment]] = None


class UnifiedRoleAssignmentScheduleInstanceCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UnifiedRoleAssignmentScheduleInstance]] = None


class UnifiedRoleEligibilityScheduleRequestCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UnifiedRoleEligibilityScheduleRequest]] = None


class UnifiedRoleEligibilityScheduleCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UnifiedRoleEligibilitySchedule]] = None


class OpenShiftCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[OpenShift]] = None


class ServiceHealthCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ServiceHealth]] = None


class SiteRestoreArtifactCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SiteRestoreArtifact]] = None


class DirectoryDefinitionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[DirectoryDefinition]] = None


class TodoTaskListCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[TodoTaskList]] = None


class TodoTaskCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[TodoTask]] = None


class PersonCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Person]] = None


class VirtualEventCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[VirtualEvent]] = None


class VirtualEventTownhallCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[VirtualEventTownhall]] = None


class VirtualEventWebinarCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[VirtualEventWebinar]] = None


class VirtualEventRegistrationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[VirtualEventRegistration]] = None


class MicrosoftAuthenticatorAuthenticationMethodConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[MicrosoftAuthenticatorAuthenticationMethodConfiguration]] = (
        None
    )


class X509CertificateAuthenticationMethodConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[X509CertificateAuthenticationMethodConfiguration]] = None


class IosVppEBookCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[IosVppEBook]] = None


class IosMobileAppConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[IosMobileAppConfiguration]] = None


class AndroidStoreAppCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AndroidStoreApp]] = None


class IosiPadOSWebClipCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[IosiPadOSWebClip]] = None


class IosStoreAppCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[IosStoreApp]] = None


class IosVppAppCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[IosVppApp]] = None


class MacOSMicrosoftDefenderAppCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[MacOSMicrosoftDefenderApp]] = None


class MacOSMicrosoftEdgeAppCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[MacOSMicrosoftEdgeApp]] = None


class MacOSOfficeSuiteAppCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[MacOSOfficeSuiteApp]] = None


class ManagedAppCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ManagedApp]] = None


class ManagedIOSStoreAppCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ManagedIOSStoreApp]] = None


class ManagedMobileLobAppCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ManagedMobileLobApp]] = None


class MicrosoftStoreForBusinessAppCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[MicrosoftStoreForBusinessApp]] = None


class AndroidLobAppCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AndroidLobApp]] = None


class IosLobAppCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[IosLobApp]] = None


class MacOSDmgAppCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[MacOSDmgApp]] = None


class MacOSLobAppCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[MacOSLobApp]] = None


class AndroidCompliancePolicyCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AndroidCompliancePolicy]] = None


class AndroidWorkProfileCompliancePolicyCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AndroidWorkProfileCompliancePolicy]] = None


class AndroidCustomConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AndroidCustomConfiguration]] = None


class AndroidGeneralDeviceConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AndroidGeneralDeviceConfiguration]] = None


class AndroidWorkProfileCustomConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AndroidWorkProfileCustomConfiguration]] = None


class AndroidWorkProfileGeneralDeviceConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AndroidWorkProfileGeneralDeviceConfiguration]] = None


class AppleDeviceFeaturesConfigurationBaseCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AppleDeviceFeaturesConfigurationBase]] = None


class IosDeviceFeaturesConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[IosDeviceFeaturesConfiguration]] = None


class MacOSDeviceFeaturesConfigurationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[MacOSDeviceFeaturesConfiguration]] = None


class EducationFeedbackOutcomeCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[EducationFeedbackOutcome]] = None


class EmailFileAssessmentRequestCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[EmailFileAssessmentRequest]] = None


class FileAssessmentRequestCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[FileAssessmentRequest]] = None


class MailAssessmentRequestCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[MailAssessmentRequest]] = None


class MailSearchFolderCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[MailSearchFolder]] = None


class CalendarSharingMessageCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[CalendarSharingMessage]] = None


class UnifiedRoleManagementPolicyApprovalRuleCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UnifiedRoleManagementPolicyApprovalRule]] = None


class UnifiedRoleManagementPolicyAuthenticationContextRuleCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UnifiedRoleManagementPolicyAuthenticationContextRule]] = None


class UnifiedRoleManagementPolicyEnablementRuleCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UnifiedRoleManagementPolicyEnablementRule]] = None


class UnifiedRoleManagementPolicyExpirationRuleCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UnifiedRoleManagementPolicyExpirationRule]] = None


class UnifiedRoleManagementPolicyNotificationRuleCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UnifiedRoleManagementPolicyNotificationRule]] = None


class ChatMessageMentionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ChatMessageMention]] = None


class ChatMessageHistoryItemCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ChatMessageHistoryItem]] = None


class MicrosoftTrainingAssignmentMappingCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[MicrosoftTrainingAssignmentMapping]] = None


class AccessReviewHistoryDefinition(Entity):
    created_by: Optional[UserIdentity] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Timestamp when the access review definition was created.',
        ),
    ] = None
    decisions: Annotated[
        Optional[List[Union[AccessReviewHistoryDecisionFilter, Dict[str, Any]]]],
        Field(
            description='Determines which review decisions will be included in the fetched review history data if specified. Optional on create. All decisions are included by default if no decisions are provided on create. Possible values are: approve, deny, dontKnow, notReviewed, and notNotified.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='Name for the access review history data collection. Required.'
        ),
    ] = None
    review_history_period_end_date_time: Annotated[
        Optional[datetime],
        Field(
            description="A timestamp. Reviews ending on or before this date will be included in the fetched history data. Only required if scheduleSettings isn't defined.",
        ),
    ] = None
    review_history_period_start_date_time: Annotated[
        Optional[datetime],
        Field(
            description="A timestamp. Reviews starting on or before this date will be included in the fetched history data. Only required if scheduleSettings isn't defined.",
        ),
    ] = None
    schedule_settings: Annotated[
        Optional[Union[AccessReviewHistoryScheduleSettings, Dict[str, Any]]],
        Field(
            description="The settings for a recurring access review history definition series. Only required if reviewHistoryPeriodStartDateTime or reviewHistoryPeriodEndDateTime aren't defined. Not supported yet."
        ),
    ] = None
    scopes: Annotated[
        Optional[List[AccessReviewScope]],
        Field(
            description='Used to scope what reviews are included in the fetched history data. Fetches reviews whose scope matches with this provided scope. Required.'
        ),
    ] = None
    status: Annotated[
        Optional[Union[AccessReviewHistoryStatus, Dict[str, Any]]],
        Field(
            description='Represents the status of the review history data collection. The possible values are: done, inProgress, error, requested, unknownFutureValue.'
        ),
    ] = None
    instances: Annotated[
        Optional[List[AccessReviewHistoryInstance]],
        Field(
            description="If the accessReviewHistoryDefinition is a recurring definition, instances represent each recurrence. A definition that doesn't recur will have exactly one instance."
        ),
    ] = None
    field_odata_type: str


class AccessReviewScheduleDefinition(Entity):
    additional_notification_recipients: Annotated[
        Optional[List[AccessReviewNotificationRecipientItem]],
        Field(
            description='Defines the list of additional users or group members to be notified of the access review progress.'
        ),
    ] = None
    created_by: Annotated[
        Optional[Union[UserIdentity, Dict[str, Any]]],
        Field(description='User who created this review. Read-only.'),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Timestamp when the access review series was created. Supports $select. Read-only.',
        ),
    ] = None
    description_for_admins: Annotated[
        Optional[str],
        Field(
            description='Description provided by review creators to provide more context of the review to admins. Supports $select.'
        ),
    ] = None
    description_for_reviewers: Annotated[
        Optional[str],
        Field(
            description='Description provided  by review creators to provide more context of the review to reviewers. Reviewers see this description in the email sent to them requesting their review. Email notifications support up to 256 characters. Supports $select.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='Name of the access review series. Supports $select and $orderby. Required on create.'
        ),
    ] = None
    fallback_reviewers: Annotated[
        Optional[List[AccessReviewReviewerScope]],
        Field(
            description="This collection of reviewer scopes is used to define the list of fallback reviewers. These fallback reviewers are notified to take action if no users are found from the list of reviewers specified. This could occur when either the group owner is specified as the reviewer but the group owner doesn't exist, or manager is specified as reviewer but a user's manager doesn't exist. See accessReviewReviewerScope. Replaces backupReviewers. Supports $select. NOTE: The value of this property will be ignored if fallback reviewers are assigned through the stageSettings property."
        ),
    ] = None
    instance_enumeration_scope: Annotated[
        Optional[Union[AccessReviewScope, Dict[str, Any]]],
        Field(
            description="This property is required when scoping a review to guest users' access across all Microsoft 365 groups and determines which Microsoft 365 groups are reviewed. Each group becomes a unique accessReviewInstance of the access review series.  For supported scopes, see accessReviewScope. Supports $select. For examples of options for configuring instanceEnumerationScope, see Configure the scope of your access review definition using the Microsoft Graph API."
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Timestamp when the access review series was last modified. Supports $select. Read-only.',
        ),
    ] = None
    reviewers: Annotated[
        Optional[List[AccessReviewReviewerScope]],
        Field(
            description='This collection of access review scopes is used to define who are the reviewers. The reviewers property is only updatable if individual users are assigned as reviewers. Required on create. Supports $select. For examples of options for assigning reviewers, see Assign reviewers to your access review definition using the Microsoft Graph API. NOTE: The value of this property will be ignored if reviewers are assigned through the stageSettings property.'
        ),
    ] = None
    scope: Annotated[
        Optional[Union[AccessReviewScope, Dict[str, Any]]],
        Field(
            description='Defines the entities whose access is reviewed. For supported scopes, see accessReviewScope. Required on create. Supports $select and $filter (contains only). For examples of options for configuring scope, see Configure the scope of your access review definition using the Microsoft Graph API.'
        ),
    ] = None
    settings: Annotated[
        Optional[Union[AccessReviewScheduleSettings, Dict[str, Any]]],
        Field(
            description='The settings for an access review series, see type definition below. Supports $select. Required on create.'
        ),
    ] = None
    stage_settings: Annotated[
        Optional[List[AccessReviewStageSettings]],
        Field(
            description='Required only for a multi-stage access review to define the stages and their settings. You can break down each review instance into up to three sequential stages, where each stage can have a different set of reviewers, fallback reviewers, and settings. Stages are created sequentially based on the dependsOn property. Optional.  When this property is defined, its settings are used instead of the corresponding settings in the accessReviewScheduleDefinition object and its settings, reviewers, and fallbackReviewers properties.'
        ),
    ] = None
    status: Annotated[
        Optional[str],
        Field(
            description='This read-only field specifies the status of an access review. The typical states include Initializing, NotStarted, Starting, InProgress, Completing, Completed, AutoReviewing, and AutoReviewed.  Supports $select, $orderby, and $filter (eq only). Read-only.'
        ),
    ] = None
    instances: Annotated[
        Optional[List[AccessReviewInstance]],
        Field(
            description="If the accessReviewScheduleDefinition is a recurring access review, instances represent each recurrence. A review that doesn't recur will have exactly one instance. Instances also represent each unique resource under review in the accessReviewScheduleDefinition. If a review has multiple resources and multiple instances, each resource has a unique instance for each recurrence."
        ),
    ] = None
    field_odata_type: str


class AccessReviewSet(Entity):
    definitions: Annotated[
        Optional[List[AccessReviewScheduleDefinition]],
        Field(
            description='Represents the template and scheduling for an access review.'
        ),
    ] = None
    history_definitions: Annotated[
        Optional[List[AccessReviewHistoryDefinition]],
        Field(
            description='Represents a collection of access review history data and the scopes used to collect that data.'
        ),
    ] = None
    field_odata_type: str


class Agreement(Entity):
    display_name: Annotated[
        Optional[str],
        Field(
            description="Display name of the agreement. The display name is used for internal tracking of the agreement but isn't shown to end users who view the agreement. Supports $filter (eq)."
        ),
    ] = None
    is_per_device_acceptance_required: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether end users are required to accept this agreement on every device that they access it from. The end user is required to register their device in Microsoft Entra ID, if they haven't already done so. Supports $filter (eq)."
        ),
    ] = None
    is_viewing_before_acceptance_required: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the user has to expand the agreement before accepting. Supports $filter (eq).'
        ),
    ] = None
    terms_expiration: Annotated[
        Optional[Union[TermsExpiration, Dict[str, Any]]],
        Field(
            description='Expiration schedule and frequency of agreement for all users. Supports $filter (eq).'
        ),
    ] = None
    user_reaccept_required_frequency: Annotated[
        Optional[timedelta],
        Field(
            description='The duration after which the user must reaccept the terms of use. The value is represented in ISO 8601 format for durations. Supports $filter (eq).',
        ),
    ] = None
    acceptances: Annotated[
        Optional[List[AgreementAcceptance]],
        Field(
            description='Read-only. Information about acceptances of this agreement.'
        ),
    ] = None
    file: Annotated[
        Optional[Union[AgreementFile, Dict[str, Any]]],
        Field(description='Default PDF linked to this agreement.'),
    ] = None
    files: Annotated[
        Optional[List[AgreementFileLocalization]],
        Field(
            description='PDFs linked to this agreement. This property is in the process of being deprecated. Use the  file property instead. Supports $expand.'
        ),
    ] = None
    field_odata_type: str


class AppConsentApprovalRoute(Entity):
    app_consent_requests: Annotated[
        Optional[List[AppConsentRequest]],
        Field(
            description='A collection of appConsentRequest objects representing apps for which admin consent has been requested by one or more users.'
        ),
    ] = None
    field_odata_type: str


class BookingBusiness(Entity):
    address: Annotated[
        Optional[Union[PhysicalAddress, Dict[str, Any]]],
        Field(
            description='The street address of the business. The address property, together with phone and webSiteUrl, appear in the footer of a business scheduling page. The attribute type of physicalAddress is not supported in v1.0. Internally we map the addresses to the type others.'
        ),
    ] = None
    booking_page_settings: Annotated[
        Optional[Union[BookingPageSettings, Dict[str, Any]]],
        Field(description='Settings for the published booking page.'),
    ] = None
    business_hours: Annotated[
        Optional[List[BookingWorkHours]],
        Field(description='The hours of operation for the business.'),
    ] = None
    business_type: Annotated[
        Optional[str], Field(description='The type of business.')
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date, time, and time zone when the booking business was created. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    default_currency_iso: Annotated[
        Optional[str],
        Field(
            description='The code for the currency that the business operates in on Microsoft Bookings.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='The name of the business, which interfaces with customers. This name appears at the top of the business scheduling page.'
        ),
    ] = None
    email: Annotated[
        Optional[str], Field(description='The email address for the business.')
    ] = None
    is_published: Annotated[
        Optional[bool],
        Field(
            description='The scheduling page has been made available to external customers. Use the publish and unpublish actions to set this property. Read-only.'
        ),
    ] = None
    language_tag: Annotated[
        Optional[str],
        Field(description='The language of the self-service booking page.'),
    ] = None
    last_updated_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date, time, and time zone when the booking business was last updated. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    phone: Annotated[
        Optional[str],
        Field(
            description='The telephone number for the business. The phone property, together with address and webSiteUrl, appear in the footer of a business scheduling page.'
        ),
    ] = None
    public_url: Annotated[
        Optional[str],
        Field(
            description='The URL for the scheduling page, which is set after you publish or unpublish the page. Read-only.'
        ),
    ] = None
    scheduling_policy: Annotated[
        Optional[Union[BookingSchedulingPolicy, Dict[str, Any]]],
        Field(description='Specifies how bookings can be created for this business.'),
    ] = None
    web_site_url: Annotated[
        Optional[str],
        Field(
            description='The URL of the business web site. The webSiteUrl property, together with address, phone, appear in the footer of a business scheduling page.'
        ),
    ] = None
    appointments: Annotated[
        Optional[List[BookingAppointment]],
        Field(
            description='All the appointments of this business. Read-only. Nullable.'
        ),
    ] = None
    calendar_view: Annotated[
        Optional[List[BookingAppointment]],
        Field(
            description='The set of appointments of this business in a specified date range. Read-only. Nullable.'
        ),
    ] = None
    customers: Annotated[
        Optional[List[BookingCustomerBase]],
        Field(description='All the customers of this business. Read-only. Nullable.'),
    ] = None
    custom_questions: Annotated[
        Optional[List[BookingCustomQuestion]],
        Field(
            description='All the custom questions of this business. Read-only. Nullable.'
        ),
    ] = None
    services: Annotated[
        Optional[List[BookingService]],
        Field(
            description='All the services offered by this business. Read-only. Nullable.'
        ),
    ] = None
    staff_members: Annotated[
        Optional[List[BookingStaffMemberBase]],
        Field(
            description='All the staff members that provide services in this business. Read-only. Nullable.'
        ),
    ] = None
    field_odata_type: str


class ChatMessage(Entity):
    attachments: Annotated[
        Optional[List[ChatMessageAttachment]],
        Field(
            description='References to attached objects like files, tabs, meetings etc.'
        ),
    ] = None
    body: Optional[ItemBody] = None
    channel_identity: Annotated[
        Optional[Union[ChannelIdentity, Dict[str, Any]]],
        Field(
            description='If the message was sent in a channel, represents identity of the channel.'
        ),
    ] = None
    chat_id: Annotated[
        Optional[str],
        Field(
            description='If the message was sent in a chat, represents the identity of the chat.'
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Timestamp of when the chat message was created.',
        ),
    ] = None
    deleted_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Read only. Timestamp at which the chat message was deleted, or null if not deleted.',
        ),
    ] = None
    etag: Annotated[
        Optional[str],
        Field(description='Read-only. Version number of the chat message.'),
    ] = None
    event_detail: Annotated[
        Optional[Union[EventMessageDetail, Dict[str, Any]]],
        Field(
            description='Read-only. If present, represents details of an event that happened in a chat, a channel, or a team, for example, adding new members. For event messages, the messageType property will be set to systemEventMessage.'
        ),
    ] = None
    from_: Annotated[
        Optional[Union[ChatMessageFromIdentitySet, Dict[str, Any]]],
        Field(
            description='Details of the sender of the chat message. Can only be set during migration.'
        ),
    ] = None
    importance: Optional[ChatMessageImportance] = None
    last_edited_date_time: Annotated[
        Optional[datetime],
        Field(
            description="Read only. Timestamp when edits to the chat message were made. Triggers an 'Edited' flag in the Teams UI. If no edits are made the value is null.",
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Read only. Timestamp when the chat message is created (initial setting) or modified, including when a reaction is added or removed.',
        ),
    ] = None
    locale: Annotated[
        Optional[str],
        Field(
            description='Locale of the chat message set by the client. Always set to en-us.'
        ),
    ] = None
    mentions: Annotated[
        Optional[List[ChatMessageMention]],
        Field(
            description='List of entities mentioned in the chat message. Supported entities are: user, bot, team, channel, chat, and tag.'
        ),
    ] = None
    message_history: Annotated[
        Optional[List[ChatMessageHistoryItem]],
        Field(
            description='List of activity history of a message item, including modification time and actions, such as reactionAdded, reactionRemoved, or reaction changes, on the message.'
        ),
    ] = None
    message_type: Optional[ChatMessageType] = None
    policy_violation: Annotated[
        Optional[Union[ChatMessagePolicyViolation, Dict[str, Any]]],
        Field(
            description='Defines the properties of a policy violation set by a data loss prevention (DLP) application.'
        ),
    ] = None
    reactions: Annotated[
        Optional[List[ChatMessageReaction]],
        Field(description='Reactions for this chat message (for example, Like).'),
    ] = None
    reply_to_id: Annotated[
        Optional[str],
        Field(
            description='Read-only. ID of the parent chat message or root chat message of the thread. (Only applies to chat messages in channels, not chats.)'
        ),
    ] = None
    subject: Annotated[
        Optional[str],
        Field(description='The subject of the chat message, in plaintext.'),
    ] = None
    summary: Annotated[
        Optional[str],
        Field(
            description='Summary text of the chat message that could be used for push notifications and summary views or fall back views. Only applies to channel chat messages, not chat messages in a chat.'
        ),
    ] = None
    web_url: Annotated[
        Optional[str],
        Field(description='Read-only. Link to the message in Microsoft Teams.'),
    ] = None
    hosted_contents: Annotated[
        Optional[List[ChatMessageHostedContent]],
        Field(
            description='Content in a message hosted by Microsoft Teams - for example, images or code snippets.'
        ),
    ] = None
    replies: Annotated[
        Optional[List[ChatMessage]],
        Field(
            description='Replies for a specified message. Supports $expand for channel messages.'
        ),
    ] = None
    field_odata_type: str


class ConditionalAccessPolicy(Entity):
    conditions: Optional[ConditionalAccessConditionSet] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Readonly.',
        ),
    ] = None
    description: Optional[str] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='Specifies a display name for the conditionalAccessPolicy object.'
        ),
    ] = None
    grant_controls: Annotated[
        Optional[Union[ConditionalAccessGrantControls, Dict[str, Any]]],
        Field(
            description='Specifies the grant controls that must be fulfilled to pass the policy.'
        ),
    ] = None
    modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Readonly.',
        ),
    ] = None
    session_controls: Annotated[
        Optional[Union[ConditionalAccessSessionControls, Dict[str, Any]]],
        Field(
            description='Specifies the session controls that are enforced after sign-in.'
        ),
    ] = None
    state: Optional[ConditionalAccessPolicyState] = None
    template_id: Optional[str] = None
    field_odata_type: str


class ConditionalAccessTemplate(Entity):
    description: Annotated[
        Optional[str], Field(description='The user-friendly name of the template.')
    ] = None
    details: Optional[ConditionalAccessPolicyDetail] = None
    name: Annotated[
        Optional[str], Field(description='The user-friendly name of the template.')
    ] = None
    scenarios: Optional[TemplateScenarios] = None
    field_odata_type: str


class Conversation(Entity):
    has_attachments: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether any of the posts within this Conversation has at least one attachment. Supports $filter (eq, ne) and $search.'
        ),
    ] = None
    last_delivered_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z',
        ),
    ] = None
    preview: Annotated[
        Optional[str],
        Field(
            description='A short summary from the body of the latest post in this conversation. Supports $filter (eq, ne, le, ge).'
        ),
    ] = None
    topic: Annotated[
        Optional[str],
        Field(
            description='The topic of the conversation. This property can be set when the conversation is created, but it cannot be updated.'
        ),
    ] = None
    unique_senders: Annotated[
        Optional[List[str]],
        Field(description='All the users that sent a message to this Conversation.'),
    ] = None
    threads: Annotated[
        Optional[List[ConversationThread]],
        Field(
            description='A collection of all the conversation threads in the conversation. A navigation property. Read-only. Nullable.'
        ),
    ] = None
    field_odata_type: str


class CrossTenantAccessPolicy(PolicyBase):
    allowed_cloud_endpoints: Annotated[
        Optional[List[str]],
        Field(
            description='Used to specify which Microsoft clouds an organization would like to collaborate with. By default, this value is empty. Supported values for this field are: microsoftonline.com, microsoftonline.us, and partner.microsoftonline.cn.'
        ),
    ] = None
    default: Annotated[
        Optional[Union[CrossTenantAccessPolicyConfigurationDefault, Dict[str, Any]]],
        Field(
            description='Defines the default configuration for how your organization interacts with external Microsoft Entra organizations.'
        ),
    ] = None
    partners: Annotated[
        Optional[List[CrossTenantAccessPolicyConfigurationPartner]],
        Field(
            description='Defines partner-specific configurations for external Microsoft Entra organizations.'
        ),
    ] = None
    templates: Annotated[
        Optional[Union[PolicyTemplate, Dict[str, Any]]],
        Field(
            description='Represents the base policy in the directory for multitenant organization settings.'
        ),
    ] = None
    field_odata_type: str


class DeviceAppManagement(Entity):
    is_enabled_for_microsoft_store_for_business: Annotated[
        Optional[bool],
        Field(
            description='Whether the account is enabled for syncing applications from the Microsoft Store for Business.'
        ),
    ] = None
    microsoft_store_for_business_language: Annotated[
        Optional[str],
        Field(
            description='The locale information used to sync applications from the Microsoft Store for Business. Cultures that are specific to a country/region. The names of these cultures follow RFC 4646 (Windows Vista and later). The format is -<country/regioncode2>, where  is a lowercase two-letter code derived from ISO 639-1 and <country/regioncode2> is an uppercase two-letter code derived from ISO 3166. For example, en-US for English (United States) is a specific culture.'
        ),
    ] = None
    microsoft_store_for_business_last_completed_application_sync_time: Annotated[
        Optional[datetime],
        Field(
            description='The last time an application sync from the Microsoft Store for Business was completed.',
        ),
    ] = None
    microsoft_store_for_business_last_successful_sync_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The last time the apps from the Microsoft Store for Business were synced successfully for the account.',
        ),
    ] = None
    android_managed_app_protections: Annotated[
        Optional[List[AndroidManagedAppProtection]],
        Field(description='Android managed app policies.'),
    ] = None
    default_managed_app_protections: Annotated[
        Optional[List[DefaultManagedAppProtection]],
        Field(description='Default managed app policies.'),
    ] = None
    ios_managed_app_protections: Annotated[
        Optional[List[IosManagedAppProtection]],
        Field(description='iOS managed app policies.'),
    ] = None
    managed_app_policies: Annotated[
        Optional[List[ManagedAppPolicy]], Field(description='Managed app policies.')
    ] = None
    managed_app_registrations: Annotated[
        Optional[List[ManagedAppRegistration]],
        Field(description='The managed app registrations.'),
    ] = None
    managed_app_statuses: Annotated[
        Optional[List[ManagedAppStatus]], Field(description='The managed app statuses.')
    ] = None
    managed_e_books: Annotated[
        Optional[List[ManagedEBook]], Field(description='The Managed eBook.')
    ] = None
    mdm_windows_information_protection_policies: Annotated[
        Optional[List[MdmWindowsInformationProtectionPolicy]],
        Field(
            description='Windows information protection for apps running on devices which are MDM enrolled.'
        ),
    ] = None
    mobile_app_categories: Annotated[
        Optional[List[MobileAppCategory]],
        Field(description='The mobile app categories.'),
    ] = None
    mobile_app_configurations: Annotated[
        Optional[List[ManagedDeviceMobileAppConfiguration]],
        Field(description='The Managed Device Mobile Application Configurations.'),
    ] = None
    mobile_apps: Annotated[
        Optional[List[MobileApp]], Field(description='The mobile apps.')
    ] = None
    targeted_managed_app_configurations: Annotated[
        Optional[List[TargetedManagedAppConfiguration]],
        Field(description='Targeted managed app configurations.'),
    ] = None
    vpp_tokens: Annotated[
        Optional[List[VppToken]],
        Field(description='List of Vpp tokens for this organization.'),
    ] = None
    windows_information_protection_policies: Annotated[
        Optional[List[WindowsInformationProtectionPolicy]],
        Field(
            description='Windows information protection for apps running on devices which are not MDM enrolled.'
        ),
    ] = None
    field_odata_type: str


class DriveRestoreArtifact(RestoreArtifactBase):
    restored_site_id: Annotated[
        Optional[str],
        Field(
            description='The new site identifier if destinationType is new, and the input site ID if the destinationType is inPlace.'
        ),
    ] = None
    restored_site_name: Annotated[
        Optional[str], Field(description='The name of the restored site.')
    ] = None
    restored_site_web_url: Annotated[
        Optional[str], Field(description='The web URL of the restored site.')
    ] = None
    field_odata_type: str


class EducationAssignment(Entity):
    added_student_action: Annotated[
        Optional[Union[EducationAddedStudentAction, Dict[str, Any]]],
        Field(
            description="Optional field to control the assignment behavior for students who are added after the assignment is published. If not specified, defaults to none. Supported values are: none, assignIfOpen. For example, a teacher can use assignIfOpen to indicate that an assignment should be assigned to any new student who joins the class while the assignment is still open, and none to indicate that an assignment shouldn't be assigned to new students."
        ),
    ] = None
    add_to_calendar_action: Annotated[
        Optional[Union[EducationAddToCalendarOptions, Dict[str, Any]]],
        Field(
            description="Optional field to control the assignment behavior  for adding assignments to students' and teachers' calendars when the assignment is published. The possible values are: none, studentsAndPublisher, studentsAndTeamOwners, unknownFutureValue, and studentsOnly. Use the Prefer: include-unknown-enum-members request header to get the following values in this evolvable enum: studentsOnly. The default value is none."
        ),
    ] = None
    allow_late_submissions: Annotated[
        Optional[bool],
        Field(
            description="Identifies whether students can submit after the due date. If this property isn't specified during create, it defaults to true."
        ),
    ] = None
    allow_students_to_add_resources_to_submission: Annotated[
        Optional[bool],
        Field(
            description='Identifies whether students can add their own resources to a submission or if they can only modify resources added by the teacher.'
        ),
    ] = None
    assign_date_time: Annotated[
        Optional[datetime],
        Field(
            description="The date when the assignment should become active. If in the future, the assignment isn't shown to the student until this date. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z",
        ),
    ] = None
    assigned_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The moment that the assignment was published to students and the assignment shows up on the students timeline. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z',
        ),
    ] = None
    assign_to: Annotated[
        Optional[Union[EducationAssignmentRecipient, Dict[str, Any]]],
        Field(
            description='Which users, or whole class should receive a submission object once the assignment is published.'
        ),
    ] = None
    class_id: Annotated[
        Optional[str], Field(description='Class to which this assignment belongs.')
    ] = None
    close_date_time: Annotated[
        Optional[datetime],
        Field(
            description="Date when the assignment is closed for submissions. This is an optional field that can be null if the assignment doesn't allowLateSubmissions or when the closeDateTime is the same as the dueDateTime. But if specified, then the closeDateTime must be greater than or equal to the dueDateTime. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z",
        ),
    ] = None
    created_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Who created the assignment.'),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Moment when the assignment was created. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z',
        ),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='Name of the assignment.')
    ] = None
    due_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date when the students assignment is due. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z',
        ),
    ] = None
    feedback_resources_folder_url: Annotated[
        Optional[str],
        Field(
            description='Folder URL where all the feedback file resources for this assignment are stored.'
        ),
    ] = None
    grading: Annotated[
        Optional[Union[EducationAssignmentGradeType, Dict[str, Any]]],
        Field(description='How the assignment will be graded.'),
    ] = None
    instructions: Annotated[
        Optional[Union[EducationItemBody, Dict[str, Any]]],
        Field(
            description='Instructions for the assignment. The instructions and the display name tell the student what to do.'
        ),
    ] = None
    last_modified_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Who last modified the assignment.'),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description="The date and time on which the assignment was modified. A student submission doesn't modify the assignment; only teachers can update assignments. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z",
        ),
    ] = None
    module_url: Annotated[
        Optional[str],
        Field(description='The URL of the module from which to access the assignment.'),
    ] = None
    notification_channel_url: Annotated[
        Optional[str],
        Field(
            description="Optional field to specify the URL of the channel to post the assignment publish notification. If not specified or null, defaults to the General channel. This field only applies to assignments where the assignTo value is educationAssignmentClassRecipient. Updating the notificationChannelUrl isn't allowed after the assignment is published."
        ),
    ] = None
    resources_folder_url: Annotated[
        Optional[str],
        Field(
            description='Folder URL where all the file resources for this assignment are stored.'
        ),
    ] = None
    status: Annotated[
        Optional[Union[EducationAssignmentStatus, Dict[str, Any]]],
        Field(
            description="Status of the assignment.  You can't PATCH this value. Possible values are: draft, scheduled, published, assigned, unknownFutureValue, inactive. Use the Prefer: include-unknown-enum-members request header to get the following value(s) in this evolvable enum: inactive."
        ),
    ] = None
    web_url: Annotated[
        Optional[str], Field(description='The deep link URL for the given assignment.')
    ] = None
    categories: Annotated[
        Optional[List[EducationCategory]],
        Field(
            description='When set, enables users to easily find assignments of a given type. Read-only. Nullable.'
        ),
    ] = None
    grading_category: Annotated[
        Optional[Union[EducationGradingCategory, Dict[str, Any]]],
        Field(
            description='When set, enables users to weight assignments differently when computing a class average grade.'
        ),
    ] = None
    resources: Annotated[
        Optional[List[EducationAssignmentResource]],
        Field(
            description='Learning objects that are associated with this assignment. Only teachers can modify this list. Nullable.'
        ),
    ] = None
    rubric: Annotated[
        Optional[Union[EducationRubric, Dict[str, Any]]],
        Field(description='When set, the grading rubric attached to this assignment.'),
    ] = None
    submissions: Annotated[
        Optional[List[EducationSubmission]],
        Field(
            description="Once published, there's a submission object for each student representing their work and grade. Read-only. Nullable."
        ),
    ] = None
    field_odata_type: str


class ExchangeProtectionPolicy(ProtectionPolicyBase):
    mailbox_inclusion_rules: Annotated[
        Optional[List[MailboxProtectionRule]],
        Field(description='The rules associated with the Exchange protection policy.'),
    ] = None
    mailbox_protection_units: Annotated[
        Optional[List[MailboxProtectionUnit]],
        Field(
            description='The protection units (mailboxes) that are  protected under the Exchange protection policy.'
        ),
    ] = None
    field_odata_type: str


class MailboxRestoreArtifact(RestoreArtifactBase):
    restored_folder_id: Annotated[
        Optional[str],
        Field(description='The new restored folder identifier for the user.'),
    ] = None
    restored_folder_name: Annotated[
        Optional[str], Field(description='The new restored folder name.')
    ] = None
    field_odata_type: str


class ManagedAndroidLobApp(ManagedMobileLobApp):
    minimum_supported_operating_system: Annotated[
        Optional[Union[AndroidMinimumOperatingSystem, Dict[str, Any]]],
        Field(description='The value for the minimum applicable operating system.'),
    ] = None
    package_id: Annotated[
        Optional[str], Field(description='The package identifier.')
    ] = None
    version_code: Annotated[
        Optional[str],
        Field(
            description='The version code of managed Android Line of Business (LoB) app.'
        ),
    ] = None
    version_name: Annotated[
        Optional[str],
        Field(
            description='The version name of managed Android Line of Business (LoB) app.'
        ),
    ] = None
    field_odata_type: str


class ManagedAndroidStoreApp(ManagedApp):
    app_store_url: Annotated[
        Optional[str], Field(description='The Android AppStoreUrl.')
    ] = None
    minimum_supported_operating_system: Optional[AndroidMinimumOperatingSystem] = None
    package_id: Annotated[Optional[str], Field(description="The app's package ID.")] = (
        None
    )
    field_odata_type: str


class ManagedIOSLobApp(ManagedMobileLobApp):
    applicable_device_type: Optional[IosDeviceType] = None
    build_number: Annotated[
        Optional[str],
        Field(
            description='The build number of managed iOS Line of Business (LoB) app.'
        ),
    ] = None
    bundle_id: Annotated[Optional[str], Field(description='The Identity Name.')] = None
    expiration_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The expiration time.',
        ),
    ] = None
    minimum_supported_operating_system: Annotated[
        Optional[Union[IosMinimumOperatingSystem, Dict[str, Any]]],
        Field(description='The value for the minimum applicable operating system.'),
    ] = None
    version_number: Annotated[
        Optional[str],
        Field(
            description='The version number of managed iOS Line of Business (LoB) app.'
        ),
    ] = None
    field_odata_type: str


class OneDriveForBusinessRestoreSession(RestoreSessionBase):
    drive_restore_artifacts: Annotated[
        Optional[List[DriveRestoreArtifact]],
        Field(
            description='A collection of restore points and destination details that can be used to restore a OneDrive for Business drive.'
        ),
    ] = None
    field_odata_type: str


class OrganizationalBranding(OrganizationalBrandingProperties):
    localizations: Annotated[
        Optional[List[OrganizationalBrandingLocalization]],
        Field(description='Add different branding based on a locale.'),
    ] = None
    field_odata_type: str


class PinnedChatMessageInfo(Entity):
    message: Annotated[
        Optional[Union[ChatMessage, Dict[str, Any]]],
        Field(description='Represents details about the chat message that is pinned.'),
    ] = None
    field_odata_type: str


class Planner(Entity):
    buckets: Annotated[
        Optional[List[PlannerBucket]],
        Field(
            description='Read-only. Nullable. Returns a collection of the specified buckets'
        ),
    ] = None
    plans: Annotated[
        Optional[List[PlannerPlan]],
        Field(
            description='Read-only. Nullable. Returns a collection of the specified plans'
        ),
    ] = None
    tasks: Annotated[
        Optional[List[PlannerTask]],
        Field(
            description='Read-only. Nullable. Returns a collection of the specified tasks'
        ),
    ] = None
    field_odata_type: str


class PlannerGroup(Entity):
    plans: Annotated[
        Optional[List[PlannerPlan]],
        Field(
            description='Read-only. Nullable. Returns the plannerPlans owned by the group.'
        ),
    ] = None
    field_odata_type: str


class ServiceAnnouncement(Entity):
    health_overviews: Annotated[
        Optional[List[ServiceHealth]],
        Field(
            description='A collection of service health information for tenant. This property is a contained navigation property, it is nullable and readonly.'
        ),
    ] = None
    issues: Annotated[
        Optional[List[ServiceHealthIssue]],
        Field(
            description='A collection of service issues for tenant. This property is a contained navigation property, it is nullable and readonly.'
        ),
    ] = None
    messages: Annotated[
        Optional[List[ServiceUpdateMessage]],
        Field(
            description='A collection of service messages for tenant. This property is a contained navigation property, it is nullable and readonly.'
        ),
    ] = None
    field_odata_type: str


class SharePointRestoreSession(RestoreSessionBase):
    site_restore_artifacts: Annotated[
        Optional[List[SiteRestoreArtifact]],
        Field(
            description='A collection of restore points and destination details that can be used to restore SharePoint sites.'
        ),
    ] = None
    field_odata_type: str


class TeamsAppDefinition(Entity):
    authorization: Annotated[
        Optional[Union[TeamsAppAuthorization, Dict[str, Any]]],
        Field(
            description='Authorization requirements specified in the Teams app manifest.'
        ),
    ] = None
    created_by: Optional[Union[IdentitySet, Dict[str, Any]]] = None
    description: Annotated[
        Optional[str], Field(description='Verbose description of the application.')
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(description='The name of the app provided by the app developer.'),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
        ),
    ] = None
    publishing_state: Annotated[
        Optional[Union[TeamsAppPublishingState, Dict[str, Any]]],
        Field(
            description='The published status of a specific version of a Teams app. Possible values are:submittedThe specific version of the Teams app was submitted and is under review.publishedThe request to publish the specific version of the Teams app was approved by the admin and the app is published.rejectedThe admin rejected the request to publish the specific version of the Teams app.'
        ),
    ] = None
    short_description: Annotated[
        Optional[str], Field(description='Short description of the application.')
    ] = None
    teams_app_id: Annotated[
        Optional[str], Field(description='The ID from the Teams app manifest.')
    ] = None
    version: Annotated[
        Optional[str], Field(description='The version number of the application.')
    ] = None
    bot: Annotated[
        Optional[Union[TeamworkBot, Dict[str, Any]]],
        Field(
            description='The details of the bot specified in the Teams app manifest.'
        ),
    ] = None
    field_odata_type: str


class TenantAppManagementPolicy(PolicyBase):
    application_restrictions: Annotated[
        Optional[Union[AppManagementApplicationConfiguration, Dict[str, Any]]],
        Field(
            description='Restrictions that apply as default to all application objects in the tenant.'
        ),
    ] = None
    is_enabled: Annotated[
        Optional[bool],
        Field(
            description='Denotes whether the policy is enabled. Default value is false.'
        ),
    ] = None
    service_principal_restrictions: Annotated[
        Optional[Union[AppManagementServicePrincipalConfiguration, Dict[str, Any]]],
        Field(
            description='Restrictions that apply as default to all service principal objects in the tenant.'
        ),
    ] = None
    field_odata_type: str


class TermsOfUseContainer(Entity):
    agreement_acceptances: Annotated[
        Optional[List[AgreementAcceptance]],
        Field(
            description="Represents the current status of a user's response to a company's customizable terms of use agreement."
        ),
    ] = None
    agreements: Annotated[
        Optional[List[Agreement]],
        Field(
            description="Represents a tenant's customizable terms of use agreement that's created and managed with Microsoft Entra ID Governance."
        ),
    ] = None
    field_odata_type: str


class Todo(Entity):
    lists: Annotated[
        Optional[List[TodoTaskList]],
        Field(description='The task lists in the users mailbox.'),
    ] = None
    field_odata_type: str


class UnifiedRoleAssignmentSchedule(UnifiedRoleScheduleBase):
    assignment_type: Annotated[
        Optional[str],
        Field(
            description='The type of the assignment that can either be Assigned or Activated. Supports $filter (eq, ne).'
        ),
    ] = None
    member_type: Annotated[
        Optional[str],
        Field(
            description='How the assignment is inherited. It can either be Inherited, Direct, or Group. It can further imply whether the unifiedRoleAssignmentSchedule can be managed by the caller. Supports $filter (eq, ne).'
        ),
    ] = None
    schedule_info: Annotated[
        Optional[Union[RequestSchedule, Dict[str, Any]]],
        Field(
            description='The period of the role assignment. It can represent a single occurrence or multiple recurrences.'
        ),
    ] = None
    activated_using: Annotated[
        Optional[Union[UnifiedRoleEligibilitySchedule, Dict[str, Any]]],
        Field(
            description="If the request is from an eligible administrator to activate a role, this parameter shows the related eligible assignment for that activation. Otherwise, it's null. Supports $expand."
        ),
    ] = None
    field_odata_type: str


class UnifiedRoleAssignmentScheduleRequest(Request):
    action: Annotated[
        Optional[Union[UnifiedRoleScheduleRequestActions, Dict[str, Any]]],
        Field(
            description='Represents the type of the operation on the role assignment request. The possible values are: adminAssign, adminUpdate, adminRemove, selfActivate, selfDeactivate, adminExtend, adminRenew, selfExtend, selfRenew, unknownFutureValue. adminAssign: For administrators to assign roles to principals.adminRemove: For administrators to remove principals from roles. adminUpdate: For administrators to change existing role assignments.adminExtend: For administrators to extend expiring assignments.adminRenew: For administrators to renew expired assignments.selfActivate: For principals to activate their assignments.selfDeactivate: For principals to deactivate their active assignments.selfExtend: For principals to request to extend their expiring assignments.selfRenew: For principals to request to renew their expired assignments.'
        ),
    ] = None
    app_scope_id: Annotated[
        Optional[str],
        Field(
            description='Identifier of the app-specific scope when the assignment is scoped to an app. The scope of an assignment determines the set of resources for which the principal has been granted access. App scopes are scopes that are defined and understood by this application only. Use / for tenant-wide app scopes. Use directoryScopeId to limit the scope to particular directory objects, for example, administrative units. Supports $filter (eq, ne, and on null values).'
        ),
    ] = None
    directory_scope_id: Annotated[
        Optional[str],
        Field(
            description='Identifier of the directory object representing the scope of the assignment. The scope of an assignment determines the set of resources for which the principal has been granted access. Directory scopes are shared scopes stored in the directory that are understood by multiple applications. Use / for tenant-wide scope. Use appScopeId to limit the scope to an application only. Supports $filter (eq, ne, and on null values).'
        ),
    ] = None
    is_validation_only: Annotated[
        Optional[bool],
        Field(
            description='Determines whether the call is a validation or an actual call. Only set this property if you want to check whether an activation is subject to additional rules like MFA before actually submitting the request.'
        ),
    ] = None
    justification: Annotated[
        Optional[str],
        Field(
            description='A message provided by users and administrators when create they create the unifiedRoleAssignmentScheduleRequest object.'
        ),
    ] = None
    principal_id: Annotated[
        Optional[str],
        Field(
            description='Identifier of the principal that has been granted the assignment. Can be a user, role-assignable group, or a service principal. Supports $filter (eq, ne).'
        ),
    ] = None
    role_definition_id: Annotated[
        Optional[str],
        Field(
            description='Identifier of the unifiedRoleDefinition object that is being assigned to the principal. Supports $filter (eq, ne).'
        ),
    ] = None
    schedule_info: Annotated[
        Optional[Union[RequestSchedule, Dict[str, Any]]],
        Field(
            description='The period of the role assignment. Recurring schedules are currently unsupported.'
        ),
    ] = None
    target_schedule_id: Annotated[
        Optional[str],
        Field(
            description="Identifier of the schedule object that's linked to the assignment request. Supports $filter (eq, ne)."
        ),
    ] = None
    ticket_info: Annotated[
        Optional[Union[TicketInfo, Dict[str, Any]]],
        Field(
            description='Ticket details linked to the role assignment request including details of the ticket number and ticket system.'
        ),
    ] = None
    activated_using: Annotated[
        Optional[Union[UnifiedRoleEligibilitySchedule, Dict[str, Any]]],
        Field(
            description="If the request is from an eligible administrator to activate a role, this parameter will show the related eligible assignment for that activation. Otherwise, it's null. Supports $expand and $select nested in $expand."
        ),
    ] = None
    app_scope: Annotated[
        Optional[Union[AppScope, Dict[str, Any]]],
        Field(
            description='Read-only property with details of the app-specific scope when the assignment is scoped to an app. Nullable. Supports $expand.'
        ),
    ] = None
    directory_scope: Annotated[
        Optional[Union[DirectoryObject, Dict[str, Any]]],
        Field(
            description='The directory object that is the scope of the assignment. Read-only. Supports $expand.'
        ),
    ] = None
    principal: Annotated[
        Optional[Union[DirectoryObject, Dict[str, Any]]],
        Field(
            description="The principal that's getting a role assignment through the request. Supports $expand and $select nested in $expand for id only."
        ),
    ] = None
    role_definition: Annotated[
        Optional[Union[UnifiedRoleDefinition, Dict[str, Any]]],
        Field(
            description='Detailed information for the unifiedRoleDefinition object that is referenced through the roleDefinitionId property. Supports $expand and $select nested in $expand.'
        ),
    ] = None
    target_schedule: Annotated[
        Optional[Union[UnifiedRoleAssignmentSchedule, Dict[str, Any]]],
        Field(
            description='The schedule for an eligible role assignment that is referenced through the targetScheduleId property. Supports $expand and $select nested in $expand.'
        ),
    ] = None
    field_odata_type: str


class VirtualEventsRoot(Entity):
    events: Optional[List[VirtualEvent]] = None
    townhalls: Annotated[
        Optional[List[VirtualEventTownhall]],
        Field(description='A collection of town halls. Nullable.'),
    ] = None
    webinars: Annotated[
        Optional[List[VirtualEventWebinar]],
        Field(description='A collection of webinars. Nullable.'),
    ] = None
    field_odata_type: str


class WorkbookChartAxis(Entity):
    major_unit: Annotated[
        Optional[Any],
        Field(
            description='Represents the interval between two major tick marks. Can be set to a numeric value or an empty string.  The returned value is always a number.'
        ),
    ] = None
    maximum: Annotated[
        Optional[Any],
        Field(
            description='Represents the maximum value on the value axis.  Can be set to a numeric value or an empty string (for automatic axis values).  The returned value is always a number.'
        ),
    ] = None
    minimum: Annotated[
        Optional[Any],
        Field(
            description='Represents the minimum value on the value axis. Can be set to a numeric value or an empty string (for automatic axis values).  The returned value is always a number.'
        ),
    ] = None
    minor_unit: Annotated[
        Optional[Any],
        Field(
            description="Represents the interval between two minor tick marks. 'Can be set to a numeric value or an empty string (for automatic axis values). The returned value is always a number."
        ),
    ] = None
    format: Annotated[
        Optional[Union[WorkbookChartAxisFormat, Dict[str, Any]]],
        Field(
            description='Represents the formatting of a chart object, which includes line and font formatting. Read-only.'
        ),
    ] = None
    major_gridlines: Annotated[
        Optional[Union[WorkbookChartGridlines, Dict[str, Any]]],
        Field(
            description='Returns a gridlines object that represents the major gridlines for the specified axis. Read-only.'
        ),
    ] = None
    minor_gridlines: Annotated[
        Optional[Union[WorkbookChartGridlines, Dict[str, Any]]],
        Field(
            description='Returns a Gridlines object that represents the minor gridlines for the specified axis. Read-only.'
        ),
    ] = None
    title: Annotated[
        Optional[Union[WorkbookChartAxisTitle, Dict[str, Any]]],
        Field(description='Represents the axis title. Read-only.'),
    ] = None
    field_odata_type: str


class AccessPackageAssignmentRequestRequirements(BaseModel):
    allow_custom_assignment_schedule: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the requestor is allowed to set a custom schedule.'
        ),
    ] = None
    is_approval_required_for_add: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether a request to add must be approved by an approver.'
        ),
    ] = None
    is_approval_required_for_update: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether a request to update must be approved by an approver.'
        ),
    ] = None
    policy_description: Annotated[
        Optional[str],
        Field(
            description='The description of the policy that the user is trying to request access using.'
        ),
    ] = None
    policy_display_name: Annotated[
        Optional[str],
        Field(
            description='The display name of the policy that the user is trying to request access using.'
        ),
    ] = None
    policy_id: Annotated[
        Optional[str],
        Field(
            description='The identifier of the policy that these requirements are associated with. This identifier can be used when creating a new assignment request.'
        ),
    ] = None
    schedule: Annotated[
        Optional[Union[EntitlementManagementSchedule, Dict[str, Any]]],
        Field(description='Schedule restrictions enforced, if any.'),
    ] = None
    questions: Optional[List[AccessPackageQuestion]] = None
    field_odata_type: str


class AccessPackageAssignmentReviewSettings(BaseModel):
    expiration_behavior: Annotated[
        Optional[Union[AccessReviewExpirationBehavior, Dict[str, Any]]],
        Field(
            description='The default decision to apply if the access is not reviewed. The possible values are: keepAccess, removeAccess, acceptAccessRecommendation, unknownFutureValue.'
        ),
    ] = None
    fallback_reviewers: Annotated[
        Optional[List[SubjectSet]],
        Field(
            description="This collection specifies the users who will be the fallback reviewers when the primary reviewers don't respond."
        ),
    ] = None
    is_enabled: Annotated[
        Optional[bool],
        Field(
            description='If true, access reviews are required for assignments through this policy.'
        ),
    ] = None
    is_recommendation_enabled: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether to display recommendations to the reviewer. The default value is true.'
        ),
    ] = None
    is_reviewer_justification_required: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether the reviewer must provide justification for the approval. The default value is true.'
        ),
    ] = None
    is_self_review: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether the principals can review their own assignments.'
        ),
    ] = None
    primary_reviewers: Annotated[
        Optional[List[SubjectSet]],
        Field(
            description='This collection specifies the users or group of users who will review the access package assignments.'
        ),
    ] = None
    schedule: Annotated[
        Optional[Union[EntitlementManagementSchedule, Dict[str, Any]]],
        Field(
            description='When the first review should start and how often it should recur.'
        ),
    ] = None
    field_odata_type: str


class AuthenticationStrengthUsage(BaseModel):
    mfa: Optional[List[ConditionalAccessPolicy]] = None
    none: Optional[List[ConditionalAccessPolicy]] = None
    field_odata_type: str


class EndUserNotificationSetting(BaseModel):
    notification_preference: Annotated[
        Optional[Union[EndUserNotificationPreference, Dict[str, Any]]],
        Field(
            description='Notification preference. Possible values are: unknown, microsoft, custom, unknownFutureValue.'
        ),
    ] = None
    positive_reinforcement: Annotated[
        Optional[Union[PositiveReinforcementNotification, Dict[str, Any]]],
        Field(description='Positive reinforcement detail.'),
    ] = None
    setting_type: Annotated[
        Optional[Union[EndUserNotificationSettingType, Dict[str, Any]]],
        Field(
            description='End user notification type. Possible values are: unknown, noTraining, trainingSelected, noNotification, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class MicrosoftCustomTrainingSetting(TrainingSetting):
    completion_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The completion date and time of the training. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    training_assignment_mappings: Annotated[
        Optional[List[MicrosoftTrainingAssignmentMapping]],
        Field(description='The mapping details of the associated training.'),
    ] = None
    training_completion_duration: Annotated[
        Optional[Union[TrainingCompletionDuration, Dict[str, Any]]],
        Field(
            description='The training completion duration that needs to be provided before scheduling the training. Possible values are: week, fortnite, month, unknownFutureValue.'
        ),
    ] = None
    field_odata_type: str


class NoTrainingNotificationSetting(EndUserNotificationSetting):
    simulation_notification: Annotated[
        Optional[Union[SimulationNotification, Dict[str, Any]]],
        Field(
            description='The notification for the user who is part of the simulation.'
        ),
    ] = None
    field_odata_type: str


class TrainingNotificationSetting(EndUserNotificationSetting):
    training_assignment: Annotated[
        Optional[Union[BaseEndUserNotification, Dict[str, Any]]],
        Field(description='Training assignment details.'),
    ] = None
    training_reminder: Annotated[
        Optional[Union[TrainingReminderNotification, Dict[str, Any]]],
        Field(description='Training reminder details.'),
    ] = None
    field_odata_type: str


class AgreementCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Agreement]] = None


class AccessReviewScheduleDefinitionCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AccessReviewScheduleDefinition]] = None


class AccessReviewHistoryDefinitionCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AccessReviewHistoryDefinition]] = None


class ExchangeProtectionPolicyCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ExchangeProtectionPolicy]] = None


class OneDriveForBusinessRestoreSessionCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[OneDriveForBusinessRestoreSession]] = None


class SharePointRestoreSessionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SharePointRestoreSession]] = None


class ChatMessageCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ChatMessage]] = None


class PinnedChatMessageInfoCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[PinnedChatMessageInfo]] = None


class ConditionalAccessPolicyCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ConditionalAccessPolicy]] = None


class ConditionalAccessTemplateCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[ConditionalAccessTemplate]] = None


class EducationAssignmentCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[EducationAssignment]] = None


class MailboxRestoreArtifactCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[MailboxRestoreArtifact]] = None


class ConversationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Conversation]] = None


class DriveRestoreArtifactCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[DriveRestoreArtifact]] = None


class UnifiedRoleAssignmentScheduleRequestCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UnifiedRoleAssignmentScheduleRequest]] = None


class UnifiedRoleAssignmentScheduleCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UnifiedRoleAssignmentSchedule]] = None


class BookingBusinessCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[BookingBusiness]] = None


class TeamsAppDefinitionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[TeamsAppDefinition]] = None


class CrossTenantAccessPolicyCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[CrossTenantAccessPolicy]] = None


class TenantAppManagementPolicyCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[TenantAppManagementPolicy]] = None


class ManagedAndroidStoreAppCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ManagedAndroidStoreApp]] = None


class ManagedAndroidLobAppCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ManagedAndroidLobApp]] = None


class ManagedIOSLobAppCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ManagedIOSLobApp]] = None


class Admin(BaseModel):
    edge: Annotated[
        Optional[Union[Edge, Dict[str, Any]]],
        Field(description='A container for Microsoft Edge resources. Read-only.'),
    ] = None
    microsoft365_apps: Annotated[
        Optional[Union[AdminMicrosoft365Apps, Dict[str, Any]]],
        Field(
            description='A container for the Microsoft 365 apps admin functionality.'
        ),
    ] = None
    people: Annotated[
        Optional[Union[PeopleAdminSettings, Dict[str, Any]]],
        Field(
            description='Represents a setting to control people-related admin settings in the tenant.'
        ),
    ] = None
    report_settings: Annotated[
        Optional[Union[AdminReportSettings, Dict[str, Any]]],
        Field(
            description='A container for administrative resources to manage reports.'
        ),
    ] = None
    service_announcement: Annotated[
        Optional[Union[ServiceAnnouncement, Dict[str, Any]]],
        Field(
            description='A container for service communications resources. Read-only.'
        ),
    ] = None
    sharepoint: Optional[Union[Sharepoint, Dict[str, Any]]] = None
    field_odata_type: str


class CloudCommunications(BaseModel):
    call_records: Optional[List[callRecords.CallRecord]] = None
    calls: Optional[List[Call]] = None
    online_meetings: Optional[List[OnlineMeeting]] = None
    presences: Optional[List[Presence]] = None
    field_odata_type: str


class ConditionalAccessRoot(Entity):
    authentication_context_class_references: Annotated[
        Optional[List[AuthenticationContextClassReference]],
        Field(
            description='Read-only. Nullable. Returns a collection of the specified authentication context class references.'
        ),
    ] = None
    authentication_strength: Optional[
        Union[AuthenticationStrengthRoot, Dict[str, Any]]
    ] = None
    named_locations: Annotated[
        Optional[List[NamedLocation]],
        Field(
            description='Read-only. Nullable. Returns a collection of the specified named locations.'
        ),
    ] = None
    policies: Annotated[
        Optional[List[ConditionalAccessPolicy]],
        Field(
            description='Read-only. Nullable. Returns a collection of the specified Conditional Access (CA) policies.'
        ),
    ] = None
    templates: Annotated[
        Optional[List[ConditionalAccessTemplate]],
        Field(
            description='Read-only. Nullable. Returns a collection of the specified Conditional Access templates.'
        ),
    ] = None
    field_odata_type: str


class GranularMailboxRestoreArtifact(MailboxRestoreArtifact):
    artifact_count: Annotated[
        Optional[float], Field(description='.', ge=-2147483648.0, le=2147483647.0)
    ] = None
    search_response_id: Annotated[Optional[str], Field(description='.')] = None
    field_odata_type: str


class IdentityContainer(Entity):
    api_connectors: Annotated[
        Optional[List[IdentityApiConnector]],
        Field(description='Represents entry point for API connectors.'),
    ] = None
    authentication_event_listeners: Annotated[
        Optional[List[AuthenticationEventListener]],
        Field(
            description='Represents listeners for custom authentication extension events in Azure AD for workforce and customers.'
        ),
    ] = None
    authentication_events_flows: Annotated[
        Optional[List[AuthenticationEventsFlow]],
        Field(
            description='Represents the entry point for self-service sign-up and sign-in user flows in both Microsoft Entra workforce and external tenants.'
        ),
    ] = None
    b2x_user_flows: Annotated[
        Optional[List[B2xIdentityUserFlow]],
        Field(
            description='Represents entry point for B2X/self-service sign-up identity userflows.'
        ),
    ] = None
    conditional_access: Annotated[
        Optional[Union[ConditionalAccessRoot, Dict[str, Any]]],
        Field(
            description='the entry point for the Conditional Access (CA) object model.'
        ),
    ] = None
    custom_authentication_extensions: Annotated[
        Optional[List[CustomAuthenticationExtension]],
        Field(
            description='Represents custom extensions to authentication flows in Azure AD for workforce and customers.'
        ),
    ] = None
    identity_providers: Optional[List[IdentityProviderBase]] = None
    user_flow_attributes: Annotated[
        Optional[List[IdentityUserFlowAttribute]],
        Field(description='Represents entry point for identity userflow attributes.'),
    ] = None
    field_odata_type: str


class Organization(DirectoryObject):
    assigned_plans: Annotated[
        Optional[List[AssignedPlan]],
        Field(
            description='The collection of service plans associated with the tenant. Not nullable.'
        ),
    ] = None
    business_phones: Annotated[
        Optional[List[str]],
        Field(
            description='Telephone number for the organization. Although this property is a string collection, only one number can be set.'
        ),
    ] = None
    city: Annotated[
        Optional[str],
        Field(description='City name of the address for the organization.'),
    ] = None
    country: Annotated[
        Optional[str],
        Field(
            description='Country or region name of the address for the organization.'
        ),
    ] = None
    country_letter_code: Annotated[
        Optional[str],
        Field(
            description='Country or region abbreviation for the organization in ISO 3166-2 format.'
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description="Timestamp of when the organization was created. The value can't be modified and is automatically populated when the organization is created. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.",
        ),
    ] = None
    default_usage_location: Annotated[
        Optional[str],
        Field(
            description='Two-letter ISO 3166 country code indicating the default service usage location of an organization.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The display name for the tenant.')
    ] = None
    marketing_notification_emails: Annotated[
        Optional[List[str]], Field(description='Not nullable.')
    ] = None
    mobile_device_management_authority: Optional[MdmAuthority] = None
    on_premises_last_sync_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The time and date at which the tenant was last synced with the on-premises directory. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.',
        ),
    ] = None
    on_premises_sync_enabled: Annotated[
        Optional[bool],
        Field(
            description="true if this object is synced from an on-premises directory; false if this object was originally synced from an on-premises directory but is no longer synced. Nullable. null if this object isn't synced from on-premises active directory (default)."
        ),
    ] = None
    partner_tenant_type: Annotated[
        Optional[Union[PartnerTenantType, Dict[str, Any]]],
        Field(
            description='The type of partnership this tenant has with Microsoft. The possible values are: microsoftSupport, syndicatePartner, breadthPartner, breadthPartnerDelegatedAdmin, resellerPartnerDelegatedAdmin, valueAddedResellerPartnerDelegatedAdmin, unknownFutureValue. Nullable. For more information about the possible types, see partnerTenantType values.'
        ),
    ] = None
    postal_code: Annotated[
        Optional[str],
        Field(description='Postal code of the address for the organization.'),
    ] = None
    preferred_language: Annotated[
        Optional[str],
        Field(
            description='The preferred language for the organization. Should follow ISO 639-1 Code; for example, en.'
        ),
    ] = None
    privacy_profile: Annotated[
        Optional[Union[PrivacyProfile, Dict[str, Any]]],
        Field(description='The privacy profile of an organization.'),
    ] = None
    provisioned_plans: Annotated[
        Optional[List[ProvisionedPlan]], Field(description='Not nullable.')
    ] = None
    security_compliance_notification_mails: Annotated[
        Optional[List[str]], Field(description='Not nullable.')
    ] = None
    security_compliance_notification_phones: Annotated[
        Optional[List[str]], Field(description='Not nullable.')
    ] = None
    state: Annotated[
        Optional[str],
        Field(description='State name of the address for the organization.'),
    ] = None
    street: Annotated[
        Optional[str], Field(description='Street name of the address for organization.')
    ] = None
    technical_notification_mails: Annotated[
        Optional[List[str]], Field(description='Not nullable.')
    ] = None
    tenant_type: Annotated[
        Optional[str],
        Field(
            description='Not nullable. Can be one of the following types:  AAD - An enterprise identity access management (IAM) service that serves business-to-employee and business-to-business (B2B) scenarios.  AAD B2C An identity access management (IAM) service that serves business-to-consumer (B2C) scenarios.   CIAM - A customer identity & access management (CIAM) solution that provides an integrated platform to serve consumers, partners, and citizen scenarios.'
        ),
    ] = None
    verified_domains: Annotated[
        Optional[List[VerifiedDomain]],
        Field(
            description='The collection of domains associated with this tenant. Not nullable.'
        ),
    ] = None
    branding: Annotated[
        Optional[Union[OrganizationalBranding, Dict[str, Any]]],
        Field(description='Branding for the organization. Nullable.'),
    ] = None
    certificate_based_auth_configuration: Annotated[
        Optional[List[CertificateBasedAuthConfiguration]],
        Field(
            description='Navigation property to manage certificate-based authentication configuration. Only a single instance of certificateBasedAuthConfiguration can be created in the collection.'
        ),
    ] = None
    extensions: Annotated[
        Optional[List[Extension]],
        Field(
            description='The collection of open extensions defined for the organization. Read-only. Nullable.'
        ),
    ] = None
    field_odata_type: str


class PolicyRoot(Entity):
    activity_based_timeout_policies: Annotated[
        Optional[List[ActivityBasedTimeoutPolicy]],
        Field(
            description='The policy that controls the idle time out for web sessions for applications.'
        ),
    ] = None
    admin_consent_request_policy: Annotated[
        Optional[Union[AdminConsentRequestPolicy, Dict[str, Any]]],
        Field(
            description='The policy by which consent requests are created and managed for the entire tenant.'
        ),
    ] = None
    app_management_policies: Annotated[
        Optional[List[AppManagementPolicy]],
        Field(
            description='The policies that enforce app management restrictions for specific applications and service principals, overriding the defaultAppManagementPolicy.'
        ),
    ] = None
    authentication_flows_policy: Annotated[
        Optional[Union[AuthenticationFlowsPolicy, Dict[str, Any]]],
        Field(
            description='The policy configuration of the self-service sign-up experience of external users.'
        ),
    ] = None
    authentication_methods_policy: Annotated[
        Optional[Union[AuthenticationMethodsPolicy, Dict[str, Any]]],
        Field(
            description='The authentication methods and the users that are allowed to use them to sign in and perform multifactor authentication (MFA) in Microsoft Entra ID.'
        ),
    ] = None
    authentication_strength_policies: Annotated[
        Optional[List[AuthenticationStrengthPolicy]],
        Field(
            description='The authentication method combinations that are to be used in scenarios defined by Microsoft Entra Conditional Access.'
        ),
    ] = None
    authorization_policy: Annotated[
        Optional[Union[AuthorizationPolicy, Dict[str, Any]]],
        Field(
            description='The policy that controls Microsoft Entra authorization settings.'
        ),
    ] = None
    claims_mapping_policies: Annotated[
        Optional[List[ClaimsMappingPolicy]],
        Field(
            description='The claim-mapping policies for WS-Fed, SAML, OAuth 2.0, and OpenID Connect protocols, for tokens issued to a specific application.'
        ),
    ] = None
    conditional_access_policies: Annotated[
        Optional[List[ConditionalAccessPolicy]],
        Field(description='The custom rules that define an access scenario.'),
    ] = None
    cross_tenant_access_policy: Annotated[
        Optional[Union[CrossTenantAccessPolicy, Dict[str, Any]]],
        Field(
            description='The custom rules that define an access scenario when interacting with external Microsoft Entra tenants.'
        ),
    ] = None
    default_app_management_policy: Annotated[
        Optional[Union[TenantAppManagementPolicy, Dict[str, Any]]],
        Field(
            description='The tenant-wide policy that enforces app management restrictions for all applications and service principals.'
        ),
    ] = None
    device_registration_policy: Optional[
        Union[DeviceRegistrationPolicy, Dict[str, Any]]
    ] = None
    feature_rollout_policies: Annotated[
        Optional[List[FeatureRolloutPolicy]],
        Field(
            description='The feature rollout policy associated with a directory object.'
        ),
    ] = None
    home_realm_discovery_policies: Annotated[
        Optional[List[HomeRealmDiscoveryPolicy]],
        Field(
            description='The policy to control Microsoft Entra authentication behavior for federated users.'
        ),
    ] = None
    identity_security_defaults_enforcement_policy: Annotated[
        Optional[Union[IdentitySecurityDefaultsEnforcementPolicy, Dict[str, Any]]],
        Field(
            description='The policy that represents the security defaults that protect against common attacks.'
        ),
    ] = None
    permission_grant_policies: Annotated[
        Optional[List[PermissionGrantPolicy]],
        Field(
            description='The policy that specifies the conditions under which consent can be granted.'
        ),
    ] = None
    role_management_policies: Annotated[
        Optional[List[UnifiedRoleManagementPolicy]],
        Field(
            description='Specifies the various policies associated with scopes and roles.'
        ),
    ] = None
    role_management_policy_assignments: Annotated[
        Optional[List[UnifiedRoleManagementPolicyAssignment]],
        Field(
            description='The assignment of a role management policy to a role definition object.'
        ),
    ] = None
    token_issuance_policies: Annotated[
        Optional[List[TokenIssuancePolicy]],
        Field(
            description='The policy that specifies the characteristics of SAML tokens issued by Microsoft Entra ID.'
        ),
    ] = None
    token_lifetime_policies: Annotated[
        Optional[List[TokenLifetimePolicy]],
        Field(
            description='The policy that controls the lifetime of a JWT access token, an ID token, or a SAML 1.1/2.0 token issued by Microsoft Entra ID.'
        ),
    ] = None
    field_odata_type: str


class RbacApplication(Entity):
    resource_namespaces: Optional[List[UnifiedRbacResourceNamespace]] = None
    role_assignments: Annotated[
        Optional[List[UnifiedRoleAssignment]],
        Field(description='Resource to grant access to users or groups.'),
    ] = None
    role_assignment_schedule_instances: Annotated[
        Optional[List[UnifiedRoleAssignmentScheduleInstance]],
        Field(description='Instances for active role assignments.'),
    ] = None
    role_assignment_schedule_requests: Annotated[
        Optional[List[UnifiedRoleAssignmentScheduleRequest]],
        Field(
            description='Requests for active role assignments to principals through PIM.'
        ),
    ] = None
    role_assignment_schedules: Annotated[
        Optional[List[UnifiedRoleAssignmentSchedule]],
        Field(description='Schedules for active role assignment operations.'),
    ] = None
    role_definitions: Annotated[
        Optional[List[UnifiedRoleDefinition]],
        Field(
            description='Resource representing the roles allowed by RBAC providers and the permissions assigned to the roles.'
        ),
    ] = None
    role_eligibility_schedule_instances: Annotated[
        Optional[List[UnifiedRoleEligibilityScheduleInstance]],
        Field(description='Instances for role eligibility requests.'),
    ] = None
    role_eligibility_schedule_requests: Annotated[
        Optional[List[UnifiedRoleEligibilityScheduleRequest]],
        Field(
            description='Requests for role eligibilities for principals through PIM.'
        ),
    ] = None
    role_eligibility_schedules: Annotated[
        Optional[List[UnifiedRoleEligibilitySchedule]],
        Field(description='Schedules for role eligibility operations.'),
    ] = None
    field_odata_type: str


class RoleManagement(BaseModel):
    directory: Optional[Union[RbacApplication, Dict[str, Any]]] = None
    entitlement_management: Annotated[
        Optional[Union[RbacApplication, Dict[str, Any]]],
        Field(
            description='Container for roles and assignments for entitlement management resources.'
        ),
    ] = None
    field_odata_type: str


class Simulation(Entity):
    attack_technique: Annotated[
        Optional[Union[SimulationAttackTechnique, Dict[str, Any]]],
        Field(
            description='The social engineering technique used in the attack simulation and training campaign. Supports $filter and $orderby. Possible values are: unknown, credentialHarvesting, attachmentMalware, driveByUrl, linkInAttachment, linkToMalwareFile, unknownFutureValue, oAuthConsentGrant. Use the Prefer: include-unknown-enum-members request header to get the following values from this evolvable enum: oAuthConsentGrant. For more information on the types of social engineering attack techniques, see simulations.'
        ),
    ] = None
    attack_type: Annotated[
        Optional[Union[SimulationAttackType, Dict[str, Any]]],
        Field(
            description='Attack type of the attack simulation and training campaign. Supports $filter and $orderby. Possible values are: unknown, social, cloud, endpoint, unknownFutureValue.'
        ),
    ] = None
    automation_id: Annotated[
        Optional[str],
        Field(description='Unique identifier for the attack simulation automation.'),
    ] = None
    completion_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time of completion of the attack simulation and training campaign. Supports $filter and $orderby.',
        ),
    ] = None
    created_by: Annotated[
        Optional[Union[EmailIdentity, Dict[str, Any]]],
        Field(
            description='Identity of the user who created the attack simulation and training campaign.'
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time of creation of the attack simulation and training campaign.',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='Description of the attack simulation and training campaign.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='Display name of the attack simulation and training campaign. Supports $filter and $orderby.'
        ),
    ] = None
    duration_in_days: Annotated[
        Optional[float],
        Field(
            description='Simulation duration in days.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    end_user_notification_setting: Annotated[
        Optional[Union[EndUserNotificationSetting, Dict[str, Any]]],
        Field(description='Details about the end user notification setting.'),
    ] = None
    excluded_account_target: Annotated[
        Optional[Union[AccountTargetContent, Dict[str, Any]]],
        Field(description='Users excluded from the simulation.'),
    ] = None
    included_account_target: Annotated[
        Optional[Union[AccountTargetContent, Dict[str, Any]]],
        Field(description='Users targeted in the simulation.'),
    ] = None
    is_automated: Annotated[
        Optional[bool],
        Field(
            description='Flag that represents if the attack simulation and training campaign was created from a simulation automation flow. Supports $filter and $orderby.'
        ),
    ] = None
    last_modified_by: Annotated[
        Optional[Union[EmailIdentity, Dict[str, Any]]],
        Field(
            description='Identity of the user who most recently modified the attack simulation and training campaign.'
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time of the most recent modification of the attack simulation and training campaign.',
        ),
    ] = None
    launch_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time of the launch/start of the attack simulation and training campaign. Supports $filter and $orderby.',
        ),
    ] = None
    o_auth_consent_app_detail: Annotated[
        Optional[Union[OAuthConsentAppDetail, Dict[str, Any]]],
        Field(description='OAuth app details for the OAuth technique.'),
    ] = None
    payload_delivery_platform: Annotated[
        Optional[Union[PayloadDeliveryPlatform, Dict[str, Any]]],
        Field(
            description='Method of delivery of the phishing payload used in the attack simulation and training campaign. Possible values are: unknown, sms, email, teams, unknownFutureValue.'
        ),
    ] = None
    report: Annotated[
        Optional[Union[SimulationReport, Dict[str, Any]]],
        Field(description='Report of the attack simulation and training campaign.'),
    ] = None
    status: Annotated[
        Optional[Union[SimulationStatus, Dict[str, Any]]],
        Field(
            description='Status of the attack simulation and training campaign. Supports $filter and $orderby. Possible values are: unknown, draft, running, scheduled, succeeded, failed, cancelled, excluded, unknownFutureValue.'
        ),
    ] = None
    training_setting: Annotated[
        Optional[Union[TrainingSetting, Dict[str, Any]]],
        Field(description='Details about the training settings for a simulation.'),
    ] = None
    landing_page: Annotated[
        Optional[Union[LandingPage, Dict[str, Any]]],
        Field(
            description='The landing page associated with a simulation during its creation.'
        ),
    ] = None
    login_page: Annotated[
        Optional[Union[LoginPage, Dict[str, Any]]],
        Field(
            description='The login page associated with a simulation during its creation.'
        ),
    ] = None
    payload: Annotated[
        Optional[Union[Payload, Dict[str, Any]]],
        Field(
            description='The payload associated with a simulation during its creation.'
        ),
    ] = None
    field_odata_type: str


class TeamsApp(Entity):
    display_name: Annotated[
        Optional[str],
        Field(
            description='The name of the catalog app provided by the app developer in the Microsoft Teams zip app package.'
        ),
    ] = None
    distribution_method: Annotated[
        Optional[Union[TeamsAppDistributionMethod, Dict[str, Any]]],
        Field(description='The method of distribution for the app. Read-only.'),
    ] = None
    external_id: Annotated[
        Optional[str],
        Field(
            description='The ID of the catalog provided by the app developer in the Microsoft Teams zip app package.'
        ),
    ] = None
    app_definitions: Annotated[
        Optional[List[TeamsAppDefinition]],
        Field(description='The details for each version of the app.'),
    ] = None
    field_odata_type: str


class TeamsAppInstallation(Entity):
    consented_permission_set: Annotated[
        Optional[Union[TeamsAppPermissionSet, Dict[str, Any]]],
        Field(
            description='The set of resource-specific permissions consented to while installing or upgrading the teamsApp.'
        ),
    ] = None
    teams_app: Annotated[
        Optional[Union[TeamsApp, Dict[str, Any]]],
        Field(description='The app that is installed.'),
    ] = None
    teams_app_definition: Annotated[
        Optional[Union[TeamsAppDefinition, Dict[str, Any]]],
        Field(description='The details of this version of the app.'),
    ] = None
    field_odata_type: str


class TeamsTab(Entity):
    configuration: Annotated[
        Optional[Union[TeamsTabConfiguration, Dict[str, Any]]],
        Field(
            description='Container for custom settings applied to a tab. The tab is considered configured only once this property is set.'
        ),
    ] = None
    display_name: Annotated[Optional[str], Field(description='Name of the tab.')] = None
    web_url: Annotated[
        Optional[str],
        Field(description='Deep link URL of the tab instance. Read only.'),
    ] = None
    teams_app: Annotated[
        Optional[Union[TeamsApp, Dict[str, Any]]],
        Field(
            description="The application that is linked to the tab. This can't be changed after tab creation."
        ),
    ] = None
    field_odata_type: str


class WorkbookChartAxes(Entity):
    category_axis: Annotated[
        Optional[Union[WorkbookChartAxis, Dict[str, Any]]],
        Field(description='Represents the category axis in a chart. Read-only.'),
    ] = None
    series_axis: Annotated[
        Optional[Union[WorkbookChartAxis, Dict[str, Any]]],
        Field(
            description='Represents the series axis of a 3-dimensional chart. Read-only.'
        ),
    ] = None
    value_axis: Annotated[
        Optional[Union[WorkbookChartAxis, Dict[str, Any]]],
        Field(description='Represents the value axis in an axis. Read-only.'),
    ] = None
    field_odata_type: str


class OrganizationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Organization]] = None


class TeamsAppCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[TeamsApp]] = None


class SimulationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Simulation]] = None


class TeamsTabCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[TeamsTab]] = None


class TeamsAppInstallationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[TeamsAppInstallation]] = None


class GranularMailboxRestoreArtifactCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[GranularMailboxRestoreArtifact]] = None


class AppCatalogs(Entity):
    teams_apps: Optional[List[TeamsApp]] = None
    field_odata_type: str


class AttackSimulationRoot(Entity):
    end_user_notifications: Annotated[
        Optional[List[EndUserNotification]],
        Field(
            description="Represents an end user's notification for an attack simulation training."
        ),
    ] = None
    landing_pages: Annotated[
        Optional[List[LandingPage]],
        Field(description='Represents an attack simulation training landing page.'),
    ] = None
    login_pages: Annotated[
        Optional[List[LoginPage]],
        Field(description='Represents an attack simulation training login page.'),
    ] = None
    operations: Annotated[
        Optional[List[AttackSimulationOperation]],
        Field(description='Represents an attack simulation training operation.'),
    ] = None
    payloads: Annotated[
        Optional[List[Payload]],
        Field(
            description='Represents an attack simulation training campaign payload in a tenant.'
        ),
    ] = None
    simulation_automations: Annotated[
        Optional[List[SimulationAutomation]],
        Field(
            description='Represents simulation automation created to run on a tenant.'
        ),
    ] = None
    simulations: Annotated[
        Optional[List[Simulation]],
        Field(
            description='Represents an attack simulation training campaign in a tenant.'
        ),
    ] = None
    trainings: Annotated[
        Optional[List[Training]],
        Field(description='Represents details about attack simulation trainings.'),
    ] = None
    field_odata_type: str


class Chat(Entity):
    chat_type: Optional[ChatType] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time at which the chat was created. Read-only.',
        ),
    ] = None
    is_hidden_for_all_members: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the chat is hidden for all its members. Read-only.'
        ),
    ] = None
    last_updated_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time at which the chat was renamed or the list of members was last changed. Read-only.',
        ),
    ] = None
    online_meeting_info: Annotated[
        Optional[Union[TeamworkOnlineMeetingInfo, Dict[str, Any]]],
        Field(
            description="Represents details about an online meeting. If the chat isn't associated with an online meeting, the property is empty. Read-only."
        ),
    ] = None
    tenant_id: Annotated[
        Optional[str],
        Field(
            description='The identifier of the tenant in which the chat was created. Read-only.'
        ),
    ] = None
    topic: Annotated[
        Optional[str],
        Field(
            description='(Optional) Subject or topic for the chat. Only available for group chats.'
        ),
    ] = None
    viewpoint: Annotated[
        Optional[Union[ChatViewpoint, Dict[str, Any]]],
        Field(
            description='Represents caller-specific information about the chat, such as the last message read date and time. This property is populated only when the request is made in a delegated context.'
        ),
    ] = None
    web_url: Annotated[
        Optional[str],
        Field(
            description='The URL for the chat in Microsoft Teams. The URL should be treated as an opaque blob, and not parsed. Read-only.'
        ),
    ] = None
    installed_apps: Annotated[
        Optional[List[TeamsAppInstallation]],
        Field(description='A collection of all the apps in the chat. Nullable.'),
    ] = None
    last_message_preview: Annotated[
        Optional[Union[ChatMessageInfo, Dict[str, Any]]],
        Field(
            description='Preview of the last message sent in the chat. Null if no messages were sent in the chat. Currently, only the list chats operation supports this property.'
        ),
    ] = None
    members: Annotated[
        Optional[List[ConversationMember]],
        Field(description='A collection of all the members in the chat. Nullable.'),
    ] = None
    messages: Annotated[
        Optional[List[ChatMessage]],
        Field(description='A collection of all the messages in the chat. Nullable.'),
    ] = None
    permission_grants: Annotated[
        Optional[List[ResourceSpecificPermissionGrant]],
        Field(description='A collection of permissions granted to apps for the chat.'),
    ] = None
    pinned_messages: Annotated[
        Optional[List[PinnedChatMessageInfo]],
        Field(
            description='A collection of all the pinned messages in the chat. Nullable.'
        ),
    ] = None
    tabs: Annotated[
        Optional[List[TeamsTab]],
        Field(description='A collection of all the tabs in the chat. Nullable.'),
    ] = None
    field_odata_type: str


class ExchangeRestoreSession(RestoreSessionBase):
    granular_mailbox_restore_artifacts: Optional[
        List[GranularMailboxRestoreArtifact]
    ] = None
    mailbox_restore_artifacts: Annotated[
        Optional[List[MailboxRestoreArtifact]],
        Field(
            description='A collection of restore points and destination details that can be used to restore Exchange mailboxes.'
        ),
    ] = None
    field_odata_type: str


class UserScopeTeamsAppInstallation(TeamsAppInstallation):
    chat: Annotated[
        Optional[Union[Chat, Dict[str, Any]]],
        Field(description='The chat between the user and Teams app.'),
    ] = None
    field_odata_type: str


class ChatCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Chat]] = None


class ExchangeRestoreSessionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ExchangeRestoreSession]] = None


class UserScopeTeamsAppInstallationCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[UserScopeTeamsAppInstallation]] = None


class BackupRestoreRoot(Entity):
    service_status: Annotated[
        Optional[Union[ServiceStatus, Dict[str, Any]]],
        Field(
            description='Represents the tenant-level status of the Backup Storage service.'
        ),
    ] = None
    drive_inclusion_rules: Annotated[
        Optional[List[DriveProtectionRule]],
        Field(description='The list of drive inclusion rules applied to the tenant.'),
    ] = None
    drive_protection_units: Annotated[
        Optional[List[DriveProtectionUnit]],
        Field(description='The list of drive protection units in the tenant.'),
    ] = None
    exchange_protection_policies: Annotated[
        Optional[List[ExchangeProtectionPolicy]],
        Field(description='The list of Exchange protection policies in the tenant.'),
    ] = None
    exchange_restore_sessions: Annotated[
        Optional[List[ExchangeRestoreSession]],
        Field(
            description='The list of Exchange restore sessions available in the tenant.'
        ),
    ] = None
    mailbox_inclusion_rules: Annotated[
        Optional[List[MailboxProtectionRule]],
        Field(description='The list of mailbox inclusion rules applied to the tenant.'),
    ] = None
    mailbox_protection_units: Annotated[
        Optional[List[MailboxProtectionUnit]],
        Field(description='The list of mailbox protection units in the tenant.'),
    ] = None
    one_drive_for_business_protection_policies: Annotated[
        Optional[List[OneDriveForBusinessProtectionPolicy]],
        Field(
            description='The list of OneDrive for Business protection policies in the tenant.'
        ),
    ] = None
    one_drive_for_business_restore_sessions: Annotated[
        Optional[List[OneDriveForBusinessRestoreSession]],
        Field(
            description='The list of OneDrive for Business restore sessions available in the tenant.'
        ),
    ] = None
    protection_policies: Annotated[
        Optional[List[ProtectionPolicyBase]],
        Field(description='List of protection policies in the tenant.'),
    ] = None
    protection_units: Annotated[
        Optional[List[ProtectionUnitBase]],
        Field(description='List of protection units in the tenant.'),
    ] = None
    restore_points: Annotated[
        Optional[List[RestorePoint]],
        Field(description='List of restore points in the tenant.'),
    ] = None
    restore_sessions: Annotated[
        Optional[List[RestoreSessionBase]],
        Field(description='List of restore sessions in the tenant.'),
    ] = None
    service_apps: Annotated[
        Optional[List[ServiceApp]],
        Field(description='List of Backup Storage apps in the tenant.'),
    ] = None
    share_point_protection_policies: Annotated[
        Optional[List[SharePointProtectionPolicy]],
        Field(description='The list of SharePoint protection policies in the tenant.'),
    ] = None
    share_point_restore_sessions: Annotated[
        Optional[List[SharePointRestoreSession]],
        Field(
            description='The list of SharePoint restore sessions available in the tenant.'
        ),
    ] = None
    site_inclusion_rules: Annotated[
        Optional[List[SiteProtectionRule]],
        Field(description='The list of site inclusion rules applied to the tenant.'),
    ] = None
    site_protection_units: Annotated[
        Optional[List[SiteProtectionUnit]],
        Field(description='The list of site protection units in the tenant.'),
    ] = None
    field_odata_type: str


class SolutionsRoot(BaseModel):
    backup_restore: Optional[Union[BackupRestoreRoot, Dict[str, Any]]] = None
    booking_businesses: Optional[List[BookingBusiness]] = None
    booking_currencies: Optional[List[BookingCurrency]] = None
    virtual_events: Optional[Union[VirtualEventsRoot, Dict[str, Any]]] = None
    field_odata_type: str


class AadUserConversationMember(ConversationMember):
    email: Annotated[
        Optional[str], Field(description='The email address of the user.')
    ] = None
    tenant_id: Annotated[
        Optional[str],
        Field(description='TenantId which the Microsoft Entra user belongs to.'),
    ] = None
    user_id: Annotated[Optional[str], Field(description='The guid of the user.')] = None
    user: Optional[Union[User, Dict[str, Any]]] = None
    field_odata_type: str


class AccessPackage(Entity):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.',
        ),
    ] = None
    description: Annotated[
        Optional[str], Field(description='The description of the access package.')
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='Required. The display name of the access package. Supports $filter (eq, contains).'
        ),
    ] = None
    is_hidden: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the access package is hidden from the requestor.'
        ),
    ] = None
    modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.',
        ),
    ] = None
    access_packages_incompatible_with: Annotated[
        Optional[List[AccessPackage]],
        Field(
            description='The access packages that are incompatible with this package. Read-only.'
        ),
    ] = None
    assignment_policies: Annotated[
        Optional[List[AccessPackageAssignmentPolicy]],
        Field(description='Read-only. Nullable. Supports $expand.'),
    ] = None
    catalog: Annotated[
        Optional[Union[AccessPackageCatalog, Dict[str, Any]]],
        Field(
            description='Required when creating the access package. Read-only. Nullable.'
        ),
    ] = None
    incompatible_access_packages: Annotated[
        Optional[List[AccessPackage]],
        Field(
            description='The access packages whose assigned users are ineligible to be assigned this access package.'
        ),
    ] = None
    incompatible_groups: Annotated[
        Optional[List[Group]],
        Field(
            description='The groups whose members are ineligible to be assigned this access package.'
        ),
    ] = None
    resource_role_scopes: Annotated[
        Optional[List[AccessPackageResourceRoleScope]],
        Field(description='The resource roles and scopes in this access package.'),
    ] = None
    field_odata_type: str


class AccessPackageAssignment(Entity):
    custom_extension_callout_instances: Annotated[
        Optional[List[CustomExtensionCalloutInstance]],
        Field(
            description='Information about all the custom extension calls that were made during the access package assignment workflow.'
        ),
    ] = None
    expired_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.',
        ),
    ] = None
    schedule: Annotated[
        Optional[Union[EntitlementManagementSchedule, Dict[str, Any]]],
        Field(description='When the access assignment is to be in place. Read-only.'),
    ] = None
    state: Annotated[
        Optional[Union[AccessPackageAssignmentState, Dict[str, Any]]],
        Field(
            description='The state of the access package assignment. The possible values are: delivering, partiallyDelivered, delivered, expired, deliveryFailed, unknownFutureValue. Read-only. Supports $filter (eq).'
        ),
    ] = None
    status: Annotated[
        Optional[str],
        Field(
            description='More information about the assignment lifecycle. Possible values include Delivering, Delivered, NearExpiry1DayNotificationTriggered, or ExpiredNotificationTriggered. Read-only.'
        ),
    ] = None
    access_package: Annotated[
        Optional[Union[AccessPackage, Dict[str, Any]]],
        Field(
            description='Read-only. Nullable. Supports $filter (eq) on the id property and $expand query parameters.'
        ),
    ] = None
    assignment_policy: Annotated[
        Optional[Union[AccessPackageAssignmentPolicy, Dict[str, Any]]],
        Field(
            description='Read-only. Supports $filter (eq) on the id property and $expand query parameters.'
        ),
    ] = None
    target: Annotated[
        Optional[Union[AccessPackageSubject, Dict[str, Any]]],
        Field(
            description='The subject of the access package assignment. Read-only. Nullable. Supports $expand. Supports $filter (eq) on objectId.'
        ),
    ] = None
    field_odata_type: str


class AccessPackageAssignmentPolicy(Entity):
    allowed_target_scope: Annotated[
        Optional[Union[AllowedTargetScope, Dict[str, Any]]],
        Field(
            description='Principals that can be assigned the access package through this policy. The possible values are: notSpecified, specificDirectoryUsers, specificConnectedOrganizationUsers, specificDirectoryServicePrincipals, allMemberUsers, allDirectoryUsers, allDirectoryServicePrincipals, allConfiguredConnectedOrganizationUsers, allExternalUsers, unknownFutureValue.'
        ),
    ] = None
    automatic_request_settings: Annotated[
        Optional[Union[AccessPackageAutomaticRequestSettings, Dict[str, Any]]],
        Field(
            description='This property is only present for an auto assignment policy; if absent, this is a request-based policy.'
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    description: Annotated[
        Optional[str], Field(description='The description of the policy.')
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The display name of the policy.')
    ] = None
    expiration: Annotated[
        Optional[Union[ExpirationPattern, Dict[str, Any]]],
        Field(
            description='The expiration date for assignments created in this policy.'
        ),
    ] = None
    modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    request_approval_settings: Annotated[
        Optional[Union[AccessPackageAssignmentApprovalSettings, Dict[str, Any]]],
        Field(
            description='Specifies the settings for approval of requests for an access package assignment through this policy. For example, if approval is required for new requests.'
        ),
    ] = None
    requestor_settings: Annotated[
        Optional[Union[AccessPackageAssignmentRequestorSettings, Dict[str, Any]]],
        Field(
            description='Provides additional settings to select who can create a request for an access package assignment through this policy, and what they can include in their request.'
        ),
    ] = None
    review_settings: Annotated[
        Optional[Union[AccessPackageAssignmentReviewSettings, Dict[str, Any]]],
        Field(
            description='Settings for access reviews of assignments through this policy.'
        ),
    ] = None
    specific_allowed_targets: Annotated[
        Optional[List[SubjectSet]],
        Field(
            description='The principals that can be assigned access from an access package through this policy.'
        ),
    ] = None
    access_package: Annotated[
        Optional[Union[AccessPackage, Dict[str, Any]]],
        Field(
            description='Access package containing this policy. Read-only.  Supports $expand.'
        ),
    ] = None
    catalog: Annotated[
        Optional[Union[AccessPackageCatalog, Dict[str, Any]]],
        Field(
            description='Catalog of the access package containing this policy. Read-only.'
        ),
    ] = None
    custom_extension_stage_settings: Annotated[
        Optional[List[CustomExtensionStageSetting]],
        Field(
            description='The collection of stages when to execute one or more custom access package workflow extensions. Supports $expand.'
        ),
    ] = None
    questions: Annotated[
        Optional[List[AccessPackageQuestion]],
        Field(description='Questions that are posed to the  requestor.'),
    ] = None
    field_odata_type: str


class AccessPackageAssignmentRequest(Entity):
    answers: Annotated[
        Optional[List[AccessPackageAnswer]],
        Field(
            description='Answers provided by the requestor to accessPackageQuestions asked of them at the time of request.'
        ),
    ] = None
    completed_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date of the end of processing, either successful or failure, of a request. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.',
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only. Supports $filter.',
        ),
    ] = None
    custom_extension_callout_instances: Annotated[
        Optional[List[CustomExtensionCalloutInstance]],
        Field(
            description='Information about all the custom extension calls that were made during the access package assignment workflow.'
        ),
    ] = None
    request_type: Annotated[
        Optional[Union[AccessPackageRequestType, Dict[str, Any]]],
        Field(
            description="The type of the request. The possible values are: notSpecified, userAdd, UserExtend, userUpdate, userRemove, adminAdd, adminUpdate, adminRemove, systemAdd, systemUpdate, systemRemove, onBehalfAdd (not supported), unknownFutureValue. Requests from the user have a requestType of userAdd, userUpdate, or userRemove. This property can't be changed once set."
        ),
    ] = None
    schedule: Annotated[
        Optional[Union[EntitlementManagementSchedule, Dict[str, Any]]],
        Field(
            description="The range of dates that access is to be assigned to the requestor. This property can't be changed once set, but a new schedule for an assignment can be included in another userUpdate or UserExtend or adminUpdate assignment request."
        ),
    ] = None
    state: Annotated[
        Optional[Union[AccessPackageRequestState, Dict[str, Any]]],
        Field(
            description='The state of the request. The possible values are: submitted, pendingApproval, delivering, delivered, deliveryFailed, denied, scheduled, canceled, partiallyDelivered, unknownFutureValue. Read-only. Supports $filter (eq).'
        ),
    ] = None
    status: Annotated[
        Optional[str],
        Field(
            description='More information on the request processing status. Read-only.'
        ),
    ] = None
    access_package: Annotated[
        Optional[Union[AccessPackage, Dict[str, Any]]],
        Field(
            description='The access package associated with the accessPackageAssignmentRequest. An access package defines the collections of resource roles and the policies for how one or more users can get access to those resources. Read-only. Nullable.  Supports $expand.'
        ),
    ] = None
    assignment: Annotated[
        Optional[Union[AccessPackageAssignment, Dict[str, Any]]],
        Field(
            description='For a requestType of userAdd or adminAdd, this is an access package assignment requested to be created. For a requestType of userRemove, adminRemove or systemRemove, this has the id property of an existing assignment to be removed.   Supports $expand.'
        ),
    ] = None
    requestor: Annotated[
        Optional[Union[AccessPackageSubject, Dict[str, Any]]],
        Field(
            description='The subject who requested or, if a direct assignment, was assigned. Read-only. Nullable. Supports $expand.'
        ),
    ] = None
    field_odata_type: str


class AccessPackageCatalog(Entity):
    catalog_type: Annotated[
        Optional[Union[AccessPackageCatalogType, Dict[str, Any]]],
        Field(
            description='Whether the catalog is created by a user or entitlement management. The possible values are: userManaged, serviceDefault, serviceManaged, unknownFutureValue.'
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(description='The description of the access package catalog.'),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(description='The display name of the access package catalog.'),
    ] = None
    is_externally_visible: Annotated[
        Optional[bool],
        Field(
            description='Whether the access packages in this catalog can be requested by users outside of the tenant.'
        ),
    ] = None
    modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.',
        ),
    ] = None
    state: Annotated[
        Optional[Union[AccessPackageCatalogState, Dict[str, Any]]],
        Field(
            description='Has the value published if the access packages are available for management. The possible values are: unpublished, published, unknownFutureValue.'
        ),
    ] = None
    access_packages: Annotated[
        Optional[List[AccessPackage]],
        Field(description='The access packages in this catalog. Read-only. Nullable.'),
    ] = None
    custom_workflow_extensions: Optional[List[CustomCalloutExtension]] = None
    resource_roles: Optional[List[AccessPackageResourceRole]] = None
    resources: Annotated[
        Optional[List[AccessPackageResource]],
        Field(description='Access package resources in this catalog.'),
    ] = None
    resource_scopes: Optional[List[AccessPackageResourceScope]] = None
    field_odata_type: str


class AccessPackageResource(Entity):
    attributes: Annotated[
        Optional[List[AccessPackageResourceAttribute]],
        Field(
            description='Contains information about the attributes to be collected from the requestor and sent to the resource application.'
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.',
        ),
    ] = None
    description: Annotated[
        Optional[str], Field(description='A description for the resource.')
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='The display name of the resource, such as the application name, group name or site name.'
        ),
    ] = None
    modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.',
        ),
    ] = None
    origin_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier of the resource in the origin system. For a Microsoft Entra group, this is the identifier of the group.'
        ),
    ] = None
    origin_system: Annotated[
        Optional[str],
        Field(
            description='The type of the resource in the origin system, such as SharePointOnline, AadApplication or AadGroup.'
        ),
    ] = None
    environment: Annotated[
        Optional[Union[AccessPackageResourceEnvironment, Dict[str, Any]]],
        Field(
            description="Contains the environment information for the resource. This can be set using either the @odata.bind annotation or the environment's originId.Supports $expand."
        ),
    ] = None
    roles: Annotated[
        Optional[List[AccessPackageResourceRole]],
        Field(description='Read-only. Nullable. Supports $expand.'),
    ] = None
    scopes: Annotated[
        Optional[List[AccessPackageResourceScope]],
        Field(description='Read-only. Nullable. Supports $expand.'),
    ] = None
    field_odata_type: str


class AccessPackageResourceEnvironment(Entity):
    connection_info: Annotated[
        Optional[Union[ConnectionInfo, Dict[str, Any]]],
        Field(
            description='Connection information of an environment used to connect to a resource.'
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time that this object was created. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    description: Annotated[
        Optional[str], Field(description='The description of this object.')
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The display name of this object.')
    ] = None
    is_default_environment: Annotated[
        Optional[bool],
        Field(
            description='Determines whether this is default environment or not. It is set to true for all static origin systems, such as Microsoft Entra groups and Microsoft Entra Applications.'
        ),
    ] = None
    modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time that this object was last modified. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    origin_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier of this environment in the origin system.'
        ),
    ] = None
    origin_system: Annotated[
        Optional[str],
        Field(
            description='The type of the resource in the origin system, that is, SharePointOnline. Requires $filter (eq).'
        ),
    ] = None
    resources: Annotated[
        Optional[List[AccessPackageResource]], Field(description='Read-only. Required.')
    ] = None
    field_odata_type: str


class AccessPackageResourceRequest(Entity):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.',
        ),
    ] = None
    request_type: Annotated[
        Optional[Union[AccessPackageRequestType, Dict[str, Any]]],
        Field(
            description='The type of the request. Use adminAdd to add a resource, if the caller is an administrator or resource owner, adminUpdate to update a resource, or adminRemove to remove a resource.'
        ),
    ] = None
    state: Annotated[
        Optional[Union[AccessPackageRequestState, Dict[str, Any]]],
        Field(
            description="The outcome of whether the service was able to add the resource to the catalog. The value is delivered if the resource was added or removed, and deliveryFailed if it couldn't be added or removed. Read-only."
        ),
    ] = None
    catalog: Optional[Union[AccessPackageCatalog, Dict[str, Any]]] = None
    resource: Optional[Union[AccessPackageResource, Dict[str, Any]]] = None
    field_odata_type: str


class AccessPackageResourceRole(Entity):
    description: Annotated[
        Optional[str], Field(description='A description for the resource role.')
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='The display name of the resource role such as the role defined by the application.'
        ),
    ] = None
    origin_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier of the resource role in the origin system. For a SharePoint Online site, the originId is the sequence number of the role in the site.'
        ),
    ] = None
    origin_system: Annotated[
        Optional[str],
        Field(
            description='The type of the resource in the origin system, such as SharePointOnline, AadApplication, or AadGroup.'
        ),
    ] = None
    resource: Optional[Union[AccessPackageResource, Dict[str, Any]]] = None
    field_odata_type: str


class AccessPackageResourceRoleScope(Entity):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z',
        ),
    ] = None
    role: Optional[Union[AccessPackageResourceRole, Dict[str, Any]]] = None
    scope: Optional[Union[AccessPackageResourceScope, Dict[str, Any]]] = None
    field_odata_type: str


class AccessPackageResourceScope(Entity):
    description: Annotated[
        Optional[str], Field(description='The description of the scope.')
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The display name of the scope.')
    ] = None
    is_root_scope: Annotated[
        Optional[bool],
        Field(
            description='True if the scopes are arranged in a hierarchy and this is the top or root scope of the resource.'
        ),
    ] = None
    origin_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier for the scope in the resource as defined in the origin system.'
        ),
    ] = None
    origin_system: Annotated[
        Optional[str], Field(description='The origin system for the scope.')
    ] = None
    resource: Optional[Union[AccessPackageResource, Dict[str, Any]]] = None
    field_odata_type: str


class ActivityHistoryItem(Entity):
    active_duration_seconds: Annotated[
        Optional[float],
        Field(
            description='Optional. The duration of active user engagement. if not supplied, this is calculated from the startedDateTime and lastActiveDateTime.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Set by the server. DateTime in UTC when the object was created on the server.',
        ),
    ] = None
    expiration_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Optional. UTC DateTime when the activityHistoryItem will undergo hard-delete. Can be set by the client.',
        ),
    ] = None
    last_active_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Optional. UTC DateTime when the activityHistoryItem (activity session) was last understood as active or finished - if null, activityHistoryItem status should be Ongoing.',
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Set by the server. DateTime in UTC when the object was modified on the server.',
        ),
    ] = None
    started_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Required. UTC DateTime when the activityHistoryItem (activity session) was started. Required for timeline history.',
        ),
    ] = None
    status: Annotated[
        Optional[Union[Status, Dict[str, Any]]],
        Field(
            description='Set by the server. A status code used to identify valid objects. Values: active, updated, deleted, ignored.'
        ),
    ] = None
    user_timezone: Annotated[
        Optional[str],
        Field(
            description="Optional. The timezone in which the user's device used to generate the activity was located at activity creation time. Values supplied as Olson IDs in order to support cross-platform representation."
        ),
    ] = None
    activity: Optional[UserActivity] = None
    field_odata_type: str


class Application(DirectoryObject):
    add_ins: Annotated[
        Optional[List[AddIn]],
        Field(
            description="Defines custom behavior that a consuming service can use to call an app in specific contexts. For example, applications that can render file streams can set the addIns property for its 'FileHandler' functionality. This lets services like Microsoft 365 call the application in the context of a document the user is working on."
        ),
    ] = None
    api: Annotated[
        Optional[Union[ApiApplication, Dict[str, Any]]],
        Field(
            description='Specifies settings for an application that implements a web API.'
        ),
    ] = None
    app_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier for the application that is assigned to an application by Microsoft Entra ID. Not nullable. Read-only. Alternate key. Supports $filter (eq).'
        ),
    ] = None
    application_template_id: Annotated[
        Optional[str],
        Field(
            description="Unique identifier of the applicationTemplate. Supports $filter (eq, not, ne). Read-only. null if the app wasn't created from an application template."
        ),
    ] = None
    app_roles: Annotated[
        Optional[List[AppRole]],
        Field(
            description='The collection of roles defined for the application. With app role assignments, these roles can be assigned to users, groups, or service principals associated with other applications. Not nullable.'
        ),
    ] = None
    certification: Annotated[
        Optional[Union[Certification, Dict[str, Any]]],
        Field(description='Specifies the certification status of the application.'),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time the application was registered. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.  Supports $filter (eq, ne, not, ge, le, in, and eq on null values) and $orderby.',
        ),
    ] = None
    default_redirect_uri: Optional[str] = None
    description: Annotated[
        Optional[str],
        Field(
            description='Free text field to provide a description of the application object to end users. The maximum allowed size is 1,024 characters. Supports $filter (eq, ne, not, ge, le, startsWith) and $search.'
        ),
    ] = None
    disabled_by_microsoft_status: Annotated[
        Optional[str],
        Field(
            description='Specifies whether Microsoft has disabled the registered application. Possible values are: null (default value), NotDisabled, and DisabledDueToViolationOfServicesAgreement (reasons include suspicious, abusive, or malicious activity, or a violation of the Microsoft Services Agreement).  Supports $filter (eq, ne, not).'
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='The display name for the application. Maximum length is 256 characters. Supports $filter (eq, ne, not, ge, le, in, startsWith, and eq on null values), $search, and $orderby.'
        ),
    ] = None
    group_membership_claims: Annotated[
        Optional[str],
        Field(
            description='Configures the groups claim issued in a user or OAuth 2.0 access token that the application expects. To set this attribute, use one of the following valid string values: None, SecurityGroup (for security groups and Microsoft Entra roles), All (this gets all of the security groups, distribution groups, and Microsoft Entra directory roles that the signed-in user is a member of).'
        ),
    ] = None
    identifier_uris: Annotated[
        Optional[List[str]],
        Field(
            description="Also known as App ID URI, this value is set when an application is used as a resource app. The identifierUris acts as the prefix for the scopes you reference in your API's code, and it must be globally unique. You can use the default value provided, which is in the form api://<appId>, or specify a more readable URI like https://contoso.com/api. For more information on valid identifierUris patterns and best practices, see Microsoft Entra application registration security best practices. Not nullable. Supports $filter (eq, ne, ge, le, startsWith)."
        ),
    ] = None
    info: Annotated[
        Optional[Union[InformationalUrl, Dict[str, Any]]],
        Field(
            description="Basic profile information of the application such as  app's marketing, support, terms of service and privacy statement URLs. The terms of service and privacy statement are surfaced to users through the user consent experience. For more info, see How to: Add Terms of service and privacy statement for registered Microsoft Entra apps. Supports $filter (eq, ne, not, ge, le, and eq on null values)."
        ),
    ] = None
    is_device_only_auth_supported: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether this application supports device authentication without a user. The default is false.'
        ),
    ] = None
    is_fallback_public_client: Annotated[
        Optional[bool],
        Field(
            description="Specifies the fallback application type as public client, such as an installed application running on a mobile device. The default value is false, which means the fallback application type is confidential client such as a web app. There are certain scenarios where Microsoft Entra ID can't determine the client application type. For example, the ROPC flow where it's configured without specifying a redirect URI. In those cases, Microsoft Entra ID interprets the application type based on the value of this property."
        ),
    ] = None
    key_credentials: Annotated[
        Optional[List[KeyCredential]],
        Field(
            description='The collection of key credentials associated with the application. Not nullable. Supports $filter (eq, not, ge, le).'
        ),
    ] = None
    logo: Annotated[
        Optional[str],
        Field(description='The main logo for the application. Not nullable.'),
    ] = None
    native_authentication_apis_enabled: Annotated[
        Optional[Union[NativeAuthenticationApisEnabled, Dict[str, Any]]],
        Field(
            description='Specifies whether the Native Authentication APIs are enabled for the application. The possible values are: none and all. Default is none. For more information, see Native Authentication.'
        ),
    ] = None
    notes: Annotated[
        Optional[str],
        Field(description='Notes relevant for the management of the application.'),
    ] = None
    oauth2_require_post_response: Optional[bool] = None
    optional_claims: Annotated[
        Optional[Union[OptionalClaims, Dict[str, Any]]],
        Field(
            description='Application developers can configure optional claims in their Microsoft Entra applications to specify the claims that are sent to their application by the Microsoft security token service. For more information, see How to: Provide optional claims to your app.'
        ),
    ] = None
    parental_control_settings: Annotated[
        Optional[Union[ParentalControlSettings, Dict[str, Any]]],
        Field(description='Specifies parental control settings for an application.'),
    ] = None
    password_credentials: Annotated[
        Optional[List[PasswordCredential]],
        Field(
            description='The collection of password credentials associated with the application. Not nullable.'
        ),
    ] = None
    public_client: Annotated[
        Optional[Union[PublicClientApplication, Dict[str, Any]]],
        Field(
            description='Specifies settings for installed clients such as desktop or mobile devices.'
        ),
    ] = None
    publisher_domain: Annotated[
        Optional[str],
        Field(
            description="The verified publisher domain for the application. Read-only. For more information, see How to: Configure an application's publisher domain. Supports $filter (eq, ne, ge, le, startsWith)."
        ),
    ] = None
    request_signature_verification: Annotated[
        Optional[Union[RequestSignatureVerification, Dict[str, Any]]],
        Field(
            description='Specifies whether this application requires Microsoft Entra ID to verify the signed authentication requests.'
        ),
    ] = None
    required_resource_access: Annotated[
        Optional[List[RequiredResourceAccess]],
        Field(
            description='Specifies the resources that the application needs to access. This property also specifies the set of delegated permissions and application roles that it needs for each of those resources. This configuration of access to the required resources drives the consent experience. No more than 50 resource services (APIs) can be configured. Beginning mid-October 2021, the total number of required permissions must not exceed 400. For more information, see Limits on requested permissions per app. Not nullable. Supports $filter (eq, not, ge, le).'
        ),
    ] = None
    saml_metadata_url: Annotated[
        Optional[str],
        Field(
            description='The URL where the service exposes SAML metadata for federation. This property is valid only for single-tenant applications. Nullable.'
        ),
    ] = None
    service_management_reference: Annotated[
        Optional[str],
        Field(
            description='References application or service contact information from a Service or Asset Management database. Nullable.'
        ),
    ] = None
    service_principal_lock_configuration: Annotated[
        Optional[Union[ServicePrincipalLockConfiguration, Dict[str, Any]]],
        Field(
            description='Specifies whether sensitive properties of a multitenant application should be locked for editing after the application is provisioned in a tenant. Nullable. null by default.'
        ),
    ] = None
    sign_in_audience: Annotated[
        Optional[str],
        Field(
            description='Specifies the Microsoft accounts that are supported for the current application. The possible values are: AzureADMyOrg (default), AzureADMultipleOrgs, AzureADandPersonalMicrosoftAccount, and PersonalMicrosoftAccount. See more in the table. The value of this object also limits the number of permissions an app can request. For more information, see Limits on requested permissions per app. The value for this property has implications on other app object properties. As a result, if you change this property, you might need to change other properties first. For more information, see Validation differences for signInAudience.Supports $filter (eq, ne, not).'
        ),
    ] = None
    spa: Annotated[
        Optional[Union[SpaApplication, Dict[str, Any]]],
        Field(
            description='Specifies settings for a single-page application, including sign out URLs and redirect URIs for authorization codes and access tokens.'
        ),
    ] = None
    tags: Annotated[
        Optional[List[str]],
        Field(
            description='Custom strings that can be used to categorize and identify the application. Not nullable. Strings added here will also appear in the tags property of any associated service principals.Supports $filter (eq, not, ge, le, startsWith) and $search.'
        ),
    ] = None
    token_encryption_key_id: Annotated[
        Optional[UUID],
        Field(
            description='Specifies the keyId of a public key from the keyCredentials collection. When configured, Microsoft Entra ID encrypts all the tokens it emits by using the key this property points to. The application code that receives the encrypted token must use the matching private key to decrypt the token before it can be used for the signed-in user.',
        ),
    ] = None
    unique_name: Annotated[
        Optional[str],
        Field(
            description='The unique identifier that can be assigned to an application and used as an alternate key. Immutable. Read-only.'
        ),
    ] = None
    verified_publisher: Annotated[
        Optional[Union[VerifiedPublisher, Dict[str, Any]]],
        Field(
            description='Specifies the verified publisher of the application. For more information about how publisher verification helps support application security, trustworthiness, and compliance, see Publisher verification.'
        ),
    ] = None
    web: Annotated[
        Optional[Union[WebApplication, Dict[str, Any]]],
        Field(description='Specifies settings for a web application.'),
    ] = None
    app_management_policies: Annotated[
        Optional[List[AppManagementPolicy]],
        Field(description='The appManagementPolicy applied to this application.'),
    ] = None
    created_on_behalf_of: Annotated[
        Optional[Union[DirectoryObject, Dict[str, Any]]],
        Field(description='Supports $filter (/$count eq 0, /$count ne 0). Read-only.'),
    ] = None
    extension_properties: Annotated[
        Optional[List[ExtensionProperty]],
        Field(
            description='Read-only. Nullable. Supports $expand and $filter (/$count eq 0, /$count ne 0).'
        ),
    ] = None
    federated_identity_credentials: Annotated[
        Optional[List[FederatedIdentityCredential]],
        Field(
            description='Federated identities for applications. Supports $expand and $filter (startsWith, /$count eq 0, /$count ne 0).'
        ),
    ] = None
    home_realm_discovery_policies: Optional[List[HomeRealmDiscoveryPolicy]] = None
    owners: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description='Directory objects that are owners of the application. Read-only. Nullable. Supports $expand, $filter (/$count eq 0, /$count ne 0, /$count eq 1, /$count ne 1), and $select nested in $expand.'
        ),
    ] = None
    synchronization: Annotated[
        Optional[Union[Synchronization, Dict[str, Any]]],
        Field(
            description='Represents the capability for Microsoft Entra identity synchronization through the Microsoft Graph API.'
        ),
    ] = None
    token_issuance_policies: Optional[List[TokenIssuancePolicy]] = None
    token_lifetime_policies: Optional[List[TokenLifetimePolicy]] = None
    field_odata_type: str


class BaseItem(Entity):
    created_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(
            description='Identity of the user, device, or application that created the item. Read-only.'
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time of item creation. Read-only.',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(description='Provides a user-visible description of the item. Optional.'),
    ] = None
    e_tag: Annotated[
        Optional[str], Field(description='ETag for the item. Read-only.')
    ] = None
    last_modified_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(
            description='Identity of the user, device, and application that last modified the item. Read-only.'
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time the item was last modified. Read-only.',
        ),
    ] = None
    name: Annotated[
        Optional[str], Field(description='The name of the item. Read-write.')
    ] = None
    parent_reference: Annotated[
        Optional[Union[ItemReference, Dict[str, Any]]],
        Field(description='Parent information, if the item has a parent. Read-write.'),
    ] = None
    web_url: Annotated[
        Optional[str],
        Field(
            description='URL that either displays the resource in the browser (for Office file formats), or is a direct link to the file (for other formats). Read-only.'
        ),
    ] = None
    created_by_user: Annotated[
        Optional[Union[User, Dict[str, Any]]],
        Field(description='Identity of the user who created the item. Read-only.'),
    ] = None
    last_modified_by_user: Annotated[
        Optional[Union[User, Dict[str, Any]]],
        Field(
            description='Identity of the user who last modified the item. Read-only.'
        ),
    ] = None
    field_odata_type: str


class Calendar(Entity):
    allowed_online_meeting_providers: Annotated[
        Optional[List[Union[OnlineMeetingProviderType, Dict[str, Any]]]],
        Field(
            description='Represent the online meeting service providers that can be used to create online meetings in this calendar. Possible values are: unknown, skypeForBusiness, skypeForConsumer, teamsForBusiness.'
        ),
    ] = None
    can_edit: Annotated[
        Optional[bool],
        Field(
            description='true if the user can write to the calendar, false otherwise. This property is true for the user who created the calendar. This property is also true for a user who has been shared a calendar and granted write access.'
        ),
    ] = None
    can_share: Annotated[
        Optional[bool],
        Field(
            description='true if the user has the permission to share the calendar, false otherwise. Only the user who created the calendar can share it.'
        ),
    ] = None
    can_view_private_items: Annotated[
        Optional[bool],
        Field(
            description='true if the user can read calendar items that have been marked private, false otherwise.'
        ),
    ] = None
    change_key: Annotated[
        Optional[str],
        Field(
            description='Identifies the version of the calendar object. Every time the calendar is changed, changeKey changes as well. This allows Exchange to apply changes to the correct version of the object. Read-only.'
        ),
    ] = None
    color: Annotated[
        Optional[Union[CalendarColor, Dict[str, Any]]],
        Field(
            description='Specifies the color theme to distinguish the calendar from other calendars in a UI. The property values are: auto, lightBlue, lightGreen, lightOrange, lightGray, lightYellow, lightTeal, lightPink, lightBrown, lightRed, maxColor.'
        ),
    ] = None
    default_online_meeting_provider: Annotated[
        Optional[Union[OnlineMeetingProviderType, Dict[str, Any]]],
        Field(
            description='The default online meeting provider for meetings sent from this calendar. Possible values are: unknown, skypeForBusiness, skypeForConsumer, teamsForBusiness.'
        ),
    ] = None
    hex_color: Annotated[
        Optional[str],
        Field(
            description='The calendar color, expressed in a hex color code of three hexadecimal values, each ranging from 00 to FF and representing the red, green, or blue components of the color in the RGB color space. If the user has never explicitly set a color for the calendar, this property is empty. Read-only.'
        ),
    ] = None
    is_default_calendar: Annotated[
        Optional[bool],
        Field(
            description='true if this is the default calendar where new events are created by default, false otherwise.'
        ),
    ] = None
    is_removable: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether this user calendar can be deleted from the user mailbox.'
        ),
    ] = None
    is_tallying_responses: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether this user calendar supports tracking of meeting responses. Only meeting invites sent from users' primary calendars support tracking of meeting responses."
        ),
    ] = None
    name: Annotated[Optional[str], Field(description='The calendar name.')] = None
    owner: Annotated[
        Optional[Union[EmailAddress, Dict[str, Any]]],
        Field(
            description='If set, this represents the user who created or added the calendar. For a calendar that the user created or added, the owner property is set to the user. For a calendar shared with the user, the owner property is set to the person who shared that calendar with the user.'
        ),
    ] = None
    calendar_permissions: Annotated[
        Optional[List[CalendarPermission]],
        Field(
            description='The permissions of the users with whom the calendar is shared.'
        ),
    ] = None
    calendar_view: Annotated[
        Optional[List[Event]],
        Field(
            description='The calendar view for the calendar. Navigation property. Read-only.'
        ),
    ] = None
    events: Annotated[
        Optional[List[Event]],
        Field(
            description='The events in the calendar. Navigation property. Read-only.'
        ),
    ] = None
    multi_value_extended_properties: Annotated[
        Optional[List[MultiValueLegacyExtendedProperty]],
        Field(
            description='The collection of multi-value extended properties defined for the calendar. Read-only. Nullable.'
        ),
    ] = None
    single_value_extended_properties: Annotated[
        Optional[List[SingleValueLegacyExtendedProperty]],
        Field(
            description='The collection of single-value extended properties defined for the calendar. Read-only. Nullable.'
        ),
    ] = None
    field_odata_type: str


class CalendarGroup(Entity):
    change_key: Annotated[
        Optional[str],
        Field(
            description='Identifies the version of the calendar group. Every time the calendar group is changed, ChangeKey changes as well. This allows Exchange to apply changes to the correct version of the object. Read-only.'
        ),
    ] = None
    class_id: Annotated[
        Optional[UUID],
        Field(
            description='The class identifier. Read-only.',
        ),
    ] = None
    name: Annotated[Optional[str], Field(description='The group name.')] = None
    calendars: Annotated[
        Optional[List[Calendar]],
        Field(
            description='The calendars in the calendar group. Navigation property. Read-only. Nullable.'
        ),
    ] = None
    field_odata_type: str


class Channel(Entity):
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Read only. Timestamp at which the channel was created.',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(description='Optional textual description for the channel.'),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='Channel name as it will appear to the user in Microsoft Teams. The maximum length is 50 characters.'
        ),
    ] = None
    email: Annotated[
        Optional[str],
        Field(
            description='The email address for sending messages to the channel. Read-only.'
        ),
    ] = None
    is_archived: Annotated[
        Optional[bool],
        Field(description='Indicates whether the channel is archived. Read-only.'),
    ] = None
    is_favorite_by_default: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the channel should be marked as recommended for all members of the team to show in their channel list. Note: All recommended channels automatically show in the channels list for education and frontline worker users. The property can only be set programmatically via the Create team method. The default value is false.'
        ),
    ] = None
    membership_type: Annotated[
        Optional[Union[ChannelMembershipType, Dict[str, Any]]],
        Field(
            description="The type of the channel. Can be set during creation and can't be changed. The possible values are: standard, private, unknownFutureValue, shared. The default value is standard. Use the Prefer: include-unknown-enum-members request header to get the following value in this evolvable enum: shared."
        ),
    ] = None
    summary: Annotated[
        Optional[Union[ChannelSummary, Dict[str, Any]]],
        Field(
            description='Contains summary information about the channel, including number of owners, members, guests, and an indicator for members from other tenants. The summary property will only be returned if it is specified in the $select clause of the Get channel method.'
        ),
    ] = None
    tenant_id: Annotated[
        Optional[str], Field(description='The ID of the Microsoft Entra tenant.')
    ] = None
    web_url: Annotated[
        Optional[str],
        Field(
            description='A hyperlink that will go to the channel in Microsoft Teams. This is the URL that you get when you right-click a channel in Microsoft Teams and select Get link to channel. This URL should be treated as an opaque blob, and not parsed. Read-only.'
        ),
    ] = None
    files_folder: Annotated[
        Optional[Union[DriveItem, Dict[str, Any]]],
        Field(
            description="Metadata for the location where the channel's files are stored."
        ),
    ] = None
    members: Annotated[
        Optional[List[ConversationMember]],
        Field(
            description='A collection of membership records associated with the channel.'
        ),
    ] = None
    messages: Annotated[
        Optional[List[ChatMessage]],
        Field(
            description='A collection of all the messages in the channel. A navigation property. Nullable.'
        ),
    ] = None
    shared_with_teams: Annotated[
        Optional[List[SharedWithChannelTeamInfo]],
        Field(description='A collection of teams with which a channel is shared.'),
    ] = None
    tabs: Annotated[
        Optional[List[TeamsTab]],
        Field(
            description='A collection of all the tabs in the channel. A navigation property.'
        ),
    ] = None
    field_odata_type: str


class CloudPcProvisioningPolicy(Entity):
    alternate_resource_url: Annotated[
        Optional[str],
        Field(
            description='The URL of the alternate resource that links to this provisioning policy. Read-only.'
        ),
    ] = None
    autopatch: Optional[Union[CloudPcProvisioningPolicyAutopatch, Dict[str, Any]]] = (
        None
    )
    cloud_pc_group_display_name: Annotated[
        Optional[str],
        Field(
            description='The display name of the Cloud PC group that the Cloud PCs reside in. Read-only.'
        ),
    ] = None
    cloud_pc_naming_template: Annotated[
        Optional[str],
        Field(
            description="The template used to name Cloud PCs provisioned using this policy. The template can contain custom text and replacement tokens, including %USERNAME:x% and %RAND:x%, which represent the user's name and a randomly generated number, respectively. For example, CPC-%USERNAME:4%-%RAND:5% means that the name of the Cloud PC starts with CPC-, followed by a four-character username, a - character, and then five random characters. The total length of the text generated by the template can't exceed 15 characters. Supports $filter, $select, and $orderby."
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='The provisioning policy description. Supports $filter, $select, and $orderBy.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(description='The display name for the provisioning policy.'),
    ] = None
    domain_join_configurations: Annotated[
        Optional[List[CloudPcDomainJoinConfiguration]],
        Field(
            description='Specifies a list ordered by priority on how Cloud PCs join Microsoft Entra ID (Azure AD). Supports $select.'
        ),
    ] = None
    enable_single_sign_on: Annotated[
        Optional[bool],
        Field(
            description="True if the provisioned Cloud PC can be accessed by single sign-on. False indicates that the provisioned Cloud PC doesn't support this feature. The default value is false. Windows 365 users can use single sign-on to authenticate to Microsoft Entra ID with passwordless options (for example, FIDO keys) to access their Cloud PC. Optional."
        ),
    ] = None
    grace_period_in_hours: Annotated[
        Optional[float],
        Field(
            description='The number of hours to wait before reprovisioning/deprovisioning happens. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    image_display_name: Annotated[
        Optional[str],
        Field(
            description='The display name of the operating system image that is used for provisioning. For example, Windows 11 Preview + Microsoft 365 Apps 23H2 23H2. Supports $filter, $select, and $orderBy.'
        ),
    ] = None
    image_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier that represents an operating system image that is used for provisioning new Cloud PCs. The format for a gallery type image is: {publisherNameofferNameskuName}. Supported values for each of the parameters are:publisher: Microsoftwindowsdesktop offer: windows-ent-cpc sku: 21h1-ent-cpc-m365, 21h1-ent-cpc-os, 20h2-ent-cpc-m365, 20h2-ent-cpc-os, 20h1-ent-cpc-m365, 20h1-ent-cpc-os, 19h2-ent-cpc-m365, and 19h2-ent-cpc-os Supports $filter, $select, and $orderBy.'
        ),
    ] = None
    image_type: Optional[CloudPcProvisioningPolicyImageType] = None
    local_admin_enabled: Annotated[
        Optional[bool],
        Field(
            description="When true, the local admin is enabled for Cloud PCs; false indicates that the local admin isn't enabled for Cloud PCs. The default value is false. Supports $filter, $select, and $orderBy."
        ),
    ] = None
    microsoft_managed_desktop: Annotated[
        Optional[Union[MicrosoftManagedDesktop, Dict[str, Any]]],
        Field(
            description='The specific settings to microsoftManagedDesktop that enables Microsoft Managed Desktop customers to get device managed experience for Cloud PC. To enable microsoftManagedDesktop to provide more value, an admin needs to specify certain settings in it. Supports $filter, $select, and $orderBy.'
        ),
    ] = None
    provisioning_type: Annotated[
        Optional[Union[CloudPcProvisioningType, Dict[str, Any]]],
        Field(
            description="Specifies the type of license used when provisioning Cloud PCs using this policy. By default, the license type is dedicated if the provisioningType isn't specified when you create the cloudPcProvisioningPolicy. You can't change this property after the cloudPcProvisioningPolicy was created. Possible values are: dedicated, shared, unknownFutureValue."
        ),
    ] = None
    windows_setting: Annotated[
        Optional[Union[CloudPcWindowsSetting, Dict[str, Any]]],
        Field(
            description='Indicates a specific Windows setting to configure during the creation of Cloud PCs for this provisioning policy. Supports $select.'
        ),
    ] = None
    assignments: Annotated[
        Optional[List[CloudPcProvisioningPolicyAssignment]],
        Field(
            description='A defined collection of provisioning policy assignments. Represents the set of Microsoft 365 groups and security groups in Microsoft Entra ID that have provisioning policy assigned. Returned only on $expand. For an example about how to get the assignments relationship, see Get cloudPcProvisioningPolicy.'
        ),
    ] = None
    field_odata_type: str


class CloudPcProvisioningPolicyAssignment(Entity):
    target: Annotated[
        Optional[Union[CloudPcManagementAssignmentTarget, Dict[str, Any]]],
        Field(
            description='The assignment target for the provisioning policy. Currently, the only target supported for this policy is a user group. For details, see cloudPcManagementGroupAssignmentTarget.'
        ),
    ] = None
    assigned_users: Annotated[
        Optional[List[User]],
        Field(
            description='The assignment targeted users for the provisioning policy. This list of users is computed based on assignments, licenses, group memberships, and policies. Read-only. Supports$expand.'
        ),
    ] = None
    field_odata_type: str


class ColumnDefinition(Entity):
    boolean: Annotated[
        Optional[Union[BooleanColumn, Dict[str, Any]]],
        Field(description='This column stores Boolean values.'),
    ] = None
    calculated: Annotated[
        Optional[Union[CalculatedColumn, Dict[str, Any]]],
        Field(description="This column's data is calculated based on other columns."),
    ] = None
    choice: Annotated[
        Optional[Union[ChoiceColumn, Dict[str, Any]]],
        Field(description='This column stores data from a list of choices.'),
    ] = None
    column_group: Annotated[
        Optional[str],
        Field(
            description='For site columns, the name of the group this column belongs to. Helps organize related columns.'
        ),
    ] = None
    content_approval_status: Annotated[
        Optional[Union[ContentApprovalStatusColumn, Dict[str, Any]]],
        Field(description='This column stores content approval status.'),
    ] = None
    currency: Annotated[
        Optional[Union[CurrencyColumn, Dict[str, Any]]],
        Field(description='This column stores currency values.'),
    ] = None
    date_time: Annotated[
        Optional[Union[DateTimeColumn, Dict[str, Any]]],
        Field(description='This column stores DateTime values.'),
    ] = None
    default_value: Annotated[
        Optional[Union[DefaultColumnValue, Dict[str, Any]]],
        Field(description='The default value for this column.'),
    ] = None
    description: Annotated[
        Optional[str], Field(description='The user-facing description of the column.')
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The user-facing name of the column.')
    ] = None
    enforce_unique_values: Annotated[
        Optional[bool],
        Field(
            description='If true, no two list items may have the same value for this column.'
        ),
    ] = None
    geolocation: Annotated[
        Optional[Union[GeolocationColumn, Dict[str, Any]]],
        Field(description='This column stores a geolocation.'),
    ] = None
    hidden: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether the column is displayed in the user interface.'
        ),
    ] = None
    hyperlink_or_picture: Annotated[
        Optional[Union[HyperlinkOrPictureColumn, Dict[str, Any]]],
        Field(description='This column stores hyperlink or picture values.'),
    ] = None
    indexed: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether the column values can be used for sorting and searching.'
        ),
    ] = None
    is_deletable: Annotated[
        Optional[bool],
        Field(description='Indicates whether this column can be deleted.'),
    ] = None
    is_reorderable: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether values in the column can be reordered. Read-only.'
        ),
    ] = None
    is_sealed: Annotated[
        Optional[bool],
        Field(description='Specifies whether the column can be changed.'),
    ] = None
    lookup: Annotated[
        Optional[Union[LookupColumn, Dict[str, Any]]],
        Field(
            description="This column's data is looked up from another source in the site."
        ),
    ] = None
    name: Annotated[
        Optional[str],
        Field(
            description='The API-facing name of the column as it appears in the fields on a listItem. For the user-facing name, see displayName.'
        ),
    ] = None
    number: Annotated[
        Optional[Union[NumberColumn, Dict[str, Any]]],
        Field(description='This column stores number values.'),
    ] = None
    person_or_group: Annotated[
        Optional[Union[PersonOrGroupColumn, Dict[str, Any]]],
        Field(description='This column stores Person or Group values.'),
    ] = None
    propagate_changes: Annotated[
        Optional[bool],
        Field(
            description="If 'true', changes to this column will be propagated to lists that implement the column."
        ),
    ] = None
    read_only: Annotated[
        Optional[bool],
        Field(description='Specifies whether the column values can be modified.'),
    ] = None
    required: Annotated[
        Optional[bool],
        Field(description="Specifies whether the column value isn't optional."),
    ] = None
    source_content_type: Annotated[
        Optional[Union[ContentTypeInfo, Dict[str, Any]]],
        Field(
            description='ContentType from which this column is inherited from. Present only in contentTypes columns response. Read-only.'
        ),
    ] = None
    term: Annotated[
        Optional[Union[TermColumn, Dict[str, Any]]],
        Field(description='This column stores taxonomy terms.'),
    ] = None
    text: Annotated[
        Optional[Union[TextColumn, Dict[str, Any]]],
        Field(description='This column stores text values.'),
    ] = None
    thumbnail: Annotated[
        Optional[Union[ThumbnailColumn, Dict[str, Any]]],
        Field(description='This column stores thumbnail values.'),
    ] = None
    type: Annotated[
        Optional[Union[ColumnTypes, Dict[str, Any]]],
        Field(description='For site columns, the type of column. Read-only.'),
    ] = None
    validation: Annotated[
        Optional[Union[ColumnValidation, Dict[str, Any]]],
        Field(
            description='This column stores validation formula and message for the column.'
        ),
    ] = None
    source_column: Annotated[
        Optional[Union[ColumnDefinition, Dict[str, Any]]],
        Field(description='The source column for the content type column.'),
    ] = None
    field_odata_type: str


class Community(Entity):
    description: Annotated[
        Optional[str],
        Field(
            description='The description of the community. The maximum length is 1,024 characters.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='The name of the community. The maximum length is 255 characters.'
        ),
    ] = None
    group_id: Annotated[
        Optional[str],
        Field(
            description='The ID of the Microsoft 365 group that manages the membership of this community.'
        ),
    ] = None
    privacy: Optional[CommunityPrivacy] = None
    group: Annotated[
        Optional[Union[Group, Dict[str, Any]]],
        Field(
            description='The Microsoft 365 group that manages the membership of this community.'
        ),
    ] = None
    owners: Annotated[
        Optional[List[User]],
        Field(
            description="The admins of the community. Limited to 100 users. If this property isn't specified when you create the community, the calling user is automatically assigned as the community owner."
        ),
    ] = None
    field_odata_type: str


class ContentType(Entity):
    associated_hubs_urls: Annotated[
        Optional[List[str]],
        Field(
            description='List of canonical URLs for hub sites with which this content type is associated to. This will contain all hub sites where this content type is queued to be enforced or is already enforced. Enforcing a content type means that the content type is applied to the lists in the enforced sites.'
        ),
    ] = None
    description: Annotated[
        Optional[str], Field(description='The descriptive text for the item.')
    ] = None
    document_set: Annotated[
        Optional[Union[DocumentSet, Dict[str, Any]]],
        Field(description='Document Set metadata.'),
    ] = None
    document_template: Annotated[
        Optional[Union[DocumentSetContent, Dict[str, Any]]],
        Field(
            description='Document template metadata. To make sure that documents have consistent content across a site and its subsites, you can associate a Word, Excel, or PowerPoint template with a site content type.'
        ),
    ] = None
    group: Annotated[
        Optional[str],
        Field(
            description='The name of the group this content type belongs to. Helps organize related content types.'
        ),
    ] = None
    hidden: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether the content type is hidden in the list's 'New' menu."
        ),
    ] = None
    inherited_from: Annotated[
        Optional[Union[ItemReference, Dict[str, Any]]],
        Field(
            description='If this content type is inherited from another scope (like a site), provides a reference to the item where the content type is defined.'
        ),
    ] = None
    is_built_in: Annotated[
        Optional[bool],
        Field(description='Specifies if a content type is a built-in content type.'),
    ] = None
    name: Annotated[
        Optional[str], Field(description='The name of the content type.')
    ] = None
    order: Annotated[
        Optional[Union[ContentTypeOrder, Dict[str, Any]]],
        Field(
            description='Specifies the order in which the content type appears in the selection UI.'
        ),
    ] = None
    parent_id: Annotated[
        Optional[str], Field(description='The unique identifier of the content type.')
    ] = None
    propagate_changes: Annotated[
        Optional[bool],
        Field(
            description='If true, any changes made to the content type are pushed to inherited content types and lists that implement the content type.'
        ),
    ] = None
    read_only: Annotated[
        Optional[bool],
        Field(
            description="If true, the content type can't be modified unless this value is first set to false."
        ),
    ] = None
    sealed: Annotated[
        Optional[bool],
        Field(
            description="If true, the content type can't be modified by users or through push-down operations. Only site collection administrators can seal or unseal content types."
        ),
    ] = None
    base: Annotated[
        Optional[Union[ContentType, Dict[str, Any]]],
        Field(
            description='Parent contentType from which this content type is derived.'
        ),
    ] = None
    base_types: Annotated[
        Optional[List[ContentType]],
        Field(
            description='The collection of content types that are ancestors of this content type.'
        ),
    ] = None
    column_links: Annotated[
        Optional[List[ColumnLink]],
        Field(
            description='The collection of columns that are required by this content type.'
        ),
    ] = None
    column_positions: Annotated[
        Optional[List[ColumnDefinition]],
        Field(description='Column order information in a content type.'),
    ] = None
    columns: Annotated[
        Optional[List[ColumnDefinition]],
        Field(
            description='The collection of column definitions for this content type.'
        ),
    ] = None
    field_odata_type: str


class DeletedItemContainer(Entity):
    workflows: Annotated[
        Optional[List[identityGovernance.Workflow]],
        Field(
            description='Deleted workflows that end up in the deletedItemsContainer.'
        ),
    ] = None
    field_odata_type: str


class DeletedTeam(Entity):
    channels: Annotated[
        Optional[List[Channel]],
        Field(
            description='The channels that are either shared with this deleted team or created in this deleted team.'
        ),
    ] = None
    field_odata_type: str


class DetectedApp(Entity):
    device_count: Annotated[
        Optional[float],
        Field(
            description='The number of devices that have installed this application',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(description='Name of the discovered application. Read-only'),
    ] = None
    platform: Optional[DetectedAppPlatformType] = None
    publisher: Annotated[
        Optional[str],
        Field(
            description="Indicates the publisher of the discovered application. For example: 'Microsoft'.  The default value is an empty string."
        ),
    ] = None
    size_in_byte: Annotated[
        Optional[float],
        Field(description='Discovered application size in bytes. Read-only'),
    ] = None
    version: Annotated[
        Optional[str],
        Field(description='Version of the discovered application. Read-only'),
    ] = None
    managed_devices: Annotated[
        Optional[List[ManagedDevice]],
        Field(description='The devices that have the discovered application installed'),
    ] = None
    field_odata_type: str


class DeviceManagement(Entity):
    device_protection_overview: Annotated[
        Optional[Union[DeviceProtectionOverview, Dict[str, Any]]],
        Field(description='Device protection overview.'),
    ] = None
    intune_account_id: Annotated[
        Optional[UUID],
        Field(
            description='Intune Account Id for given tenant',
        ),
    ] = None
    intune_brand: Annotated[
        Optional[Union[IntuneBrand, Dict[str, Any]]],
        Field(
            description='intuneBrand contains data which is used in customizing the appearance of the Company Portal applications as well as the end user web portal.'
        ),
    ] = None
    settings: Annotated[
        Optional[Union[DeviceManagementSettings, Dict[str, Any]]],
        Field(description='Account level settings.'),
    ] = None
    subscription_state: Optional[DeviceManagementSubscriptionState] = None
    user_experience_analytics_settings: Annotated[
        Optional[Union[UserExperienceAnalyticsSettings, Dict[str, Any]]],
        Field(description='User experience analytics device settings'),
    ] = None
    windows_malware_overview: Annotated[
        Optional[Union[WindowsMalwareOverview, Dict[str, Any]]],
        Field(description='Malware overview for windows devices.'),
    ] = None
    apple_push_notification_certificate: Annotated[
        Optional[Union[ApplePushNotificationCertificate, Dict[str, Any]]],
        Field(description='Apple push notification certificate.'),
    ] = None
    audit_events: Annotated[
        Optional[List[AuditEvent]], Field(description='The Audit Events')
    ] = None
    compliance_management_partners: Annotated[
        Optional[List[ComplianceManagementPartner]],
        Field(
            description='The list of Compliance Management Partners configured by the tenant.'
        ),
    ] = None
    conditional_access_settings: Annotated[
        Optional[Union[OnPremisesConditionalAccessSettings, Dict[str, Any]]],
        Field(
            description='The Exchange on premises conditional access settings. On premises conditional access will require devices to be both enrolled and compliant for mail access'
        ),
    ] = None
    detected_apps: Annotated[
        Optional[List[DetectedApp]],
        Field(description='The list of detected apps associated with a device.'),
    ] = None
    device_categories: Annotated[
        Optional[List[DeviceCategory]],
        Field(description='The list of device categories with the tenant.'),
    ] = None
    device_compliance_policies: Annotated[
        Optional[List[DeviceCompliancePolicy]],
        Field(description='The device compliance policies.'),
    ] = None
    device_compliance_policy_device_state_summary: Annotated[
        Optional[Union[DeviceCompliancePolicyDeviceStateSummary, Dict[str, Any]]],
        Field(description='The device compliance state summary for this account.'),
    ] = None
    device_compliance_policy_setting_state_summaries: Annotated[
        Optional[List[DeviceCompliancePolicySettingStateSummary]],
        Field(
            description='The summary states of compliance policy settings for this account.'
        ),
    ] = None
    device_configuration_device_state_summaries: Annotated[
        Optional[Union[DeviceConfigurationDeviceStateSummary, Dict[str, Any]]],
        Field(
            description='The device configuration device state summary for this account.'
        ),
    ] = None
    device_configurations: Annotated[
        Optional[List[DeviceConfiguration]],
        Field(description='The device configurations.'),
    ] = None
    device_enrollment_configurations: Annotated[
        Optional[List[DeviceEnrollmentConfiguration]],
        Field(description='The list of device enrollment configurations'),
    ] = None
    device_management_partners: Annotated[
        Optional[List[DeviceManagementPartner]],
        Field(
            description='The list of Device Management Partners configured by the tenant.'
        ),
    ] = None
    exchange_connectors: Annotated[
        Optional[List[DeviceManagementExchangeConnector]],
        Field(description='The list of Exchange Connectors configured by the tenant.'),
    ] = None
    imported_windows_autopilot_device_identities: Annotated[
        Optional[List[ImportedWindowsAutopilotDeviceIdentity]],
        Field(description='Collection of imported Windows autopilot devices.'),
    ] = None
    ios_update_statuses: Annotated[
        Optional[List[IosUpdateDeviceStatus]],
        Field(
            description='The IOS software update installation statuses for this account.'
        ),
    ] = None
    managed_device_overview: Annotated[
        Optional[Union[ManagedDeviceOverview, Dict[str, Any]]],
        Field(description='Device overview'),
    ] = None
    managed_devices: Annotated[
        Optional[List[ManagedDevice]], Field(description='The list of managed devices.')
    ] = None
    mobile_app_troubleshooting_events: Annotated[
        Optional[List[MobileAppTroubleshootingEvent]],
        Field(description='The collection property of MobileAppTroubleshootingEvent.'),
    ] = None
    mobile_threat_defense_connectors: Annotated[
        Optional[List[MobileThreatDefenseConnector]],
        Field(
            description='The list of Mobile threat Defense connectors configured by the tenant.'
        ),
    ] = None
    notification_message_templates: Annotated[
        Optional[List[NotificationMessageTemplate]],
        Field(description='The Notification Message Templates.'),
    ] = None
    remote_assistance_partners: Annotated[
        Optional[List[RemoteAssistancePartner]],
        Field(description='The remote assist partners.'),
    ] = None
    reports: Annotated[
        Optional[Union[DeviceManagementReports, Dict[str, Any]]],
        Field(description='Reports singleton'),
    ] = None
    resource_operations: Annotated[
        Optional[List[ResourceOperation]], Field(description='The Resource Operations.')
    ] = None
    role_assignments: Annotated[
        Optional[List[DeviceAndAppManagementRoleAssignment]],
        Field(description='The Role Assignments.'),
    ] = None
    role_definitions: Annotated[
        Optional[List[RoleDefinition]], Field(description='The Role Definitions.')
    ] = None
    software_update_status_summary: Annotated[
        Optional[Union[SoftwareUpdateStatusSummary, Dict[str, Any]]],
        Field(description='The software update status summary.'),
    ] = None
    telecom_expense_management_partners: Annotated[
        Optional[List[TelecomExpenseManagementPartner]],
        Field(description='The telecom expense management partners.'),
    ] = None
    terms_and_conditions: Annotated[
        Optional[List[TermsAndConditions]],
        Field(
            description='The terms and conditions associated with device management of the company.'
        ),
    ] = None
    troubleshooting_events: Annotated[
        Optional[List[DeviceManagementTroubleshootingEvent]],
        Field(description='The list of troubleshooting events for the tenant.'),
    ] = None
    user_experience_analytics_app_health_application_performance: Annotated[
        Optional[List[UserExperienceAnalyticsAppHealthApplicationPerformance]],
        Field(
            description='User experience analytics appHealth Application Performance'
        ),
    ] = None
    user_experience_analytics_app_health_application_performance_by_app_version_details: Annotated[
        Optional[
            List[UserExperienceAnalyticsAppHealthAppPerformanceByAppVersionDetails]
        ],
        Field(
            description='User experience analytics appHealth Application Performance by App Version details'
        ),
    ] = None
    user_experience_analytics_app_health_application_performance_by_app_version_device_id: Annotated[
        Optional[
            List[UserExperienceAnalyticsAppHealthAppPerformanceByAppVersionDeviceId]
        ],
        Field(
            description='User experience analytics appHealth Application Performance by App Version Device Id'
        ),
    ] = None
    user_experience_analytics_app_health_application_performance_by_os_version: Annotated[
        Optional[List[UserExperienceAnalyticsAppHealthAppPerformanceByOSVersion]],
        Field(
            description='User experience analytics appHealth Application Performance by OS Version'
        ),
    ] = None
    user_experience_analytics_app_health_device_model_performance: Annotated[
        Optional[List[UserExperienceAnalyticsAppHealthDeviceModelPerformance]],
        Field(description='User experience analytics appHealth Model Performance'),
    ] = None
    user_experience_analytics_app_health_device_performance: Annotated[
        Optional[List[UserExperienceAnalyticsAppHealthDevicePerformance]],
        Field(description='User experience analytics appHealth Device Performance'),
    ] = None
    user_experience_analytics_app_health_device_performance_details: Annotated[
        Optional[List[UserExperienceAnalyticsAppHealthDevicePerformanceDetails]],
        Field(description='User experience analytics device performance details'),
    ] = None
    user_experience_analytics_app_health_os_version_performance: Annotated[
        Optional[List[UserExperienceAnalyticsAppHealthOSVersionPerformance]],
        Field(description='User experience analytics appHealth OS version Performance'),
    ] = None
    user_experience_analytics_app_health_overview: Annotated[
        Optional[Union[UserExperienceAnalyticsCategory, Dict[str, Any]]],
        Field(description='User experience analytics appHealth overview'),
    ] = None
    user_experience_analytics_baselines: Annotated[
        Optional[List[UserExperienceAnalyticsBaseline]],
        Field(description='User experience analytics baselines'),
    ] = None
    user_experience_analytics_categories: Annotated[
        Optional[List[UserExperienceAnalyticsCategory]],
        Field(description='User experience analytics categories'),
    ] = None
    user_experience_analytics_device_performance: Annotated[
        Optional[List[UserExperienceAnalyticsDevicePerformance]],
        Field(description='User experience analytics device performance'),
    ] = None
    user_experience_analytics_device_scores: Annotated[
        Optional[List[UserExperienceAnalyticsDeviceScores]],
        Field(description='User experience analytics device scores'),
    ] = None
    user_experience_analytics_device_startup_history: Annotated[
        Optional[List[UserExperienceAnalyticsDeviceStartupHistory]],
        Field(description='User experience analytics device Startup History'),
    ] = None
    user_experience_analytics_device_startup_processes: Annotated[
        Optional[List[UserExperienceAnalyticsDeviceStartupProcess]],
        Field(description='User experience analytics device Startup Processes'),
    ] = None
    user_experience_analytics_device_startup_process_performance: Annotated[
        Optional[List[UserExperienceAnalyticsDeviceStartupProcessPerformance]],
        Field(
            description='User experience analytics device Startup Process Performance'
        ),
    ] = None
    user_experience_analytics_metric_history: Annotated[
        Optional[List[UserExperienceAnalyticsMetricHistory]],
        Field(description='User experience analytics metric history'),
    ] = None
    user_experience_analytics_model_scores: Annotated[
        Optional[List[UserExperienceAnalyticsModelScores]],
        Field(description='User experience analytics model scores'),
    ] = None
    user_experience_analytics_overview: Annotated[
        Optional[Union[UserExperienceAnalyticsOverview, Dict[str, Any]]],
        Field(description='User experience analytics overview'),
    ] = None
    user_experience_analytics_score_history: Annotated[
        Optional[List[UserExperienceAnalyticsScoreHistory]],
        Field(description='User experience analytics device Startup Score History'),
    ] = None
    user_experience_analytics_work_from_anywhere_hardware_readiness_metric: Annotated[
        Optional[
            Union[
                UserExperienceAnalyticsWorkFromAnywhereHardwareReadinessMetric,
                Dict[str, Any],
            ]
        ],
        Field(
            description='User experience analytics work from anywhere hardware readiness metrics.'
        ),
    ] = None
    user_experience_analytics_work_from_anywhere_metrics: Annotated[
        Optional[List[UserExperienceAnalyticsWorkFromAnywhereMetric]],
        Field(description='User experience analytics work from anywhere metrics.'),
    ] = None
    user_experience_analytics_work_from_anywhere_model_performance: Annotated[
        Optional[List[UserExperienceAnalyticsWorkFromAnywhereModelPerformance]],
        Field(
            description='The user experience analytics work from anywhere model performance'
        ),
    ] = None
    virtual_endpoint: Annotated[
        Optional[Union[VirtualEndpoint, Dict[str, Any]]],
        Field(description='Virtual endpoint'),
    ] = None
    windows_autopilot_device_identities: Annotated[
        Optional[List[WindowsAutopilotDeviceIdentity]],
        Field(
            description='The Windows autopilot device identities contained collection.'
        ),
    ] = None
    windows_information_protection_app_learning_summaries: Annotated[
        Optional[List[WindowsInformationProtectionAppLearningSummary]],
        Field(description='The windows information protection app learning summaries.'),
    ] = None
    windows_information_protection_network_learning_summaries: Annotated[
        Optional[List[WindowsInformationProtectionNetworkLearningSummary]],
        Field(
            description='The windows information protection network learning summaries.'
        ),
    ] = None
    windows_malware_information: Annotated[
        Optional[List[WindowsMalwareInformation]],
        Field(description='The list of affected malware in the tenant.'),
    ] = None
    field_odata_type: str


class EducationClass(Entity):
    class_code: Annotated[
        Optional[str],
        Field(description='Class code used by the school to identify the class.'),
    ] = None
    course: Optional[Union[EducationCourse, Dict[str, Any]]] = None
    created_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Entity who created the class'),
    ] = None
    description: Annotated[
        Optional[str], Field(description='Description of the class.')
    ] = None
    display_name: Annotated[Optional[str], Field(description='Name of the class.')] = (
        None
    )
    external_id: Annotated[
        Optional[str], Field(description='ID of the class from the syncing system.')
    ] = None
    external_name: Annotated[
        Optional[str], Field(description='Name of the class in the syncing system.')
    ] = None
    external_source: Annotated[
        Optional[Union[EducationExternalSource, Dict[str, Any]]],
        Field(
            description='How this class was created. Possible values are: sis, manual.'
        ),
    ] = None
    external_source_detail: Annotated[
        Optional[str],
        Field(
            description='The name of the external source this resource was generated from.'
        ),
    ] = None
    grade: Annotated[Optional[str], Field(description='Grade level of the class.')] = (
        None
    )
    mail_nickname: Annotated[
        Optional[str],
        Field(
            description='Mail name for sending email to all members, if this is enabled.'
        ),
    ] = None
    term: Annotated[
        Optional[Union[EducationTerm, Dict[str, Any]]],
        Field(description='Term for this class.'),
    ] = None
    assignment_categories: Annotated[
        Optional[List[EducationCategory]],
        Field(description='All categories associated with this class. Nullable.'),
    ] = None
    assignment_defaults: Annotated[
        Optional[Union[EducationAssignmentDefaults, Dict[str, Any]]],
        Field(
            description='Specifies class-level defaults respected by new assignments created in the class.'
        ),
    ] = None
    assignments: Annotated[
        Optional[List[EducationAssignment]],
        Field(description='All assignments associated with this class. Nullable.'),
    ] = None
    assignment_settings: Annotated[
        Optional[Union[EducationAssignmentSettings, Dict[str, Any]]],
        Field(description='Specifies class-level assignments settings.'),
    ] = None
    group: Annotated[
        Optional[Union[Group, Dict[str, Any]]],
        Field(description='The underlying Microsoft 365 group object.'),
    ] = None
    members: Annotated[
        Optional[List[EducationUser]],
        Field(description='All users in the class. Nullable.'),
    ] = None
    modules: Annotated[
        Optional[List[EducationModule]],
        Field(description='All modules in the class. Nullable.'),
    ] = None
    schools: Annotated[
        Optional[List[EducationSchool]],
        Field(description='All schools that this class is associated with. Nullable.'),
    ] = None
    teachers: Annotated[
        Optional[List[EducationUser]],
        Field(description='All teachers in the class. Nullable.'),
    ] = None
    field_odata_type: str


class EducationRoot(BaseModel):
    classes: Optional[List[EducationClass]] = None
    me: Optional[Union[EducationUser, Dict[str, Any]]] = None
    schools: Optional[List[EducationSchool]] = None
    users: Optional[List[EducationUser]] = None
    field_odata_type: str


class EducationSchool(EducationOrganization):
    address: Annotated[
        Optional[Union[PhysicalAddress, Dict[str, Any]]],
        Field(description='Address of the school.'),
    ] = None
    created_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Entity who created the school.'),
    ] = None
    external_id: Annotated[
        Optional[str], Field(description='ID of school in syncing system.')
    ] = None
    external_principal_id: Annotated[
        Optional[str], Field(description='ID of principal in syncing system.')
    ] = None
    fax: Optional[str] = None
    highest_grade: Annotated[
        Optional[str], Field(description='Highest grade taught.')
    ] = None
    lowest_grade: Annotated[
        Optional[str], Field(description='Lowest grade taught.')
    ] = None
    phone: Annotated[Optional[str], Field(description='Phone number of school.')] = None
    principal_email: Annotated[
        Optional[str], Field(description='Email address of the principal.')
    ] = None
    principal_name: Annotated[
        Optional[str], Field(description='Name of the principal.')
    ] = None
    school_number: Annotated[Optional[str], Field(description='School Number.')] = None
    administrative_unit: Annotated[
        Optional[Union[AdministrativeUnit, Dict[str, Any]]],
        Field(description='The underlying administrativeUnit for this school.'),
    ] = None
    classes: Annotated[
        Optional[List[EducationClass]],
        Field(description='Classes taught at the school. Nullable.'),
    ] = None
    users: Annotated[
        Optional[List[EducationUser]],
        Field(description='Users in the school. Nullable.'),
    ] = None
    field_odata_type: str


class EducationUser(Entity):
    account_enabled: Annotated[
        Optional[bool],
        Field(
            description='True if the account is enabled; otherwise, false. This property is required when a user is created. Supports $filter.'
        ),
    ] = None
    assigned_licenses: Annotated[
        Optional[List[AssignedLicense]],
        Field(description='The licenses that are assigned to the user. Not nullable.'),
    ] = None
    assigned_plans: Annotated[
        Optional[List[AssignedPlan]],
        Field(
            description='The plans that are assigned to the user. Read-only. Not nullable.'
        ),
    ] = None
    business_phones: Annotated[
        Optional[List[str]],
        Field(
            description='The telephone numbers for the user. Note: Although this is a string collection, only one number can be set for this property.'
        ),
    ] = None
    created_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='The entity who created the user.'),
    ] = None
    department: Annotated[
        Optional[str],
        Field(
            description='The name for the department in which the user works. Supports $filter.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description="The name displayed in the address book for the user. This is usually the combination of the user's first name, middle initial, and last name. This property is required when a user is created and it cannot be cleared during updates. Supports $filter and $orderby."
        ),
    ] = None
    external_source: Annotated[
        Optional[Union[EducationExternalSource, Dict[str, Any]]],
        Field(
            description='Where this user was created from. Possible values are: sis, manual.'
        ),
    ] = None
    external_source_detail: Annotated[
        Optional[str],
        Field(
            description='The name of the external source this resource was generated from.'
        ),
    ] = None
    given_name: Annotated[
        Optional[str],
        Field(description='The given name (first name) of the user. Supports $filter.'),
    ] = None
    mail: Annotated[
        Optional[str],
        Field(
            description='The SMTP address for the user, for example, jeff@contoso.com. Read-Only. Supports $filter.'
        ),
    ] = None
    mailing_address: Annotated[
        Optional[Union[PhysicalAddress, Dict[str, Any]]],
        Field(description='The mail address of the user.'),
    ] = None
    mail_nickname: Annotated[
        Optional[str],
        Field(
            description='The mail alias for the user. This property must be specified when a user is created. Supports $filter.'
        ),
    ] = None
    middle_name: Annotated[
        Optional[str], Field(description='The middle name of the user.')
    ] = None
    mobile_phone: Annotated[
        Optional[str],
        Field(description='The primary cellular telephone number for the user.'),
    ] = None
    office_location: Annotated[
        Optional[str], Field(description='The office location for the user.')
    ] = None
    on_premises_info: Annotated[
        Optional[Union[EducationOnPremisesInfo, Dict[str, Any]]],
        Field(
            description='Additional information used to associate the Microsoft Entra user with its Active Directory counterpart.'
        ),
    ] = None
    password_policies: Annotated[
        Optional[str],
        Field(
            description='Specifies password policies for the user. This value is an enumeration with one possible value being DisableStrongPassword, which allows weaker passwords than the default policy to be specified. DisablePasswordExpiration can also be specified. The two can be specified together; for example: DisablePasswordExpiration, DisableStrongPassword.'
        ),
    ] = None
    password_profile: Annotated[
        Optional[Union[PasswordProfile, Dict[str, Any]]],
        Field(
            description="Specifies the password profile for the user. The profile contains the user's password. This property is required when a user is created. The password in the profile must satisfy minimum requirements as specified by the passwordPolicies property. By default, a strong password is required."
        ),
    ] = None
    preferred_language: Annotated[
        Optional[str],
        Field(
            description='The preferred language for the user that should follow the ISO 639-1 code, for example, en-US.'
        ),
    ] = None
    primary_role: Optional[EducationUserRole] = None
    provisioned_plans: Annotated[
        Optional[List[ProvisionedPlan]],
        Field(
            description='The plans that are provisioned for the user. Read-only. Not nullable.'
        ),
    ] = None
    refresh_tokens_valid_from_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Any refresh tokens or sessions tokens (session cookies) issued before this time are invalid, and applications get an error when using an invalid refresh or sessions token to acquire a delegated access token (to access APIs such as Microsoft Graph).  If this happens, the application needs to acquire a new refresh token by requesting the authorized endpoint. Returned only on $select. Read-only.',
        ),
    ] = None
    related_contacts: Annotated[
        Optional[List[RelatedContact]],
        Field(description='Related records associated with the user. Read-only.'),
    ] = None
    residence_address: Annotated[
        Optional[Union[PhysicalAddress, Dict[str, Any]]],
        Field(description='The address where the user lives.'),
    ] = None
    show_in_address_list: Annotated[
        Optional[bool],
        Field(
            description='True if the Outlook Global Address List should contain this user; otherwise, false. If not set, this will be treated as true. For users invited through the invitation manager, this property will be set to false.'
        ),
    ] = None
    student: Annotated[
        Optional[Union[EducationStudent, Dict[str, Any]]],
        Field(
            description='If the primary role is student, this block will contain student specific data.'
        ),
    ] = None
    surname: Annotated[
        Optional[str],
        Field(
            description="The user's surname (family name or last name). Supports $filter."
        ),
    ] = None
    teacher: Annotated[
        Optional[Union[EducationTeacher, Dict[str, Any]]],
        Field(
            description='If the primary role is teacher, this block will contain teacher specific data.'
        ),
    ] = None
    usage_location: Annotated[
        Optional[str],
        Field(
            description='A two-letter country code (ISO standard 3166). Required for users who will be assigned licenses due to a legal requirement to check for availability of services in countries or regions. Examples include: US, JP, and GB. Not nullable. Supports $filter.'
        ),
    ] = None
    user_principal_name: Annotated[
        Optional[str],
        Field(
            description="The user principal name (UPN) of the user. The UPN is an internet-style login name for the user based on the internet standard RFC 822. By convention, this should map to the user's email name. The general format is alias@domain, where domain must be present in the tenant's collection of verified domains. This property is required when a user is created. The verified domains for the tenant can be accessed from the verifiedDomains property of the organization. Supports $filter and $orderby."
        ),
    ] = None
    user_type: Annotated[
        Optional[str],
        Field(
            description='A string value that can be used to classify user types in your directory, such as Member and Guest. Supports $filter.'
        ),
    ] = None
    assignments: Annotated[
        Optional[List[EducationAssignment]],
        Field(description='Assignments belonging to the user.'),
    ] = None
    classes: Annotated[
        Optional[List[EducationClass]],
        Field(description='Classes to which the user belongs. Nullable.'),
    ] = None
    rubrics: Annotated[
        Optional[List[EducationRubric]],
        Field(description='When set, the grading rubric attached to the assignment.'),
    ] = None
    schools: Annotated[
        Optional[List[EducationSchool]],
        Field(description='Schools to which the user belongs. Nullable.'),
    ] = None
    taught_classes: Annotated[
        Optional[List[EducationClass]],
        Field(description='Classes for which the user is a teacher.'),
    ] = None
    user: Annotated[
        Optional[Union[User, Dict[str, Any]]],
        Field(description='The directory user that corresponds to this user.'),
    ] = None
    field_odata_type: str


class EmployeeExperience(BaseModel):
    communities: Annotated[
        Optional[List[Community]],
        Field(description='A collection of communities in Viva Engage.'),
    ] = None
    engagement_async_operations: Annotated[
        Optional[List[EngagementAsyncOperation]],
        Field(
            description='A collection of long-running, asynchronous operations related to Viva Engage.'
        ),
    ] = None
    learning_course_activities: Optional[List[LearningCourseActivity]] = None
    learning_providers: Annotated[
        Optional[List[LearningProvider]],
        Field(description='A collection of learning providers.'),
    ] = None
    field_odata_type: str


class EntitlementManagement(Entity):
    access_package_assignment_approvals: Annotated[
        Optional[List[Approval]],
        Field(
            description='Approval stages for decisions associated with access package assignment requests.'
        ),
    ] = None
    access_packages: Annotated[
        Optional[List[AccessPackage]],
        Field(
            description='Access packages define the collection of resource roles and the policies for which subjects can request or be assigned access to those resources.'
        ),
    ] = None
    assignment_policies: Annotated[
        Optional[List[AccessPackageAssignmentPolicy]],
        Field(
            description='Access package assignment policies govern which subjects can request or be assigned an access package via an access package assignment.'
        ),
    ] = None
    assignment_requests: Annotated[
        Optional[List[AccessPackageAssignmentRequest]],
        Field(
            description='Access package assignment requests created by or on behalf of a subject.'
        ),
    ] = None
    assignments: Annotated[
        Optional[List[AccessPackageAssignment]],
        Field(
            description='The assignment of an access package to a subject for a period of time.'
        ),
    ] = None
    catalogs: Annotated[
        Optional[List[AccessPackageCatalog]],
        Field(description='A container for access packages.'),
    ] = None
    connected_organizations: Annotated[
        Optional[List[ConnectedOrganization]],
        Field(
            description='References to a directory or domain of another organization whose users can request access.'
        ),
    ] = None
    resource_environments: Annotated[
        Optional[List[AccessPackageResourceEnvironment]],
        Field(
            description='A reference to the geolocation environments in which a resource is located.'
        ),
    ] = None
    resource_requests: Annotated[
        Optional[List[AccessPackageResourceRequest]],
        Field(
            description='Represents a request to add or remove a resource to or from a catalog respectively.'
        ),
    ] = None
    resource_role_scopes: Optional[List[AccessPackageResourceRoleScope]] = None
    resources: Annotated[
        Optional[List[AccessPackageResource]],
        Field(description='The resources associated with the catalogs.'),
    ] = None
    settings: Annotated[
        Optional[Union[EntitlementManagementSettings, Dict[str, Any]]],
        Field(
            description='The settings that control the behavior of Microsoft Entra entitlement management.'
        ),
    ] = None
    field_odata_type: str


class Event(OutlookItem):
    allow_new_time_proposals: Annotated[
        Optional[bool],
        Field(
            description='true if the meeting organizer allows invitees to propose a new time when responding; otherwise, false. Optional. Default is true.'
        ),
    ] = None
    attendees: Annotated[
        Optional[List[Attendee]],
        Field(description='The collection of attendees for the event.'),
    ] = None
    body: Annotated[
        Optional[Union[ItemBody, Dict[str, Any]]],
        Field(
            description='The body of the message associated with the event. It can be in HTML or text format.'
        ),
    ] = None
    body_preview: Annotated[
        Optional[str],
        Field(
            description='The preview of the message associated with the event. It is in text format.'
        ),
    ] = None
    end: Annotated[
        Optional[Union[DateTimeTimeZone, Dict[str, Any]]],
        Field(
            description='The date, time, and time zone that the event ends. By default, the end time is in UTC.'
        ),
    ] = None
    has_attachments: Annotated[
        Optional[bool], Field(description='Set to true if the event has attachments.')
    ] = None
    hide_attendees: Annotated[
        Optional[bool],
        Field(
            description='When set to true, each attendee only sees themselves in the meeting request and meeting Tracking list. Default is false.'
        ),
    ] = None
    i_cal_u_id: Annotated[
        Optional[str],
        Field(
            description='A unique identifier for an event across calendars. This ID is different for each occurrence in a recurring series. Read-only.'
        ),
    ] = None
    importance: Annotated[
        Optional[Union[Importance, Dict[str, Any]]],
        Field(
            description='The importance of the event. The possible values are: low, normal, high.'
        ),
    ] = None
    is_all_day: Annotated[
        Optional[bool],
        Field(
            description="Set to true if the event lasts all day. If true, regardless of whether it's a single-day or multi-day event, start and end time must be set to midnight and be in the same time zone."
        ),
    ] = None
    is_cancelled: Annotated[
        Optional[bool], Field(description='Set to true if the event has been canceled.')
    ] = None
    is_draft: Annotated[
        Optional[bool],
        Field(
            description='Set to true if the user has updated the meeting in Outlook but has not sent the updates to attendees. Set to false if all changes have been sent, or if the event is an appointment without any attendees.'
        ),
    ] = None
    is_online_meeting: Annotated[
        Optional[bool],
        Field(
            description='True if this event has online meeting information (that is, onlineMeeting points to an onlineMeetingInfo resource), false otherwise. Default is false (onlineMeeting is null). Optional.  After you set isOnlineMeeting to true, Microsoft Graph initializes onlineMeeting. Subsequently Outlook ignores any further changes to isOnlineMeeting, and the meeting remains available online.'
        ),
    ] = None
    is_organizer: Annotated[
        Optional[bool],
        Field(
            description='Set to true if the calendar owner (specified by the owner property of the calendar) is the organizer of the event (specified by the organizer property of the event). This also applies if a delegate organized the event on behalf of the owner.'
        ),
    ] = None
    is_reminder_on: Annotated[
        Optional[bool],
        Field(
            description='Set to true if an alert is set to remind the user of the event.'
        ),
    ] = None
    location: Annotated[
        Optional[Union[Location, Dict[str, Any]]],
        Field(description='The location of the event.'),
    ] = None
    locations: Annotated[
        Optional[List[Location]],
        Field(
            description='The locations where the event is held or attended from. The location and locations properties always correspond with each other. If you update the location property, any prior locations in the locations collection would be removed and replaced by the new location value.'
        ),
    ] = None
    online_meeting: Annotated[
        Optional[Union[OnlineMeetingInfo, Dict[str, Any]]],
        Field(
            description='Details for an attendee to join the meeting online. Default is null. Read-only. After you set the isOnlineMeeting and onlineMeetingProvider properties to enable a meeting online, Microsoft Graph initializes onlineMeeting. When set, the meeting remains available online, and you cannot change the isOnlineMeeting, onlineMeetingProvider, and onlneMeeting properties again.'
        ),
    ] = None
    online_meeting_provider: Annotated[
        Optional[Union[OnlineMeetingProviderType, Dict[str, Any]]],
        Field(
            description='Represents the online meeting service provider. By default, onlineMeetingProvider is unknown. The possible values are unknown, teamsForBusiness, skypeForBusiness, and skypeForConsumer. Optional.  After you set onlineMeetingProvider, Microsoft Graph initializes onlineMeeting. Subsequently you cannot change onlineMeetingProvider again, and the meeting remains available online.'
        ),
    ] = None
    online_meeting_url: Annotated[
        Optional[str],
        Field(
            description='A URL for an online meeting. The property is set only when an organizer specifies in Outlook that an event is an online meeting such as Skype. Read-only.To access the URL to join an online meeting, use joinUrl which is exposed via the onlineMeeting property of the event. The onlineMeetingUrl property will be deprecated in the future.'
        ),
    ] = None
    organizer: Annotated[
        Optional[Union[Recipient, Dict[str, Any]]],
        Field(description='The organizer of the event.'),
    ] = None
    original_end_time_zone: Annotated[
        Optional[str],
        Field(
            description='The end time zone that was set when the event was created. A value of tzone://Microsoft/Custom indicates that a legacy custom time zone was set in desktop Outlook.'
        ),
    ] = None
    original_start: Annotated[
        Optional[datetime],
        Field(
            description='Represents the start time of an event when it is initially created as an occurrence or exception in a recurring series. This property is not returned for events that are single instances. Its date and time information is expressed in ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z',
        ),
    ] = None
    original_start_time_zone: Annotated[
        Optional[str],
        Field(
            description='The start time zone that was set when the event was created. A value of tzone://Microsoft/Custom indicates that a legacy custom time zone was set in desktop Outlook.'
        ),
    ] = None
    recurrence: Annotated[
        Optional[Union[PatternedRecurrence, Dict[str, Any]]],
        Field(description='The recurrence pattern for the event.'),
    ] = None
    reminder_minutes_before_start: Annotated[
        Optional[float],
        Field(
            description='The number of minutes before the event start time that the reminder alert occurs.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    response_requested: Annotated[
        Optional[bool],
        Field(
            description='Default is true, which represents the organizer would like an invitee to send a response to the event.'
        ),
    ] = None
    response_status: Annotated[
        Optional[Union[ResponseStatus, Dict[str, Any]]],
        Field(
            description='Indicates the type of response sent in response to an event message.'
        ),
    ] = None
    sensitivity: Annotated[
        Optional[Union[Sensitivity, Dict[str, Any]]],
        Field(
            description='Possible values are: normal, personal, private, confidential.'
        ),
    ] = None
    series_master_id: Annotated[
        Optional[str],
        Field(
            description='The ID for the recurring series master item, if this event is part of a recurring series.'
        ),
    ] = None
    show_as: Annotated[
        Optional[Union[FreeBusyStatus, Dict[str, Any]]],
        Field(
            description='The status to show. Possible values are: free, tentative, busy, oof, workingElsewhere, unknown.'
        ),
    ] = None
    start: Annotated[
        Optional[Union[DateTimeTimeZone, Dict[str, Any]]],
        Field(
            description='The start date, time, and time zone of the event. By default, the start time is in UTC.'
        ),
    ] = None
    subject: Annotated[
        Optional[str], Field(description="The text of the event's subject line.")
    ] = None
    transaction_id: Annotated[
        Optional[str],
        Field(
            description="A custom identifier specified by a client app for the server to avoid redundant POST operations in case of client retries to create the same event. This is useful when low network connectivity causes the client to time out before receiving a response from the server for the client's prior create-event request. After you set transactionId when creating an event, you cannot change transactionId in a subsequent update. This property is only returned in a response payload if an app has set it. Optional."
        ),
    ] = None
    type: Annotated[
        Optional[Union[EventType, Dict[str, Any]]],
        Field(
            description='The event type. Possible values are: singleInstance, occurrence, exception, seriesMaster. Read-only'
        ),
    ] = None
    web_link: Annotated[
        Optional[str],
        Field(
            description='The URL to open the event in Outlook on the web.Outlook on the web opens the event in the browser if you are signed in to your mailbox. Otherwise, Outlook on the web prompts you to sign in.This URL cannot be accessed from within an iFrame.'
        ),
    ] = None
    attachments: Annotated[
        Optional[List[Attachment]],
        Field(
            description='The collection of FileAttachment, ItemAttachment, and referenceAttachment attachments for the event. Navigation property. Read-only. Nullable.'
        ),
    ] = None
    calendar: Annotated[
        Optional[Union[Calendar, Dict[str, Any]]],
        Field(
            description='The calendar that contains the event. Navigation property. Read-only.'
        ),
    ] = None
    extensions: Annotated[
        Optional[List[Extension]],
        Field(
            description='The collection of open extensions defined for the event. Nullable.'
        ),
    ] = None
    instances: Annotated[
        Optional[List[Event]],
        Field(
            description='The occurrences of a recurring series, if the event is a series master. This property includes occurrences that are part of the recurrence pattern, and exceptions that have been modified, but does not include occurrences that have been cancelled from the series. Navigation property. Read-only. Nullable.'
        ),
    ] = None
    multi_value_extended_properties: Annotated[
        Optional[List[MultiValueLegacyExtendedProperty]],
        Field(
            description='The collection of multi-value extended properties defined for the event. Read-only. Nullable.'
        ),
    ] = None
    single_value_extended_properties: Annotated[
        Optional[List[SingleValueLegacyExtendedProperty]],
        Field(
            description='The collection of single-value extended properties defined for the event. Read-only. Nullable.'
        ),
    ] = None
    field_odata_type: str


class EventMessage(Message):
    end_date_time: Optional[Union[DateTimeTimeZone, Dict[str, Any]]] = None
    is_all_day: Optional[bool] = None
    is_delegated: Annotated[
        Optional[bool],
        Field(
            description='True if this meeting request is accessible to a delegate, false otherwise. Default is false.'
        ),
    ] = None
    is_out_of_date: Optional[bool] = None
    location: Optional[Union[Location, Dict[str, Any]]] = None
    meeting_message_type: Annotated[
        Optional[Union[MeetingMessageType, Dict[str, Any]]],
        Field(
            description='The type of event message: none, meetingRequest, meetingCancelled, meetingAccepted, meetingTenativelyAccepted, meetingDeclined.'
        ),
    ] = None
    recurrence: Optional[Union[PatternedRecurrence, Dict[str, Any]]] = None
    start_date_time: Optional[Union[DateTimeTimeZone, Dict[str, Any]]] = None
    type: Optional[Union[EventType, Dict[str, Any]]] = None
    event: Annotated[
        Optional[Union[Event, Dict[str, Any]]],
        Field(
            description='The event associated with the event message. The assumption for attendees or room resources is that the Calendar Attendant is set to automatically update the calendar with an event when meeting request event messages arrive. Navigation property. Read-only.'
        ),
    ] = None
    field_odata_type: str


class FileStorage(Entity):
    containers: Optional[List[FileStorageContainer]] = None
    deleted_containers: Optional[List[FileStorageContainer]] = None
    field_odata_type: str


class FileStorageContainer(Entity):
    container_type_id: Annotated[
        Optional[UUID],
        Field(
            description='Container type ID of the fileStorageContainer. For details about container types, see Container Types. Each container must have only one container type. Read-only.',
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time of the fileStorageContainer creation. Read-only.',
        ),
    ] = None
    custom_properties: Annotated[
        Optional[Union[FileStorageContainerCustomPropertyDictionary, Dict[str, Any]]],
        Field(
            description='Custom property collection for the fileStorageContainer. Read-write.'
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='Provides a user-visible description of the fileStorageContainer. Read-write.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(description='The display name of the fileStorageContainer. Read-write.'),
    ] = None
    lock_state: Annotated[
        Optional[Union[SiteLockState, Dict[str, Any]]],
        Field(
            description='Indicates the lock state of the fileStorageContainer. The possible values are unlocked and lockedReadOnly. Read-only.'
        ),
    ] = None
    settings: Optional[FileStorageContainerSettings] = None
    status: Annotated[
        Optional[Union[FileStorageContainerStatus, Dict[str, Any]]],
        Field(
            description='Status of the fileStorageContainer. Containers are created as inactive and require activation. Inactive containers are subjected to automatic deletion in 24 hours. The possible values are: inactive, active. Read-only.'
        ),
    ] = None
    viewpoint: Annotated[
        Optional[Union[FileStorageContainerViewpoint, Dict[str, Any]]],
        Field(description='Data specific to the current user. Read-only.'),
    ] = None
    drive: Annotated[
        Optional[Union[Drive, Dict[str, Any]]],
        Field(description='The drive of the resource fileStorageContainer. Read-only.'),
    ] = None
    permissions: Annotated[
        Optional[List[Permission]],
        Field(
            description='The set of permissions for users in the fileStorageContainer. Permission for each user is set by the roles property. The possible values are: reader, writer, manager, and owner. Read-write.'
        ),
    ] = None
    recycle_bin: Annotated[
        Optional[Union[RecycleBin, Dict[str, Any]]],
        Field(description='Recycle bin of the fileStorageContainer. Read-only.'),
    ] = None
    field_odata_type: str


class Group(DirectoryObject):
    allow_external_senders: Annotated[
        Optional[bool],
        Field(
            description='Indicates if people external to the organization can send messages to the group. The default value is false. Returned only on $select. Supported only on the Get group API (GET /groups/{ID}).'
        ),
    ] = None
    assigned_labels: Annotated[
        Optional[List[AssignedLabel]],
        Field(
            description='The list of sensitivity label pairs (label ID, label name) associated with a Microsoft 365 group. Returned only on $select. This property can be updated only in delegated scenarios where the caller requires both the Microsoft Graph permission and a supported administrator role.'
        ),
    ] = None
    assigned_licenses: Annotated[
        Optional[List[AssignedLicense]],
        Field(
            description='The licenses that are assigned to the group. Returned only on $select. Supports $filter (eq).Read-only.'
        ),
    ] = None
    auto_subscribe_new_members: Annotated[
        Optional[bool],
        Field(
            description="Indicates if new members added to the group are autosubscribed to receive email notifications. You can set this property in a PATCH request for the group; don't set it in the initial POST request that creates the group. Default value is false. Returned only on $select. Supported only on the Get group API (GET /groups/{ID})."
        ),
    ] = None
    classification: Annotated[
        Optional[str],
        Field(
            description='Describes a classification for the group (such as low, medium, or high business impact). Valid values for this property are defined by creating a ClassificationList setting value, based on the template definition.Returned by default. Supports $filter (eq, ne, not, ge, le, startsWith).'
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description="Timestamp of when the group was created. The value can't be modified and is automatically populated when the group is created. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on January 1, 2014 is 2014-01-01T00:00:00Z. Returned by default. Read-only.",
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='An optional description for the group. Returned by default. Supports $filter (eq, ne, not, ge, le, startsWith) and $search.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description="The display name for the group. This property is required when a group is created and can't be cleared during updates. Maximum length is 256 characters. Returned by default. Supports $filter (eq, ne, not, ge, le, in, startsWith, and eq on null values), $search, and $orderby."
        ),
    ] = None
    expiration_date_time: Annotated[
        Optional[datetime],
        Field(
            description="Timestamp of when the group is set to expire. It's null for security groups, but for Microsoft 365 groups, it represents when the group is set to expire as defined in the groupLifecyclePolicy. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on January 1, 2014 is 2014-01-01T00:00:00Z. Returned by default. Supports $filter (eq, ne, not, ge, le, in). Read-only.",
        ),
    ] = None
    group_types: Annotated[
        Optional[List[str]],
        Field(
            description="Specifies the group type and its membership. If the collection contains Unified, the group is a Microsoft 365 group; otherwise, it's either a security group or a distribution group. For details, see groups overview.If the collection includes DynamicMembership, the group has dynamic membership; otherwise, membership is static. Returned by default. Supports $filter (eq, not)."
        ),
    ] = None
    has_members_with_license_errors: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether there are members in this group that have license errors from its group-based license assignment. This property is never returned on a GET operation. You can use it as a $filter argument to get groups that have members with license errors (that is, filter for this property being true). See an example. Supports $filter (eq).'
        ),
    ] = None
    hide_from_address_lists: Annotated[
        Optional[bool],
        Field(
            description="True if the group isn't displayed in certain parts of the Outlook UI: the Address Book, address lists for selecting message recipients, and the Browse Groups dialog for searching groups; otherwise, false. The default value is false. Returned only on $select. Supported only on the Get group API (GET /groups/{ID})."
        ),
    ] = None
    hide_from_outlook_clients: Annotated[
        Optional[bool],
        Field(
            description="True if the group isn't displayed in Outlook clients, such as Outlook for Windows and Outlook on the web; otherwise, false. The default value is false. Returned only on $select. Supported only on the Get group API (GET /groups/{ID})."
        ),
    ] = None
    is_archived: Annotated[
        Optional[bool],
        Field(
            description='When a group is associated with a team, this property determines whether the team is in read-only mode.To read this property, use the /group/{groupId}/team endpoint or the Get team API. To update this property, use the archiveTeam and unarchiveTeam APIs.'
        ),
    ] = None
    is_assignable_to_role: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether this group can be assigned to a Microsoft Entra role. Optional. This property can only be set while creating the group and is immutable. If set to true, the securityEnabled property must also be set to true, visibility must be Hidden, and the group can't be a dynamic group (that is, groupTypes can't contain DynamicMembership). Only callers with at least the Privileged Role Administrator role can set this property. The caller must also be assigned the RoleManagement.ReadWrite.Directory permission to set this property or update the membership of such groups. For more, see Using a group to manage Microsoft Entra role assignmentsUsing this feature requires a Microsoft Entra ID P1 license. Returned by default. Supports $filter (eq, ne, not)."
        ),
    ] = None
    is_management_restricted: Optional[bool] = None
    is_subscribed_by_mail: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the signed-in user is subscribed to receive email conversations. The default value is true. Returned only on $select. Supported only on the Get group API (GET /groups/{ID}).'
        ),
    ] = None
    license_processing_state: Annotated[
        Optional[Union[LicenseProcessingState, Dict[str, Any]]],
        Field(
            description='Indicates the status of the group license assignment to all group members. The default value is false. Read-only. Possible values: QueuedForProcessing, ProcessingInProgress, and ProcessingComplete.Returned only on $select. Read-only.'
        ),
    ] = None
    mail: Annotated[
        Optional[str],
        Field(
            description="The SMTP address for the group, for example, 'serviceadmins@contoso.com'. Returned by default. Read-only. Supports $filter (eq, ne, not, ge, le, in, startsWith, and eq on null values)."
        ),
    ] = None
    mail_enabled: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether the group is mail-enabled. Required. Returned by default. Supports $filter (eq, ne, not).'
        ),
    ] = None
    mail_nickname: Annotated[
        Optional[str],
        Field(
            description="The mail alias for the group, unique for Microsoft 365 groups in the organization. Maximum length is 64 characters. This property can contain only characters in the ASCII character set 0 - 127 except the following characters: @ () / [] ' ; : <> , SPACE. Required. Returned by default. Supports $filter (eq, ne, not, ge, le, in, startsWith, and eq on null values)."
        ),
    ] = None
    membership_rule: Annotated[
        Optional[str],
        Field(
            description='The rule that determines members for this group if the group is a dynamic group (groupTypes contains DynamicMembership). For more information about the syntax of the membership rule, see Membership Rules syntax. Returned by default. Supports $filter (eq, ne, not, ge, le, startsWith).'
        ),
    ] = None
    membership_rule_processing_state: Annotated[
        Optional[str],
        Field(
            description='Indicates whether the dynamic membership processing is on or paused. Possible values are On or Paused. Returned by default. Supports $filter (eq, ne, not, in).'
        ),
    ] = None
    on_premises_domain_name: Annotated[
        Optional[str],
        Field(
            description='Contains the on-premises domain FQDN, also called dnsDomainName synchronized from the on-premises directory. The property is only populated for customers synchronizing their on-premises directory to Microsoft Entra ID via Microsoft Entra Connect.Returned by default. Read-only.'
        ),
    ] = None
    on_premises_last_sync_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Indicates the last time at which the group was synced with the on-premises directory. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on January 1, 2014 is 2014-01-01T00:00:00Z. Returned by default. Read-only. Supports $filter (eq, ne, not, ge, le, in).',
        ),
    ] = None
    on_premises_net_bios_name: Annotated[
        Optional[str],
        Field(
            description='Contains the on-premises netBios name synchronized from the on-premises directory. The property is only populated for customers synchronizing their on-premises directory to Microsoft Entra ID via Microsoft Entra Connect.Returned by default. Read-only.'
        ),
    ] = None
    on_premises_provisioning_errors: Annotated[
        Optional[List[OnPremisesProvisioningError]],
        Field(
            description='Errors when using Microsoft synchronization product during provisioning. Returned by default. Supports $filter (eq, not).'
        ),
    ] = None
    on_premises_sam_account_name: Annotated[
        Optional[str],
        Field(
            description='Contains the on-premises SAM account name synchronized from the on-premises directory. The property is only populated for customers synchronizing their on-premises directory to Microsoft Entra ID via Microsoft Entra Connect.Returned by default. Supports $filter (eq, ne, not, ge, le, in, startsWith). Read-only.'
        ),
    ] = None
    on_premises_security_identifier: Annotated[
        Optional[str],
        Field(
            description='Contains the on-premises security identifier (SID) for the group synchronized from on-premises to the cloud. Read-only. Returned by default. Supports $filter (eq including on null values).'
        ),
    ] = None
    on_premises_sync_enabled: Annotated[
        Optional[bool],
        Field(
            description='true if this group is synced from an on-premises directory; false if this group was originally synced from an on-premises directory but is no longer synced; null if this object has never synced from an on-premises directory (default). Returned by default. Read-only. Supports $filter (eq, ne, not, in, and eq on null values).'
        ),
    ] = None
    preferred_data_location: Annotated[
        Optional[str],
        Field(
            description="The preferred data location for the Microsoft 365 group. By default, the group inherits the group creator's preferred data location. To set this property, the calling app must be granted the Directory.ReadWrite.All permission and the user be assigned at least one of the following Microsoft Entra roles: User Account Administrator Directory Writer  Exchange Administrator  SharePoint Administrator  For more information about this property, see OneDrive Online Multi-Geo. Nullable. Returned by default."
        ),
    ] = None
    preferred_language: Annotated[
        Optional[str],
        Field(
            description='The preferred language for a Microsoft 365 group. Should follow ISO 639-1 Code; for example, en-US. Returned by default. Supports $filter (eq, ne, not, ge, le, in, startsWith, and eq on null values).'
        ),
    ] = None
    proxy_addresses: Annotated[
        Optional[List[str]],
        Field(
            description="Email addresses for the group that direct to the same group mailbox. For example: ['SMTP: bob@contoso.com', 'smtp: bob@sales.contoso.com']. The any operator is required to filter expressions on multi-valued properties. Returned by default. Read-only. Not nullable. Supports $filter (eq, not, ge, le, startsWith, endsWith, /$count eq 0, /$count ne 0)."
        ),
    ] = None
    renewed_date_time: Annotated[
        Optional[datetime],
        Field(
            description="Timestamp of when the group was last renewed. This value can't be modified directly and is only updated via the renew service action. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on January 1, 2014 is 2014-01-01T00:00:00Z. Returned by default. Supports $filter (eq, ne, not, ge, le, in). Read-only.",
        ),
    ] = None
    security_enabled: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether the group is a security group. Required. Returned by default. Supports $filter (eq, ne, not, in).'
        ),
    ] = None
    security_identifier: Annotated[
        Optional[str],
        Field(
            description='Security identifier of the group, used in Windows scenarios. Read-only. Returned by default.'
        ),
    ] = None
    service_provisioning_errors: Annotated[
        Optional[List[ServiceProvisioningError]],
        Field(
            description='Errors published by a federated service describing a nontransient, service-specific error regarding the properties or link from a group object.  Supports $filter (eq, not, for isResolved and serviceInstance).'
        ),
    ] = None
    theme: Annotated[
        Optional[str],
        Field(
            description="Specifies a Microsoft 365 group's color theme. Possible values are Teal, Purple, Green, Blue, Pink, Orange, or Red. Returned by default."
        ),
    ] = None
    unique_name: Annotated[
        Optional[str],
        Field(
            description='The unique identifier that can be assigned to a group and used as an alternate key. Immutable. Read-only.'
        ),
    ] = None
    unseen_count: Annotated[
        Optional[float],
        Field(
            description='Count of conversations that received new posts since the signed-in user last visited the group. Returned only on $select. Supported only on the Get group API (GET /groups/{ID}).',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    visibility: Annotated[
        Optional[str],
        Field(
            description="Specifies the group join policy and group content visibility for groups. Possible values are: Private, Public, or HiddenMembership. HiddenMembership can be set only for Microsoft 365 groups when the groups are created. It can't be updated later. Other values of visibility can be updated after group creation. If visibility value isn't specified during group creation on Microsoft Graph, a security group is created as Private by default, and the Microsoft 365 group is Public. Groups assignable to roles are always Private. To learn more, see group visibility options. Returned by default. Nullable."
        ),
    ] = None
    accepted_senders: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description='The list of users or groups allowed to create posts or calendar events in this group. If this list is nonempty, then only users or groups listed here are allowed to post.'
        ),
    ] = None
    app_role_assignments: Annotated[
        Optional[List[AppRoleAssignment]],
        Field(
            description='Represents the app roles granted to a group for an application. Supports $expand.'
        ),
    ] = None
    calendar: Annotated[
        Optional[Union[Calendar, Dict[str, Any]]],
        Field(description="The group's calendar. Read-only."),
    ] = None
    calendar_view: Annotated[
        Optional[List[Event]],
        Field(description='The calendar view for the calendar. Read-only.'),
    ] = None
    conversations: Annotated[
        Optional[List[Conversation]], Field(description="The group's conversations.")
    ] = None
    created_on_behalf_of: Annotated[
        Optional[Union[DirectoryObject, Dict[str, Any]]],
        Field(
            description="The user (or application) that created the group. NOTE: This property isn't set if the user is an administrator. Read-only."
        ),
    ] = None
    drive: Annotated[
        Optional[Union[Drive, Dict[str, Any]]],
        Field(description="The group's default drive. Read-only."),
    ] = None
    drives: Annotated[
        Optional[List[Drive]], Field(description="The group's drives. Read-only.")
    ] = None
    events: Annotated[
        Optional[List[Event]], Field(description="The group's calendar events.")
    ] = None
    extensions: Annotated[
        Optional[List[Extension]],
        Field(
            description='The collection of open extensions defined for the group. Read-only. Nullable.'
        ),
    ] = None
    group_lifecycle_policies: Annotated[
        Optional[List[GroupLifecyclePolicy]],
        Field(
            description='The collection of lifecycle policies for this group. Read-only. Nullable.'
        ),
    ] = None
    member_of: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description='Groups that this group is a member of. HTTP Methods: GET (supported for all groups). Read-only. Nullable. Supports $expand.'
        ),
    ] = None
    members: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description="The members of this group, who can be users, devices, other groups, or service principals. Supports the List members, Add member, and Remove member operations. Nullable. Supports $expand including nested $select. For example, /groups?$filter=startsWith(displayName,'Role')&$select=id,displayName&$expand=members($select=id,userPrincipalName,displayName)."
        ),
    ] = None
    members_with_license_errors: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description='A list of group members with license errors from this group-based license assignment. Read-only.'
        ),
    ] = None
    onenote: Optional[Union[Onenote, Dict[str, Any]]] = None
    owners: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description="The owners of the group who can be users or service principals. Limited to 100 owners. Nullable. If this property isn't specified when creating a Microsoft 365 group the calling user (admin or non-admin) is automatically assigned as the group owner. A non-admin user can't explicitly add themselves to this collection when they're creating the group. For more information, see the related known issue. For security groups, the admin user isn't automatically added to this collection. For more information, see the related known issue. Supports $filter (/$count eq 0, /$count ne 0, /$count eq 1, /$count ne 1); Supports $expand including nested $select. For example, /groups?$filter=startsWith(displayName,'Role')&$select=id,displayName&$expand=owners($select=id,userPrincipalName,displayName)."
        ),
    ] = None
    permission_grants: Optional[List[ResourceSpecificPermissionGrant]] = None
    photo: Annotated[
        Optional[Union[ProfilePhoto, Dict[str, Any]]],
        Field(description="The group's profile photo"),
    ] = None
    photos: Annotated[
        Optional[List[ProfilePhoto]],
        Field(
            description='The profile photos owned by the group. Read-only. Nullable.'
        ),
    ] = None
    planner: Annotated[
        Optional[Union[PlannerGroup, Dict[str, Any]]],
        Field(
            description='Entry-point to Planner resource that might exist for a Unified Group.'
        ),
    ] = None
    rejected_senders: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description='The list of users or groups not allowed to create posts or calendar events in this group. Nullable'
        ),
    ] = None
    settings: Annotated[
        Optional[List[GroupSetting]],
        Field(
            description="Settings that can govern this group's behavior, like whether members can invite guests to the group. Nullable."
        ),
    ] = None
    sites: Annotated[
        Optional[List[Site]],
        Field(
            description='The list of SharePoint sites in this group. Access the default site with /sites/root.'
        ),
    ] = None
    team: Annotated[
        Optional[Union[Team, Dict[str, Any]]],
        Field(description='The team associated with this group.'),
    ] = None
    threads: Annotated[
        Optional[List[ConversationThread]],
        Field(description="The group's conversation threads. Nullable."),
    ] = None
    transitive_member_of: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description='The groups that a group is a member of, either directly or through nested membership. Nullable.'
        ),
    ] = None
    transitive_members: Annotated[
        Optional[List[DirectoryObject]],
        Field(description='The direct and transitive members of a group. Nullable.'),
    ] = None
    field_odata_type: str


class IdentityGovernance(BaseModel):
    access_reviews: Optional[Union[AccessReviewSet, Dict[str, Any]]] = None
    app_consent: Optional[Union[AppConsentApprovalRoute, Dict[str, Any]]] = None
    entitlement_management: Optional[Union[EntitlementManagement, Dict[str, Any]]] = (
        None
    )
    lifecycle_workflows: Optional[
        Union[identityGovernance.LifecycleWorkflowsContainer, Dict[str, Any]]
    ] = None
    privileged_access: Optional[Union[PrivilegedAccessRoot, Dict[str, Any]]] = None
    terms_of_use: Optional[Union[TermsOfUseContainer, Dict[str, Any]]] = None
    field_odata_type: str


class IdentityProtectionRoot(BaseModel):
    risk_detections: Annotated[
        Optional[List[RiskDetection]],
        Field(
            description='Risk detection in Microsoft Entra ID Protection and the associated information about the detection.'
        ),
    ] = None
    risky_service_principals: Annotated[
        Optional[List[RiskyServicePrincipal]],
        Field(description='Microsoft Entra service principals that are at risk.'),
    ] = None
    risky_users: Annotated[
        Optional[List[RiskyUser]],
        Field(
            description='Users that are flagged as at-risk by Microsoft Entra ID Protection.'
        ),
    ] = None
    service_principal_risk_detections: Annotated[
        Optional[List[ServicePrincipalRiskDetection]],
        Field(
            description='Represents information about detected at-risk service principals in a Microsoft Entra tenant.'
        ),
    ] = None
    field_odata_type: str


class Invitation(Entity):
    invited_user_display_name: Annotated[
        Optional[str], Field(description='The display name of the user being invited.')
    ] = None
    invited_user_email_address: Annotated[
        Optional[str],
        Field(
            description="The email address of the user being invited. Required. The following special characters aren't permitted in the email address:Tilde (~)Exclamation point (!)Number sign (#)Dollar sign ($)Percent (%)Circumflex (^)Ampersand (&)Asterisk (*)Parentheses (( ))Plus sign (+)Equal sign (=)Brackets ([ ])Braces ({ })Backslash (/)Slash mark (/)Pipe (/|)Semicolon (;)Colon (:)Quotation marks (')Angle brackets (< >)Question mark (?)Comma (,)However, the following exceptions apply:A period (.) or a hyphen (-) is permitted anywhere in the user name, except at the beginning or end of the name.An underscore (_) is permitted anywhere in the user name, including at the beginning or end of the name."
        ),
    ] = None
    invited_user_message_info: Annotated[
        Optional[Union[InvitedUserMessageInfo, Dict[str, Any]]],
        Field(
            description='Contains configuration for the message being sent to the invited user, including customizing message text, language, and cc recipient list.'
        ),
    ] = None
    invited_user_type: Annotated[
        Optional[str],
        Field(
            description="The userType of the user being invited. By default, this is Guest. You can invite as Member if you're a company administrator."
        ),
    ] = None
    invite_redeem_url: Annotated[
        Optional[str],
        Field(
            description='The URL the user can use to redeem their invitation. Read-only.'
        ),
    ] = None
    invite_redirect_url: Annotated[
        Optional[str],
        Field(
            description='The URL the user should be redirected to after the invitation is redeemed. Required.'
        ),
    ] = None
    reset_redemption: Annotated[
        Optional[bool],
        Field(
            description="Reset the user's redemption status and reinvite a user while retaining their user identifier, group memberships, and app assignments. This property allows you to enable a user to sign-in using a different email address from the one in the previous invitation. When true, the invitedUser/id relationship is required. For more information about using this property, see Reset redemption status for a guest user."
        ),
    ] = None
    send_invitation_message: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether an email should be sent to the user being invited. The default is false.'
        ),
    ] = None
    status: Annotated[
        Optional[str],
        Field(
            description='The status of the invitation. Possible values are: PendingAcceptance, Completed, InProgress, and Error.'
        ),
    ] = None
    invited_user: Annotated[
        Optional[Union[User, Dict[str, Any]]],
        Field(
            description='The user created as part of the invitation creation. Read-only. The id property is required in the request body to reset a redemption status.'
        ),
    ] = None
    invited_user_sponsors: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description="The users or groups who are sponsors of the invited user. Sponsors are users and groups that are responsible for guest users' privileges in the tenant and for keeping the guest users' information and access up to date."
        ),
    ] = None
    field_odata_type: str


class ItemActivity(Entity):
    access: Annotated[
        Optional[Union[AccessAction, Dict[str, Any]]],
        Field(description='An item was accessed.'),
    ] = None
    activity_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Details about when the activity took place. Read-only.',
        ),
    ] = None
    actor: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Identity of who performed the action. Read-only.'),
    ] = None
    drive_item: Annotated[
        Optional[Union[DriveItem, Dict[str, Any]]],
        Field(
            description='Exposes the driveItem that was the target of this activity.'
        ),
    ] = None
    field_odata_type: str


class ItemActivityStat(Entity):
    access: Annotated[
        Optional[Union[ItemActionStat, Dict[str, Any]]],
        Field(
            description='Statistics about the access actions in this interval. Read-only.'
        ),
    ] = None
    create: Annotated[
        Optional[Union[ItemActionStat, Dict[str, Any]]],
        Field(
            description='Statistics about the create actions in this interval. Read-only.'
        ),
    ] = None
    delete: Annotated[
        Optional[Union[ItemActionStat, Dict[str, Any]]],
        Field(
            description='Statistics about the delete actions in this interval. Read-only.'
        ),
    ] = None
    edit: Annotated[
        Optional[Union[ItemActionStat, Dict[str, Any]]],
        Field(
            description='Statistics about the edit actions in this interval. Read-only.'
        ),
    ] = None
    end_date_time: Annotated[
        Optional[datetime],
        Field(
            description='When the interval ends. Read-only.',
        ),
    ] = None
    incomplete_data: Annotated[
        Optional[Union[IncompleteData, Dict[str, Any]]],
        Field(
            description='Indicates that the statistics in this interval are based on incomplete data. Read-only.'
        ),
    ] = None
    is_trending: Annotated[
        Optional[bool],
        Field(description="Indicates whether the item is 'trending.' Read-only."),
    ] = None
    move: Annotated[
        Optional[Union[ItemActionStat, Dict[str, Any]]],
        Field(
            description='Statistics about the move actions in this interval. Read-only.'
        ),
    ] = None
    start_date_time: Annotated[
        Optional[datetime],
        Field(
            description='When the interval starts. Read-only.',
        ),
    ] = None
    activities: Annotated[
        Optional[List[ItemActivity]],
        Field(
            description='Exposes the itemActivities represented in this itemActivityStat resource.'
        ),
    ] = None
    field_odata_type: str


class ItemAnalytics(Entity):
    all_time: Optional[Union[ItemActivityStat, Dict[str, Any]]] = None
    item_activity_stats: Optional[List[ItemActivityStat]] = None
    last_seven_days: Optional[Union[ItemActivityStat, Dict[str, Any]]] = None
    field_odata_type: str


class ManagedDevice(Entity):
    activation_lock_bypass_code: Annotated[
        Optional[str],
        Field(
            description='The code that allows the Activation Lock on managed device to be bypassed. Default, is Null (Non-Default property) for this property when returned as part of managedDevice entity in LIST call. To retrieve actual values GET call needs to be made, with device id and included in select parameter. Supports: $select. $Search is not supported. Read-only. This property is read-only.'
        ),
    ] = None
    android_security_patch_level: Annotated[
        Optional[str],
        Field(description='Android security patch level. This property is read-only.'),
    ] = None
    azure_ad_device_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier for the Azure Active Directory device. Read only. This property is read-only.'
        ),
    ] = None
    azure_ad_registered: Annotated[
        Optional[bool],
        Field(
            description='Whether the device is Azure Active Directory registered. This property is read-only.'
        ),
    ] = None
    compliance_grace_period_expiration_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The DateTime when device compliance grace period expires. This property is read-only.',
        ),
    ] = None
    compliance_state: Optional[ComplianceState] = None
    configuration_manager_client_enabled_features: Annotated[
        Optional[Union[ConfigurationManagerClientEnabledFeatures, Dict[str, Any]]],
        Field(
            description='ConfigrMgr client enabled features. This property is read-only.'
        ),
    ] = None
    device_action_results: Annotated[
        Optional[List[DeviceActionResult]],
        Field(
            description='List of ComplexType deviceActionResult objects. This property is read-only.'
        ),
    ] = None
    device_category_display_name: Annotated[
        Optional[str],
        Field(
            description="Device category display name. Default is an empty string. Supports $filter operator 'eq' and 'or'. This property is read-only."
        ),
    ] = None
    device_enrollment_type: Optional[DeviceEnrollmentType] = None
    device_health_attestation_state: Annotated[
        Optional[Union[DeviceHealthAttestationState, Dict[str, Any]]],
        Field(
            description='The device health attestation state. This property is read-only.'
        ),
    ] = None
    device_name: Annotated[
        Optional[str],
        Field(description='Name of the device. This property is read-only.'),
    ] = None
    device_registration_state: Optional[DeviceRegistrationState] = None
    eas_activated: Annotated[
        Optional[bool],
        Field(
            description='Whether the device is Exchange ActiveSync activated. This property is read-only.'
        ),
    ] = None
    eas_activation_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Exchange ActivationSync activation time of the device. This property is read-only.',
        ),
    ] = None
    eas_device_id: Annotated[
        Optional[str],
        Field(
            description='Exchange ActiveSync Id of the device. This property is read-only.'
        ),
    ] = None
    email_address: Annotated[
        Optional[str],
        Field(
            description='Email(s) for the user associated with the device. This property is read-only.'
        ),
    ] = None
    enrolled_date_time: Annotated[
        Optional[datetime],
        Field(
            description="Enrollment time of the device. Supports $filter operator 'lt' and 'gt'. This property is read-only.",
        ),
    ] = None
    enrollment_profile_name: Annotated[
        Optional[str],
        Field(
            description='Name of the enrollment profile assigned to the device. Default value is empty string, indicating no enrollment profile was assgined. This property is read-only.'
        ),
    ] = None
    ethernet_mac_address: Annotated[
        Optional[str],
        Field(
            description='Indicates Ethernet MAC Address of the device. Default, is Null (Non-Default property) for this property when returned as part of managedDevice entity. Individual get call with select query options is needed to retrieve actual values. Example: deviceManagement/managedDevices({managedDeviceId})?$select=ethernetMacAddress Supports: $select. $Search is not supported. Read-only. This property is read-only.'
        ),
    ] = None
    exchange_access_state: Optional[DeviceManagementExchangeAccessState] = None
    exchange_access_state_reason: Optional[
        DeviceManagementExchangeAccessStateReason
    ] = None
    exchange_last_successful_sync_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Last time the device contacted Exchange. This property is read-only.',
        ),
    ] = None
    free_storage_space_in_bytes: Annotated[
        Optional[float],
        Field(
            description='Free Storage in Bytes. Default value is 0. Read-only. This property is read-only.'
        ),
    ] = None
    iccid: Annotated[
        Optional[str],
        Field(
            description="Integrated Circuit Card Identifier, it is A SIM card's unique identification number. Default is an empty string. To retrieve actual values GET call needs to be made, with device id and included in select parameter. Supports: $select. $Search is not supported. Read-only. This property is read-only."
        ),
    ] = None
    imei: Annotated[
        Optional[str], Field(description='IMEI. This property is read-only.')
    ] = None
    is_encrypted: Annotated[
        Optional[bool],
        Field(description='Device encryption status. This property is read-only.'),
    ] = None
    is_supervised: Annotated[
        Optional[bool],
        Field(description='Device supervised status. This property is read-only.'),
    ] = None
    jail_broken: Annotated[
        Optional[str],
        Field(
            description="Whether the device is jail broken or rooted. Default is an empty string. Supports $filter operator 'eq' and 'or'. This property is read-only."
        ),
    ] = None
    last_sync_date_time: Annotated[
        Optional[datetime],
        Field(
            description="The date and time that the device last completed a successful sync with Intune. Supports $filter operator 'lt' and 'gt'. This property is read-only.",
        ),
    ] = None
    managed_device_name: Annotated[
        Optional[str],
        Field(
            description='Automatically generated name to identify a device. Can be overwritten to a user friendly name.'
        ),
    ] = None
    managed_device_owner_type: Optional[ManagedDeviceOwnerType] = None
    management_agent: Optional[ManagementAgentType] = None
    management_certificate_expiration_date: Annotated[
        Optional[datetime],
        Field(
            description='Reports device management certificate expiration date. This property is read-only.',
        ),
    ] = None
    manufacturer: Annotated[
        Optional[str],
        Field(description='Manufacturer of the device. This property is read-only.'),
    ] = None
    meid: Annotated[
        Optional[str], Field(description='MEID. This property is read-only.')
    ] = None
    model: Annotated[
        Optional[str],
        Field(description='Model of the device. This property is read-only.'),
    ] = None
    notes: Annotated[
        Optional[str],
        Field(
            description='Notes on the device created by IT Admin. Default is null. To retrieve actual values GET call needs to be made, with device id and included in select parameter. Supports: $select. $Search is not supported.'
        ),
    ] = None
    operating_system: Annotated[
        Optional[str],
        Field(
            description='Operating system of the device. Windows, iOS, etc. This property is read-only.'
        ),
    ] = None
    os_version: Annotated[
        Optional[str],
        Field(
            description='Operating system version of the device. This property is read-only.'
        ),
    ] = None
    partner_reported_threat_state: Optional[ManagedDevicePartnerReportedHealthState] = (
        None
    )
    phone_number: Annotated[
        Optional[str],
        Field(description='Phone number of the device. This property is read-only.'),
    ] = None
    physical_memory_in_bytes: Annotated[
        Optional[float],
        Field(
            description='Total Memory in Bytes. Default is 0. To retrieve actual values GET call needs to be made, with device id and included in select parameter. Supports: $select. Read-only. This property is read-only.'
        ),
    ] = None
    remote_assistance_session_error_details: Annotated[
        Optional[str],
        Field(
            description='An error string that identifies issues when creating Remote Assistance session objects. This property is read-only.'
        ),
    ] = None
    remote_assistance_session_url: Annotated[
        Optional[str],
        Field(
            description='Url that allows a Remote Assistance session to be established with the device. Default is an empty string. To retrieve actual values GET call needs to be made, with device id and included in select parameter. This property is read-only.'
        ),
    ] = None
    require_user_enrollment_approval: Annotated[
        Optional[bool],
        Field(
            description='Reports if the managed iOS device is user approval enrollment. This property is read-only.'
        ),
    ] = None
    serial_number: Annotated[
        Optional[str], Field(description='SerialNumber. This property is read-only.')
    ] = None
    subscriber_carrier: Annotated[
        Optional[str],
        Field(description='Subscriber Carrier. This property is read-only.'),
    ] = None
    total_storage_space_in_bytes: Annotated[
        Optional[float],
        Field(description='Total Storage in Bytes. This property is read-only.'),
    ] = None
    udid: Annotated[
        Optional[str],
        Field(
            description='Unique Device Identifier for iOS and macOS devices. Default is an empty string. To retrieve actual values GET call needs to be made, with device id and included in select parameter. Supports: $select. $Search is not supported. Read-only. This property is read-only.'
        ),
    ] = None
    user_display_name: Annotated[
        Optional[str],
        Field(description='User display name. This property is read-only.'),
    ] = None
    user_id: Annotated[
        Optional[str],
        Field(
            description='Unique Identifier for the user associated with the device. This property is read-only.'
        ),
    ] = None
    user_principal_name: Annotated[
        Optional[str],
        Field(description='Device user principal name. This property is read-only.'),
    ] = None
    wi_fi_mac_address: Annotated[
        Optional[str], Field(description='Wi-Fi MAC. This property is read-only.')
    ] = None
    device_category: Annotated[
        Optional[Union[DeviceCategory, Dict[str, Any]]],
        Field(description='Device category'),
    ] = None
    device_compliance_policy_states: Annotated[
        Optional[List[DeviceCompliancePolicyState]],
        Field(description='Device compliance policy states for this device.'),
    ] = None
    device_configuration_states: Annotated[
        Optional[List[DeviceConfigurationState]],
        Field(description='Device configuration states for this device.'),
    ] = None
    log_collection_requests: Annotated[
        Optional[List[DeviceLogCollectionResponse]],
        Field(description='List of log collection requests'),
    ] = None
    users: Annotated[
        Optional[List[User]],
        Field(description='The primary users associated with the managed device.'),
    ] = None
    windows_protection_state: Annotated[
        Optional[Union[WindowsProtectionState, Dict[str, Any]]],
        Field(description='The device protection status. This property is read-only.'),
    ] = None
    field_odata_type: str


class MembershipOutlierInsight(GovernanceInsight):
    container_id: Annotated[
        Optional[str],
        Field(
            description='Indicates the identifier of the container, for example, a group ID.'
        ),
    ] = None
    member_id: Annotated[
        Optional[str], Field(description='Indicates the identifier of the user.')
    ] = None
    outlier_container_type: Optional[OutlierContainerType] = None
    outlier_member_type: Optional[OutlierMemberType] = None
    container: Annotated[
        Optional[Union[DirectoryObject, Dict[str, Any]]],
        Field(
            description='Navigation link to the container directory object. For example, to a group.'
        ),
    ] = None
    last_modified_by: Annotated[
        Optional[Union[User, Dict[str, Any]]],
        Field(
            description='Navigation link to a member object who modified the record. For example, to a user.'
        ),
    ] = None
    member: Annotated[
        Optional[Union[DirectoryObject, Dict[str, Any]]],
        Field(
            description='Navigation link to a member object. For example, to a user.'
        ),
    ] = None
    field_odata_type: str


class Notebook(OnenoteEntityHierarchyModel):
    is_default: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether this is the user's default notebook. Read-only."
        ),
    ] = None
    is_shared: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the notebook is shared. If true, the contents of the notebook can be seen by people other than the owner. Read-only.'
        ),
    ] = None
    links: Annotated[
        Optional[Union[NotebookLinks, Dict[str, Any]]],
        Field(
            description="Links for opening the notebook. The oneNoteClientURL link opens the notebook in the OneNote native client if it's installed. The oneNoteWebURL link opens the notebook in OneNote on the web."
        ),
    ] = None
    section_groups_url: Annotated[
        Optional[str],
        Field(
            description='The URL for the sectionGroups navigation property, which returns all the section groups in the notebook. Read-only.'
        ),
    ] = None
    sections_url: Annotated[
        Optional[str],
        Field(
            description='The URL for the sections navigation property, which returns all the sections in the notebook. Read-only.'
        ),
    ] = None
    user_role: Annotated[
        Optional[Union[OnenoteUserRole, Dict[str, Any]]],
        Field(
            description='Possible values are: Owner, Contributor, Reader, None. Owner represents owner-level access to the notebook. Contributor represents read/write access to the notebook. Reader represents read-only access to the notebook. Read-only.'
        ),
    ] = None
    section_groups: Annotated[
        Optional[List[SectionGroup]],
        Field(description='The section groups in the notebook. Read-only. Nullable.'),
    ] = None
    sections: Annotated[
        Optional[List[OnenoteSection]],
        Field(description='The sections in the notebook. Read-only. Nullable.'),
    ] = None
    field_odata_type: str


class Onenote(Entity):
    notebooks: Annotated[
        Optional[List[Notebook]],
        Field(
            description='The collection of OneNote notebooks that are owned by the user or group. Read-only. Nullable.'
        ),
    ] = None
    operations: Annotated[
        Optional[List[OnenoteOperation]],
        Field(
            description="The status of OneNote operations. Getting an operations collection isn't supported, but you can get the status of long-running operations if the Operation-Location header is returned in the response. Read-only. Nullable."
        ),
    ] = None
    pages: Annotated[
        Optional[List[OnenotePage]],
        Field(
            description='The pages in all OneNote notebooks that are owned by the user or group.  Read-only. Nullable.'
        ),
    ] = None
    resources: Annotated[
        Optional[List[OnenoteResource]],
        Field(
            description="The image and other file resources in OneNote pages. Getting a resources collection isn't supported, but you can get the binary content of a specific resource. Read-only. Nullable."
        ),
    ] = None
    section_groups: Annotated[
        Optional[List[SectionGroup]],
        Field(
            description='The section groups in all OneNote notebooks that are owned by the user or group.  Read-only. Nullable.'
        ),
    ] = None
    sections: Annotated[
        Optional[List[OnenoteSection]],
        Field(
            description='The sections in all OneNote notebooks that are owned by the user or group.  Read-only. Nullable.'
        ),
    ] = None
    field_odata_type: str


class OnenotePage(OnenoteEntitySchemaObjectModel):
    content: Annotated[Optional[str], Field(description="The page's HTML content.")] = (
        None
    )
    content_url: Annotated[
        Optional[str],
        Field(description="The URL for the page's HTML content.  Read-only."),
    ] = None
    created_by_app_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier of the application that created the page. Read-only.'
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the page was last modified. The timestamp represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.',
        ),
    ] = None
    level: Annotated[
        Optional[float],
        Field(
            description='The indentation level of the page. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    links: Annotated[
        Optional[Union[PageLinks, Dict[str, Any]]],
        Field(
            description="Links for opening the page. The oneNoteClientURL link opens the page in the OneNote native client if it 's installed. The oneNoteWebUrl link opens the page in OneNote on the web. Read-only."
        ),
    ] = None
    order: Annotated[
        Optional[float],
        Field(
            description='The order of the page within its parent section. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    title: Annotated[Optional[str], Field(description='The title of the page.')] = None
    user_tags: Optional[List[str]] = None
    parent_notebook: Annotated[
        Optional[Union[Notebook, Dict[str, Any]]],
        Field(description='The notebook that contains the page.  Read-only.'),
    ] = None
    parent_section: Annotated[
        Optional[Union[OnenoteSection, Dict[str, Any]]],
        Field(description='The section that contains the page. Read-only.'),
    ] = None
    field_odata_type: str


class OnenoteSection(OnenoteEntityHierarchyModel):
    is_default: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether this is the user's default section. Read-only."
        ),
    ] = None
    links: Annotated[
        Optional[Union[SectionLinks, Dict[str, Any]]],
        Field(
            description="Links for opening the section. The oneNoteClientURL link opens the section in the OneNote native client if it's installed. The oneNoteWebURL link opens the section in OneNote on the web."
        ),
    ] = None
    pages_url: Annotated[
        Optional[str],
        Field(
            description='The pages endpoint where you can get details for all the pages in the section. Read-only.'
        ),
    ] = None
    pages: Annotated[
        Optional[List[OnenotePage]],
        Field(
            description='The collection of pages in the section.  Read-only. Nullable.'
        ),
    ] = None
    parent_notebook: Annotated[
        Optional[Union[Notebook, Dict[str, Any]]],
        Field(description='The notebook that contains the section.  Read-only.'),
    ] = None
    parent_section_group: Annotated[
        Optional[Union[SectionGroup, Dict[str, Any]]],
        Field(description='The section group that contains the section.  Read-only.'),
    ] = None
    field_odata_type: str


class Print(BaseModel):
    settings: Annotated[
        Optional[Union[PrintSettings, Dict[str, Any]]],
        Field(description='Tenant-wide settings for the Universal Print service.'),
    ] = None
    connectors: Annotated[
        Optional[List[PrintConnector]],
        Field(description='The list of available print connectors.'),
    ] = None
    operations: Annotated[
        Optional[List[PrintOperation]],
        Field(description='The list of print long running operations.'),
    ] = None
    printers: Annotated[
        Optional[List[Printer]],
        Field(description='The list of printers registered in the tenant.'),
    ] = None
    services: Annotated[
        Optional[List[PrintService]],
        Field(description='The list of available Universal Print service endpoints.'),
    ] = None
    shares: Annotated[
        Optional[List[PrinterShare]],
        Field(description='The list of printer shares registered in the tenant.'),
    ] = None
    task_definitions: Annotated[
        Optional[List[PrintTaskDefinition]],
        Field(
            description='List of abstract definition for a task that can be triggered when various events occur within Universal Print.'
        ),
    ] = None
    field_odata_type: str


class PrinterBase(Entity):
    capabilities: Annotated[
        Optional[Union[PrinterCapabilities, Dict[str, Any]]],
        Field(description='The capabilities of the printer/printerShare.'),
    ] = None
    defaults: Annotated[
        Optional[Union[PrinterDefaults, Dict[str, Any]]],
        Field(description='The default print settings of printer/printerShare.'),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The name of the printer/printerShare.')
    ] = None
    is_accepting_jobs: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether the printer/printerShare is currently accepting new print jobs.'
        ),
    ] = None
    location: Annotated[
        Optional[Union[PrinterLocation, Dict[str, Any]]],
        Field(
            description='The physical and/or organizational location of the printer/printerShare.'
        ),
    ] = None
    manufacturer: Annotated[
        Optional[str],
        Field(description='The manufacturer of the printer/printerShare.'),
    ] = None
    model: Annotated[
        Optional[str], Field(description='The model name of the printer/printerShare.')
    ] = None
    status: Optional[PrinterStatus] = None
    jobs: Annotated[
        Optional[List[PrintJob]],
        Field(
            description='The list of jobs that are queued for printing by the printer/printerShare.'
        ),
    ] = None
    field_odata_type: str


class PrinterCreateOperation(PrintOperation):
    certificate: Annotated[
        Optional[str],
        Field(
            description='The signed certificate created during the registration process. Read-only.'
        ),
    ] = None
    printer: Annotated[
        Optional[Union[Printer, Dict[str, Any]]],
        Field(description='The created printer entity. Read-only.'),
    ] = None
    field_odata_type: str


class PrintJob(Entity):
    configuration: Optional[PrintJobConfiguration] = None
    created_by: Optional[Union[UserIdentity, Dict[str, Any]]] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The DateTimeOffset when the job was created. Read-only.',
        ),
    ] = None
    is_fetchable: Annotated[
        Optional[bool],
        Field(description='If true, document can be fetched by printer.'),
    ] = None
    redirected_from: Annotated[
        Optional[str],
        Field(
            description='Contains the source job URL, if the job has been redirected from another printer.'
        ),
    ] = None
    redirected_to: Annotated[
        Optional[str],
        Field(
            description='Contains the destination job URL, if the job has been redirected to another printer.'
        ),
    ] = None
    status: Optional[PrintJobStatus] = None
    documents: Optional[List[PrintDocument]] = None
    tasks: Annotated[
        Optional[List[PrintTask]],
        Field(
            description='A list of printTasks that were triggered by this print job.'
        ),
    ] = None
    field_odata_type: str


class PrintTask(Entity):
    parent_url: Annotated[
        Optional[str],
        Field(
            description='The URL for the print entity that triggered this task. For example, https://graph.microsoft.com/v1.0/print/printers/{printerId}/jobs/{jobId}. Read-only.'
        ),
    ] = None
    status: Optional[PrintTaskStatus] = None
    definition: Optional[PrintTaskDefinition] = None
    trigger: Optional[PrintTaskTrigger] = None
    field_odata_type: str


class PrintTaskDefinition(Entity):
    created_by: Optional[AppIdentity] = None
    display_name: Annotated[
        Optional[str], Field(description='The name of the printTaskDefinition.')
    ] = None
    tasks: Annotated[
        Optional[List[PrintTask]],
        Field(
            description='A list of tasks that have been created based on this definition. The list includes currently running tasks and recently completed tasks. Read-only.'
        ),
    ] = None
    field_odata_type: str


class PrintTaskTrigger(Entity):
    event: Optional[PrintEvent] = None
    definition: Optional[PrintTaskDefinition] = None
    field_odata_type: str


class Privacy(BaseModel):
    subject_rights_requests: Optional[List[SubjectRightsRequest]] = None
    field_odata_type: str


class PrivilegedAccessGroup(Entity):
    assignment_approvals: Optional[List[Approval]] = None
    assignment_schedule_instances: Annotated[
        Optional[List[PrivilegedAccessGroupAssignmentScheduleInstance]],
        Field(
            description='The instances of assignment schedules to activate a just-in-time access.'
        ),
    ] = None
    assignment_schedule_requests: Annotated[
        Optional[List[PrivilegedAccessGroupAssignmentScheduleRequest]],
        Field(
            description='The schedule requests for operations to create, update, delete, extend, and renew an assignment.'
        ),
    ] = None
    assignment_schedules: Annotated[
        Optional[List[PrivilegedAccessGroupAssignmentSchedule]],
        Field(
            description='The assignment schedules to activate a just-in-time access.'
        ),
    ] = None
    eligibility_schedule_instances: Annotated[
        Optional[List[PrivilegedAccessGroupEligibilityScheduleInstance]],
        Field(
            description='The instances of eligibility schedules to activate a just-in-time access.'
        ),
    ] = None
    eligibility_schedule_requests: Annotated[
        Optional[List[PrivilegedAccessGroupEligibilityScheduleRequest]],
        Field(
            description='The schedule requests for operations to create, update, delete, extend, and renew an eligibility.'
        ),
    ] = None
    eligibility_schedules: Annotated[
        Optional[List[PrivilegedAccessGroupEligibilitySchedule]],
        Field(
            description='The eligibility schedules to activate a just-in-time access.'
        ),
    ] = None
    field_odata_type: str


class PrivilegedAccessGroupAssignmentSchedule(PrivilegedAccessSchedule):
    access_id: Annotated[
        Optional[Union[PrivilegedAccessGroupRelationships, Dict[str, Any]]],
        Field(
            description='The identifier of the membership or ownership assignment to the group that is governed through PIM. Required. The possible values are: owner, member, unknownFutureValue. Supports $filter (eq).'
        ),
    ] = None
    assignment_type: Annotated[
        Optional[Union[PrivilegedAccessGroupAssignmentType, Dict[str, Any]]],
        Field(
            description='Indicates whether the membership or ownership assignment for the principal is granted through activation or direct assignment. Required. The possible values are: assigned, activated, unknownFutureValue. Supports $filter (eq).'
        ),
    ] = None
    group_id: Annotated[
        Optional[str],
        Field(
            description='The identifier of the group representing the scope of the membership or ownership assignment through PIM for groups. Required. Supports $filter (eq).'
        ),
    ] = None
    member_type: Annotated[
        Optional[Union[PrivilegedAccessGroupMemberType, Dict[str, Any]]],
        Field(
            description='Indicates whether the assignment is derived from a direct group assignment or through a transitive assignment. The possible values are: direct, group, unknownFutureValue. Supports $filter (eq).'
        ),
    ] = None
    principal_id: Annotated[
        Optional[str],
        Field(
            description='The identifier of the principal whose membership or ownership assignment is granted through PIM for groups. Required. Supports $filter (eq).'
        ),
    ] = None
    activated_using: Annotated[
        Optional[Union[PrivilegedAccessGroupEligibilitySchedule, Dict[str, Any]]],
        Field(
            description="When the request activates an ownership or membership assignment in PIM for groups, this object represents the eligibility relationship. Otherwise, it's null. Supports $expand."
        ),
    ] = None
    group: Annotated[
        Optional[Union[Group, Dict[str, Any]]],
        Field(
            description='References the group that is the scope of the membership or ownership assignment through PIM for groups. Supports $expand and $select nested in $expand for select properties like id, displayName, and mail.'
        ),
    ] = None
    principal: Annotated[
        Optional[Union[DirectoryObject, Dict[str, Any]]],
        Field(
            description="References the principal that's in the scope of this membership or ownership assignment request to the group that's governed through PIM. Supports $expand and $select nested in $expand for id only."
        ),
    ] = None
    field_odata_type: str


class PrivilegedAccessGroupAssignmentScheduleInstance(PrivilegedAccessScheduleInstance):
    access_id: Annotated[
        Optional[Union[PrivilegedAccessGroupRelationships, Dict[str, Any]]],
        Field(
            description='The identifier of the membership or ownership assignment relationship to the group. Required. The possible values are: owner, member,  unknownFutureValue. Supports $filter (eq).'
        ),
    ] = None
    assignment_schedule_id: Annotated[
        Optional[str],
        Field(
            description='The identifier of the privilegedAccessGroupAssignmentSchedule from which this instance was created. Required. Supports $filter (eq, ne).'
        ),
    ] = None
    assignment_type: Annotated[
        Optional[Union[PrivilegedAccessGroupAssignmentType, Dict[str, Any]]],
        Field(
            description='Indicates whether the membership or ownership assignment is granted through activation of an eligibility or through direct assignment. Required. The possible values are: assigned, activated, unknownFutureValue. Supports $filter (eq).'
        ),
    ] = None
    group_id: Annotated[
        Optional[str],
        Field(
            description='The identifier of the group representing the scope of the membership or ownership assignment through PIM for groups. Optional. Supports $filter (eq).'
        ),
    ] = None
    member_type: Annotated[
        Optional[Union[PrivilegedAccessGroupMemberType, Dict[str, Any]]],
        Field(
            description='Indicates whether the assignment is derived from a group assignment. It can further imply whether the caller can manage the assignment schedule. Required. The possible values are: direct, group, unknownFutureValue. Supports $filter (eq).'
        ),
    ] = None
    principal_id: Annotated[
        Optional[str],
        Field(
            description='The identifier of the principal whose membership or ownership assignment to the group is managed through PIM for groups. Required. Supports $filter (eq).'
        ),
    ] = None
    activated_using: Annotated[
        Optional[
            Union[PrivilegedAccessGroupEligibilityScheduleInstance, Dict[str, Any]]
        ],
        Field(
            description='When the request activates a membership or ownership in PIM for groups, this object represents the eligibility request for the group. Otherwise, it is null.'
        ),
    ] = None
    group: Annotated[
        Optional[Union[Group, Dict[str, Any]]],
        Field(
            description='References the group that is the scope of the membership or ownership assignment through PIM for groups. Supports $expand.'
        ),
    ] = None
    principal: Annotated[
        Optional[Union[DirectoryObject, Dict[str, Any]]],
        Field(
            description="References the principal that's in the scope of the membership or ownership assignment request through the group that's governed by PIM. Supports $expand."
        ),
    ] = None
    field_odata_type: str


class PrivilegedAccessGroupAssignmentScheduleRequest(PrivilegedAccessScheduleRequest):
    access_id: Annotated[
        Optional[Union[PrivilegedAccessGroupRelationships, Dict[str, Any]]],
        Field(
            description='The identifier of a membership or ownership assignment relationship to the group. Required. The possible values are: owner, member, unknownFutureValue.'
        ),
    ] = None
    group_id: Annotated[
        Optional[str],
        Field(
            description='The identifier of the group representing the scope of the membership or ownership assignment through PIM for groups. Required.'
        ),
    ] = None
    principal_id: Annotated[
        Optional[str],
        Field(
            description='The identifier of the principal whose membership or ownership assignment to the group is managed through PIM for groups. Supports $filter (eq, ne).'
        ),
    ] = None
    target_schedule_id: Annotated[
        Optional[str],
        Field(
            description="The identifier of the schedule that's created from the membership or ownership assignment request. Supports $filter (eq, ne)."
        ),
    ] = None
    activated_using: Annotated[
        Optional[Union[PrivilegedAccessGroupEligibilitySchedule, Dict[str, Any]]],
        Field(
            description='When the request activates a membership or ownership assignment in PIM for groups, this object represents the eligibility policy for the group. Otherwise, it is null. Supports $expand.'
        ),
    ] = None
    group: Annotated[
        Optional[Union[Group, Dict[str, Any]]],
        Field(
            description='References the group that is the scope of the membership or ownership assignment request through PIM for groups. Supports $expand and $select nested in $expand for select properties like id, displayName, and mail.'
        ),
    ] = None
    principal: Annotated[
        Optional[Union[DirectoryObject, Dict[str, Any]]],
        Field(
            description="References the principal that's in the scope of this membership or ownership assignment request through the group that's governed by PIM. Supports $expand and $select nested in $expand for id only."
        ),
    ] = None
    target_schedule: Annotated[
        Optional[Union[PrivilegedAccessGroupEligibilitySchedule, Dict[str, Any]]],
        Field(description='Schedule created by this request. Supports $expand.'),
    ] = None
    field_odata_type: str


class PrivilegedAccessGroupEligibilitySchedule(PrivilegedAccessSchedule):
    access_id: Annotated[
        Optional[Union[PrivilegedAccessGroupRelationships, Dict[str, Any]]],
        Field(
            description='The identifier of the membership or ownership eligibility to the group that is governed by PIM. Required. The possible values are: owner, member. Supports $filter (eq).'
        ),
    ] = None
    group_id: Annotated[
        Optional[str],
        Field(
            description='The identifier of the group representing the scope of the membership or ownership eligibility through PIM for groups. Required. Supports $filter (eq).'
        ),
    ] = None
    member_type: Annotated[
        Optional[Union[PrivilegedAccessGroupMemberType, Dict[str, Any]]],
        Field(
            description='Indicates whether the assignment is derived from a group assignment. It can further imply whether the caller can manage the schedule. Required. The possible values are: direct, group, unknownFutureValue. Supports $filter (eq).'
        ),
    ] = None
    principal_id: Annotated[
        Optional[str],
        Field(
            description='The identifier of the principal whose membership or ownership eligibility is granted through PIM for groups. Required. Supports $filter (eq).'
        ),
    ] = None
    group: Annotated[
        Optional[Union[Group, Dict[str, Any]]],
        Field(
            description='References the group that is the scope of the membership or ownership eligibility through PIM for groups. Supports $expand.'
        ),
    ] = None
    principal: Annotated[
        Optional[Union[DirectoryObject, Dict[str, Any]]],
        Field(
            description="References the principal that's in the scope of this membership or ownership eligibility request to the group that's governed by PIM. Supports $expand."
        ),
    ] = None
    field_odata_type: str


class PrivilegedAccessGroupEligibilityScheduleInstance(
    PrivilegedAccessScheduleInstance
):
    access_id: Annotated[
        Optional[Union[PrivilegedAccessGroupRelationships, Dict[str, Any]]],
        Field(
            description='The identifier of the membership or ownership eligibility relationship to the group. Required. The possible values are: owner, member. Supports $filter (eq).'
        ),
    ] = None
    eligibility_schedule_id: Annotated[
        Optional[str],
        Field(
            description='The identifier of the privilegedAccessGroupEligibilitySchedule from which this instance was created. Required. Supports $filter (eq, ne).'
        ),
    ] = None
    group_id: Annotated[
        Optional[str],
        Field(
            description='The identifier of the group representing the scope of the membership or ownership eligibility through PIM for groups. Required. Supports $filter (eq).'
        ),
    ] = None
    member_type: Annotated[
        Optional[Union[PrivilegedAccessGroupMemberType, Dict[str, Any]]],
        Field(
            description='Indicates whether the assignment is derived from a group assignment. It can further imply whether the calling principal can manage the assignment schedule. Required. The possible values are: direct, group, unknownFutureValue. Supports $filter (eq).'
        ),
    ] = None
    principal_id: Annotated[
        Optional[str],
        Field(
            description='The identifier of the principal whose membership or ownership eligibility to the group is managed through PIM for groups. Required. Supports $filter (eq).'
        ),
    ] = None
    group: Annotated[
        Optional[Union[Group, Dict[str, Any]]],
        Field(
            description='References the group that is the scope of the membership or ownership eligibility through PIM for groups. Supports $expand.'
        ),
    ] = None
    principal: Annotated[
        Optional[Union[DirectoryObject, Dict[str, Any]]],
        Field(
            description="References the principal that's in the scope of the membership or ownership eligibility request through the group that's governed by PIM. Supports $expand."
        ),
    ] = None
    field_odata_type: str


class PrivilegedAccessGroupEligibilityScheduleRequest(PrivilegedAccessScheduleRequest):
    access_id: Annotated[
        Optional[Union[PrivilegedAccessGroupRelationships, Dict[str, Any]]],
        Field(
            description='The identifier of membership or ownership eligibility relationship to the group. Required. The possible values are: owner, member, unknownFutureValue.'
        ),
    ] = None
    group_id: Annotated[
        Optional[str],
        Field(
            description='The identifier of the group representing the scope of the membership and ownership eligibility through PIM for groups. Required.'
        ),
    ] = None
    principal_id: Annotated[
        Optional[str],
        Field(
            description='The identifier of the principal whose membership or ownership eligibility to the group is managed through PIM for groups. Required.'
        ),
    ] = None
    target_schedule_id: Annotated[
        Optional[str],
        Field(
            description="The identifier of the schedule that's created from the eligibility request. Optional."
        ),
    ] = None
    group: Annotated[
        Optional[Union[Group, Dict[str, Any]]],
        Field(
            description='References the group that is the scope of the membership or ownership eligibility request through PIM for groups. Supports $expand and $select nested in $expand for select properties like id, displayName, and mail.'
        ),
    ] = None
    principal: Annotated[
        Optional[Union[DirectoryObject, Dict[str, Any]]],
        Field(
            description="References the principal that's in the scope of the membership or ownership eligibility request through the group that's governed by PIM. Supports $expand and $select nested in $expand for id only."
        ),
    ] = None
    target_schedule: Annotated[
        Optional[Union[PrivilegedAccessGroupEligibilitySchedule, Dict[str, Any]]],
        Field(description='Schedule created by this request.'),
    ] = None
    field_odata_type: str


class PrivilegedAccessRoot(Entity):
    group: Annotated[
        Optional[Union[PrivilegedAccessGroup, Dict[str, Any]]],
        Field(
            description="A group that's governed through Privileged Identity Management (PIM)."
        ),
    ] = None
    field_odata_type: str


class RiskyServicePrincipal(Entity):
    app_id: Annotated[
        Optional[str],
        Field(
            description='The globally unique identifier for the associated application (its appId property), if any.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The display name for the service principal.')
    ] = None
    is_enabled: Annotated[
        Optional[bool],
        Field(
            description='true if the service principal account is enabled; otherwise, false.'
        ),
    ] = None
    is_processing: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether Microsoft Entra ID is currently processing the service principal's risky state."
        ),
    ] = None
    risk_detail: Annotated[
        Optional[Union[RiskDetail, Dict[str, Any]]],
        Field(
            description='Details of the detected risk. Note: Details for this property are only available for Workload Identities Premium customers. Events in tenants without this license will be returned hidden. The possible values are: none, hidden,  unknownFutureValue, adminConfirmedServicePrincipalCompromised, adminDismissedAllRiskForServicePrincipal. Use the Prefer: include-unknown-enum-members request header to get the following value(s) in this evolvable enum: adminConfirmedServicePrincipalCompromised , adminDismissedAllRiskForServicePrincipal.'
        ),
    ] = None
    risk_last_updated_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time that the risk state was last updated. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2021 is 2021-01-01T00:00:00Z. Supports $filter (eq).',
        ),
    ] = None
    risk_level: Annotated[
        Optional[Union[RiskLevel, Dict[str, Any]]],
        Field(
            description='Level of the detected risky workload identity. The possible values are: low, medium, high, hidden, none, unknownFutureValue. Supports $filter (eq).'
        ),
    ] = None
    risk_state: Annotated[
        Optional[Union[RiskState, Dict[str, Any]]],
        Field(
            description="State of the service principal's risk. The possible values are: none, confirmedSafe, remediated, dismissed, atRisk, confirmedCompromised, unknownFutureValue."
        ),
    ] = None
    service_principal_type: Annotated[
        Optional[str],
        Field(
            description='Identifies whether the service principal represents an Application, a ManagedIdentity, or a legacy application (socialIdp). This is set by Microsoft Entra ID internally and is inherited from servicePrincipal.'
        ),
    ] = None
    history: Annotated[
        Optional[List[RiskyServicePrincipalHistoryItem]],
        Field(
            description='Represents the risk history of Microsoft Entra service principals.'
        ),
    ] = None
    field_odata_type: str


class RiskyUser(Entity):
    is_deleted: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the user is deleted. Possible values are: true, false.'
        ),
    ] = None
    is_processing: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether the backend is processing a user's risky state."
        ),
    ] = None
    risk_detail: Annotated[
        Optional[Union[RiskDetail, Dict[str, Any]]],
        Field(
            description='The possible values are none, adminGeneratedTemporaryPassword, userPerformedSecuredPasswordChange, userPerformedSecuredPasswordReset, adminConfirmedSigninSafe, aiConfirmedSigninSafe, userPassedMFADrivenByRiskBasedPolicy, adminDismissedAllRiskForUser, adminConfirmedSigninCompromised, hidden, adminConfirmedUserCompromised, unknownFutureValue, adminConfirmedServicePrincipalCompromised, adminDismissedAllRiskForServicePrincipal, m365DAdminDismissedDetection, userChangedPasswordOnPremises, adminDismissedRiskForSignIn, adminConfirmedAccountSafe. Use the Prefer: include-unknown-enum-members request header to get the following value or values in this evolvable enum: adminConfirmedServicePrincipalCompromised, adminDismissedAllRiskForServicePrincipal, m365DAdminDismissedDetection, userChangedPasswordOnPremises, adminDismissedRiskForSignIn, adminConfirmedAccountSafe.'
        ),
    ] = None
    risk_last_updated_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time that the risky user was last updated. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    risk_level: Annotated[
        Optional[Union[RiskLevel, Dict[str, Any]]],
        Field(
            description='Level of the detected risky user. Possible values are: low, medium, high, hidden, none, unknownFutureValue.'
        ),
    ] = None
    risk_state: Annotated[
        Optional[Union[RiskState, Dict[str, Any]]],
        Field(
            description="State of the user's risk. Possible values are: none, confirmedSafe, remediated, dismissed, atRisk, confirmedCompromised, unknownFutureValue."
        ),
    ] = None
    user_display_name: Annotated[
        Optional[str], Field(description='Risky user display name.')
    ] = None
    user_principal_name: Annotated[
        Optional[str], Field(description='Risky user principal name.')
    ] = None
    history: Annotated[
        Optional[List[RiskyUserHistoryItem]],
        Field(description='The activity related to user risk level change'),
    ] = None
    field_odata_type: str


class RoleAssignment(Entity):
    description: Annotated[
        Optional[str], Field(description='Description of the Role Assignment.')
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(description='The display or friendly name of the role Assignment.'),
    ] = None
    resource_scopes: Annotated[
        Optional[List[str]],
        Field(
            description='List of ids of role scope member security groups.  These are IDs from Azure Active Directory.'
        ),
    ] = None
    role_definition: Annotated[
        Optional[Union[RoleDefinition, Dict[str, Any]]],
        Field(description='Role definition this assignment is part of.'),
    ] = None
    field_odata_type: str


class RoleDefinition(Entity):
    description: Annotated[
        Optional[str], Field(description='Description of the Role definition.')
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='Display Name of the Role definition.')
    ] = None
    is_built_in: Annotated[
        Optional[bool],
        Field(
            description='Type of Role. Set to True if it is built-in, or set to False if it is a custom role definition.'
        ),
    ] = None
    role_permissions: Annotated[
        Optional[List[RolePermission]],
        Field(
            description='List of Role Permissions this role is allowed to perform. These must match the actionName that is defined as part of the rolePermission.'
        ),
    ] = None
    role_assignments: Annotated[
        Optional[List[RoleAssignment]],
        Field(description='List of Role assignments for this role definition.'),
    ] = None
    field_odata_type: str


class SectionGroup(OnenoteEntityHierarchyModel):
    section_groups_url: Annotated[
        Optional[str],
        Field(
            description='The URL for the sectionGroups navigation property, which returns all the section groups in the section group. Read-only.'
        ),
    ] = None
    sections_url: Annotated[
        Optional[str],
        Field(
            description='The URL for the sections navigation property, which returns all the sections in the section group. Read-only.'
        ),
    ] = None
    parent_notebook: Annotated[
        Optional[Union[Notebook, Dict[str, Any]]],
        Field(description='The notebook that contains the section group. Read-only.'),
    ] = None
    parent_section_group: Annotated[
        Optional[Union[SectionGroup, Dict[str, Any]]],
        Field(
            description='The section group that contains the section group. Read-only.'
        ),
    ] = None
    section_groups: Annotated[
        Optional[List[SectionGroup]],
        Field(description='The section groups in the section. Read-only. Nullable.'),
    ] = None
    sections: Annotated[
        Optional[List[OnenoteSection]],
        Field(description='The sections in the section group. Read-only. Nullable.'),
    ] = None
    field_odata_type: str


class Security(Entity):
    alerts: Optional[List[Alert]] = None
    alerts_v2: Annotated[
        Optional[List[security.Alert]],
        Field(description='A collection of alerts in Microsoft 365 Defender.'),
    ] = None
    attack_simulation: Optional[Union[AttackSimulationRoot, Dict[str, Any]]] = None
    cases: Optional[Union[security.CasesRoot, Dict[str, Any]]] = None
    identities: Annotated[
        Optional[Union[security.IdentityContainer, Dict[str, Any]]],
        Field(description='A container for security identities APIs.'),
    ] = None
    incidents: Annotated[
        Optional[List[security.Incident]],
        Field(
            description='A collection of incidents in Microsoft 365 Defender, each of which is a set of correlated alerts and associated metadata that reflects the story of an attack.'
        ),
    ] = None
    labels: Optional[Union[security.LabelsRoot, Dict[str, Any]]] = None
    secure_score_control_profiles: Optional[List[SecureScoreControlProfile]] = None
    secure_scores: Optional[List[SecureScore]] = None
    subject_rights_requests: Optional[List[SubjectRightsRequest]] = None
    threat_intelligence: Optional[
        Union[security.ThreatIntelligence, Dict[str, Any]]
    ] = None
    triggers: Optional[Union[security.TriggersRoot, Dict[str, Any]]] = None
    trigger_types: Optional[Union[security.TriggerTypesRoot, Dict[str, Any]]] = None
    field_odata_type: str


class ServicePrincipal(DirectoryObject):
    account_enabled: Annotated[
        Optional[bool],
        Field(
            description="true if the service principal account is enabled; otherwise, false. If set to false, then no users are able to sign in to this app, even if they're assigned to it. Supports $filter (eq, ne, not, in)."
        ),
    ] = None
    add_ins: Annotated[
        Optional[List[AddIn]],
        Field(
            description="Defines custom behavior that a consuming service can use to call an app in specific contexts. For example, applications that can render file streams may set the addIns property for its 'FileHandler' functionality. This lets services like Microsoft 365 call the application in the context of a document the user is working on."
        ),
    ] = None
    alternative_names: Annotated[
        Optional[List[str]],
        Field(
            description='Used to retrieve service principals by subscription, identify resource group and full resource IDs for managed identities. Supports $filter (eq, not, ge, le, startsWith).'
        ),
    ] = None
    app_description: Annotated[
        Optional[str],
        Field(description='The description exposed by the associated application.'),
    ] = None
    app_display_name: Annotated[
        Optional[str],
        Field(
            description='The display name exposed by the associated application. Maximum length is 256 characters.'
        ),
    ] = None
    app_id: Annotated[
        Optional[str],
        Field(
            description='The unique identifier for the associated application (its appId property). Alternate key. Supports $filter (eq, ne, not, in, startsWith).'
        ),
    ] = None
    application_template_id: Annotated[
        Optional[str],
        Field(
            description="Unique identifier of the applicationTemplate. Supports $filter (eq, not, ne). Read-only. null if the service principal wasn't created from an application template."
        ),
    ] = None
    app_owner_organization_id: Annotated[
        Optional[UUID],
        Field(
            description='Contains the tenant ID where the application is registered. This is applicable only to service principals backed by applications. Supports $filter (eq, ne, NOT, ge, le).',
        ),
    ] = None
    app_role_assignment_required: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether users or other service principals need to be granted an app role assignment for this service principal before users can sign in or apps can get tokens. The default value is false. Not nullable. Supports $filter (eq, ne, NOT).'
        ),
    ] = None
    app_roles: Annotated[
        Optional[List[AppRole]],
        Field(
            description="The roles exposed by the application that's linked to this service principal. For more information, see the appRoles property definition on the application entity. Not nullable."
        ),
    ] = None
    custom_security_attributes: Annotated[
        Optional[Union[CustomSecurityAttributeValue, Dict[str, Any]]],
        Field(
            description='An open complex type that holds the value of a custom security attribute that is assigned to a directory object. Nullable. Returned only on $select. Supports $filter (eq, ne, not, startsWith). Filter value is case sensitive. To read this property, the calling app must be assigned the CustomSecAttributeAssignment.Read.All permission. To write this property, the calling app must be assigned the CustomSecAttributeAssignment.ReadWrite.All permissions. To read or write this property in delegated scenarios, the admin must be assigned the Attribute Assignment Administrator role.'
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='Free text field to provide an internal end-user facing description of the service principal. End-user portals such MyApps displays the application description in this field. The maximum allowed size is 1,024 characters. Supports $filter (eq, ne, not, ge, le, startsWith) and $search.'
        ),
    ] = None
    disabled_by_microsoft_status: Annotated[
        Optional[str],
        Field(
            description='Specifies whether Microsoft has disabled the registered application. Possible values are: null (default value), NotDisabled, and DisabledDueToViolationOfServicesAgreement (reasons include suspicious, abusive, or malicious activity, or a violation of the Microsoft Services Agreement).  Supports $filter (eq, ne, not).'
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description='The display name for the service principal. Supports $filter (eq, ne, not, ge, le, in, startsWith, and eq on null values), $search, and $orderby.'
        ),
    ] = None
    homepage: Annotated[
        Optional[str],
        Field(description='Home page or landing page of the application.'),
    ] = None
    info: Annotated[
        Optional[Union[InformationalUrl, Dict[str, Any]]],
        Field(
            description="Basic profile information of the acquired application such as app's marketing, support, terms of service and privacy statement URLs. The terms of service and privacy statement are surfaced to users through the user consent experience. For more info, see How to: Add Terms of service and privacy statement for registered Microsoft Entra apps. Supports $filter (eq, ne, not, ge, le, and eq on null values)."
        ),
    ] = None
    key_credentials: Annotated[
        Optional[List[KeyCredential]],
        Field(
            description='The collection of key credentials associated with the service principal. Not nullable. Supports $filter (eq, not, ge, le).'
        ),
    ] = None
    login_url: Annotated[
        Optional[str],
        Field(
            description='Specifies the URL where the service provider redirects the user to Microsoft Entra ID to authenticate. Microsoft Entra ID uses the URL to launch the application from Microsoft 365 or the Microsoft Entra My Apps. When blank, Microsoft Entra ID performs IdP-initiated sign-on for applications configured with SAML-based single sign-on. The user launches the application from Microsoft 365, the Microsoft Entra My Apps, or the Microsoft Entra SSO URL.'
        ),
    ] = None
    logout_url: Annotated[
        Optional[str],
        Field(
            description="Specifies the URL that the Microsoft's authorization service uses to sign out a user using OpenID Connect front-channel, back-channel, or SAML sign out protocols."
        ),
    ] = None
    notes: Annotated[
        Optional[str],
        Field(
            description='Free text field to capture information about the service principal, typically used for operational purposes. Maximum allowed size is 1,024 characters.'
        ),
    ] = None
    notification_email_addresses: Annotated[
        Optional[List[str]],
        Field(
            description='Specifies the list of email addresses where Microsoft Entra ID sends a notification when the active certificate is near the expiration date. This is only for the certificates used to sign the SAML token issued for Microsoft Entra Gallery applications.'
        ),
    ] = None
    oauth2_permission_scopes: Annotated[
        Optional[List[PermissionScope]],
        Field(
            description="The delegated permissions exposed by the application. For more information, see the oauth2PermissionScopes property on the application entity's api property. Not nullable."
        ),
    ] = None
    password_credentials: Annotated[
        Optional[List[PasswordCredential]],
        Field(
            description='The collection of password credentials associated with the application. Not nullable.'
        ),
    ] = None
    preferred_single_sign_on_mode: Annotated[
        Optional[str],
        Field(
            description="Specifies the single sign-on mode configured for this application. Microsoft Entra ID uses the preferred single sign-on mode to launch the application from Microsoft 365 or the My Apps portal. The supported values are password, saml, notSupported, and oidc. Note: This field might be null for older SAML apps and for OIDC applications where it isn't set automatically."
        ),
    ] = None
    preferred_token_signing_key_thumbprint: Annotated[
        Optional[str],
        Field(
            description="This property can be used on SAML applications (apps that have preferredSingleSignOnMode set to saml) to control which certificate is used to sign the SAML responses. For applications that aren't SAML, don't write or otherwise rely on this property."
        ),
    ] = None
    reply_urls: Annotated[
        Optional[List[str]],
        Field(
            description='The URLs that user tokens are sent to for sign in with the associated application, or the redirect URIs that OAuth 2.0 authorization codes and access tokens are sent to for the associated application. Not nullable.'
        ),
    ] = None
    resource_specific_application_permissions: Annotated[
        Optional[List[ResourceSpecificPermission]],
        Field(
            description='The resource-specific application permissions exposed by this application. Currently, resource-specific permissions are only supported for Teams apps accessing to specific chats and teams using Microsoft Graph. Read-only.'
        ),
    ] = None
    saml_single_sign_on_settings: Annotated[
        Optional[Union[SamlSingleSignOnSettings, Dict[str, Any]]],
        Field(
            description='The collection for settings related to saml single sign-on.'
        ),
    ] = None
    service_principal_names: Annotated[
        Optional[List[str]],
        Field(
            description="Contains the list of identifiersUris, copied over from the associated application. Additional values can be added to hybrid applications. These values can be used to identify the permissions exposed by this app within Microsoft Entra ID. For example,Client apps can specify a resource URI that is based on the values of this property to acquire an access token, which is the URI returned in the 'aud' claim.The any operator is required for filter expressions on multi-valued properties. Not nullable.  Supports $filter (eq, not, ge, le, startsWith)."
        ),
    ] = None
    service_principal_type: Annotated[
        Optional[str],
        Field(
            description="Identifies whether the service principal represents an application, a managed identity, or a legacy application. This is set by Microsoft Entra ID internally. The servicePrincipalType property can be set to three different values: Application - A service principal that represents an application or service. The appId property identifies the associated app registration, and matches the appId of an application, possibly from a different tenant. If the associated app registration is missing, tokens aren't issued for the service principal.ManagedIdentity - A service principal that represents a managed identity. Service principals representing managed identities can be granted access and permissions, but can't be updated or modified directly.Legacy - A service principal that represents an app created before app registrations, or through legacy experiences. A legacy service principal can have credentials, service principal names, reply URLs, and other properties that are editable by an authorized user, but doesn't have an associated app registration. The appId value doesn't associate the service principal with an app registration. The service principal can only be used in the tenant where it was created.SocialIdp - For internal use."
        ),
    ] = None
    sign_in_audience: Annotated[
        Optional[str],
        Field(
            description="Specifies the Microsoft accounts that are supported for the current application. Read-only. Supported values are:AzureADMyOrg: Users with a Microsoft work or school account in my organization's Microsoft Entra tenant (single-tenant).AzureADMultipleOrgs: Users with a Microsoft work or school account in any organization's Microsoft Entra tenant (multitenant).AzureADandPersonalMicrosoftAccount: Users with a personal Microsoft account, or a work or school account in any organization's Microsoft Entra tenant.PersonalMicrosoftAccount: Users with a personal Microsoft account only."
        ),
    ] = None
    tags: Annotated[
        Optional[List[str]],
        Field(
            description="Custom strings that can be used to categorize and identify the service principal. Not nullable. The value is the union of strings set here and on the associated application entity's tags property.Supports $filter (eq, not, ge, le, startsWith)."
        ),
    ] = None
    token_encryption_key_id: Annotated[
        Optional[UUID],
        Field(
            description='Specifies the keyId of a public key from the keyCredentials collection. When configured, Microsoft Entra ID issues tokens for this application encrypted using the key specified by this property. The application code that receives the encrypted token must use the matching private key to decrypt the token before it can be used for the signed-in user.',
        ),
    ] = None
    verified_publisher: Annotated[
        Optional[Union[VerifiedPublisher, Dict[str, Any]]],
        Field(
            description="Specifies the verified publisher of the application that's linked to this service principal."
        ),
    ] = None
    app_management_policies: Annotated[
        Optional[List[AppManagementPolicy]],
        Field(description='The appManagementPolicy applied to this application.'),
    ] = None
    app_role_assigned_to: Annotated[
        Optional[List[AppRoleAssignment]],
        Field(
            description='App role assignments for this app or service, granted to users, groups, and other service principals. Supports $expand.'
        ),
    ] = None
    app_role_assignments: Annotated[
        Optional[List[AppRoleAssignment]],
        Field(
            description='App role assignment for another app or service, granted to this service principal. Supports $expand.'
        ),
    ] = None
    claims_mapping_policies: Annotated[
        Optional[List[ClaimsMappingPolicy]],
        Field(
            description='The claimsMappingPolicies assigned to this service principal. Supports $expand.'
        ),
    ] = None
    created_objects: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description='Directory objects created by this service principal. Read-only. Nullable.'
        ),
    ] = None
    delegated_permission_classifications: Optional[
        List[DelegatedPermissionClassification]
    ] = None
    endpoints: Optional[List[Endpoint]] = None
    federated_identity_credentials: Annotated[
        Optional[List[FederatedIdentityCredential]],
        Field(
            description='Federated identities for a specific type of service principal - managed identity. Supports $expand and $filter (/$count eq 0, /$count ne 0).'
        ),
    ] = None
    home_realm_discovery_policies: Annotated[
        Optional[List[HomeRealmDiscoveryPolicy]],
        Field(
            description='The homeRealmDiscoveryPolicies assigned to this service principal. Supports $expand.'
        ),
    ] = None
    member_of: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description='Roles that this service principal is a member of. HTTP Methods: GET Read-only. Nullable. Supports $expand.'
        ),
    ] = None
    oauth2_permission_grants: Annotated[
        Optional[List[OAuth2PermissionGrant]],
        Field(
            description='Delegated permission grants authorizing this service principal to access an API on behalf of a signed-in user. Read-only. Nullable.'
        ),
    ] = None
    owned_objects: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description='Directory objects that this service principal owns. Read-only. Nullable. Supports $expand, $select nested in $expand, and $filter (/$count eq 0, /$count ne 0, /$count eq 1, /$count ne 1).'
        ),
    ] = None
    owners: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description='Directory objects that are owners of this servicePrincipal. The owners are a set of nonadmin users or servicePrincipals who are allowed to modify this object. Read-only. Nullable. Supports $expand, $filter (/$count eq 0, /$count ne 0, /$count eq 1, /$count ne 1), and $select nested in $expand.'
        ),
    ] = None
    remote_desktop_security_configuration: Annotated[
        Optional[Union[RemoteDesktopSecurityConfiguration, Dict[str, Any]]],
        Field(
            description='The remoteDesktopSecurityConfiguration object applied to this service principal. Supports $filter (eq) for isRemoteDesktopProtocolEnabled property.'
        ),
    ] = None
    synchronization: Annotated[
        Optional[Union[Synchronization, Dict[str, Any]]],
        Field(
            description='Represents the capability for Microsoft Entra identity synchronization through the Microsoft Graph API.'
        ),
    ] = None
    token_issuance_policies: Annotated[
        Optional[List[TokenIssuancePolicy]],
        Field(
            description='The tokenIssuancePolicies assigned to this service principal.'
        ),
    ] = None
    token_lifetime_policies: Annotated[
        Optional[List[TokenLifetimePolicy]],
        Field(
            description='The tokenLifetimePolicies assigned to this service principal.'
        ),
    ] = None
    transitive_member_of: Optional[List[DirectoryObject]] = None
    field_odata_type: str


class Storage(BaseModel):
    file_storage: Optional[Union[FileStorage, Dict[str, Any]]] = None
    settings: Optional[Union[StorageSettings, Dict[str, Any]]] = None
    field_odata_type: str


class SubjectRightsRequest(Entity):
    assigned_to: Annotated[
        Optional[Union[Identity, Dict[str, Any]]],
        Field(description='Identity that the request is assigned to.'),
    ] = None
    closed_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the request was closed. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    content_query: Annotated[
        Optional[str],
        Field(
            description='KQL based content query that should be used for search. This property is defined only for APIs accessed using the /security query path and not the /privacy query path.'
        ),
    ] = None
    created_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(
            description='Identity information for the entity that created the request.'
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the request was created. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    data_subject: Annotated[
        Optional[Union[DataSubject, Dict[str, Any]]],
        Field(description='Information about the data subject.'),
    ] = None
    data_subject_type: Annotated[
        Optional[Union[DataSubjectType, Dict[str, Any]]],
        Field(
            description='The type of the data subject. Possible values are: customer, currentEmployee, formerEmployee, prospectiveEmployee, student, teacher, faculty, other, unknownFutureValue.'
        ),
    ] = None
    description: Annotated[
        Optional[str], Field(description='Description for the request.')
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The name of the request.')
    ] = None
    external_id: Annotated[
        Optional[str],
        Field(
            description='The external ID for the request that is immutable after creation and is used for tracking the request for the external system. This property is defined only for APIs accessed using the /security query path and not the /privacy query path.'
        ),
    ] = None
    history: Annotated[
        Optional[List[SubjectRightsRequestHistory]],
        Field(description='Collection of history change events.'),
    ] = None
    include_all_versions: Annotated[
        Optional[bool],
        Field(
            description='Include all versions of the documents. By default, the current copies of the documents are returned. If SharePoint sites have versioning enabled, including all versions includes the historical copies of the documents. This property is defined only for APIs accessed using the /security query path and not the /privacy query path.'
        ),
    ] = None
    include_authored_content: Annotated[
        Optional[bool],
        Field(
            description='Include content authored by the data subject. This property is defined only for APIs accessed using the /security query path and not the /privacy query path.'
        ),
    ] = None
    insight: Annotated[
        Optional[Union[SubjectRightsRequestDetail, Dict[str, Any]]],
        Field(description='Insight about the request.'),
    ] = None
    internal_due_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the request is internally due. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    last_modified_by: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(
            description='Identity information for the entity that last modified the request.'
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the request was last modified. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    mailbox_locations: Annotated[
        Optional[Union[SubjectRightsRequestMailboxLocation, Dict[str, Any]]],
        Field(
            description='The mailbox locations that should be searched. This property is defined only for APIs accessed using the /security query path and not the /privacy query path.'
        ),
    ] = None
    pause_after_estimate: Annotated[
        Optional[bool],
        Field(
            description='Pause the request after estimate has finished. By default, the data estimate runs and then pauses, allowing you to preview results and then select the option to retrieve data in the UI. You can set this property to false if you want it to perform the estimate and then automatically begin with the retrieval of the content. This property is defined only for APIs accessed using the /security query path and not the /privacy query path.'
        ),
    ] = None
    regulations: Annotated[
        Optional[List[str]],
        Field(description='List of regulations that this request fulfill.'),
    ] = None
    site_locations: Annotated[
        Optional[Union[SubjectRightsRequestSiteLocation, Dict[str, Any]]],
        Field(
            description='The SharePoint and OneDrive site locations that should be searched. This property is defined only for APIs accessed using the /security query path and not the /privacy query path.'
        ),
    ] = None
    stages: Annotated[
        Optional[List[SubjectRightsRequestStageDetail]],
        Field(description='Information about the different stages for the request.'),
    ] = None
    status: Annotated[
        Optional[Union[SubjectRightsRequestStatus, Dict[str, Any]]],
        Field(
            description='The status of the request. Possible values are: active, closed, unknownFutureValue.'
        ),
    ] = None
    type: Annotated[
        Optional[Union[SubjectRightsRequestType, Dict[str, Any]]],
        Field(
            description='The type of the request. Possible values are: export, delete, access, tagForAction, unknownFutureValue.'
        ),
    ] = None
    approvers: Annotated[
        Optional[List[User]],
        Field(
            description='Collection of users who can approve the request. Currently only supported for requests of type delete.'
        ),
    ] = None
    collaborators: Annotated[
        Optional[List[User]],
        Field(description='Collection of users who can collaborate on the request.'),
    ] = None
    notes: Annotated[
        Optional[List[AuthoredNote]],
        Field(description='List of notes associated with the request.'),
    ] = None
    team: Annotated[
        Optional[Union[Team, Dict[str, Any]]],
        Field(
            description='Information about the Microsoft Teams team that was created for the request.'
        ),
    ] = None
    field_odata_type: str


class Synchronization(Entity):
    secrets: Annotated[
        Optional[List[SynchronizationSecretKeyStringValuePair]],
        Field(
            description='Represents a collection of credentials to access provisioned cloud applications.'
        ),
    ] = None
    jobs: Annotated[
        Optional[List[SynchronizationJob]],
        Field(
            description='Performs synchronization by periodically running in the background, polling for changes in one directory, and pushing them to another directory.'
        ),
    ] = None
    templates: Annotated[
        Optional[List[SynchronizationTemplate]],
        Field(
            description='Preconfigured synchronization settings for a particular application.'
        ),
    ] = None
    field_odata_type: str


class SynchronizationJob(Entity):
    schedule: Annotated[
        Optional[Union[SynchronizationSchedule, Dict[str, Any]]],
        Field(description='Schedule used to run the job. Read-only.'),
    ] = None
    status: Annotated[
        Optional[Union[SynchronizationStatus, Dict[str, Any]]],
        Field(
            description='Status of the job, which includes when the job was last run, current job state, and errors.'
        ),
    ] = None
    synchronization_job_settings: Annotated[
        Optional[List[KeyValuePair]],
        Field(
            description='Settings associated with the job. Some settings are inherited from the template.'
        ),
    ] = None
    template_id: Annotated[
        Optional[str],
        Field(
            description='Identifier of the synchronization template this job is based on.'
        ),
    ] = None
    bulk_upload: Annotated[
        Optional[Union[BulkUpload, Dict[str, Any]]],
        Field(description='The bulk upload operation for the job.'),
    ] = None
    schema_: Annotated[
        Optional[Union[SynchronizationSchema, Dict[str, Any]]],
        Field(description='The synchronization schema configured for the job.'),
    ] = None
    field_odata_type: str


class SynchronizationSchema(Entity):
    synchronization_rules: Annotated[
        Optional[List[SynchronizationRule]],
        Field(
            description='A collection of synchronization rules configured for the synchronizationJob or synchronizationTemplate.'
        ),
    ] = None
    version: Annotated[
        Optional[str],
        Field(
            description='The version of the schema, updated automatically with every schema change.'
        ),
    ] = None
    directories: Annotated[
        Optional[List[DirectoryDefinition]],
        Field(
            description='Contains the collection of directories and all of their objects.'
        ),
    ] = None
    field_odata_type: str


class SynchronizationTemplate(Entity):
    application_id: Annotated[
        Optional[UUID],
        Field(
            description='Identifier of the application this template belongs to.',
        ),
    ] = None
    default: Annotated[
        Optional[bool],
        Field(
            description='true if this template is recommended to be the default for the application.'
        ),
    ] = None
    description: Annotated[
        Optional[str], Field(description='Description of the template.')
    ] = None
    discoverable: Annotated[
        Optional[bool],
        Field(
            description='true if this template should appear in the collection of templates available for the application instance (service principal).'
        ),
    ] = None
    factory_tag: Annotated[
        Optional[str],
        Field(
            description='One of the well-known factory tags supported by the synchronization engine. The factoryTag tells the synchronization engine which implementation to use when processing jobs based on this template.'
        ),
    ] = None
    metadata: Annotated[
        Optional[List[SynchronizationMetadataEntry]],
        Field(
            description='Additional extension properties. Unless mentioned explicitly, metadata values should not be changed.'
        ),
    ] = None
    schema_: Annotated[
        Optional[Union[SynchronizationSchema, Dict[str, Any]]],
        Field(
            description='Default synchronization schema for the jobs based on this template.'
        ),
    ] = None
    field_odata_type: str


class Team(Entity):
    classification: Annotated[
        Optional[str],
        Field(
            description="An optional label. Typically describes the data or business sensitivity of the team. Must match one of a preconfigured set in the tenant's directory."
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Timestamp at which the team was created.',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='An optional description for the team. Maximum length: 1,024 characters.'
        ),
    ] = None
    display_name: Annotated[
        Optional[str], Field(description='The name of the team.')
    ] = None
    fun_settings: Annotated[
        Optional[Union[TeamFunSettings, Dict[str, Any]]],
        Field(
            description='Settings to configure use of Giphy, memes, and stickers in the team.'
        ),
    ] = None
    guest_settings: Annotated[
        Optional[Union[TeamGuestSettings, Dict[str, Any]]],
        Field(
            description='Settings to configure whether guests can create, update, or delete channels in the team.'
        ),
    ] = None
    internal_id: Annotated[
        Optional[str],
        Field(
            description='A unique ID for the team that was used in a few places such as the audit log/Office 365 Management Activity API.'
        ),
    ] = None
    is_archived: Annotated[
        Optional[bool], Field(description='Whether this team is in read-only mode.')
    ] = None
    member_settings: Annotated[
        Optional[Union[TeamMemberSettings, Dict[str, Any]]],
        Field(
            description='Settings to configure whether members can perform certain actions, for example, create channels and add bots, in the team.'
        ),
    ] = None
    messaging_settings: Annotated[
        Optional[Union[TeamMessagingSettings, Dict[str, Any]]],
        Field(description='Settings to configure messaging and mentions in the team.'),
    ] = None
    specialization: Annotated[
        Optional[Union[TeamSpecialization, Dict[str, Any]]],
        Field(
            description='Optional. Indicates whether the team is intended for a particular use case. Each team specialization has access to unique behaviors and experiences targeted to its use case.'
        ),
    ] = None
    summary: Annotated[
        Optional[Union[TeamSummary, Dict[str, Any]]],
        Field(
            description='Contains summary information about the team, including number of owners, members, and guests.'
        ),
    ] = None
    tenant_id: Annotated[
        Optional[str], Field(description='The ID of the Microsoft Entra tenant.')
    ] = None
    visibility: Annotated[
        Optional[Union[TeamVisibilityType, Dict[str, Any]]],
        Field(description='The visibility of the group and team. Defaults to Public.'),
    ] = None
    web_url: Annotated[
        Optional[str],
        Field(
            description='A hyperlink that goes to the team in the Microsoft Teams client. You get this URL when you right-click a team in the Microsoft Teams client and select Get link to team. This URL should be treated as an opaque blob, and not parsed.'
        ),
    ] = None
    all_channels: Annotated[
        Optional[List[Channel]],
        Field(
            description='List of channels either hosted in or shared with the team (incoming channels).'
        ),
    ] = None
    channels: Annotated[
        Optional[List[Channel]],
        Field(
            description='The collection of channels and messages associated with the team.'
        ),
    ] = None
    group: Optional[Union[Group, Dict[str, Any]]] = None
    incoming_channels: Annotated[
        Optional[List[Channel]],
        Field(description='List of channels shared with the team.'),
    ] = None
    installed_apps: Annotated[
        Optional[List[TeamsAppInstallation]],
        Field(description='The apps installed in this team.'),
    ] = None
    members: Annotated[
        Optional[List[ConversationMember]],
        Field(description='Members and owners of the team.'),
    ] = None
    operations: Annotated[
        Optional[List[TeamsAsyncOperation]],
        Field(description='The async operations that ran or are running on this team.'),
    ] = None
    permission_grants: Annotated[
        Optional[List[ResourceSpecificPermissionGrant]],
        Field(
            description='A collection of permissions granted to apps to access the team.'
        ),
    ] = None
    photo: Annotated[
        Optional[Union[ProfilePhoto, Dict[str, Any]]],
        Field(description='The profile photo for the team.'),
    ] = None
    primary_channel: Annotated[
        Optional[Union[Channel, Dict[str, Any]]],
        Field(description='The general channel for the team.'),
    ] = None
    schedule: Annotated[
        Optional[Union[Schedule, Dict[str, Any]]],
        Field(description='The schedule of shifts for this team.'),
    ] = None
    tags: Annotated[
        Optional[List[TeamworkTag]],
        Field(description='The tags associated with the team.'),
    ] = None
    template: Annotated[
        Optional[Union[TeamsTemplate, Dict[str, Any]]],
        Field(
            description='The template this team was created from. See available templates.'
        ),
    ] = None
    field_odata_type: str


class TeamInfo(Entity):
    display_name: Annotated[
        Optional[str], Field(description='The name of the team.')
    ] = None
    tenant_id: Annotated[
        Optional[str], Field(description='The ID of the Microsoft Entra tenant.')
    ] = None
    team: Optional[Union[Team, Dict[str, Any]]] = None
    field_odata_type: str


class Teamwork(Entity):
    is_teams_enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether Microsoft Teams is enabled for the organization.'
        ),
    ] = None
    region: Annotated[
        Optional[str],
        Field(
            description='Represents the region of the organization or the tenant. The region value can be any region supported by the Teams payload. The possible values are: Americas, Europe and MiddleEast, Asia Pacific, UAE, Australia, Brazil, Canada, Switzerland, Germany, France, India, Japan, South Korea, Norway, Singapore, United Kingdom, South Africa, Sweden, Qatar, Poland, Italy, Israel, Spain, Mexico, USGov Community Cloud, USGov Community Cloud High, USGov Department of Defense, and China.'
        ),
    ] = None
    deleted_chats: Annotated[
        Optional[List[DeletedChat]], Field(description='A collection of deleted chats.')
    ] = None
    deleted_teams: Annotated[
        Optional[List[DeletedTeam]], Field(description='The deleted team.')
    ] = None
    teams_app_settings: Annotated[
        Optional[Union[TeamsAppSettings, Dict[str, Any]]],
        Field(
            description='Represents tenant-wide settings for all Teams apps in the tenant.'
        ),
    ] = None
    workforce_integrations: Optional[List[WorkforceIntegration]] = None
    field_odata_type: str


class TermsAndConditions(Entity):
    acceptance_statement: Annotated[
        Optional[str],
        Field(
            description='Administrator-supplied explanation of the terms and conditions, typically describing what it means to accept the terms and conditions set out in the T&C policy. This is shown to the user on prompts to accept the T&C policy.'
        ),
    ] = None
    body_text: Annotated[
        Optional[str],
        Field(
            description='Administrator-supplied body text of the terms and conditions, typically the terms themselves. This is shown to the user on prompts to accept the T&C policy.'
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='DateTime the object was created.',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(description='Administrator-supplied description of the T&C policy.'),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(description='Administrator-supplied name for the T&C policy.'),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='DateTime the object was last modified.',
        ),
    ] = None
    title: Annotated[
        Optional[str],
        Field(
            description='Administrator-supplied title of the terms and conditions. This is shown to the user on prompts to accept the T&C policy.'
        ),
    ] = None
    version: Annotated[
        Optional[float],
        Field(
            description='Integer indicating the current version of the terms. Incremented when an administrator makes a change to the terms and wishes to require users to re-accept the modified T&C policy.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    acceptance_statuses: Annotated[
        Optional[List[TermsAndConditionsAcceptanceStatus]],
        Field(description='The list of acceptance statuses for this T&C policy.'),
    ] = None
    assignments: Annotated[
        Optional[List[TermsAndConditionsAssignment]],
        Field(description='The list of assignments for this T&C policy.'),
    ] = None
    field_odata_type: str


class TermsAndConditionsAcceptanceStatus(Entity):
    accepted_date_time: Annotated[
        Optional[datetime],
        Field(
            description='DateTime when the terms were last accepted by the user.',
        ),
    ] = None
    accepted_version: Annotated[
        Optional[float],
        Field(
            description='Most recent version number of the T&C accepted by the user.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    user_display_name: Annotated[
        Optional[str],
        Field(
            description='Display name of the user whose acceptance the entity represents.'
        ),
    ] = None
    user_principal_name: Annotated[
        Optional[str],
        Field(description='The userPrincipalName of the User that accepted the term.'),
    ] = None
    terms_and_conditions: Annotated[
        Optional[Union[TermsAndConditions, Dict[str, Any]]],
        Field(
            description='Navigation link to the terms and conditions that are assigned.'
        ),
    ] = None
    field_odata_type: str


class User(DirectoryObject):
    about_me: Annotated[
        Optional[str],
        Field(
            description='A freeform text entry field for the user to describe themselves. Returned only on $select.'
        ),
    ] = None
    account_enabled: Annotated[
        Optional[bool],
        Field(
            description='true if the account is enabled; otherwise, false. This property is required when a user is created. Returned only on $select. Supports $filter (eq, ne, not, and in).'
        ),
    ] = None
    age_group: Annotated[
        Optional[str],
        Field(
            description='Sets the age group of the user. Allowed values: null, Minor, NotAdult, and Adult. For more information, see legal age group property definitions. Returned only on $select. Supports $filter (eq, ne, not, and in).'
        ),
    ] = None
    assigned_licenses: Annotated[
        Optional[List[AssignedLicense]],
        Field(
            description="The licenses that are assigned to the user, including inherited (group-based) licenses. This property doesn't differentiate between directly assigned and inherited licenses. Use the licenseAssignmentStates property to identify the directly assigned and inherited licenses. Not nullable. Returned only on $select. Supports $filter (eq, not, /$count eq 0, /$count ne 0)."
        ),
    ] = None
    assigned_plans: Annotated[
        Optional[List[AssignedPlan]],
        Field(
            description='The plans that are assigned to the user. Read-only. Not nullable. Returned only on $select. Supports $filter (eq and not).'
        ),
    ] = None
    authorization_info: Optional[Union[AuthorizationInfo, Dict[str, Any]]] = None
    birthday: Annotated[
        Optional[datetime],
        Field(
            description='The birthday of the user. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014, is 2014-01-01T00:00:00Z. Returned only on $select.',
        ),
    ] = None
    business_phones: Annotated[
        Optional[List[str]],
        Field(
            description="The telephone numbers for the user. NOTE: Although it's a string collection, only one number can be set for this property. Read-only for users synced from the on-premises directory. Returned by default. Supports $filter (eq, not, ge, le, startsWith)."
        ),
    ] = None
    city: Annotated[
        Optional[str],
        Field(
            description='The city where the user is located. Maximum length is 128 characters. Returned only on $select. Supports $filter (eq, ne, not, ge, le, in, startsWith, and eq on null values).'
        ),
    ] = None
    company_name: Annotated[
        Optional[str],
        Field(
            description='The name of the company that the user is associated with. This property can be useful for describing the company that a guest comes from. The maximum length is 64 characters.Returned only on $select. Supports $filter (eq, ne, not, ge, le, in, startsWith, and eq on null values).'
        ),
    ] = None
    consent_provided_for_minor: Annotated[
        Optional[str],
        Field(
            description='Sets whether consent was obtained for minors. Allowed values: null, Granted, Denied, and NotRequired. For more information, see legal age group property definitions. Returned only on $select. Supports $filter (eq, ne, not, and in).'
        ),
    ] = None
    country: Annotated[
        Optional[str],
        Field(
            description='The country/region where the user is located; for example, US or UK. Maximum length is 128 characters. Returned only on $select. Supports $filter (eq, ne, not, ge, le, in, startsWith, and eq on null values).'
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description="The date and time the user was created, in ISO 8601 format and UTC. The value can't be modified and is automatically populated when the entity is created. Nullable. For on-premises users, the value represents when they were first created in Microsoft Entra ID. Property is null for some users created before June 2018 and on-premises users that were synced to Microsoft Entra ID before June 2018. Read-only. Returned only on $select. Supports $filter (eq, ne, not , ge, le, in).",
        ),
    ] = None
    creation_type: Annotated[
        Optional[str],
        Field(
            description='Indicates whether the user account was created through one of the following methods:  As a regular school or work account (null). As an external account (Invitation). As a local account for an Azure Active Directory B2C tenant (LocalAccount). Through self-service sign-up by an internal user using email verification (EmailVerified). Through self-service sign-up by a guest signing up through a link that is part of a user flow (SelfServiceSignUp). Read-only.Returned only on $select. Supports $filter (eq, ne, not, in).'
        ),
    ] = None
    custom_security_attributes: Annotated[
        Optional[Union[CustomSecurityAttributeValue, Dict[str, Any]]],
        Field(
            description='An open complex type that holds the value of a custom security attribute that is assigned to a directory object. Nullable. Returned only on $select. Supports $filter (eq, ne, not, startsWith). The filter value is case-sensitive. To read this property, the calling app must be assigned the CustomSecAttributeAssignment.Read.All permission. To write this property, the calling app must be assigned the CustomSecAttributeAssignment.ReadWrite.All permissions. To read or write this property in delegated scenarios, the admin must be assigned the Attribute Assignment Administrator role.'
        ),
    ] = None
    department: Annotated[
        Optional[str],
        Field(
            description='The name of the department in which the user works. Maximum length is 64 characters. Returned only on $select. Supports $filter (eq, ne, not , ge, le, in, and eq on null values).'
        ),
    ] = None
    device_enrollment_limit: Annotated[
        Optional[float],
        Field(
            description='The limit on the maximum number of devices that the user is permitted to enroll. Allowed values are 5 or 1000.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    display_name: Annotated[
        Optional[str],
        Field(
            description="The name displayed in the address book for the user. This value is usually the combination of the user's first name, middle initial, and family name. This property is required when a user is created and it can't be cleared during updates. Maximum length is 256 characters. Returned by default. Supports $filter (eq, ne, not , ge, le, in, startsWith, and eq on null values), $orderby, and $search."
        ),
    ] = None
    employee_hire_date: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the user was hired or will start work in a future hire. Returned only on $select. Supports $filter (eq, ne, not , ge, le, in).',
        ),
    ] = None
    employee_id: Annotated[
        Optional[str],
        Field(
            description='The employee identifier assigned to the user by the organization. The maximum length is 16 characters. Returned only on $select. Supports $filter (eq, ne, not , ge, le, in, startsWith, and eq on null values).'
        ),
    ] = None
    employee_leave_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The date and time when the user left or will leave the organization. To read this property, the calling app must be assigned the User-LifeCycleInfo.Read.All permission. To write this property, the calling app must be assigned the User.Read.All and User-LifeCycleInfo.ReadWrite.All permissions. To read this property in delegated scenarios, the admin needs at least one of the following Microsoft Entra roles: Lifecycle Workflows Administrator (least privilege), Global Reader. To write this property in delegated scenarios, the admin needs the Global Administrator role. Supports $filter (eq, ne, not , ge, le, in). For more information, see Configure the employeeLeaveDateTime property for a user.',
        ),
    ] = None
    employee_org_data: Annotated[
        Optional[Union[EmployeeOrgData, Dict[str, Any]]],
        Field(
            description='Represents organization data (for example, division and costCenter) associated with a user. Returned only on $select. Supports $filter (eq, ne, not , ge, le, in).'
        ),
    ] = None
    employee_type: Annotated[
        Optional[str],
        Field(
            description='Captures enterprise worker type. For example, Employee, Contractor, Consultant, or Vendor. Returned only on $select. Supports $filter (eq, ne, not , ge, le, in, startsWith).'
        ),
    ] = None
    external_user_state: Annotated[
        Optional[str],
        Field(
            description="For a guest invited to the tenant using the invitation API, this property represents the invited user's invitation status. For invited users, the state can be PendingAcceptance or Accepted, or null for all other users. Returned only on $select. Supports $filter (eq, ne, not , in)."
        ),
    ] = None
    external_user_state_change_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Shows the timestamp for the latest change to the externalUserState property. Returned only on $select. Supports $filter (eq, ne, not , in).',
        ),
    ] = None
    fax_number: Annotated[
        Optional[str],
        Field(
            description='The fax number of the user. Returned only on $select. Supports $filter (eq, ne, not , ge, le, in, startsWith, and eq on null values).'
        ),
    ] = None
    given_name: Annotated[
        Optional[str],
        Field(
            description='The given name (first name) of the user. Maximum length is 64 characters. Returned by default. Supports $filter (eq, ne, not , ge, le, in, startsWith, and eq on null values).'
        ),
    ] = None
    hire_date: Annotated[
        Optional[datetime],
        Field(
            description='The hire date of the user. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014, is 2014-01-01T00:00:00Z. Returned only on $select.  Note: This property is specific to SharePoint in Microsoft 365. We recommend using the native employeeHireDate property to set and update hire date values using Microsoft Graph APIs.',
        ),
    ] = None
    identities: Annotated[
        Optional[List[ObjectIdentity]],
        Field(
            description='Represents the identities that can be used to sign in to this user account. Microsoft (also known as a local account), organizations, or social identity providers such as Facebook, Google, and Microsoft can provide identity and tie it to a user account. It might contain multiple items with the same signInType value. Returned only on $select.  Supports $filter (eq) with limitations.'
        ),
    ] = None
    im_addresses: Annotated[
        Optional[List[str]],
        Field(
            description='The instant message voice-over IP (VOIP) session initiation protocol (SIP) addresses for the user. Read-only. Returned only on $select. Supports $filter (eq, not, ge, le, startsWith).'
        ),
    ] = None
    interests: Annotated[
        Optional[List[str]],
        Field(
            description='A list for the user to describe their interests. Returned only on $select.'
        ),
    ] = None
    is_management_restricted: Optional[bool] = None
    is_resource_account: Annotated[
        Optional[bool], Field(description="Don't use  reserved for future use.")
    ] = None
    job_title: Annotated[
        Optional[str],
        Field(
            description="The user's job title. Maximum length is 128 characters. Returned by default. Supports $filter (eq, ne, not , ge, le, in, startsWith, and eq on null values)."
        ),
    ] = None
    last_password_change_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The time when this Microsoft Entra user last changed their password or when their password was created, whichever date the latest action was performed. The date and time information uses ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Returned only on $select.',
        ),
    ] = None
    legal_age_group_classification: Annotated[
        Optional[str],
        Field(
            description='Used by enterprise applications to determine the legal age group of the user. This property is read-only and calculated based on ageGroup and consentProvidedForMinor properties. Allowed values: null, Undefined,  MinorWithOutParentalConsent, MinorWithParentalConsent, MinorNoParentalConsentRequired, NotAdult, and Adult. For more information, see legal age group property definitions. Returned only on $select.'
        ),
    ] = None
    license_assignment_states: Annotated[
        Optional[List[LicenseAssignmentState]],
        Field(
            description='State of license assignments for this user. Also indicates licenses that are directly assigned or the user inherited through group memberships. Read-only. Returned only on $select.'
        ),
    ] = None
    mail: Annotated[
        Optional[str],
        Field(
            description="The SMTP address for the user, for example, jeff@contoso.com. Changes to this property update the user's proxyAddresses collection to include the value as an SMTP address. This property can't contain accent characters.  NOTE: We don't recommend updating this property for Azure AD B2C user profiles. Use the otherMails property instead. Returned by default. Supports $filter (eq, ne, not, ge, le, in, startsWith, endsWith, and eq on null values)."
        ),
    ] = None
    mailbox_settings: Annotated[
        Optional[Union[MailboxSettings, Dict[str, Any]]],
        Field(
            description='Settings for the primary mailbox of the signed-in user. You can get or update settings for sending automatic replies to incoming messages, locale, and time zone. Returned only on $select.'
        ),
    ] = None
    mail_nickname: Annotated[
        Optional[str],
        Field(
            description='The mail alias for the user. This property must be specified when a user is created. Maximum length is 64 characters. Returned only on $select. Supports $filter (eq, ne, not, ge, le, in, startsWith, and eq on null values).'
        ),
    ] = None
    mobile_phone: Annotated[
        Optional[str],
        Field(
            description='The primary cellular telephone number for the user. Read-only for users synced from the on-premises directory. Maximum length is 64 characters. Returned by default. Supports $filter (eq, ne, not, ge, le, in, startsWith, and eq on null values) and $search.'
        ),
    ] = None
    my_site: Annotated[
        Optional[str],
        Field(description="The URL for the user's site. Returned only on $select."),
    ] = None
    office_location: Annotated[
        Optional[str],
        Field(
            description="The office location in the user's place of business. Returned by default. Supports $filter (eq, ne, not, ge, le, in, startsWith, and eq on null values)."
        ),
    ] = None
    on_premises_distinguished_name: Annotated[
        Optional[str],
        Field(
            description='Contains the on-premises Active Directory distinguished name or DN. The property is only populated for customers who are synchronizing their on-premises directory to Microsoft Entra ID via Microsoft Entra Connect. Read-only. Returned only on $select.'
        ),
    ] = None
    on_premises_domain_name: Annotated[
        Optional[str],
        Field(
            description='Contains the on-premises domainFQDN, also called dnsDomainName synchronized from the on-premises directory. The property is only populated for customers who are synchronizing their on-premises directory to Microsoft Entra ID via Microsoft Entra Connect. Read-only. Returned only on $select.'
        ),
    ] = None
    on_premises_extension_attributes: Annotated[
        Optional[Union[OnPremisesExtensionAttributes, Dict[str, Any]]],
        Field(
            description='Contains extensionAttributes1-15 for the user. These extension attributes are also known as Exchange custom attributes 1-15. Each attribute can store up to 1024 characters. For an onPremisesSyncEnabled user, the source of authority for this set of properties is the on-premises and is read-only. For a cloud-only user (where onPremisesSyncEnabled is false), these properties can be set during the creation or update of a user object.  For a cloud-only user previously synced from on-premises Active Directory, these properties are read-only in Microsoft Graph but can be fully managed through the Exchange Admin Center or the Exchange Online V2 module in PowerShell. Returned only on $select. Supports $filter (eq, ne, not, in).'
        ),
    ] = None
    on_premises_immutable_id: Annotated[
        Optional[str],
        Field(
            description="This property is used to associate an on-premises Active Directory user account to their Microsoft Entra user object. This property must be specified when creating a new user account in the Graph if you're using a federated domain for the user's userPrincipalName (UPN) property. NOTE: The $ and _ characters can't be used when specifying this property. Returned only on $select. Supports $filter (eq, ne, not, ge, le, in)."
        ),
    ] = None
    on_premises_last_sync_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Indicates the last time at which the object was synced with the on-premises directory; for example: 2013-02-16T03:04:54Z. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only. Returned only on $select. Supports $filter (eq, ne, not, ge, le, in).',
        ),
    ] = None
    on_premises_provisioning_errors: Annotated[
        Optional[List[OnPremisesProvisioningError]],
        Field(
            description='Errors when using Microsoft synchronization product during provisioning. Returned only on $select. Supports $filter (eq, not, ge, le).'
        ),
    ] = None
    on_premises_sam_account_name: Annotated[
        Optional[str],
        Field(
            description='Contains the on-premises samAccountName synchronized from the on-premises directory. The property is only populated for customers who are synchronizing their on-premises directory to Microsoft Entra ID via Microsoft Entra Connect. Read-only. Returned only on $select. Supports $filter (eq, ne, not, ge, le, in, startsWith).'
        ),
    ] = None
    on_premises_security_identifier: Annotated[
        Optional[str],
        Field(
            description='Contains the on-premises security identifier (SID) for the user that was synchronized from on-premises to the cloud. Read-only. Returned only on $select. Supports $filter (eq including on null values).'
        ),
    ] = None
    on_premises_sync_enabled: Annotated[
        Optional[bool],
        Field(
            description="true if this user object is currently being synced from an on-premises Active Directory (AD); otherwise the user isn't being synced and can be managed in Microsoft Entra ID. Read-only. Returned only on $select. Supports $filter (eq, ne, not, in, and eq on null values)."
        ),
    ] = None
    on_premises_user_principal_name: Annotated[
        Optional[str],
        Field(
            description='Contains the on-premises userPrincipalName synchronized from the on-premises directory. The property is only populated for customers who are synchronizing their on-premises directory to Microsoft Entra ID via Microsoft Entra Connect. Read-only. Returned only on $select. Supports $filter (eq, ne, not, ge, le, in, startsWith).'
        ),
    ] = None
    other_mails: Annotated[
        Optional[List[str]],
        Field(
            description="A list of other email addresses for the user; for example: ['bob@contoso.com', 'Robert@fabrikam.com']. NOTE: This property can't contain accent characters. Returned only on $select. Supports $filter (eq, not, ge, le, in, startsWith, endsWith, /$count eq 0, /$count ne 0)."
        ),
    ] = None
    password_policies: Annotated[
        Optional[str],
        Field(
            description='Specifies password policies for the user. This value is an enumeration with one possible value being DisableStrongPassword, which allows weaker passwords than the default policy to be specified. DisablePasswordExpiration can also be specified. The two might be specified together; for example: DisablePasswordExpiration, DisableStrongPassword. Returned only on $select. For more information on the default password policies, see Microsoft Entra password policies. Supports $filter (ne, not, and eq on null values).'
        ),
    ] = None
    password_profile: Annotated[
        Optional[Union[PasswordProfile, Dict[str, Any]]],
        Field(
            description="Specifies the password profile for the user. The profile contains the user's password. This property is required when a user is created. The password in the profile must satisfy minimum requirements as specified by the passwordPolicies property. By default, a strong password is required. Returned only on $select. Supports $filter (eq, ne, not, in, and eq on null values). To update this property:  User-PasswordProfile.ReadWrite.All is the least privileged permission to update this property.  In delegated scenarios, the User Administrator Microsoft Entra role is the least privileged admin role supported to update this property for nonadmin users. Privileged Authentication Administrator is the least privileged role that's allowed to update this property for all administrators in the tenant. In general, the signed-in user must have a higher privileged administrator role as indicated in Who can reset passwords.  In app-only scenarios, the calling app must be assigned a supported permission and at least the User Administrator Microsoft Entra role."
        ),
    ] = None
    past_projects: Annotated[
        Optional[List[str]],
        Field(
            description='A list for the user to enumerate their past projects. Returned only on $select.'
        ),
    ] = None
    postal_code: Annotated[
        Optional[str],
        Field(
            description="The postal code for the user's postal address. The postal code is specific to the user's country/region. In the United States of America, this attribute contains the ZIP code. Maximum length is 40 characters. Returned only on $select. Supports $filter (eq, ne, not, ge, le, in, startsWith, and eq on null values)."
        ),
    ] = None
    preferred_data_location: Annotated[
        Optional[str],
        Field(
            description='The preferred data location for the user. For more information, see OneDrive Online Multi-Geo.'
        ),
    ] = None
    preferred_language: Annotated[
        Optional[str],
        Field(
            description="The preferred language for the user. The preferred language format is based on RFC 4646. The name is a combination of an ISO 639 two-letter lowercase culture code associated with the language, and an ISO 3166 two-letter uppercase subculture code associated with the country or region. Example: 'en-US', or 'es-ES'. Returned by default. Supports $filter (eq, ne, not, ge, le, in, startsWith, and eq on null values)"
        ),
    ] = None
    preferred_name: Annotated[
        Optional[str],
        Field(
            description='The preferred name for the user. Not Supported. This attribute returns an empty string.Returned only on $select.'
        ),
    ] = None
    print: Optional[Union[UserPrint, Dict[str, Any]]] = None
    provisioned_plans: Annotated[
        Optional[List[ProvisionedPlan]],
        Field(
            description='The plans that are provisioned for the user. Read-only. Not nullable. Returned only on $select. Supports $filter (eq, not, ge, le).'
        ),
    ] = None
    proxy_addresses: Annotated[
        Optional[List[str]],
        Field(
            description="For example: ['SMTP: bob@contoso.com', 'smtp: bob@sales.contoso.com']. Changes to the mail property update this collection to include the value as an SMTP address. For more information, see mail and proxyAddresses properties. The proxy address prefixed with SMTP (capitalized) is the primary proxy address, while those addresses prefixed with smtp are the secondary proxy addresses. For Azure AD B2C accounts, this property has a limit of 10 unique addresses. Read-only in Microsoft Graph; you can update this property only through the Microsoft 365 admin center. Not nullable. Returned only on $select. Supports $filter (eq, not, ge, le, startsWith, endsWith, /$count eq 0, /$count ne 0)."
        ),
    ] = None
    responsibilities: Annotated[
        Optional[List[str]],
        Field(
            description='A list for the user to enumerate their responsibilities. Returned only on $select.'
        ),
    ] = None
    schools: Annotated[
        Optional[List[str]],
        Field(
            description='A list for the user to enumerate the schools they attended. Returned only on $select.'
        ),
    ] = None
    security_identifier: Annotated[
        Optional[str],
        Field(
            description='Security identifier (SID) of the user, used in Windows scenarios. Read-only. Returned by default. Supports $select and $filter (eq, not, ge, le, startsWith).'
        ),
    ] = None
    service_provisioning_errors: Annotated[
        Optional[List[ServiceProvisioningError]],
        Field(
            description='Errors published by a federated service describing a nontransient, service-specific error regarding the properties or link from a user object.  Supports $filter (eq, not, for isResolved and serviceInstance).'
        ),
    ] = None
    show_in_address_list: Annotated[
        Optional[bool],
        Field(
            description='Do not use in Microsoft Graph. Manage this property through the Microsoft 365 admin center instead. Represents whether the user should be included in the Outlook global address list. See Known issue.'
        ),
    ] = None
    sign_in_activity: Annotated[
        Optional[Union[SignInActivity, Dict[str, Any]]],
        Field(
            description="Get the last signed-in date and request ID of the sign-in for a given user. Read-only.Returned only on $select. Supports $filter (eq, ne, not, ge, le) but not with any other filterable properties. Note: Details for this property require a Microsoft Entra ID P1 or P2 license and the AuditLog.Read.All permission.This property isn't returned for a user who never signed in or last signed in before April 2020."
        ),
    ] = None
    sign_in_sessions_valid_from_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Any refresh tokens or session tokens (session cookies) issued before this time are invalid. Applications get an error when using an invalid refresh or session token to acquire a delegated access token (to access APIs such as Microsoft Graph). If this happens, the application needs to acquire a new refresh token by requesting the authorized endpoint. Read-only. Use revokeSignInSessions to reset. Returned only on $select.',
        ),
    ] = None
    skills: Annotated[
        Optional[List[str]],
        Field(
            description='A list for the user to enumerate their skills. Returned only on $select.'
        ),
    ] = None
    state: Annotated[
        Optional[str],
        Field(
            description="The state or province in the user's address. Maximum length is 128 characters. Returned only on $select. Supports $filter (eq, ne, not, ge, le, in, startsWith, and eq on null values)."
        ),
    ] = None
    street_address: Annotated[
        Optional[str],
        Field(
            description="The street address of the user's place of business. Maximum length is 1,024 characters. Returned only on $select. Supports $filter (eq, ne, not, ge, le, in, startsWith, and eq on null values)."
        ),
    ] = None
    surname: Annotated[
        Optional[str],
        Field(
            description="The user's surname (family name or last name). Maximum length is 64 characters. Returned by default. Supports $filter (eq, ne, not, ge, le, in, startsWith, and eq on null values)."
        ),
    ] = None
    usage_location: Annotated[
        Optional[str],
        Field(
            description='A two-letter country code (ISO standard 3166). Required for users that are assigned licenses due to legal requirements to check for availability of services in countries. Examples include: US, JP, and GB. Not nullable. Returned only on $select. Supports $filter (eq, ne, not, ge, le, in, startsWith, and eq on null values).'
        ),
    ] = None
    user_principal_name: Annotated[
        Optional[str],
        Field(
            description="The user principal name (UPN) of the user. The UPN is an Internet-style sign-in name for the user based on the Internet standard RFC 822. By convention, this value should map to the user's email name. The general format is alias@domain, where the domain must be present in the tenant's collection of verified domains. This property is required when a user is created. The verified domains for the tenant can be accessed from the verifiedDomains property of organization.NOTE: This property can't contain accent characters. Only the following characters are allowed A - Z, a - z, 0 - 9, ' . - _ ! # ^ ~. For the complete list of allowed characters, see username policies. Returned by default. Supports $filter (eq, ne, not, ge, le, in, startsWith, endsWith) and $orderby."
        ),
    ] = None
    user_type: Annotated[
        Optional[str],
        Field(
            description='A string value that can be used to classify user types in your directory. The possible values are Member and Guest. Returned only on $select. Supports $filter (eq, ne, not, in, and eq on null values). NOTE: For more information about the permissions for members and guests, see What are the default user permissions in Microsoft Entra ID?'
        ),
    ] = None
    activities: Annotated[
        Optional[List[UserActivity]],
        Field(description="The user's activities across devices. Read-only. Nullable."),
    ] = None
    agreement_acceptances: Annotated[
        Optional[List[AgreementAcceptance]],
        Field(
            description="The user's terms of use acceptance statuses. Read-only. Nullable."
        ),
    ] = None
    app_role_assignments: Annotated[
        Optional[List[AppRoleAssignment]],
        Field(
            description='Represents the app roles a user is granted for an application. Supports $expand.'
        ),
    ] = None
    authentication: Annotated[
        Optional[Union[Authentication, Dict[str, Any]]],
        Field(
            description='The authentication methods that are supported for the user.'
        ),
    ] = None
    calendar: Annotated[
        Optional[Union[Calendar, Dict[str, Any]]],
        Field(description="The user's primary calendar. Read-only."),
    ] = None
    calendar_groups: Annotated[
        Optional[List[CalendarGroup]],
        Field(description="The user's calendar groups. Read-only. Nullable."),
    ] = None
    calendars: Annotated[
        Optional[List[Calendar]],
        Field(description="The user's calendars. Read-only. Nullable."),
    ] = None
    calendar_view: Annotated[
        Optional[List[Event]],
        Field(description='The calendar view for the calendar. Read-only. Nullable.'),
    ] = None
    chats: Optional[List[Chat]] = None
    cloud_clipboard: Optional[Union[CloudClipboardRoot, Dict[str, Any]]] = None
    contact_folders: Annotated[
        Optional[List[ContactFolder]],
        Field(description="The user's contacts folders. Read-only. Nullable."),
    ] = None
    contacts: Annotated[
        Optional[List[Contact]],
        Field(description="The user's contacts. Read-only. Nullable."),
    ] = None
    created_objects: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description='Directory objects that the user created. Read-only. Nullable.'
        ),
    ] = None
    device_management_troubleshooting_events: Annotated[
        Optional[List[DeviceManagementTroubleshootingEvent]],
        Field(description='The list of troubleshooting events for this user.'),
    ] = None
    direct_reports: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description='The users and contacts that report to the user. (The users and contacts that have their manager property set to this user.) Read-only. Nullable. Supports $expand.'
        ),
    ] = None
    drive: Annotated[
        Optional[Union[Drive, Dict[str, Any]]],
        Field(description="The user's OneDrive. Read-only."),
    ] = None
    drives: Annotated[
        Optional[List[Drive]],
        Field(description='A collection of drives available for this user. Read-only.'),
    ] = None
    employee_experience: Optional[Union[EmployeeExperienceUser, Dict[str, Any]]] = None
    events: Annotated[
        Optional[List[Event]],
        Field(
            description="The user's events. Default is to show Events under the Default Calendar. Read-only. Nullable."
        ),
    ] = None
    extensions: Annotated[
        Optional[List[Extension]],
        Field(
            description='The collection of open extensions defined for the user. Read-only. Supports $expand. Nullable.'
        ),
    ] = None
    followed_sites: Optional[List[Site]] = None
    inference_classification: Annotated[
        Optional[Union[InferenceClassification, Dict[str, Any]]],
        Field(
            description="Relevance classification of the user's messages based on explicit designations that override inferred relevance or importance."
        ),
    ] = None
    insights: Annotated[
        Optional[Union[ItemInsights, Dict[str, Any]]],
        Field(
            description='Represents relationships between a user and items such as OneDrive for work or school documents, calculated using advanced analytics and machine learning techniques. Read-only. Nullable.'
        ),
    ] = None
    joined_teams: Optional[List[Team]] = None
    license_details: Annotated[
        Optional[List[LicenseDetails]],
        Field(description="A collection of this user's license details. Read-only."),
    ] = None
    mail_folders: Annotated[
        Optional[List[MailFolder]],
        Field(description="The user's mail folders. Read-only. Nullable."),
    ] = None
    managed_app_registrations: Annotated[
        Optional[List[ManagedAppRegistration]],
        Field(
            description='Zero or more managed app registrations that belong to the user.'
        ),
    ] = None
    managed_devices: Annotated[
        Optional[List[ManagedDevice]],
        Field(description='The managed devices associated with the user.'),
    ] = None
    manager: Annotated[
        Optional[Union[DirectoryObject, Dict[str, Any]]],
        Field(
            description="The user or contact that is this user's manager. Read-only. Supports $expand."
        ),
    ] = None
    member_of: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description='The groups and directory roles that the user is a member of. Read-only. Nullable. Supports $expand.'
        ),
    ] = None
    messages: Annotated[
        Optional[List[Message]],
        Field(description='The messages in a mailbox or folder. Read-only. Nullable.'),
    ] = None
    oauth2_permission_grants: Optional[List[OAuth2PermissionGrant]] = None
    onenote: Optional[Union[Onenote, Dict[str, Any]]] = None
    online_meetings: Annotated[
        Optional[List[OnlineMeeting]],
        Field(
            description='Information about a meeting, including the URL used to join a meeting, the attendees list, and the description.'
        ),
    ] = None
    outlook: Optional[Union[OutlookUser, Dict[str, Any]]] = None
    owned_devices: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description='Devices the user owns. Read-only. Nullable. Supports $expand and $filter (/$count eq 0, /$count ne 0, /$count eq 1, /$count ne 1).'
        ),
    ] = None
    owned_objects: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description='Directory objects the user owns. Read-only. Nullable. Supports $expand, $select nested in $expand, and $filter (/$count eq 0, /$count ne 0, /$count eq 1, /$count ne 1).'
        ),
    ] = None
    people: Annotated[
        Optional[List[Person]],
        Field(description='People that are relevant to the user. Read-only. Nullable.'),
    ] = None
    permission_grants: Annotated[
        Optional[List[ResourceSpecificPermissionGrant]],
        Field(description='List all resource-specific permission grants of a user.'),
    ] = None
    photo: Annotated[
        Optional[Union[ProfilePhoto, Dict[str, Any]]],
        Field(description="The user's profile photo. Read-only."),
    ] = None
    photos: Annotated[
        Optional[List[ProfilePhoto]],
        Field(
            description="The collection of the user's profile photos in different sizes. Read-only."
        ),
    ] = None
    planner: Annotated[
        Optional[Union[PlannerUser, Dict[str, Any]]],
        Field(
            description='Entry-point to the Planner resource that might exist for a user. Read-only.'
        ),
    ] = None
    presence: Optional[Union[Presence, Dict[str, Any]]] = None
    registered_devices: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description='Devices that are registered for the user. Read-only. Nullable. Supports $expand and returns up to 100 objects.'
        ),
    ] = None
    scoped_role_member_of: Optional[List[ScopedRoleMembership]] = None
    settings: Optional[Union[UserSettings, Dict[str, Any]]] = None
    solutions: Annotated[
        Optional[Union[UserSolutionRoot, Dict[str, Any]]],
        Field(
            description='The identifier that relates the user to the working time schedule triggers. Read-Only. Nullable'
        ),
    ] = None
    sponsors: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description="The users and groups responsible for this guest's privileges in the tenant and keeping the guest's information and access updated. (HTTP Methods: GET, POST, DELETE.). Supports $expand."
        ),
    ] = None
    teamwork: Annotated[
        Optional[Union[UserTeamwork, Dict[str, Any]]],
        Field(
            description='A container for Microsoft Teams features available for the user. Read-only. Nullable.'
        ),
    ] = None
    todo: Annotated[
        Optional[Union[Todo, Dict[str, Any]]],
        Field(description='Represents the To Do services available to a user.'),
    ] = None
    transitive_member_of: Annotated[
        Optional[List[DirectoryObject]],
        Field(
            description='The groups, including nested groups, and directory roles that a user is a member of. Nullable.'
        ),
    ] = None
    field_odata_type: str


class UserActivity(Entity):
    activation_url: Annotated[
        Optional[str],
        Field(
            description='Required. URL used to launch the activity in the best native experience represented by the appId. Might launch a web-based app if no native app exists.'
        ),
    ] = None
    activity_source_host: Annotated[
        Optional[str],
        Field(
            description='Required. URL for the domain representing the cross-platform identity mapping for the app. Mapping is stored either as a JSON file hosted on the domain or configurable via Windows Dev Center. The JSON file is named cross-platform-app-identifiers and is hosted at root of your HTTPS domain, either at the top level domain or include a sub domain. For example: https://contoso.com or https://myapp.contoso.com but NOT https://myapp.contoso.com/somepath. You must have a unique file and domain (or sub domain) per cross-platform app identity. For example, a separate file and domain is needed for Word vs. PowerPoint.'
        ),
    ] = None
    app_activity_id: Annotated[
        Optional[str],
        Field(
            description='Required. The unique activity ID in the context of the app - supplied by caller and immutable thereafter.'
        ),
    ] = None
    app_display_name: Annotated[
        Optional[str],
        Field(
            description='Optional. Short text description of the app used to generate the activity for use in cases when the app is not installed on the users local device.'
        ),
    ] = None
    content_info: Annotated[
        Optional[Any],
        Field(
            description='Optional. A custom piece of data - JSON-LD extensible description of content according to schema.org syntax.'
        ),
    ] = None
    content_url: Annotated[
        Optional[str],
        Field(
            description='Optional. Used in the event the content can be rendered outside of a native or web-based app experience (for example, a pointer to an item in an RSS feed).'
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Set by the server. DateTime in UTC when the object was created on the server.',
        ),
    ] = None
    expiration_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Set by the server. DateTime in UTC when the object expired on the server.',
        ),
    ] = None
    fallback_url: Annotated[
        Optional[str],
        Field(
            description='Optional. URL used to launch the activity in a web-based app, if available.'
        ),
    ] = None
    last_modified_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Set by the server. DateTime in UTC when the object was modified on the server.',
        ),
    ] = None
    status: Annotated[
        Optional[Union[Status, Dict[str, Any]]],
        Field(
            description='Set by the server. A status code used to identify valid objects. Values: active, updated, deleted, ignored.'
        ),
    ] = None
    user_timezone: Annotated[
        Optional[str],
        Field(
            description="Optional. The timezone in which the user's device used to generate the activity was located at activity creation time; values supplied as Olson IDs in order to support cross-platform representation."
        ),
    ] = None
    visual_elements: Optional[VisualInfo] = None
    history_items: Annotated[
        Optional[List[ActivityHistoryItem]],
        Field(
            description="Optional. NavigationProperty/Containment; navigation property to the activity's historyItems."
        ),
    ] = None
    field_odata_type: str


class UserTeamwork(Entity):
    locale: Annotated[
        Optional[str],
        Field(
            description="Represents the location that a user selected in Microsoft Teams and doesn't follow the Office's locale setting. A users locale is represented by their preferred language and country or region. For example, en-us. The language component follows two-letter codes as defined in ISO 639-1, and the country component follows two-letter codes as defined in ISO 3166-1 alpha-2."
        ),
    ] = None
    region: Annotated[
        Optional[str],
        Field(
            description="Represents the region of the organization or the user. For users with multigeo licenses, the property contains the user's region (if available). For users without multigeo licenses, the property contains the organization's region.The region value can be any region supported by the Teams payload. The possible values are: Americas, Europe and MiddleEast, Asia Pacific, UAE, Australia, Brazil, Canada, Switzerland, Germany, France, India, Japan, South Korea, Norway, Singapore, United Kingdom, South Africa, Sweden, Qatar, Poland, Italy, Israel, Spain, Mexico, USGov Community Cloud, USGov Community Cloud High, USGov Department of Defense, and China."
        ),
    ] = None
    associated_teams: Annotated[
        Optional[List[AssociatedTeamInfo]],
        Field(
            description='The list of associatedTeamInfo objects that a user is associated with.'
        ),
    ] = None
    installed_apps: Annotated[
        Optional[List[UserScopeTeamsAppInstallation]],
        Field(description='The apps installed in the personal scope of this user.'),
    ] = None
    field_odata_type: str


class VirtualEndpoint(Entity):
    audit_events: Annotated[
        Optional[List[CloudPcAuditEvent]],
        Field(description='A collection of Cloud PC audit events.'),
    ] = None
    cloud_p_cs: Annotated[
        Optional[List[CloudPC]],
        Field(description='A collection of cloud-managed virtual desktops.'),
    ] = None
    device_images: Annotated[
        Optional[List[CloudPcDeviceImage]],
        Field(description='A collection of device image resources on Cloud PC.'),
    ] = None
    gallery_images: Annotated[
        Optional[List[CloudPcGalleryImage]],
        Field(description='A collection of gallery image resources on Cloud PC.'),
    ] = None
    on_premises_connections: Annotated[
        Optional[List[CloudPcOnPremisesConnection]],
        Field(
            description='A defined collection of Azure resource information that can be used to establish Azure network connections for Cloud PCs.'
        ),
    ] = None
    provisioning_policies: Annotated[
        Optional[List[CloudPcProvisioningPolicy]],
        Field(description='A collection of Cloud PC provisioning policies.'),
    ] = None
    user_settings: Annotated[
        Optional[List[CloudPcUserSetting]],
        Field(description='A collection of Cloud PC user settings.'),
    ] = None
    field_odata_type: str


class Workbook(Entity):
    application: Optional[Union[WorkbookApplication, Dict[str, Any]]] = None
    comments: Annotated[
        Optional[List[WorkbookComment]],
        Field(description='Represents a collection of comments in a workbook.'),
    ] = None
    functions: Optional[Union[WorkbookFunctions, Dict[str, Any]]] = None
    names: Annotated[
        Optional[List[WorkbookNamedItem]],
        Field(
            description='Represents a collection of workbooks scoped named items (named ranges and constants). Read-only.'
        ),
    ] = None
    operations: Annotated[
        Optional[List[WorkbookOperation]],
        Field(
            description='The status of workbook operations. Getting an operation collection is not supported, but you can get the status of a long-running operation if the Location header is returned in the response. Read-only.'
        ),
    ] = None
    tables: Annotated[
        Optional[List[WorkbookTable]],
        Field(
            description='Represents a collection of tables associated with the workbook. Read-only.'
        ),
    ] = None
    worksheets: Annotated[
        Optional[List[WorkbookWorksheet]],
        Field(
            description='Represents a collection of worksheets associated with the workbook. Read-only.'
        ),
    ] = None
    field_odata_type: str


class WorkbookChart(Entity):
    height: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='Represents the height, in points, of the chart object.'),
    ] = None
    left: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='The distance, in points, from the left side of the chart to the worksheet origin.'
        ),
    ] = None
    name: Annotated[
        Optional[str], Field(description='Represents the name of a chart object.')
    ] = None
    top: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(
            description='Represents the distance, in points, from the top edge of the object to the top of row 1 (on a worksheet) or the top of the chart area (on a chart).'
        ),
    ] = None
    width: Annotated[
        Optional[Union[float, str, ReferenceNumeric]],
        Field(description='Represents the width, in points, of the chart object.'),
    ] = None
    axes: Annotated[
        Optional[Union[WorkbookChartAxes, Dict[str, Any]]],
        Field(description='Represents chart axes. Read-only.'),
    ] = None
    data_labels: Annotated[
        Optional[Union[WorkbookChartDataLabels, Dict[str, Any]]],
        Field(description='Represents the data labels on the chart. Read-only.'),
    ] = None
    format: Annotated[
        Optional[Union[WorkbookChartAreaFormat, Dict[str, Any]]],
        Field(
            description='Encapsulates the format properties for the chart area. Read-only.'
        ),
    ] = None
    legend: Annotated[
        Optional[Union[WorkbookChartLegend, Dict[str, Any]]],
        Field(description='Represents the legend for the chart. Read-only.'),
    ] = None
    series: Annotated[
        Optional[List[WorkbookChartSeries]],
        Field(
            description='Represents either a single series or collection of series in the chart. Read-only.'
        ),
    ] = None
    title: Annotated[
        Optional[Union[WorkbookChartTitle, Dict[str, Any]]],
        Field(
            description='Represents the title of the specified chart, including the text, visibility, position and formatting of the title. Read-only.'
        ),
    ] = None
    worksheet: Annotated[
        Optional[Union[WorkbookWorksheet, Dict[str, Any]]],
        Field(description='The worksheet containing the current chart. Read-only.'),
    ] = None
    field_odata_type: str


class WorkbookNamedItem(Entity):
    comment: Annotated[
        Optional[str], Field(description='The comment associated with this name.')
    ] = None
    name: Annotated[
        Optional[str], Field(description='The name of the object. Read-only.')
    ] = None
    scope: Annotated[
        Optional[str],
        Field(
            description='Indicates whether the name is scoped to the workbook or to a specific worksheet. Read-only.'
        ),
    ] = None
    type: Annotated[
        Optional[str],
        Field(
            description='The type of reference is associated with the name. Possible values are: String, Integer, Double, Boolean, Range. Read-only.'
        ),
    ] = None
    value: Annotated[
        Optional[Any],
        Field(
            description='The formula that the name is defined to refer to. For example, =Sheet14!$B$2:$H$12 and =4.75. Read-only.'
        ),
    ] = None
    visible: Annotated[
        Optional[bool], Field(description='Indicates whether the object is visible.')
    ] = None
    worksheet: Annotated[
        Optional[Union[WorkbookWorksheet, Dict[str, Any]]],
        Field(
            description='Returns the worksheet to which the named item is scoped. Available only if the item is scoped to the worksheet. Read-only.'
        ),
    ] = None
    field_odata_type: str


class WorkbookPivotTable(Entity):
    name: Annotated[
        Optional[str], Field(description='The name of the pivot table.')
    ] = None
    worksheet: Annotated[
        Optional[Union[WorkbookWorksheet, Dict[str, Any]]],
        Field(
            description='The worksheet that contains the current pivot table. Read-only.'
        ),
    ] = None
    field_odata_type: str


class WorkbookRange(Entity):
    address: Annotated[
        Optional[str],
        Field(
            description='Represents the range reference in A1-style. Address value contains the Sheet reference (for example, Sheet1!A1:B4). Read-only.'
        ),
    ] = None
    address_local: Annotated[
        Optional[str],
        Field(
            description='Represents range reference for the specified range in the language of the user. Read-only.'
        ),
    ] = None
    cell_count: Annotated[
        Optional[float],
        Field(
            description='Number of cells in the range. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    column_count: Annotated[
        Optional[float],
        Field(
            description='Represents the total number of columns in the range. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    column_hidden: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether all columns of the current range are hidden.'
        ),
    ] = None
    column_index: Annotated[
        Optional[float],
        Field(
            description='Represents the column number of the first cell in the range. Zero-indexed. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    formulas: Annotated[
        Optional[Any], Field(description='Represents the formula in A1-style notation.')
    ] = None
    formulas_local: Annotated[
        Optional[Any],
        Field(
            description="Represents the formula in A1-style notation, in the user's language and number-formatting locale.  For example, the English '=SUM(A1, 1.5)' formula would become '=SUMME(A1; 1,5)' in German."
        ),
    ] = None
    formulas_r1_c1: Annotated[
        Optional[Any],
        Field(description='Represents the formula in R1C1-style notation.'),
    ] = None
    hidden: Annotated[
        Optional[bool],
        Field(
            description='Represents if all cells of the current range are hidden. Read-only.'
        ),
    ] = None
    number_format: Annotated[
        Optional[Any],
        Field(description="Represents Excel's number format code for the given cell."),
    ] = None
    row_count: Annotated[
        Optional[float],
        Field(
            description='Returns the total number of rows in the range. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    row_hidden: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether all rows of the current range are hidden.'
        ),
    ] = None
    row_index: Annotated[
        Optional[float],
        Field(
            description='Returns the row number of the first cell in the range. Zero-indexed. Read-only.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    text: Annotated[
        Optional[Any],
        Field(
            description="Text values of the specified range. The Text value doesn't depend on the cell width. The # sign substitution that happens in Excel UI doesn't affect the text value returned by the API. Read-only."
        ),
    ] = None
    values: Annotated[
        Optional[Any],
        Field(
            description='Represents the raw values of the specified range. The data returned can be of type string, number, or a Boolean. Cell that contains an error returns the error string.'
        ),
    ] = None
    value_types: Annotated[
        Optional[Any],
        Field(
            description='Represents the type of data of each cell. The possible values are: Unknown, Empty, String, Integer, Double, Boolean, Error. Read-only.'
        ),
    ] = None
    format: Annotated[
        Optional[Union[WorkbookRangeFormat, Dict[str, Any]]],
        Field(
            description="Returns a format object, encapsulating the range's font, fill, borders, alignment, and other properties. Read-only."
        ),
    ] = None
    sort: Annotated[
        Optional[Union[WorkbookRangeSort, Dict[str, Any]]],
        Field(description='The worksheet containing the current range. Read-only.'),
    ] = None
    worksheet: Annotated[
        Optional[Union[WorkbookWorksheet, Dict[str, Any]]],
        Field(description='The worksheet containing the current range. Read-only.'),
    ] = None
    field_odata_type: str


class WorkbookTable(Entity):
    highlight_first_column: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the first column contains special formatting.'
        ),
    ] = None
    highlight_last_column: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the last column contains special formatting.'
        ),
    ] = None
    legacy_id: Annotated[
        Optional[str],
        Field(
            description="A legacy identifier used in older Excel clients. The value of the identifier remains the same even when the table is renamed. This property should be interpreted as an opaque string value and shouldn't be parsed to any other type. Read-only."
        ),
    ] = None
    name: Annotated[Optional[str], Field(description='The name of the table.')] = None
    show_banded_columns: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the columns show banded formatting in which odd columns are highlighted differently from even ones to make reading the table easier.'
        ),
    ] = None
    show_banded_rows: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the rows show banded formatting in which odd rows are highlighted differently from even ones to make reading the table easier.'
        ),
    ] = None
    show_filter_button: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the filter buttons are visible at the top of each column header. Setting this is only allowed if the table contains a header row.'
        ),
    ] = None
    show_headers: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the header row is visible or not. This value can be set to show or remove the header row.'
        ),
    ] = None
    show_totals: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether the total row is visible or not. This value can be set to show or remove the total row.'
        ),
    ] = None
    style: Annotated[
        Optional[str],
        Field(
            description='A constant value that represents the Table style. Possible values are: TableStyleLight1 through TableStyleLight21, TableStyleMedium1 through TableStyleMedium28, TableStyleStyleDark1 through TableStyleStyleDark11. A custom user-defined style present in the workbook can also be specified.'
        ),
    ] = None
    columns: Annotated[
        Optional[List[WorkbookTableColumn]],
        Field(description='The list of all the columns in the table. Read-only.'),
    ] = None
    rows: Annotated[
        Optional[List[WorkbookTableRow]],
        Field(description='The list of all the rows in the table. Read-only.'),
    ] = None
    sort: Annotated[
        Optional[Union[WorkbookTableSort, Dict[str, Any]]],
        Field(description='The sorting for the table. Read-only.'),
    ] = None
    worksheet: Annotated[
        Optional[Union[WorkbookWorksheet, Dict[str, Any]]],
        Field(description='The worksheet containing the current table. Read-only.'),
    ] = None
    field_odata_type: str


class WorkbookWorksheet(Entity):
    name: Annotated[
        Optional[str], Field(description='The display name of the worksheet.')
    ] = None
    position: Annotated[
        Optional[float],
        Field(
            description='The zero-based position of the worksheet within the workbook.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    visibility: Annotated[
        Optional[str],
        Field(
            description='The visibility of the worksheet. The possible values are: Visible, Hidden, VeryHidden.'
        ),
    ] = None
    charts: Annotated[
        Optional[List[WorkbookChart]],
        Field(
            description='The list of charts that are part of the worksheet. Read-only.'
        ),
    ] = None
    names: Annotated[
        Optional[List[WorkbookNamedItem]],
        Field(
            description='The list of names that are associated with the worksheet. Read-only.'
        ),
    ] = None
    pivot_tables: Annotated[
        Optional[List[WorkbookPivotTable]],
        Field(description='The list of piot tables that are part of the worksheet.'),
    ] = None
    protection: Annotated[
        Optional[Union[WorkbookWorksheetProtection, Dict[str, Any]]],
        Field(description='The sheet protection object for a worksheet. Read-only.'),
    ] = None
    tables: Annotated[
        Optional[List[WorkbookTable]],
        Field(
            description='The list of tables that are part of the worksheet. Read-only.'
        ),
    ] = None
    field_odata_type: str


class ApplicationServicePrincipal(BaseModel):
    application: Optional[Union[Application, Dict[str, Any]]] = None
    service_principal: Optional[Union[ServicePrincipal, Dict[str, Any]]] = None
    field_odata_type: str


class AttributeMapping(BaseModel):
    default_value: Annotated[
        Optional[str],
        Field(
            description='Default value to be used in case the source property was evaluated to null. Optional.'
        ),
    ] = None
    export_missing_references: Annotated[
        Optional[bool], Field(description='For internal use only.')
    ] = None
    flow_behavior: Optional[AttributeFlowBehavior] = None
    flow_type: Optional[AttributeFlowType] = None
    matching_priority: Annotated[
        Optional[float],
        Field(
            description='If higher than 0, this attribute will be used to perform an initial match of the objects between source and target directories. The synchronization engine will try to find the matching object using attribute with lowest value of matching priority first. If not found, the attribute with the next matching priority will be used, and so on a until match is found or no more matching attributes are left. Only attributes that are expected to have unique values, such as email, should be used as matching attributes.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    source: Annotated[
        Optional[Union[AttributeMappingSource, Dict[str, Any]]],
        Field(
            description='Defines how a value should be extracted (or transformed) from the source object.'
        ),
    ] = None
    target_attribute_name: Annotated[
        Optional[str], Field(description='Name of the attribute on the target object.')
    ] = None
    field_odata_type: str


class AttributeMappingSource(BaseModel):
    expression: Annotated[
        Optional[str],
        Field(
            description='Equivalent expression representation of this attributeMappingSource object.'
        ),
    ] = None
    name: Annotated[
        Optional[str],
        Field(
            description='Name parameter of the mapping source. Depending on the type property value, this can be the name of the function, the name of the source attribute, or a constant value to be used.'
        ),
    ] = None
    parameters: Annotated[
        Optional[List[StringKeyAttributeMappingSourceValuePair]],
        Field(
            description="If this object represents a function, lists function parameters. Parameters consist of attributeMappingSource objects themselves, allowing for complex expressions. If type isn't Function, this property is null/empty array."
        ),
    ] = None
    type: Optional[AttributeMappingSourceType] = None
    field_odata_type: str


class DocumentSet(BaseModel):
    allowed_content_types: Annotated[
        Optional[List[ContentTypeInfo]],
        Field(description='Content types allowed in document set.'),
    ] = None
    default_contents: Annotated[
        Optional[List[DocumentSetContent]],
        Field(description='Default contents of document set.'),
    ] = None
    propagate_welcome_page_changes: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether to push welcome page changes to inherited content types.'
        ),
    ] = None
    should_prefix_name_to_file: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether to add the name of the document set to each file name.'
        ),
    ] = None
    welcome_page_url: Annotated[
        Optional[str], Field(description='Welcome page absolute URL.')
    ] = None
    shared_columns: Optional[List[ColumnDefinition]] = None
    welcome_page_columns: Optional[List[ColumnDefinition]] = None
    field_odata_type: str


class ObjectMapping(BaseModel):
    attribute_mappings: Annotated[
        Optional[List[AttributeMapping]],
        Field(
            description='Attribute mappings define which attributes to map from the source object into the target object and how they should flow. A number of functions are available to support the transformation of the original source values.'
        ),
    ] = None
    enabled: Annotated[
        Optional[bool],
        Field(
            description='When true, this object mapping will be processed during synchronization. When false, this object mapping will be skipped.'
        ),
    ] = None
    flow_types: Optional[ObjectFlowTypes] = None
    metadata: Annotated[
        Optional[List[ObjectMappingMetadataEntry]],
        Field(
            description='Additional extension properties. Unless mentioned explicitly, metadata values should not be changed.'
        ),
    ] = None
    name: Annotated[
        Optional[str], Field(description='Human-friendly name of the object mapping.')
    ] = None
    scope: Annotated[
        Optional[Union[Filter, Dict[str, Any]]],
        Field(
            description='Defines a filter to be used when deciding whether a given object should be provisioned. For example, you might want to only provision users that are located in the US.'
        ),
    ] = None
    source_object_name: Annotated[
        Optional[str],
        Field(
            description='Name of the object in the source directory. Must match the object name from the source directory definition.'
        ),
    ] = None
    target_object_name: Annotated[
        Optional[str],
        Field(
            description='Name of the object in target directory. Must match the object name from the target directory definition.'
        ),
    ] = None
    field_odata_type: str


class ParseExpressionResponse(BaseModel):
    error: Annotated[
        Optional[Union[PublicError, Dict[str, Any]]],
        Field(
            description='Error details, if expression evaluation resulted in an error.'
        ),
    ] = None
    evaluation_result: Annotated[
        Optional[List[str]],
        Field(
            description='A collection of values produced by the evaluation of the expression.'
        ),
    ] = None
    evaluation_succeeded: Annotated[
        Optional[bool], Field(description='true if the evaluation was successful.')
    ] = None
    parsed_expression: Annotated[
        Optional[Union[AttributeMappingSource, Dict[str, Any]]],
        Field(
            description='An attributeMappingSource object representing the parsed expression.'
        ),
    ] = None
    parsing_succeeded: Annotated[
        Optional[bool],
        Field(description='true if the expression was parsed successfully.'),
    ] = None
    field_odata_type: str


class StringKeyAttributeMappingSourceValuePair(BaseModel):
    key: Annotated[Optional[str], Field(description='The name of the parameter.')] = (
        None
    )
    value: Annotated[
        Optional[Union[AttributeMappingSource, Dict[str, Any]]],
        Field(description='The value of the parameter.'),
    ] = None
    field_odata_type: str


class SynchronizationJobApplicationParameters(BaseModel):
    rule_id: Annotated[
        Optional[str],
        Field(
            description='The identifier of the synchronizationRule to be applied. This rule ID is defined in the schema for a given synchronization job or template.'
        ),
    ] = None
    subjects: Annotated[
        Optional[List[SynchronizationJobSubject]],
        Field(
            description='The identifiers of one or more objects to which a synchronizationJob is to be applied.'
        ),
    ] = None
    field_odata_type: str


class SynchronizationJobSubject(BaseModel):
    links: Annotated[
        Optional[Union[SynchronizationLinkedObjects, Dict[str, Any]]],
        Field(description='Principals that you would like to provision.'),
    ] = None
    object_id: Annotated[
        Optional[str],
        Field(
            description='The identifier of an object to which a synchronizationJob is to be applied. Can be one of the following: An onPremisesDistinguishedName for synchronization from Active Directory to Azure AD.The user ID for synchronization from Microsoft Entra ID to a third-party.The Worker ID of the Workday worker for synchronization from Workday to either Active Directory or Microsoft Entra ID.'
        ),
    ] = None
    object_type_name: Annotated[
        Optional[str],
        Field(
            description='The type of the object to which a synchronizationJob is to be applied. Can be one of the following: user for synchronizing between Active Directory and Azure AD.User for synchronizing a user between Microsoft Entra ID and a third-party application. Worker for synchronization a user between Workday and either Active Directory or Microsoft Entra ID.Group for synchronizing a group between Microsoft Entra ID and a third-party application.'
        ),
    ] = None
    field_odata_type: str


class SynchronizationLinkedObjects(BaseModel):
    manager: Optional[Union[SynchronizationJobSubject, Dict[str, Any]]] = None
    members: Annotated[
        Optional[List[SynchronizationJobSubject]],
        Field(description='All group members that you would like to provision.'),
    ] = None
    owners: Optional[List[SynchronizationJobSubject]] = None
    field_odata_type: str


class SynchronizationRule(BaseModel):
    container_filter: Optional[Union[ContainerFilter, Dict[str, Any]]] = None
    editable: Annotated[
        Optional[bool],
        Field(
            description="true if the synchronization rule can be customized; false if this rule is read-only and shouldn't be changed."
        ),
    ] = None
    group_filter: Optional[Union[GroupFilter, Dict[str, Any]]] = None
    id: Annotated[
        Optional[str],
        Field(
            description='Synchronization rule identifier. Must be one of the identifiers recognized by the synchronization engine. Supported rule identifiers can be found in the synchronization template returned by the API.'
        ),
    ] = None
    metadata: Annotated[
        Optional[List[StringKeyStringValuePair]],
        Field(
            description="Additional extension properties. Unless instructed explicitly by the support team, metadata values shouldn't be changed."
        ),
    ] = None
    name: Annotated[
        Optional[str],
        Field(
            description='Human-readable name of the synchronization rule. Not nullable.'
        ),
    ] = None
    object_mappings: Annotated[
        Optional[List[ObjectMapping]],
        Field(
            description='Collection of object mappings supported by the rule. Tells the synchronization engine which objects should be synchronized.'
        ),
    ] = None
    priority: Annotated[
        Optional[float],
        Field(
            description='Priority relative to other rules in the synchronizationSchema. Rules with the lowest priority number will be processed first.',
            ge=-2147483648.0,
            le=2147483647.0,
        ),
    ] = None
    source_directory_name: Annotated[
        Optional[str],
        Field(
            description='Name of the source directory. Must match one of the directory definitions in synchronizationSchema.'
        ),
    ] = None
    target_directory_name: Annotated[
        Optional[str],
        Field(
            description='Name of the target directory. Must match one of the directory definitions in synchronizationSchema.'
        ),
    ] = None
    field_odata_type: str


class TermColumn(BaseModel):
    allow_multiple_values: Annotated[
        Optional[bool],
        Field(description='Specifies whether the column allows more than one value.'),
    ] = None
    show_fully_qualified_name: Annotated[
        Optional[bool],
        Field(
            description='Specifies whether to display the entire term path or only the term label.'
        ),
    ] = None
    parent_term: Optional[Union[termStore.Term, Dict[str, Any]]] = None
    term_set: Optional[Union[termStore.Set, Dict[str, Any]]] = None
    field_odata_type: str


class UserPrint(BaseModel):
    recent_printer_shares: Optional[List[PrinterShare]] = None
    field_odata_type: str


class ApplicationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Application]] = None


class DriveCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Drive]] = None


class GroupCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Group]] = None


class InvitationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Invitation]] = None


class ServicePrincipalCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ServicePrincipal]] = None


class SharedDriveItemCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SharedDriveItem]] = None


class SiteCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Site]] = None


class TeamCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Team]] = None


class UserCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[User]] = None


class AccessPackageCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AccessPackage]] = None


class AccessPackageAssignmentPolicyCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AccessPackageAssignmentPolicy]] = None


class AccessPackageResourceRoleScopeCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AccessPackageResourceRoleScope]] = None


class AccessPackageResourceRoleCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AccessPackageResourceRole]] = None


class AccessPackageResourceCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AccessPackageResource]] = None


class AccessPackageResourceScopeCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AccessPackageResourceScope]] = None


class EventCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Event]] = None


class CalendarCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Calendar]] = None


class SharedWithChannelTeamInfoCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[SharedWithChannelTeamInfo]] = None


class CloudPcProvisioningPolicyAssignmentCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[CloudPcProvisioningPolicyAssignment]] = None


class ContentTypeCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ContentType]] = None


class ColumnDefinitionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ColumnDefinition]] = None


class ChannelCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Channel]] = None


class ManagedDeviceCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ManagedDevice]] = None


class RoleAssignmentCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[RoleAssignment]] = None


class DetectedAppCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[DetectedApp]] = None


class DeviceAndAppManagementRoleAssignmentCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DeviceAndAppManagementRoleAssignment]] = None


class RoleDefinitionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[RoleDefinition]] = None


class TermsAndConditionsCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[TermsAndConditions]] = None


class DriveItemCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[DriveItem]] = None


class EducationUserCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[EducationUser]] = None


class EducationSchoolCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[EducationSchool]] = None


class EducationClassCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[EducationClass]] = None


class CommunityCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Community]] = None


class AccessPackageAssignmentRequestCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AccessPackageAssignmentRequest]] = None


class AccessPackageAssignmentCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AccessPackageAssignment]] = None


class AccessPackageCatalogCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AccessPackageCatalog]] = None


class AccessPackageResourceEnvironmentCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AccessPackageResourceEnvironment]] = None


class AccessPackageResourceRequestCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AccessPackageResourceRequest]] = None


class FileStorageContainerCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[FileStorageContainer]] = None


class RiskyServicePrincipalCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[RiskyServicePrincipal]] = None


class RiskyUserCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[RiskyUser]] = None


class ItemActivityCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ItemActivity]] = None


class ItemActivityStatCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ItemActivityStat]] = None


class ListItemCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ListItem]] = None


class SectionGroupCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SectionGroup]] = None


class OnenoteSectionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[OnenoteSection]] = None


class NotebookCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Notebook]] = None


class OnenotePageCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[OnenotePage]] = None


class PrinterCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[Printer]] = None


class PrinterShareCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[PrinterShare]] = None


class PrintTaskDefinitionCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[PrintTaskDefinition]] = None


class PrintJobCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[PrintJob]] = None


class PrintTaskTriggerCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[PrintTaskTrigger]] = None


class PrintTaskCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[PrintTask]] = None


class SubjectRightsRequestCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SubjectRightsRequest]] = None


class PrivilegedAccessGroupAssignmentScheduleInstanceCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[PrivilegedAccessGroupAssignmentScheduleInstance]] = None


class PrivilegedAccessGroupAssignmentScheduleRequestCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[PrivilegedAccessGroupAssignmentScheduleRequest]] = None


class PrivilegedAccessGroupAssignmentScheduleCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[PrivilegedAccessGroupAssignmentSchedule]] = None


class PrivilegedAccessGroupEligibilityScheduleInstanceCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[PrivilegedAccessGroupEligibilityScheduleInstance]] = None


class PrivilegedAccessGroupEligibilityScheduleRequestCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[PrivilegedAccessGroupEligibilityScheduleRequest]] = None


class PrivilegedAccessGroupEligibilityScheduleCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[PrivilegedAccessGroupEligibilitySchedule]] = None


class RecycleBinItemCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[RecycleBinItem]] = None


class RiskyServicePrincipalHistoryItemCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[RiskyServicePrincipalHistoryItem]] = None


class RiskyUserHistoryItemCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[RiskyUserHistoryItem]] = None


class BaseItemCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[BaseItem]] = None


class ListCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ListModel]] = None


class BaseSitePageCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[BaseSitePage]] = None


class SynchronizationJobCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SynchronizationJob]] = None


class SynchronizationTemplateCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SynchronizationTemplate]] = None


class DeletedTeamCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[DeletedTeam]] = None


class TermsAndConditionsAcceptanceStatusCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[TermsAndConditionsAcceptanceStatus]] = None


class UserActivityCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[UserActivity]] = None


class CalendarGroupCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[CalendarGroup]] = None


class ActivityHistoryItemCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ActivityHistoryItem]] = None


class AssociatedTeamInfoCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AssociatedTeamInfo]] = None


class CloudPcProvisioningPolicyCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[CloudPcProvisioningPolicy]] = None


class WorkbookNamedItemCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[WorkbookNamedItem]] = None


class WorkbookTableCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[WorkbookTable]] = None


class WorkbookWorksheetCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[WorkbookWorksheet]] = None


class WorkbookChartCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[WorkbookChart]] = None


class WorkbookPivotTableCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[WorkbookPivotTable]] = None


class MembershipOutlierInsightCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[MembershipOutlierInsight]] = None


class AadUserConversationMemberCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[AadUserConversationMember]] = None


class DeviceAndAppManagementRoleDefinitionCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[DeviceAndAppManagementRoleDefinition]] = None


class EventMessageCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[EventMessage]] = None


class EventMessageRequestCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[EventMessageRequest]] = None


class EventMessageResponseCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[EventMessageResponse]] = None


class PrinterCreateOperationCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[PrinterCreateOperation]] = None


class SitePageCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SitePage]] = None


class RecycleBinCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[RecycleBin]] = None


class SynchronizationRuleCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[SynchronizationRule]] = None


class StringKeyAttributeMappingSourceValuePairCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[StringKeyAttributeMappingSourceValuePair]] = None


class AttributeMappingCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[AttributeMapping]] = None


class SynchronizationJobSubjectCollectionResponse(
    BaseCollectionPaginationCountResponse
):
    value: Optional[List[SynchronizationJobSubject]] = None


class ObjectMappingCollectionResponse(BaseCollectionPaginationCountResponse):
    value: Optional[List[ObjectMapping]] = None


class BaseSitePage(BaseItem):
    page_layout: Annotated[
        Optional[Union[PageLayoutType, Dict[str, Any]]],
        Field(
            description='The name of the page layout of the page. The possible values are: microsoftReserved, article, home, unknownFutureValue.'
        ),
    ] = None
    publishing_state: Annotated[
        Optional[Union[PublicationFacet, Dict[str, Any]]],
        Field(description='The publishing status and the MM.mm version of the page.'),
    ] = None
    title: Annotated[Optional[str], Field(description='Title of the sitePage.')] = None
    field_odata_type: str


class Drive(BaseItem):
    drive_type: Annotated[
        Optional[str],
        Field(
            description='Describes the type of drive represented by this resource. OneDrive personal drives return personal. OneDrive for Business returns business. SharePoint document libraries return documentLibrary. Read-only.'
        ),
    ] = None
    owner: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(description='Optional. The user account that owns the drive. Read-only.'),
    ] = None
    quota: Annotated[
        Optional[Union[Quota, Dict[str, Any]]],
        Field(
            description="Optional. Information about the drive's storage space quota. Read-only."
        ),
    ] = None
    share_point_ids: Optional[Union[SharepointIds, Dict[str, Any]]] = None
    system: Annotated[
        Optional[Union[SystemFacet, Dict[str, Any]]],
        Field(
            description="If present, indicates that it's a system-managed drive. Read-only."
        ),
    ] = None
    bundles: Annotated[
        Optional[List[DriveItem]],
        Field(
            description='Collection of bundles (albums and multi-select-shared sets of items). Only in personal OneDrive.'
        ),
    ] = None
    following: Annotated[
        Optional[List[DriveItem]],
        Field(
            description='The list of items the user is following. Only in OneDrive for Business.'
        ),
    ] = None
    items: Annotated[
        Optional[List[DriveItem]],
        Field(description='All items contained in the drive. Read-only. Nullable.'),
    ] = None
    list: Annotated[
        Optional[Union[ListModel, Dict[str, Any]]],
        Field(
            description='For drives in SharePoint, the underlying document library list. Read-only. Nullable.'
        ),
    ] = None
    root: Annotated[
        Optional[Union[DriveItem, Dict[str, Any]]],
        Field(description='The root folder of the drive. Read-only.'),
    ] = None
    special: Annotated[
        Optional[List[DriveItem]],
        Field(
            description='Collection of common folders available in OneDrive. Read-only. Nullable.'
        ),
    ] = None
    field_odata_type: str


class DriveItem(BaseItem):
    audio: Annotated[
        Optional[Union[Audio, Dict[str, Any]]],
        Field(
            description='Audio metadata, if the item is an audio file. Read-only. Read-only. Only on OneDrive Personal.'
        ),
    ] = None
    bundle: Annotated[
        Optional[Union[Bundle, Dict[str, Any]]],
        Field(description='Bundle metadata, if the item is a bundle. Read-only.'),
    ] = None
    content: Annotated[
        Optional[str],
        Field(description='The content stream, if the item represents a file.'),
    ] = None
    c_tag: Annotated[
        Optional[str],
        Field(
            description="An eTag for the content of the item. This eTag isn't changed if only the metadata is changed. Note This property isn't returned if the item is a folder. Read-only."
        ),
    ] = None
    deleted: Annotated[
        Optional[Union[Deleted, Dict[str, Any]]],
        Field(
            description='Information about the deleted state of the item. Read-only.'
        ),
    ] = None
    file: Annotated[
        Optional[Union[File, Dict[str, Any]]],
        Field(description='File metadata, if the item is a file. Read-only.'),
    ] = None
    file_system_info: Annotated[
        Optional[Union[FileSystemInfo, Dict[str, Any]]],
        Field(description='File system information on client. Read-write.'),
    ] = None
    folder: Annotated[
        Optional[Union[Folder, Dict[str, Any]]],
        Field(description='Folder metadata, if the item is a folder. Read-only.'),
    ] = None
    image: Annotated[
        Optional[Union[Image, Dict[str, Any]]],
        Field(description='Image metadata, if the item is an image. Read-only.'),
    ] = None
    location: Annotated[
        Optional[Union[GeoCoordinates, Dict[str, Any]]],
        Field(
            description='Location metadata, if the item has location data. Read-only.'
        ),
    ] = None
    malware: Annotated[
        Optional[Union[Malware, Dict[str, Any]]],
        Field(
            description='Malware metadata, if the item was detected to contain malware. Read-only.'
        ),
    ] = None
    package: Annotated[
        Optional[Union[Package, Dict[str, Any]]],
        Field(
            description='If present, indicates that this item is a package instead of a folder or file. Packages are treated like files in some contexts and folders in others. Read-only.'
        ),
    ] = None
    pending_operations: Annotated[
        Optional[Union[PendingOperations, Dict[str, Any]]],
        Field(
            description='If present, indicates that one or more operations that might affect the state of the driveItem are pending completion. Read-only.'
        ),
    ] = None
    photo: Annotated[
        Optional[Union[Photo, Dict[str, Any]]],
        Field(description='Photo metadata, if the item is a photo. Read-only.'),
    ] = None
    publication: Annotated[
        Optional[Union[PublicationFacet, Dict[str, Any]]],
        Field(
            description="Provides information about the published or checked-out state of an item, in locations that support such actions. This property isn't returned by default. Read-only."
        ),
    ] = None
    remote_item: Annotated[
        Optional[Union[RemoteItem, Dict[str, Any]]],
        Field(
            description='Remote item data, if the item is shared from a drive other than the one being accessed. Read-only.'
        ),
    ] = None
    root: Annotated[
        Optional[Union[Root, Dict[str, Any]]],
        Field(
            description='If this property is non-null, it indicates that the driveItem is the top-most driveItem in the drive.'
        ),
    ] = None
    search_result: Annotated[
        Optional[Union[SearchResult, Dict[str, Any]]],
        Field(
            description='Search metadata, if the item is from a search result. Read-only.'
        ),
    ] = None
    shared: Annotated[
        Optional[Union[Shared, Dict[str, Any]]],
        Field(
            description='Indicates that the item was shared with others and provides information about the shared state of the item. Read-only.'
        ),
    ] = None
    sharepoint_ids: Annotated[
        Optional[Union[SharepointIds, Dict[str, Any]]],
        Field(
            description='Returns identifiers useful for SharePoint REST compatibility. Read-only.'
        ),
    ] = None
    size: Annotated[
        Optional[float], Field(description='Size of the item in bytes. Read-only.')
    ] = None
    special_folder: Annotated[
        Optional[Union[SpecialFolder, Dict[str, Any]]],
        Field(
            description='If the current item is also available as a special folder, this facet is returned. Read-only.'
        ),
    ] = None
    video: Annotated[
        Optional[Union[Video, Dict[str, Any]]],
        Field(description='Video metadata, if the item is a video. Read-only.'),
    ] = None
    web_dav_url: Annotated[
        Optional[str], Field(description='WebDAV compatible URL for the item.')
    ] = None
    analytics: Annotated[
        Optional[Union[ItemAnalytics, Dict[str, Any]]],
        Field(
            description='Analytics about the view activities that took place on this item.'
        ),
    ] = None
    children: Annotated[
        Optional[List[DriveItem]],
        Field(
            description='Collection containing Item objects for the immediate children of Item. Only items representing folders have children. Read-only. Nullable.'
        ),
    ] = None
    list_item: Annotated[
        Optional[Union[ListItem, Dict[str, Any]]],
        Field(
            description='For drives in SharePoint, the associated document library list item. Read-only. Nullable.'
        ),
    ] = None
    permissions: Annotated[
        Optional[List[Permission]],
        Field(description='The set of permissions for the item. Read-only. Nullable.'),
    ] = None
    retention_label: Annotated[
        Optional[Union[ItemRetentionLabel, Dict[str, Any]]],
        Field(
            description='Information about retention label and settings enforced on the driveItem. Read-write.'
        ),
    ] = None
    subscriptions: Annotated[
        Optional[List[Subscription]],
        Field(
            description='The set of subscriptions on the item. Only supported on the root of a drive.'
        ),
    ] = None
    thumbnails: Annotated[
        Optional[List[ThumbnailSet]],
        Field(
            description='Collection of thumbnailSet objects associated with the item. For more information, see getting thumbnails. Read-only. Nullable.'
        ),
    ] = None
    versions: Annotated[
        Optional[List[DriveItemVersion]],
        Field(
            description='The list of previous versions of the item. For more info, see getting previous versions. Read-only. Nullable.'
        ),
    ] = None
    workbook: Annotated[
        Optional[Union[Workbook, Dict[str, Any]]],
        Field(
            description="For files that are Excel spreadsheets, access to the workbook API to work with the spreadsheet's contents. Nullable."
        ),
    ] = None
    field_odata_type: str


class ListModel(BaseItem):
    display_name: Annotated[
        Optional[str], Field(description='The displayable title of the list.')
    ] = None
    list: Annotated[
        Optional[Union[ListInfo, Dict[str, Any]]],
        Field(description='Contains more details about the list.'),
    ] = None
    sharepoint_ids: Annotated[
        Optional[Union[SharepointIds, Dict[str, Any]]],
        Field(
            description='Returns identifiers useful for SharePoint REST compatibility. Read-only.'
        ),
    ] = None
    system: Annotated[
        Optional[Union[SystemFacet, Dict[str, Any]]],
        Field(
            description='If present, indicates that the list is system-managed. Read-only.'
        ),
    ] = None
    columns: Annotated[
        Optional[List[ColumnDefinition]],
        Field(description='The collection of field definitions for this list.'),
    ] = None
    content_types: Annotated[
        Optional[List[ContentType]],
        Field(description='The collection of content types present in this list.'),
    ] = None
    drive: Annotated[
        Optional[Union[Drive, Dict[str, Any]]],
        Field(
            description='Allows access to the list as a drive resource with driveItems. Only present on document libraries.'
        ),
    ] = None
    items: Annotated[
        Optional[List[ListItem]], Field(description='All items contained in the list.')
    ] = None
    operations: Annotated[
        Optional[List[RichLongRunningOperation]],
        Field(description='The collection of long-running operations on the list.'),
    ] = None
    subscriptions: Annotated[
        Optional[List[Subscription]],
        Field(description='The set of subscriptions on the list.'),
    ] = None
    field_odata_type: str


class ListItem(BaseItem):
    content_type: Annotated[
        Optional[Union[ContentTypeInfo, Dict[str, Any]]],
        Field(description='The content type of this list item'),
    ] = None
    sharepoint_ids: Annotated[
        Optional[Union[SharepointIds, Dict[str, Any]]],
        Field(
            description='Returns identifiers useful for SharePoint REST compatibility. Read-only.'
        ),
    ] = None
    analytics: Annotated[
        Optional[Union[ItemAnalytics, Dict[str, Any]]],
        Field(
            description='Analytics about the view activities that took place on this item.'
        ),
    ] = None
    document_set_versions: Annotated[
        Optional[List[DocumentSetVersion]],
        Field(
            description='Version information for a document set version created by a user.'
        ),
    ] = None
    drive_item: Annotated[
        Optional[Union[DriveItem, Dict[str, Any]]],
        Field(
            description='For document libraries, the driveItem relationship exposes the listItem as a driveItem'
        ),
    ] = None
    fields: Annotated[
        Optional[Union[FieldValueSet, Dict[str, Any]]],
        Field(description='The values of the columns set on this list item.'),
    ] = None
    versions: Annotated[
        Optional[List[ListItemVersion]],
        Field(description='The list of previous versions of the list item.'),
    ] = None
    field_odata_type: str


class RecycleBin(BaseItem):
    settings: Optional[Union[RecycleBinSettings, Dict[str, Any]]] = None
    items: Annotated[
        Optional[List[RecycleBinItem]],
        Field(description='List of the recycleBinItems deleted by a user.'),
    ] = None
    field_odata_type: str


class RecycleBinItem(BaseItem):
    deleted_date_time: Annotated[
        Optional[datetime],
        Field(
            description='Date and time when the item was deleted. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.',
        ),
    ] = None
    deleted_from_location: Annotated[
        Optional[str],
        Field(
            description='Relative URL of the list or folder that originally contained the item.'
        ),
    ] = None
    size: Annotated[
        Optional[float], Field(description='Size of the item in bytes.')
    ] = None
    field_odata_type: str


class SharedDriveItem(BaseItem):
    owner: Annotated[
        Optional[Union[IdentitySet, Dict[str, Any]]],
        Field(
            description='Information about the owner of the shared item being referenced.'
        ),
    ] = None
    drive_item: Annotated[
        Optional[Union[DriveItem, Dict[str, Any]]],
        Field(description='Used to access the underlying driveItem'),
    ] = None
    items: Annotated[
        Optional[List[DriveItem]],
        Field(
            description='All driveItems contained in the sharing root. This collection cannot be enumerated.'
        ),
    ] = None
    list: Annotated[
        Optional[Union[ListModel, Dict[str, Any]]],
        Field(description='Used to access the underlying list'),
    ] = None
    list_item: Annotated[
        Optional[Union[ListItem, Dict[str, Any]]],
        Field(description='Used to access the underlying listItem'),
    ] = None
    permission: Annotated[
        Optional[Union[Permission, Dict[str, Any]]],
        Field(
            description='Used to access the permission representing the underlying sharing link'
        ),
    ] = None
    root: Annotated[
        Optional[Union[DriveItem, Dict[str, Any]]],
        Field(
            description='Used to access the underlying driveItem. Deprecated -- use driveItem instead.'
        ),
    ] = None
    site: Annotated[
        Optional[Union[Site, Dict[str, Any]]],
        Field(description='Used to access the underlying site'),
    ] = None
    field_odata_type: str


class Site(BaseItem):
    display_name: Annotated[
        Optional[str], Field(description='The full title for the site. Read-only.')
    ] = None
    error: Optional[Union[PublicError, Dict[str, Any]]] = None
    is_personal_site: Annotated[
        Optional[bool],
        Field(description='Identifies whether the site is personal or not. Read-only.'),
    ] = None
    root: Annotated[
        Optional[Union[Root, Dict[str, Any]]],
        Field(
            description='If present, provides the root site in the site collection. Read-only.'
        ),
    ] = None
    sharepoint_ids: Annotated[
        Optional[Union[SharepointIds, Dict[str, Any]]],
        Field(
            description='Returns identifiers useful for SharePoint REST compatibility. Read-only.'
        ),
    ] = None
    site_collection: Annotated[
        Optional[Union[SiteCollection, Dict[str, Any]]],
        Field(
            description="Provides details about the site's site collection. Available only on the root site. Read-only."
        ),
    ] = None
    analytics: Annotated[
        Optional[Union[ItemAnalytics, Dict[str, Any]]],
        Field(
            description='Analytics about the view activities that took place on this site.'
        ),
    ] = None
    columns: Annotated[
        Optional[List[ColumnDefinition]],
        Field(
            description='The collection of column definitions reusable across lists under this site.'
        ),
    ] = None
    content_types: Annotated[
        Optional[List[ContentType]],
        Field(description='The collection of content types defined for this site.'),
    ] = None
    drive: Annotated[
        Optional[Union[Drive, Dict[str, Any]]],
        Field(description='The default drive (document library) for this site.'),
    ] = None
    drives: Annotated[
        Optional[List[Drive]],
        Field(
            description='The collection of drives (document libraries) under this site.'
        ),
    ] = None
    external_columns: Optional[List[ColumnDefinition]] = None
    items: Annotated[
        Optional[List[BaseItem]],
        Field(
            description="Used to address any item contained in this site. This collection can't be enumerated."
        ),
    ] = None
    lists: Annotated[
        Optional[List[ListModel]],
        Field(description='The collection of lists under this site.'),
    ] = None
    onenote: Annotated[
        Optional[Union[Onenote, Dict[str, Any]]],
        Field(description='Calls the OneNote service for notebook related operations.'),
    ] = None
    operations: Annotated[
        Optional[List[RichLongRunningOperation]],
        Field(description='The collection of long-running operations on the site.'),
    ] = None
    pages: Annotated[
        Optional[List[BaseSitePage]],
        Field(
            description='The collection of pages in the baseSitePages list in this site.'
        ),
    ] = None
    permissions: Annotated[
        Optional[List[Permission]],
        Field(description='The permissions associated with the site. Nullable.'),
    ] = None
    sites: Annotated[
        Optional[List[Site]],
        Field(description='The collection of the sub-sites under this site.'),
    ] = None
    term_store: Annotated[
        Optional[Union[termStore.Store, Dict[str, Any]]],
        Field(description='The default termStore under this site.'),
    ] = None
    term_stores: Annotated[
        Optional[List[termStore.Store]],
        Field(description='The collection of termStores under this site.'),
    ] = None
    field_odata_type: str


class EventMessageRequest(EventMessage):
    allow_new_time_proposals: Annotated[
        Optional[bool],
        Field(
            description='True if the meeting organizer allows invitees to propose a new time when responding, false otherwise. Optional. Default is true.'
        ),
    ] = None
    meeting_request_type: Optional[Union[MeetingRequestType, Dict[str, Any]]] = None
    previous_end_date_time: Annotated[
        Optional[Union[DateTimeTimeZone, Dict[str, Any]]],
        Field(
            description='If the meeting update changes the meeting end time, this property specifies the previous meeting end time.'
        ),
    ] = None
    previous_location: Annotated[
        Optional[Union[Location, Dict[str, Any]]],
        Field(
            description='If the meeting update changes the meeting location, this property specifies the previous meeting location.'
        ),
    ] = None
    previous_start_date_time: Annotated[
        Optional[Union[DateTimeTimeZone, Dict[str, Any]]],
        Field(
            description='If the meeting update changes the meeting start time, this property specifies the previous meeting start time.'
        ),
    ] = None
    response_requested: Annotated[
        Optional[bool],
        Field(
            description='Set to true if the sender would like the invitee to send a response to the requested meeting.'
        ),
    ] = None
    field_odata_type: str


class EventMessageResponse(EventMessage):
    proposed_new_time: Annotated[
        Optional[Union[TimeSlot, Dict[str, Any]]],
        Field(
            description='An alternate date/time proposed by an invitee for a meeting request to start and end. Read-only. Not filterable.'
        ),
    ] = None
    response_type: Annotated[
        Optional[Union[ResponseType, Dict[str, Any]]],
        Field(
            description='Specifies the type of response to a meeting request. Possible values are: tentativelyAccepted, accepted, declined. For the eventMessageResponse type, none, organizer, and notResponded are not supported. Read-only. Not filterable.'
        ),
    ] = None
    field_odata_type: str


class Printer(PrinterBase):
    has_physical_device: Annotated[
        Optional[bool],
        Field(
            description='True if the printer has a physical device for printing. Read-only.'
        ),
    ] = None
    is_shared: Annotated[
        Optional[bool],
        Field(description='True if the printer is shared; false otherwise. Read-only.'),
    ] = None
    last_seen_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The most recent dateTimeOffset when a printer interacted with Universal Print. Read-only.',
        ),
    ] = None
    registered_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The DateTimeOffset when the printer was registered. Read-only.',
        ),
    ] = None
    connectors: Annotated[
        Optional[List[PrintConnector]],
        Field(description='The connectors that are associated with the printer.'),
    ] = None
    shares: Annotated[
        Optional[List[PrinterShare]],
        Field(
            description='The list of printerShares that are associated with the printer. Currently, only one printerShare can be associated with the printer. Read-only. Nullable.'
        ),
    ] = None
    task_triggers: Annotated[
        Optional[List[PrintTaskTrigger]],
        Field(
            description='A list of task triggers that are associated with the printer.'
        ),
    ] = None
    field_odata_type: str


class PrinterShare(PrinterBase):
    allow_all_users: Annotated[
        Optional[bool],
        Field(
            description='If true, all users and groups will be granted access to this printer share. This supersedes the allow lists defined by the allowedUsers and allowedGroups navigation properties.'
        ),
    ] = None
    created_date_time: Annotated[
        Optional[datetime],
        Field(
            description='The DateTimeOffset when the printer share was created. Read-only.',
        ),
    ] = None
    view_point: Annotated[
        Optional[Union[PrinterShareViewpoint, Dict[str, Any]]],
        Field(
            description='Additional data for a printer share as viewed by the signed-in user.'
        ),
    ] = None
    allowed_groups: Annotated[
        Optional[List[Group]],
        Field(
            description='The groups whose users have access to print using the printer.'
        ),
    ] = None
    allowed_users: Annotated[
        Optional[List[User]],
        Field(description='The users who have access to print using the printer.'),
    ] = None
    printer: Annotated[
        Optional[Union[Printer, Dict[str, Any]]],
        Field(description='The printer that this printer share is related to.'),
    ] = None
    field_odata_type: str


class RiskyServicePrincipalHistoryItem(RiskyServicePrincipal):
    activity: Annotated[
        Optional[Union[RiskServicePrincipalActivity, Dict[str, Any]]],
        Field(
            description='The activity related to service principal risk level change.'
        ),
    ] = None
    initiated_by: Annotated[
        Optional[str],
        Field(description='The identifier of the actor of the operation.'),
    ] = None
    field_odata_type: str


class RiskyUserHistoryItem(RiskyUser):
    activity: Annotated[
        Optional[Union[RiskUserActivity, Dict[str, Any]]],
        Field(description='The activity related to user risk level change.'),
    ] = None
    initiated_by: Annotated[
        Optional[str], Field(description='The ID of actor that does the operation.')
    ] = None
    user_id: Annotated[Optional[str], Field(description='The ID of the user.')] = None
    field_odata_type: str


class DeviceAndAppManagementRoleAssignment(RoleAssignment):
    members: Annotated[
        Optional[List[str]],
        Field(
            description='The list of ids of role member security groups. These are IDs from Azure Active Directory.'
        ),
    ] = None
    field_odata_type: str


class DeviceAndAppManagementRoleDefinition(RoleDefinition):
    field_odata_type: str


class AssociatedTeamInfo(TeamInfo):
    field_odata_type: str


class SharedWithChannelTeamInfo(TeamInfo):
    is_host_team: Annotated[
        Optional[bool],
        Field(description='Indicates whether the team is the host of the channel.'),
    ] = None
    allowed_members: Annotated[
        Optional[List[ConversationMember]],
        Field(
            description='A collection of team members who have access to the shared channel.'
        ),
    ] = None
    field_odata_type: str


class SitePage(BaseSitePage):
    promotion_kind: Annotated[
        Optional[Union[PagePromotionType, Dict[str, Any]]],
        Field(
            description='Indicates the promotion kind of the sitePage. The possible values are: microsoftReserved, page, newsPost, unknownFutureValue.'
        ),
    ] = None
    reactions: Annotated[
        Optional[Union[ReactionsFacet, Dict[str, Any]]],
        Field(description='Reactions information for the page.'),
    ] = None
    show_comments: Annotated[
        Optional[bool],
        Field(
            description='Determines whether or not to show comments at the bottom of the page.'
        ),
    ] = None
    show_recommended_pages: Annotated[
        Optional[bool],
        Field(
            description='Determines whether or not to show recommended pages at the bottom of the page.'
        ),
    ] = None
    thumbnail_web_url: Annotated[
        Optional[str], Field(description="Url of the sitePage's thumbnail image")
    ] = None
    title_area: Annotated[
        Optional[Union[TitleArea, Dict[str, Any]]],
        Field(description='Title area on the SharePoint page.'),
    ] = None
    canvas_layout: Annotated[
        Optional[Union[CanvasLayout, Dict[str, Any]]],
        Field(
            description='Indicates the layout of the content in a given SharePoint page, including horizontal sections and vertical sections.'
        ),
    ] = None
    web_parts: Annotated[
        Optional[List[WebPart]],
        Field(description='Collection of webparts on the SharePoint page.'),
    ] = None
    field_odata_type: str


from . import callRecords, identityGovernance, search, security, termStore
from . import billing

WorkbookRangeView.model_rebuild()
WorkbookOperationError.model_rebuild()
ContactFolder.model_rebuild()
UnifiedRoleDefinition.model_rebuild()
Post.model_rebuild()
Domain.model_rebuild()
MailFolder.model_rebuild()
ChatMessage.model_rebuild()
AadUserConversationMember.model_rebuild()
AccessPackage.model_rebuild()
AccessPackageAssignment.model_rebuild()
AccessPackageAssignmentPolicy.model_rebuild()
AccessPackageCatalog.model_rebuild()
AccessPackageResource.model_rebuild()
AccessPackageResourceRoleScope.model_rebuild()
ActivityHistoryItem.model_rebuild()
Application.model_rebuild()
BaseItem.model_rebuild()
Calendar.model_rebuild()
Channel.model_rebuild()
CloudPcProvisioningPolicy.model_rebuild()
CloudPcProvisioningPolicyAssignment.model_rebuild()
ColumnDefinition.model_rebuild()
Community.model_rebuild()
ContentType.model_rebuild()
DeletedItemContainer.model_rebuild()
DetectedApp.model_rebuild()
DeviceManagement.model_rebuild()
EducationClass.model_rebuild()
EducationRoot.model_rebuild()
EducationSchool.model_rebuild()
EducationUser.model_rebuild()
FileStorage.model_rebuild()
FileStorageContainer.model_rebuild()
Group.model_rebuild()
IdentityGovernance.model_rebuild()
IdentityProtectionRoot.model_rebuild()
Invitation.model_rebuild()
ItemActivity.model_rebuild()
ManagedDevice.model_rebuild()
MembershipOutlierInsight.model_rebuild()
Notebook.model_rebuild()
Onenote.model_rebuild()
OnenotePage.model_rebuild()
OnenoteSection.model_rebuild()
Print.model_rebuild()
PrinterBase.model_rebuild()
PrinterCreateOperation.model_rebuild()
PrintJob.model_rebuild()
PrintTask.model_rebuild()
Privacy.model_rebuild()
PrivilegedAccessGroup.model_rebuild()
PrivilegedAccessGroupAssignmentSchedule.model_rebuild()
PrivilegedAccessGroupAssignmentScheduleInstance.model_rebuild()
PrivilegedAccessGroupAssignmentScheduleRequest.model_rebuild()
RiskyServicePrincipal.model_rebuild()
RiskyUser.model_rebuild()
RoleAssignment.model_rebuild()
Security.model_rebuild()
ServicePrincipal.model_rebuild()
SubjectRightsRequest.model_rebuild()
Synchronization.model_rebuild()
SynchronizationJob.model_rebuild()
SynchronizationSchema.model_rebuild()
TermsAndConditions.model_rebuild()
User.model_rebuild()
UserTeamwork.model_rebuild()
Workbook.model_rebuild()
WorkbookChart.model_rebuild()
WorkbookNamedItem.model_rebuild()
WorkbookPivotTable.model_rebuild()
WorkbookRange.model_rebuild()
WorkbookTable.model_rebuild()
AttributeMapping.model_rebuild()
AttributeMappingSource.model_rebuild()
SynchronizationJobApplicationParameters.model_rebuild()
SynchronizationJobSubject.model_rebuild()
TermColumn.model_rebuild()
UserPrint.model_rebuild()
DriveCollectionResponse.model_rebuild()
SharedDriveItemCollectionResponse.model_rebuild()
SiteCollectionResponse.model_rebuild()
SharedWithChannelTeamInfoCollectionResponse.model_rebuild()
DeviceAndAppManagementRoleAssignmentCollectionResponse.model_rebuild()
DriveItemCollectionResponse.model_rebuild()
ListItemCollectionResponse.model_rebuild()
PrinterCollectionResponse.model_rebuild()
PrinterShareCollectionResponse.model_rebuild()
RecycleBinItemCollectionResponse.model_rebuild()
RiskyServicePrincipalHistoryItemCollectionResponse.model_rebuild()
RiskyUserHistoryItemCollectionResponse.model_rebuild()
ListCollectionResponse.model_rebuild()
BaseSitePageCollectionResponse.model_rebuild()
AssociatedTeamInfoCollectionResponse.model_rebuild()
DeviceAndAppManagementRoleDefinitionCollectionResponse.model_rebuild()
EventMessageRequestCollectionResponse.model_rebuild()
EventMessageResponseCollectionResponse.model_rebuild()
SitePageCollectionResponse.model_rebuild()
RecycleBinCollectionResponse.model_rebuild()
BaseSitePage.model_rebuild()
Drive.model_rebuild()
DriveItem.model_rebuild()
ListModel.model_rebuild()
ListItem.model_rebuild()
RecycleBin.model_rebuild()
RecycleBinItem.model_rebuild()
SharedDriveItem.model_rebuild()
Site.model_rebuild()
Printer.model_rebuild()
PrinterShare.model_rebuild()
RiskyServicePrincipalHistoryItem.model_rebuild()
RiskyUserHistoryItem.model_rebuild()
DeviceAndAppManagementRoleAssignment.model_rebuild()
SitePage.model_rebuild()
